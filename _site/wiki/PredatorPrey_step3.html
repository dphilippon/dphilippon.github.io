
    <!doctype html><html lang="en"><head><meta charset="utf-8"><title>3. Prey Agent Behavior</title></head>
    <body>
    <link rel="stylesheet" href="/style.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script src="//connect.facebook.net/en_US/all.js"></script>
<script src="/linkify.min.js"></script>
<script src="/linkify-jquery.min.js"></script>
<script>
  $(document).ready(function(){
	  		$.getJSON('https://graph.facebook.com/238065426321929/feed?access_token=229040647557399|MQKFlFYX7YW25XGj4GUYZ7B1lcY', function(data) {
		var ahtml="";
		for(var i = 0; i < 5; i++) {
			ahtml=ahtml+"<li>"+data["data"][i]["message"]+"</li>";
		}
		ahtml=ahtml+"";
		$("#fbquotes").html(ahtml);
		$("#fbquotes").linkify();
	});
	 
		$.getJSON('https://api.github.com/repos/gama-platform/gama/commits', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data[i]["commit"]["message"]+" by "+data[i]["commit"]["author"]["name"]+" <a href='"+data[i]["html_url"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#commitquotes").html(ahtml);
			$("#commitquotes").linkify();
		});
				
				
		$.getJSON('https://api.github.com/repos/gama-platform/gama/issues', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data[i]["title"]+" by "+data[i]["user"]["login"]+" <a href='"+data[i]["html_url"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#issuequotes").html(ahtml);
			$("#issuequotes").linkify();
		});
		
		$.getJSON('https://api.rss2json.com/v1/api.json?rss_url=https%3A%2F%2Fgroups.google.com%2Fforum%2Ffeed%2Fgama-platform%2Ftopics%2Frss.xml%3Fnum%3D15', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data["items"][i]["title"]+" by "+data["items"][i]["author"]+" <a href='"+data["items"][i]["link"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#googleusersquotes").html(ahtml);
			$("#googleusersquotes").linkify();
			
		});
 });
  
</script>

      <div id="left">

		<ul class="mcd-menu"><li><a href="/">Home</a></li><li><a href="/">Discussions</a></li>
<li><a href='/wiki/Tutorials'>Tutorials
</a></li>
<ul class='sub'>
<li><a href='/wiki/LearnGAMLStepByStep'>Learn GAML Step by Step
</a></li>
<ul class='sub'>
<li><a href='/wiki/Introduction'>Introduction
</a></li>
<li><a href='/wiki/StartWithGAML'>Start with GAML
</a></li>
<ul class='sub'>
<li><a href='/wiki/ModelOrganization'>Organization of a model
</a></li>
<li><a href='/wiki/BasicProgrammingConceptsInGAML'>Basic programming concepts in GAML
</a></li>
</ul>
<li><a href='/wiki/ManipulateBasicSpecies'>Manipulate basic species
</a></li>
<ul class='sub'>
<li><a href='/wiki/GlobalSpecies'>The global species
</a></li>
<li><a href='/wiki/RegularSpecies'>Regular species
</a></li>
<li><a href='/wiki/DefiningActionsAndBehaviors'>Defining actions and behaviors
</a></li>
<li><a href='/wiki/InteractionBetweenAgents'>Interaction between agents
</a></li>
<li><a href='/wiki/AttachingSkills'>Attaching Skills
</a></li>
<li><a href='/wiki/Inheritance'>Inheritance
</a></li>
</ul>
<li><a href='/wiki/DefiningAdvancedSpecies'>Defining advanced species
</a></li>
<ul class='sub'>
<li><a href='/wiki/GridSpecies'>Grid Species
</a></li>
<li><a href='/wiki/GraphSpecies'>Graph Species
</a></li>
<li><a href='/wiki/MirrorSpecies'>Mirror species
</a></li>
<li><a href='/wiki/MultiLevelArchitecture'>Multi-level architecture
</a></li>
</ul>
<li><a href='/wiki/DefiningGUIExperiment'>Defining GUI Experiment
</a></li>
<ul class='sub'>
<li><a href='/wiki/DefiningParameters'>Defining Parameters
</a></li>
<li><a href='/wiki/DefiningDisplaysGeneralities'>Defining displays (Generalities)
</a></li>
<li><a href='/wiki/DefiningCharts'>Defining Charts
</a></li>
<li><a href='/wiki/Defining3DDisplays'>Defining 3D Displays
</a></li>
<li><a href='/wiki/DefiningMonitorsAndInspectors'>Defining monitors and inspectors
</a></li>
<li><a href='/wiki/DefiningExportFiles'>Defining export files
</a></li>
<li><a href='/wiki/DefiningUserInteraction'>Defining user interaction
</a></li>
</ul>
<li><a href='/wiki/ExploringModels'>Exploring Models
</a></li>
<ul class='sub'>
<li><a href='/wiki/RunSeveralSimulations'>Run Several Simulations
</a></li>
<li><a href='/wiki/BatchExperiments'>Defining Batch Experiments
</a></li>
<li><a href='/wiki/ExplorationMethods'>Exploration Methods
</a></li>
</ul>
<li><a href='/wiki/OptimizingModels'>Optimizing Models
</a></li>
<ul class='sub'>
<li><a href='/wiki/RuntimeConcepts'>Runtime Concepts
</a></li>
<li><a href='/wiki/OptimizingModels'>Optimizing Models
</a></li>
</ul>
<li><a href='/wiki/MultiParadigmModeling'>Multi-Paradigm Modeling
</a></li>
<ul class='sub'>
<li><a href='/wiki/ControlArchitecture'>Control Architectures
</a></li>
<li><a href='/wiki/Equations'>Using Equations
</a></li>
</ul>
</ul>
<li><a href='/wiki/Recipes'>Recipes
</a></li>
<ul class='sub'>
<li><a href='/wiki/ManipulateOSMDatas'>Manipulate OSM Datas
</a></li>
<li><a href='/wiki/Diffusion'>Implementing diffusion
</a></li>
<li><a href='/wiki/UsingDatabase'>Using Database Access
</a></li>
<li><a href='/wiki/CallingR'>Calling R
</a></li>
<li><a href='/wiki/UsingFIPAACL'>Using FIPA ACL
</a></li>
<li><a href='/wiki/GamAnalyzer'>Using GAMAnalyzer
</a></li>
<li><a href='/wiki/UsingBDI'>Using BDI
</a></li>
<li><a href='/wiki/UsingDrivingSkill'>Advanced Driving Skill
</a></li>
<li><a href='/wiki/ManipulateDates'>Manipulate Dates
</a></li>
<li><a href='/wiki/ManipulateLight'>Implementing light
</a></li>
<li><a href='/wiki/Comodel'>Using Comodel
</a></li>
</ul>
<li><a href='/wiki/Tutorials'>Tutorials
</a></li>
<ul class='sub'>
<li><a href='/wiki/LuneraysFlu'>Luneray's flu
</a></li>
<ul class='sub'>
<li><a href='/wiki/LuneraysFlu_step1'>1. Creation of a first basic disease spreading model
</a></li>
<li><a href='/wiki/LuneraysFlu_step2'>2. Definition of monitors and chart outputs
</a></li>
<li><a href='/wiki/LuneraysFlu_step3'>3. Importation of GIS data
</a></li>
<li><a href='/wiki/LuneraysFlu_step4'>4. Use of a graph to constraint the movements of people]
</a></li>
<li><a href='/wiki/LuneraysFlu_step5'>5. Definition of 3D displays
</a></li>
</ul>
<li><a href='/wiki/IncrementalModel'>Incremental Model
</a></li>
<ul class='sub'>
<li><a href='/wiki/IncrementalModel_step1'>1. Simple SI Model
</a></li>
<li><a href='/wiki/IncrementalModel_step2'>2. Charts
</a></li>
<li><a href='/wiki/IncrementalModel_step3'>3. Integration of GIS Data
</a></li>
<li><a href='/wiki/IncrementalModel_step4'>4. Movement on Graph
</a></li>
<li><a href='/wiki/IncrementalModel_step5'>5. Visualizing in 3D
</a></li>
<li><a href='/wiki/IncrementalModel_step6'>6. Multi-Level
</a></li>
<li><a href='/wiki/IncrementalModel_step7'>7. Differential Equations
</a></li>
</ul>
<li><a href='/wiki/PredatorPrey'>Predator Prey
</a></li>
<ul class='sub'>
<li><a href='/wiki/PredatorPrey_step1'>1. Basic Model
</a></li>
<li><a href='/wiki/PredatorPrey_step2'>2. Vegetation Dynamic
</a></li>
<li><a href='/wiki/PredatorPrey_step3'>3. Prey Agent Behavior
</a></li>
<li><a href='/wiki/PredatorPrey_step4'>4. Inspectors and Monitors
</a></li>
<li><a href='/wiki/PredatorPrey_step5'>5. Predator Agent
</a></li>
<li><a href='/wiki/PredatorPrey_step6'>6. Breeding
</a></li>
<li><a href='/wiki/PredatorPrey_step7'>7. Agent Aspect
</a></li>
<li><a href='/wiki/PredatorPrey_step8'>8. Complex Behavior
</a></li>
<li><a href='/wiki/PredatorPrey_step9'>9. Stopping condition
</a></li>
<li><a href='/wiki/PredatorPrey_step10'>10. Charts
</a></li>
<li><a href='/wiki/PredatorPrey_step11'>11. Writing Files
</a></li>
<li><a href='/wiki/PredatorPrey_step12'>12. Image loading
</a></li>
</ul>
<li><a href='/wiki/RoadTrafficModel'>Road Traffic
</a></li>
<ul class='sub'>
<li><a href='/wiki/RoadTrafficModel_step1'>1. Loading of GIS Data
</a></li>
<li><a href='/wiki/RoadTrafficModel_step2'>2. People Agents
</a></li>
<li><a href='/wiki/RoadTrafficModel_step3'>3. Movement of People
</a></li>
<li><a href='/wiki/RoadTrafficModel_step4'>4. Weight for Road Network
</a></li>
<li><a href='/wiki/RoadTrafficModel_step5'>5. Dynamic weights
</a></li>
<li><a href='/wiki/RoadTrafficModel_step6'>6. Charts
</a></li>
<li><a href='/wiki/RoadTrafficModel_step7'>7. Automatic Road Repair
</a></li>
</ul>
<li><a href='/wiki/ThreeD'>3D Tutorial
</a></li>
<ul class='sub'>
<li><a href='/wiki/ThreeD_step1'>1. Basic Model
</a></li>
<li><a href='/wiki/ThreeD_step2'>2. Moving Cells
</a></li>
<li><a href='/wiki/ThreeD_step3'>3. Connections
</a></li>
</ul>
</ul>
</ul>
<li><a href='/wiki/References'>References
</a></li>
<ul class='sub'>
<li><a href='/wiki/PlatformDocumentation'>Platform
</a></li>
<ul class='sub'>
<li><a href='/wiki/InstallationAndLaunching'>Installation and Launching
</a></li>
<ul class='sub'>
<li><a href='/wiki/Installation'>Installation
</a></li>
<li><a href='/wiki/Launching'>Launching GAMA
</a></li>
<li><a href='/wiki/Headless'>Headless Mode
</a></li>
<li><a href='/wiki/Updating'>Updating GAMA
</a></li>
<li><a href='/wiki/InstallingPlugins'>Installing Plugins
</a></li>
<li><a href='/wiki/Troubleshooting'>Troubleshooting
</a></li>
</ul>
<li><a href='/wiki/WorkspaceProjectsAndModels'>Workspace, Projects and Models
</a></li>
<ul class='sub'>
<li><a href='/wiki/NavigatingWorkspace'>Navigating in the Workspace
</a></li>
<li><a href='/wiki/ChangingWorkspace'>Changing Workspace
</a></li>
<li><a href='/wiki/ImportingModels'>Importing Models
</a></li>
</ul>
<li><a href='/wiki/EditingModels'>Editing models
</a></li>
<ul class='sub'>
<li><a href='/wiki/GamlEditorGeneralities'>The GAML Editor - Generalities
</a></li>
<li><a href='/wiki/GamlEditorToolbar'>The GAML Editor Toolbar
</a></li>
<li><a href='/wiki/ValidationOfModels'>Validation of Models
</a></li>
</ul>
<li><a href='/wiki/RunningExperiments'>Running Experiments
</a></li>
<ul class='sub'>
<li><a href='/wiki/LaunchingExperiments'>Launching Experiments from the User Interface
</a></li>
<li><a href='/wiki/ExperimentsUserInterface'>Experiments User Interface
</a></li>
<li><a href='/wiki/MenusAndCommands'>Menus and Commands
</a></li>
<li><a href='/wiki/ParametersView'>Parameters View
</a></li>
<li><a href='/wiki/InspectorsAndMonitors'>Inspectors and monitors
</a></li>
<li><a href='/wiki/Displays'>Displays
</a></li>
<li><a href='/wiki/BatchSpecific'>Batch Specific UI
</a></li>
<li><a href='/wiki/ErrorsView'>Errors View
</a></li>
</ul>
<li><a href='/wiki/Preferences'>Preferences
</a></li>
</ul>
<li><a href='/wiki/GamlReferences'>Gaml Reference
</a></li>
<ul class='sub'>
<li><a href='/wiki/BuiltInSpecies'>Built-in Species
</a></li>
<ul class='sub'>
<li><a href='/wiki/AgentBuiltIn'>The 'agent' built-in species (Under Construction)
</a></li>
<li><a href='/wiki/ModelBuiltIn'>The 'model' built-in species (Under Construction)
</a></li>
<li><a href='/wiki/ExperimentBuiltIn'>The 'experiment' built-in species (Under Construction)
</a></li>
</ul>
<li><a href='/wiki/BuiltInSkills'>Built-in Skills
</a></li>
<li><a href='/wiki/BuiltInArchitectures'>Built-in Architectures
</a></li>
<li><a href='/wiki/Statements'>Statements
</a></li>
<li><a href='/wiki/DataTypes'>Types
</a></li>
<li><a href='/wiki/FileTypes'>File Types
</a></li>
<li><a href='/wiki/Expressions'>Expressions
</a></li>
<ul class='sub'>
<li><a href='/wiki/Literals'>Literals
</a></li>
<li><a href='/wiki/UnitsAndConstants'>Units and constants
</a></li>
<li><a href='/wiki/PseudoVariables'>Pseudo-variables
</a></li>
<li><a href='/wiki/VariablesAndAttributes'>Variables and Attributes
</a></li>
<li><a href='/wiki/Operators'>Operators 
</a></li>
</ul>
</ul>
</ul>
<li>Community
</li>
<ul class='sub'>
<li><a href='/wiki/Contribute'>Contribute
</a></li>
<li><a href='/wiki/Projects'>Projects
</a></li>
<li><a href='/wiki/TrainingSession'>Training Session
</a></li>
</ul></ul></div><div id="right">
<h3>Facebook Activities</h3>
<ul id="fbquotes">
</ul>
<h3>Commit Activities</h3>
<ul id="commitquotes">
</ul>
<h3>Issue Activities</h3>
<ul id="issuequotes">
</ul>
<h3>Gama Platform Users Activities</h3>
<ul id="googleusersquotes">
</ul>
</div><div id="content"><h1 id="3-prey-agent-behavior">3. Prey Agent Behavior</h1>
<p>This third step Illustrates how to define the behaviors of prey agents and the concept of spatial topology.</p>

<h2 id="formulation">Formulation</h2>
<ul>
  <li>Random movement of the prey agents to a distance of 2 cells (Von Neumann neighborhood)</li>
  <li>At each step, the prey agents loss energy</li>
  <li>At each step, the prey agents eat food if there is food on the cell on which they are localized (with a max of max_transfer) and gain energy</li>
  <li>If a prey agent has no more energy, it dies</li>
</ul>

<h2 id="model-definition">Model Definition</h2>

<h3 id="parameters">parameters</h3>
<p>To define a behavior for the prey agents we add them three new parameters:</p>
<ul>
  <li>The max energy of the prey agents</li>
  <li>The maximum energy that can a prey agent consume from vegetation per tick</li>
  <li>The energy used by a prey agent at each time step</li>
</ul>

<p>As we consider these parameters to be global to all prey, we define them in the  global section as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>   float prey_max_energy &lt;- 1.0;
   float prey_max_transfer &lt;- 0.1;
   float prey_energy_consum &lt;- 0.05;
   
</code></pre>
</div>

<p>Yet we may allow the user to change it from an experiment to another through the user interface. To do so we add the following definition of parameters within the experiment section :</p>
<div class="highlighter-rouge"><pre class="highlight"><code>   parameter "Prey max energy: " var: prey_max_energy category: "Prey" ;
   parameter "Prey max transfer: " var: prey_max_transfer  category: "Prey" ;
   parameter "Prey energy consumption: " var: prey_energy_consum  category: "Prey" ;
</code></pre>
</div>

<h3 id="vegetation_cell-grid">vegetation_cell grid</h3>
<p>We add a new variable for the vegetation_cell grid called <strong>neighbours</strong>, that contains for each vegetation cell the list of the neighbor vegetation cells (distance of 2 - Von Neumann neighborhood). We will use these neighbors list for the movement of the prey.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  grid vegetation_cell width: 50 height: 50 neighbours: 4 {
      ...
      list&lt;vegetation_cell&gt; neighbours &lt;- self neighbours_at 2;
   }
</code></pre>
</div>

<p>Note that the result of the operator <strong>neighbours_at dist</strong> depends on the type of topology of the agent applying this operator:</p>
<ul>
  <li>For a grid topology (grid species), the operator returns the neighbor cells (with a Von Neumann or Moore neighborhood).</li>
  <li>For a continuous topology, the operator returns the list of agents of which the shape is located at a distance equals or inferior <em>dist</em> meters to the agent shape.</li>
</ul>

<p>Also note the use of the <a href="PseudoVariables#self">self</a> pseudo variable which is a reference to the agent currently executing the statement</p>

<h2 id="prey-agents">Prey agents</h2>

<p>We copy the values of the three global parameters into the prey species in order for it to be available for each agent and possibly modified locally.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>species prey {
   ...
   float max_energy &lt;- prey_max_energy ;
   float max_transfer &lt;- prey_max_transfer ;
   float energy_consum &lt;- prey_energy_consum ;
   ...
}		
</code></pre>
</div>

<p>The energy used by each prey at each timestep is randomly computed initially (within ]0;max_energy]).</p>
<div class="highlighter-rouge"><pre class="highlight"><code>species prey {
   ...
   float energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;
   ...
}    
</code></pre>
</div>

<p>In order to define the movement behaviour of a prey we will add a <strong>reflex</strong>. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>   reflex reflex_name when: condition {...}
</code></pre>
</div>

<p>The <strong>when</strong> facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.</p>

<p>We define a first reflex called <strong>basic_move</strong> that allows the prey agents to choose (randomly) a new vegetation_cell in the neighborhood of my_cell and to move to this cell.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>species prey {
   ...
   reflex basic_move { 
       myCell &lt;- one_of (myCell.neighbours) ;
       location &lt;- myCell.location ;
   }
}
</code></pre>
</div>

<p>We define a second reflex called <strong>eat</strong> that will only be activated when there is food in my_cell and that will allows the prey agents to eat food and gain energy. In order to store the energy gain by the eating (that is equals to the minimum between the <strong>max_transfer</strong> value and the quantity of food available in <strong>myCell</strong>), we define a local variable called <strong>energy_transfer</strong>.  A local variable is a variable that will only exist within this block: once it has been executed, the variable is forgotten. To define it, we have to use the following statement:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var_type var_name &lt;- value; 
</code></pre>
</div>

<p>Thus, the reflex <strong>eat</strong> is defined by:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>species prey {
   ...
   reflex eat when: myCell.food &gt; 0 { 
      float energy_transfer &lt;- min([max_transfer, myCell.food]) ;
      myCell.food &lt;- myCell.food - energy_transfer ;
      energy &lt;- energy + energy_transfer ;
   }
}
</code></pre>
</div>

<p>We define a third reflex for the prey agent: when the agent has no more energy, it dies (application of the built-in <strong>die</strong> action):</p>
<div class="highlighter-rouge"><pre class="highlight"><code>species prey {
   ...
   reflex die when: energy &lt;= 0 {
      do die ;
   }
}
</code></pre>
</div>

<p>Note that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the <strong>die</strong> action defined for all the agents.</p>
<ul>
  <li>An action can accept arguments. For instance, write takes an argument called message.</li>
  <li>An action can return a result.</li>
</ul>

<p>There are two ways to call an action: using a statement or as part of an expression</p>
<ul>
  <li>for actions that do not return a result:
    <div class="highlighter-rouge"><pre class="highlight"><code>do action_name arg1: v1 arg2: v2;
</code></pre>
    </div>
  </li>
  <li>for actions that return a result:
    <div class="highlighter-rouge"><pre class="highlight"><code>my_var &lt;- self action_name (arg1:v1, arg2:v2);
</code></pre>
    </div>
  </li>
</ul>

<h2 id="complete-model">Complete Model</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>model prey_predator

global {
	int nb_preys_init &lt;- 200;
	float prey_max_energy &lt;- 1.0;
	float prey_max_transfer &lt;- 0.1;
	float prey_energy_consum &lt;- 0.05;
	
	init {
		create prey number: nb_preys_init ;
	}
}

species prey {
	float size &lt;- 1.0 ;
	rgb color &lt;- #blue;
	float max_energy &lt;- prey_max_energy ;
	float max_transfer &lt;- prey_max_transfer ;
	float energy_consum &lt;- prey_energy_consum ;
		
	vegetation_cell myCell &lt;- one_of (vegetation_cell) ; 
	float energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;
		
	init { 
		location &lt;- myCell.location;
	}
		
	reflex basic_move { 
		myCell &lt;- one_of (myCell.neighbours) ;
		location &lt;- myCell.location ;
	}
	reflex eat when: myCell.food &gt; 0 { 
		float energy_transfer &lt;- min([max_transfer, myCell.food]) ;
		myCell.food &lt;- myCell.food - energy_transfer ;
		energy &lt;- energy + energy_transfer ;
	}
	reflex die when: energy &lt;= 0 {
		do die ;
	}

	aspect base {
		draw circle(size) color: color ;
	}
}

grid vegetation_cell width: 50 height: 50 neighbours: 4 {
	float maxFood &lt;- 1.0 ;
	float foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;
	float food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;
	rgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;
	list&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2);
}

experiment prey_predator type: gui {
	parameter "Initial number of preys: " var: nb_preys_init min: 1 max: 1000 category: "Prey" ;
	parameter "Prey max energy: " var: prey_max_energy category: "Prey" ;
	parameter "Prey max transfer: " var: prey_max_transfer  category: "Prey" ;
	parameter "Prey energy consumption: " var: prey_energy_consum  category: "Prey" ;
	output {
		display main_display {
			grid vegetation_cell lines: #black ;
			species prey aspect: base ;
		}
	}
}
</code></pre>
</div>
</div></body></html>
