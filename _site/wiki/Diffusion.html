
    <!doctype html><html lang="en"><head><meta charset="utf-8"><title>Implementing diffusion</title></head>
    <body>
    <link rel="stylesheet" href="/style.css">
<link rel="stylesheet" href="/w3.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script src="//connect.facebook.net/en_US/all.js"></script>
<script src="/linkify.min.js"></script>
<script src="/linkify-jquery.min.js"></script>
<script>
  $(document).ready(function(){
	  		$.getJSON('https://graph.facebook.com/238065426321929/feed?access_token=229040647557399|MQKFlFYX7YW25XGj4GUYZ7B1lcY', function(data) {
		var ahtml="";
		for(var i = 0; i < 5; i++) {
			ahtml=ahtml+"<li>"+data["data"][i]["message"]+"</li>";
		}
		ahtml=ahtml+"";
		$("#fbquotes").html(ahtml);
		$("#fbquotes").linkify();
	});
	 
		$.getJSON('https://api.github.com/repos/gama-platform/gama/commits', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data[i]["commit"]["message"]+" by "+data[i]["commit"]["author"]["name"]+" <a href='"+data[i]["html_url"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#commitquotes").html(ahtml);
			$("#commitquotes").linkify();
		});
				
				
		$.getJSON('https://api.github.com/repos/gama-platform/gama/issues', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data[i]["title"]+" by "+data[i]["user"]["login"]+" <a href='"+data[i]["html_url"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#issuequotes").html(ahtml);
			$("#issuequotes").linkify();
		});
		
		$.getJSON('https://api.rss2json.com/v1/api.json?rss_url=https%3A%2F%2Fgroups.google.com%2Fforum%2Ffeed%2Fgama-platform%2Ftopics%2Frss.xml%3Fnum%3D15', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data["items"][i]["title"]+" by "+data["items"][i]["author"]+" <a href='"+data["items"][i]["link"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#googleusersquotes").html(ahtml);
			$("#googleusersquotes").linkify();
			
		});
 });
  
</script>

    <div class="w3-bar w3-white w3-hide-small">
      <a href="/" class="w3-bar-item w3-button"><img src="/images/icon_gama_50.png"></a>
      <a href="/wiki/" class="w3-bar-item w3-button w3-text-blue">Documentation</a>
      <a href="/wiki/Tutorials" class="w3-bar-item w3-button w3-text-blue">Tutorials</a>
      <a href="#" class="w3-bar-item w3-button w3-text-blue">News</a>
      <a href="#" class="w3-bar-item w3-button w3-text-blue">Download</a>
      <a href="#" class="w3-bar-item w3-button w3-text-blue">Contribute</a>
    </div>

    <div class="w3-row-padding w3-padding-64 w3-container">
        <div>
             <div class="w3-quarter" style="width:260px">
		<nav class="w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left w3-small"  style="z-index:3;margin-left:10px" id="mySidebar">
                    <div class="w3-medium w3-text-blue" style="font-weight:bold"><div>
<a href='/wiki/Tutorials'>Tutorials
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/LearnGAMLStepByStep'>Learn GAML Step by Step
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/Introduction'>Introduction
</a><br/>
<a href='/wiki/StartWithGAML'>Start with GAML
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/ModelOrganization'>Organization of a model
</a><br/>
<a href='/wiki/BasicProgrammingConceptsInGAML'>Basic programming concepts in GAML
</a><br/>
    </div>
<a href='/wiki/ManipulateBasicSpecies'>Manipulate basic species
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/GlobalSpecies'>The global species
</a><br/>
<a href='/wiki/RegularSpecies'>Regular species
</a><br/>
<a href='/wiki/DefiningActionsAndBehaviors'>Defining actions and behaviors
</a><br/>
<a href='/wiki/InteractionBetweenAgents'>Interaction between agents
</a><br/>
<a href='/wiki/AttachingSkills'>Attaching Skills
</a><br/>
<a href='/wiki/Inheritance'>Inheritance
</a><br/>
    </div>
<a href='/wiki/DefiningAdvancedSpecies'>Defining advanced species
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/GridSpecies'>Grid Species
</a><br/>
<a href='/wiki/GraphSpecies'>Graph Species
</a><br/>
<a href='/wiki/MirrorSpecies'>Mirror species
</a><br/>
<a href='/wiki/MultiLevelArchitecture'>Multi-level architecture
</a><br/>
    </div>
<a href='/wiki/DefiningGUIExperiment'>Defining GUI Experiment
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/DefiningParameters'>Defining Parameters
</a><br/>
<a href='/wiki/DefiningDisplaysGeneralities'>Defining displays (Generalities)
</a><br/>
<a href='/wiki/DefiningCharts'>Defining Charts
</a><br/>
<a href='/wiki/Defining3DDisplays'>Defining 3D Displays
</a><br/>
<a href='/wiki/DefiningMonitorsAndInspectors'>Defining monitors and inspectors
</a><br/>
<a href='/wiki/DefiningExportFiles'>Defining export files
</a><br/>
<a href='/wiki/DefiningUserInteraction'>Defining user interaction
</a><br/>
    </div>
<a href='/wiki/ExploringModels'>Exploring Models
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/RunSeveralSimulations'>Run Several Simulations
</a><br/>
<a href='/wiki/BatchExperiments'>Defining Batch Experiments
</a><br/>
<a href='/wiki/ExplorationMethods'>Exploration Methods
</a><br/>
    </div>
<a href='/wiki/OptimizingModels'>Optimizing Models
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/RuntimeConcepts'>Runtime Concepts
</a><br/>
OptimizingModelsSelection
    </div>
<a href='/wiki/MultiParadigmModeling'>Multi-Paradigm Modeling
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/ControlArchitecture'>Control Architectures
</a><br/>
<a href='/wiki/Equations'>Using Equations
</a><br/>
    </div>
    </div>
<a href='/wiki/Recipes'>Recipes
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/ManipulateOSMDatas'>Manipulate OSM Datas
</a><br/>
<a href='/wiki/Diffusion'>Implementing diffusion
</a><br/>
<a href='/wiki/UsingDatabase'>Using Database Access
</a><br/>
<a href='/wiki/CallingR'>Calling R
</a><br/>
<a href='/wiki/UsingFIPAACL'>Using FIPA ACL
</a><br/>
<a href='/wiki/GamAnalyzer'>Using GAMAnalyzer
</a><br/>
<a href='/wiki/UsingBDI'>Using BDI
</a><br/>
<a href='/wiki/UsingDrivingSkill'>Advanced Driving Skill
</a><br/>
<a href='/wiki/ManipulateDates'>Manipulate Dates
</a><br/>
<a href='/wiki/ManipulateLight'>Implementing light
</a><br/>
<a href='/wiki/Comodel'>Using Comodel
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
—Headlessmodefordummies
    </div>
    </div>
    </div>
<a href='/wiki/Tutorials'>Tutorials
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/LuneraysFlu'>Luneray's flu
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/LuneraysFlu_step1'>1. Creation of a first basic disease spreading model
</a><br/>
<a href='/wiki/LuneraysFlu_step2'>2. Definition of monitors and chart outputs
</a><br/>
<a href='/wiki/LuneraysFlu_step3'>3. Importation of GIS data
</a><br/>
<a href='/wiki/LuneraysFlu_step4'>4. Use of a graph to constraint the movements of people]
</a><br/>
<a href='/wiki/LuneraysFlu_step5'>5. Definition of 3D displays
</a><br/>
    </div>
<a href='/wiki/IncrementalModel'>Incremental Model
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/IncrementalModel_step1'>1. Simple SI Model
</a><br/>
<a href='/wiki/IncrementalModel_step2'>2. Charts
</a><br/>
<a href='/wiki/IncrementalModel_step3'>3. Integration of GIS Data
</a><br/>
<a href='/wiki/IncrementalModel_step4'>4. Movement on Graph
</a><br/>
<a href='/wiki/IncrementalModel_step5'>5. Visualizing in 3D
</a><br/>
<a href='/wiki/IncrementalModel_step6'>6. Multi-Level
</a><br/>
<a href='/wiki/IncrementalModel_step7'>7. Differential Equations
</a><br/>
    </div>
<a href='/wiki/PredatorPrey'>Predator Prey
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/PredatorPrey_step1'>1. Basic Model
</a><br/>
<a href='/wiki/PredatorPrey_step2'>2. Vegetation Dynamic
</a><br/>
<a href='/wiki/PredatorPrey_step3'>3. Prey Agent Behavior
</a><br/>
<a href='/wiki/PredatorPrey_step4'>4. Inspectors and Monitors
</a><br/>
<a href='/wiki/PredatorPrey_step5'>5. Predator Agent
</a><br/>
<a href='/wiki/PredatorPrey_step6'>6. Breeding
</a><br/>
<a href='/wiki/PredatorPrey_step7'>7. Agent Aspect
</a><br/>
<a href='/wiki/PredatorPrey_step8'>8. Complex Behavior
</a><br/>
<a href='/wiki/PredatorPrey_step9'>9. Stopping condition
</a><br/>
<a href='/wiki/PredatorPrey_step10'>10. Charts
</a><br/>
<a href='/wiki/PredatorPrey_step11'>11. Writing Files
</a><br/>
<a href='/wiki/PredatorPrey_step12'>12. Image loading
</a><br/>
    </div>
<a href='/wiki/RoadTrafficModel'>Road Traffic
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/RoadTrafficModel_step1'>1. Loading of GIS Data
</a><br/>
<a href='/wiki/RoadTrafficModel_step2'>2. People Agents
</a><br/>
<a href='/wiki/RoadTrafficModel_step3'>3. Movement of People
</a><br/>
<a href='/wiki/RoadTrafficModel_step4'>4. Weight for Road Network
</a><br/>
<a href='/wiki/RoadTrafficModel_step5'>5. Dynamic weights
</a><br/>
<a href='/wiki/RoadTrafficModel_step6'>6. Charts
</a><br/>
<a href='/wiki/RoadTrafficModel_step7'>7. Automatic Road Repair
</a><br/>
    </div>
<a href='/wiki/ThreeD'>3D Tutorial
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/ThreeD_step1'>1. Basic Model
</a><br/>
<a href='/wiki/ThreeD_step2'>2. Moving Cells
</a><br/>
<a href='/wiki/ThreeD_step3'>3. Connections
</a><br/>
    </div>
    </div>
    </div>
<a href='/wiki/References'>References
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/PlatformDocumentation'>Platform
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/InstallationAndLaunching'>Installation and Launching
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/Installation'>Installation
</a><br/>
<a href='/wiki/Launching'>Launching GAMA
</a><br/>
<a href='/wiki/Headless'>Headless Mode
</a><br/>
<a href='/wiki/Updating'>Updating GAMA
</a><br/>
<a href='/wiki/InstallingPlugins'>Installing Plugins
</a><br/>
<a href='/wiki/Troubleshooting'>Troubleshooting
</a><br/>
    </div>
<a href='/wiki/WorkspaceProjectsAndModels'>Workspace, Projects and Models
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/NavigatingWorkspace'>Navigating in the Workspace
</a><br/>
<a href='/wiki/ChangingWorkspace'>Changing Workspace
</a><br/>
<a href='/wiki/ImportingModels'>Importing Models
</a><br/>
    </div>
<a href='/wiki/EditingModels'>Editing models
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/GamlEditorGeneralities'>The GAML Editor - Generalities
</a><br/>
<a href='/wiki/GamlEditorToolbar'>The GAML Editor Toolbar
</a><br/>
<a href='/wiki/ValidationOfModels'>Validation of Models
</a><br/>
    </div>
<a href='/wiki/RunningExperiments'>Running Experiments
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/LaunchingExperiments'>Launching Experiments from the User Interface
</a><br/>
<a href='/wiki/ExperimentsUserInterface'>Experiments User Interface
</a><br/>
<a href='/wiki/MenusAndCommands'>Menus and Commands
</a><br/>
<a href='/wiki/ParametersView'>Parameters View
</a><br/>
<a href='/wiki/InspectorsAndMonitors'>Inspectors and monitors
</a><br/>
<a href='/wiki/Displays'>Displays
</a><br/>
<a href='/wiki/BatchSpecific'>Batch Specific UI
</a><br/>
<a href='/wiki/ErrorsView'>Errors View
</a><br/>
    </div>
<a href='/wiki/Preferences'>Preferences
</a><br/>
    </div>
<a href='/wiki/GamlReferences'>Gaml Reference
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/BuiltInSpecies'>Built-in Species
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/AgentBuiltIn'>The 'agent' built-in species (Under Construction)
</a><br/>
<a href='/wiki/ModelBuiltIn'>The 'model' built-in species (Under Construction)
</a><br/>
<a href='/wiki/ExperimentBuiltIn'>The 'experiment' built-in species (Under Construction)
</a><br/>
    </div>
<a href='/wiki/BuiltInSkills'>Built-in Skills
</a><br/>
<a href='/wiki/BuiltInArchitectures'>Built-in Architectures
</a><br/>
<a href='/wiki/Statements'>Statements
</a><br/>
<a href='/wiki/DataTypes'>Types
</a><br/>
<a href='/wiki/FileTypes'>File Types
</a><br/>
<a href='/wiki/Expressions'>Expressions
</a><br/>
      <div id='sub' class=' w3-padding-small w3-bar-block w3-small'>
<a href='/wiki/Literals'>Literals
</a><br/>
<a href='/wiki/UnitsAndConstants'>Units and constants
</a><br/>
<a href='/wiki/PseudoVariables'>Pseudo-variables
</a><br/>
<a href='/wiki/VariablesAndAttributes'>Variables and Attributes
</a><br/>
<a href='/wiki/Operators'>Operators 
</a><br/>
    </div>
    </div>
    </div>
Community
</div></div></nav></div>
    <div class="w3-threequarter">
        <h1 id="implementing-diffusion">Implementing diffusion</h1>

<p>GAMA provides you the possibility to represent and simulate the diffusion of a variable through a grid topology.</p>

<h2 id="index">Index</h2>

<ul>
  <li><a href="#diffuse-statement">Diffuse statement</a></li>
  <li><a href="#diffusion-with-matrix">Diffusion with matrix</a>
    <ul>
      <li><a href="#diffusion-matrix">Diffusion matrix</a></li>
      <li><a href="#gradient-matrix">Gradient matrix</a></li>
      <li><a href="#compute-multiple-propagations-at-the-same-step">Compute multiple propagations at the same step</a></li>
      <li><a href="#execution-several-diffusion-matrix">Executing several diffusion matrix</a></li>
    </ul>
  </li>
  <li><a href="#diffusion-with-parameters">Diffusion with parameters</a></li>
  <li><a href="#computation-methods">Computation methods</a>
    <ul>
      <li><a href="#convolution">Convolution</a></li>
      <li><a href="#dot-product">Dot Product</a></li>
    </ul>
  </li>
  <li><a href="#using-mask">Use mask</a>
    <ul>
      <li><a href="#generalities">Generalities</a></li>
      <li><a href="#tips">Tips</a></li>
    </ul>
  </li>
  <li><a href="#pseudo-code">Pseudo code</a></li>
</ul>

<h2 id="diffuse-statement">Diffuse statement</h2>

<p>The statement to use for the diffusion is <code class="highlighter-rouge">diffuse</code>. It has to be used in a <code class="highlighter-rouge">grid</code> species. The <code class="highlighter-rouge">diffuse</code> uses the following facets:</p>

<ul>
  <li><strong><code class="highlighter-rouge">var</code></strong> (an identifier), (omissible) : the variable to be diffused</li>
  <li><strong><code class="highlighter-rouge">on</code></strong> (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occur</li>
  <li><code class="highlighter-rouge">avoid_mask</code> (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the variation value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won’t diffuse the value afterward (lost of signal). (default value : false)</li>
  <li><code class="highlighter-rouge">cycle_length</code> (int): the number of diffusion operation applied in one simulation step</li>
  <li><code class="highlighter-rouge">mask</code> (matrix): a matrix masking the diffusion (matrix created from a image for example). The cells corresponding to the values smaller than “-1” in the mask matrix will not diffuse, and the other will diffuse.</li>
  <li><code class="highlighter-rouge">matrix</code> (matrix): the diffusion matrix (“kernel” or “filter” in image processing). Can have any size, as long as dimensions are odd values.</li>
  <li><code class="highlighter-rouge">method</code> (an identifier), takes values in: {convolution, dot_product}: the diffusion method</li>
  <li><code class="highlighter-rouge">min_value</code> (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.</li>
  <li><code class="highlighter-rouge">propagation</code> (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals ‘diffusion’, the intensity of a signal is shared between its neighbors with respect to ‘proportion’, ‘variation’ and the number of neighbours of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S’ = (S / N / proportion) - variation. The intensity of S is then diminished by S <code class="highlighter-rouge">*</code> proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals ‘gradient’, the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If ‘propagation’ is not defined, it is assumed that it is equal to ‘diffusion’.</li>
  <li><code class="highlighter-rouge">proportion</code> (float): a diffusion rate</li>
  <li><code class="highlighter-rouge">radius</code> (int): a diffusion radius (in number of cells from the center)</li>
  <li><code class="highlighter-rouge">variation</code> (float): an absolute value to decrease at each neighbors</li>
</ul>

<p>To write a diffusion, you first have to declare a grid, and declare a special attribute for the diffusion. You will then have to write the <code class="highlighter-rouge">diffuse</code> statement in an other scope (such as the <code class="highlighter-rouge">global</code> scope for instance), which will permit the values to be diffused at each step. There, you will specify which variable you want to diffuse (through the <strong><code class="highlighter-rouge">var</code></strong> facet), on which species or list of agents you want the diffusion (through the <strong><code class="highlighter-rouge">on</code></strong> facet), and how you want this value to be diffused (through all the other facets, we will see how it works <a href="#diffusion-with-matrix">with matrix</a> and <a href="#diffusion-with-parameters">with special parameters</a> just after).</p>

<p>Here is the template of code we will use for the next following part of this page:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>global {
	int size &lt;- 64; // the size has to be a power of 2.
  	cells selected_cells;

	// Initialize the emiter cell as the cell at the center of the word
	init {
		selected_cells &lt;- location as cells;
	}
	// Affecting "1" to each step
	reflex new_Value {
		ask(selected_cells){
			phero &lt;- 1.0;
		}	
	}

	reflex diff {
		// Declare a diffusion on the grid "cells" and on "quick_cells". The diffusion declared on "quick_cells" will make 10 computations at each step to accelerate the process. 
		// The value of the diffusion will be store in the new variable "phero" of the cell.
		diffuse var: phero on: cells /*HERE WRITE DOWN THE DIFFUSION PROPERTIES*/;			
	}
}


grid cells height: size width: size {
	// "phero" is the variable storing the value of the diffusion
	float phero  &lt;- 0.0;
	// The color of the cell is linked to the value of "phero".
	rgb color &lt;- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);
}


experiment diffusion type: gui {
	output {
		display a type: opengl {
			// Display the grid with elevation
			grid cells elevation: phero * 10 triangulation: true;
		}
	}
}
</code></pre>
</div>

<p>This model will simulate a diffusion through a grid at each step, affecting 1 to the center cell diffusing variable value. The diffusion will be seen during the simulation through a color code, and through the elevation of the cell.</p>

<h2 id="diffusion-with-matrix">Diffusion with matrix</h2>

<p>A first way of specifying the behavior of your diffusion is using diffusion matrix. A diffusion matrix is a 2 dimension matrix <code class="highlighter-rouge">[n][m]</code> with <code class="highlighter-rouge">float</code> values, where both <code class="highlighter-rouge">n</code> and <code class="highlighter-rouge">m</code> have to be <strong>pair values</strong>. The most often, diffusion matrix are square matrix, but you can also declare rectangular matrix.</p>

<p>Example of matrix:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>matrix&lt;float&gt; mat_diff &lt;- matrix([
		[1/9,1/9,1/9],
		[1/9,1/9,1/9],
		[1/9,1/9,1/9]]);
</code></pre>
</div>

<p>In the <code class="highlighter-rouge">diffuse</code> statement, you than have to specify the matrix of diffusion you want in the facet <code class="highlighter-rouge">matrix</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>diffuse var: phero on: cells matrix:mat_diff;
</code></pre>
</div>

<p>Using the facet <code class="highlighter-rouge">propagation</code>, you can specify if you want the value to be propagated as a <em>diffusion</em> or as a <em>gratient</em>.</p>

<h3 id="diffusion-matrix">Diffusion matrix</h3>

<p>A <em>diffusion</em> (the default value of the facet <code class="highlighter-rouge">propagation</code>) will spread the values to the neighbors cells according to the diffusion matrix, and all those values will be added together, as it is the case in the following example :</p>

<p><img src="resources/images/recipes/diffusion_computation.png" alt="resources/images/recipes/diffusion_computation.png" /></p>

<p>Note that the sum of all the values diffused at the next step is equal to the sum of the values that will be diffused multiply by the sum of the values of the diffusion matrix. That means that if the sum of the values of your diffusion matrix is larger than 1, the values will increase exponentially at each step. The sum of the value of a diffusion matrix is usually equal to 1.</p>

<p>Here are some example of matrix you can use, played with the template model:</p>

<p><img src="resources/images/recipes/uniform_diffusion.png" alt="resources/images/recipes/uniform_diffusion.png" /></p>

<p><img src="resources/images/recipes/anisotropic_diffusion.png" alt="resources/images/recipes/anisotropic_diffusion.png" /></p>

<h3 id="gradient-matrix">Gradient matrix</h3>

<p>A <code class="highlighter-rouge">gradient</code> (use facet : <code class="highlighter-rouge">propagation:gradient</code>) is an other type of propagation. This time, only the larger value diffused will be chosen as the new one.</p>

<p><img src="resources/images/recipes/gradient_computation.png" alt="resources/images/recipes/gradient_computation.png" /></p>

<p>Note that unlike the <em>diffusion</em> propagation, the sum of your matrix can be greater than 1 (and it is the case, most often !).</p>

<p>Here are some example of matrix with gradient propagation:</p>

<p><img src="resources/images/recipes/uniform_gradient.png" alt="resources/images/recipes/uniform_gradient.png" /></p>

<p><img src="resources/images/recipes/irregular_gradient.png" alt="resources/images/recipes/irregular_gradient.png" /></p>

<h3 id="compute-multiple-propagations-at-the-same-step">Compute multiple propagations at the same step</h3>

<p>You can compute several times the propagation you want by using the facet <code class="highlighter-rouge">cycle_length</code>. GAMA will compute for you the corresponding new matrix, and will apply it.</p>

<p><img src="resources/images/recipes/cycle_length.png" alt="resources/images/recipes/cycle_length.png" /></p>

<p>Writing those two thinks are exactly equivalent (for diffusion):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	matrix&lt;float&gt; mat_diff &lt;- matrix([
			[1/81,2/81,3/81,2/81,1/81],
			[2/81,4/81,6/81,4/81,2/81],
			[3/81,6/81,1/9,6/81,3/81],
			[2/81,4/81,6/81,4/81,2/81],
			[1/81,2/81,3/81,2/81,1/81]]);
	reflex diff {
		diffuse var: phero on: cells matrix:mat_diff;
</code></pre>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>	matrix&lt;float&gt; mat_diff &lt;- matrix([
			[1/9,1/9,1/9],
			[1/9,1/9,1/9],
			[1/9,1/9,1/9]]);
	reflex diff {
		diffuse var: phero on: cells matrix:mat_diff cycle_length:2;
</code></pre>
</div>

<h3 id="executing-several-diffusion-matrix">Executing several diffusion matrix</h3>

<p>If you execute several times the statement <code class="highlighter-rouge">diffuse</code> with different matrix on the same variable, their values will be added (and centered if their dimension is not equal).</p>

<p>Thus, the following 3 matrix will be combined to create one unique matrix:</p>

<p><img src="resources/images/recipes/addition_matrix.png" alt="resources/images/recipes/addition_matrix.png" /></p>

<h2 id="diffusion-with-parameters">Diffusion with parameters</h2>

<p>Sometimes writing diffusion matrix is not exactly what you want, and you may prefer to just give some parameters to compute the correct diffusion matrix. You can use the following facets in order to do that : <code class="highlighter-rouge">propagation</code>, <code class="highlighter-rouge">variation</code> and <code class="highlighter-rouge">radius</code>.</p>

<p>Depending on which <code class="highlighter-rouge">propagation</code> you choose, and how many neighbors your grid have, the propagation matrix will be compute differently. The propagation matrix will have the size : range*2+1.</p>

<p>Let’s note <strong>P</strong> for the propagation value, <strong>V</strong> for the variation, <strong>R</strong> for the range and <strong>N</strong> for the number of neighbors.</p>

<ul>
  <li><strong>With diffusion propagation</strong></li>
</ul>

<p>For diffusion propagation, we compute following the following steps:</p>

<p>(1) We determine the “minimale” matrix according to N (if N = 8, the matrix will be <code class="highlighter-rouge">[[P/9,P/9,P/9][P/9,1/9,P/9][P/9,P/9,P/9]]</code>. if N = 4, the matrix will be <code class="highlighter-rouge">[[0,P/5,0][P/5,1/5,P/5][0,P/5,0]]</code>).</p>

<p>(2) If R != 1, we propagate the matrix R times to obtain a <code class="highlighter-rouge">[2*R+1][2*R+1]</code> matrix (same computation as for <code class="highlighter-rouge">cycle_length</code>).</p>

<p>(3) If V != 0, we substract each value by V*DistanceFromCenter (DistanceFromCenter depends on N).</p>

<p>Ex with the default values (P=1, R=1, V=0, N=8):</p>

<ul>
  <li><strong>With gradient propagation</strong></li>
</ul>

<p>The value of each cell will be equal to <strong>P/POW(N,DistanceFromCenter)-DistanceFromCenter*V</strong>. (DistanceFromCenter depends on N).</p>

<p>Ex with R=2, other parameters default values (R=2, P=1, V=0, N=8):</p>

<p><img src="resources/images/recipes/gradient_computation_from_parameters.png" alt="resources/images/recipes/gradient_computation_from_parameters.png" /></p>

<p>Note that if you declared a diffusion matrix, you cannot use those 3 facets (it will raise a warning). Note also that if you use parameters, you will only have uniform matrix.</p>

<h2 id="computation-methods">Computation methods</h2>

<p>You can compute the output matrix using two computation methods by using the facet <code class="highlighter-rouge">method</code> : the dot product and the convolution. Note that the result of those two methods is exactly the same (except if you use the <code class="highlighter-rouge">avoid_mask</code> facet, the results can be slightly differents between the two computations).</p>

<h3 id="convolution">Convolution</h3>

<p><code class="highlighter-rouge">convolution</code> is the default computation method for the diffusion. For every output cells, we will multiply the input values and the flipped kernel together, as shown in the following image :</p>

<p><img src="resources/images/recipes/convolution.png" alt="resources/images/recipes/convolution.png" /></p>

<p>Pseudo-code (<code class="highlighter-rouge">k</code> the kernel, <code class="highlighter-rouge">x</code> the input matrix, <code class="highlighter-rouge">y</code> the output matrix) :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for (i = 0 ; i &lt; y.nbRows ; i++)
  for (j = 0 ; j &lt; y.nbCols ; j++)
    for (m = 0 ; m &lt; k.nbRows ; m++)
      for (n = 0 ; n &lt; k.nbCols ; n++)
        y[i,j] += k[k.nbRows - m - 1, k.nbCols - n - 1] 
            * x[i - k.nbRows/2 + m, j - k.nbCols/2 + n]
</code></pre>
</div>

<h3 id="dot-product">Dot Product</h3>

<p><code class="highlighter-rouge">dot_product</code> method will compute the matrix using a simple dot product between the matrix. For every input cells, we multiply the cell by the kernel matrix, as shown in the following image :</p>

<p><img src="resources/images/recipes/dot_product.png" alt="resources/images/recipes/dot_product.png" /></p>

<p>Pseudo-code (<code class="highlighter-rouge">k</code> the kernel, <code class="highlighter-rouge">x</code> the input matrix, <code class="highlighter-rouge">y</code> the output matrix) :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for (i = 0 ; i &lt; y.nbRows ; i++)
  for (j = 0 ; j &lt; y.nbCols ; j++)
    for (m = 0 ; m &lt; k.nbRows ; m++)
      for (n = 0 ; n &lt; k.nbCols ; n++)
        y[i - k.nbRows/2 + m, j - k.nbCols/2 + n] += k[m, n] * x[i, j]
</code></pre>
</div>

<h2 id="using-mask">Using mask</h2>

<h3 id="generalities">Generalities</h3>

<p>If you want to propagate some values in an heterogeneous grid, you can use some mask to forbid some cells to propagate their values.</p>

<p>You can pass a matrix to the facet <code class="highlighter-rouge">mask</code>. All the values smaller than <code class="highlighter-rouge">-1</code> will not propagate, and all the values greater or equal to <code class="highlighter-rouge">-1</code> will propagate.</p>

<p>A simple way to use mask is by loading an image :</p>

<p><img src="resources/images/recipes/simple_mask.png" alt="resources/images/recipes/simple_mask.png" /></p>

<p>Note that when you use the <code class="highlighter-rouge">on</code> facet for the <code class="highlighter-rouge">diffuse</code> statement, you can choose only some cells, and not every cells. In fact, when you restrain the values to be diffuse, it is exactly the same process as if you were defining a mask.</p>

<p><img src="resources/images/recipes/mask_with_on_facet.png" alt="resources/images/recipes/mask_with_on_facet.png" /></p>

<p>When your diffusion is combined with a mask, the default behavior is that the non-masked cells will diffuse their values in <strong>all</strong> existing cells (that means, even the masked cells !). To change this behavior, you can use the facet <code class="highlighter-rouge">avoid_mask</code>. In that case, the value which was supposed to be affected to the masked cell will be redistributed to the neighboring non-masked cells.</p>

<h3 id="tips">Tips</h3>

<p>Masks can be used to simulate a lot of environments. Here are some ideas for your models:</p>

<h4 id="wall-blocking-the-diffusion">Wall blocking the diffusion</h4>

<p>If you want to simulate a wall blocking a uniform diffusion, you can declare a second diffusion matrix that will be applied only on the cells where your wall will be. This diffusion matrix will “push” the values outside from himself, but conserving the values (the sum of the values of the diffusion still have to be equal to 1) :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>matrix&lt;float&gt; mat_diff &lt;- matrix([
			[1/9,1/9,1/9],
			[1/9,1/9,1/9],
			[1/9,1/9,1/9]]);
								
matrix&lt;float&gt; mat_diff_left_wall &lt;- matrix([
			[0.0,0.0,2/9],
			[0.0,0.0,4/9],
			[0.0,0.0,2/9]]);

reflex diff { 
	diffuse var: phero on: (cells where(each.grid_x&gt;30)) matrix:mat_diff;
	diffuse var: phero on: (cells where(each.grid_x=30)) matrix:mat_diff_left_wall;
}
</code></pre>
</div>

<p><img src="resources/images/recipes/wall_simulation.png" alt="resources/images/recipes/wall_simulation.png" /></p>

<p>Note that almost the same result can be obtained by using the facet <code class="highlighter-rouge">avoid_mask</code> : the value of all masked cells will remain at 0, and the value which was supposed to be affected to the masked cell will be distributed to the neighboring cells. Notice that the results can be slightly different if you are using the <code class="highlighter-rouge">convolution</code> or the <code class="highlighter-rouge">dot_product</code> method : the algorithm of redistribution of the value to the neighboring cells is a bit different. We advise you to use the <code class="highlighter-rouge">dot_product</code> with the <code class="highlighter-rouge">avoid_mask</code> facet, the results are more accurates.</p>

<h4 id="wind-pushing-the-diffusion">Wind pushing the diffusion</h4>

<p>Let’s simulate a uniform diffusion that is pushed by a wind from “north” everywhere in the grid. A wind from “west” as blowing at the top side of the grid. We will here have to build 2 matrix : one for the uniform diffusion, one for the “north” wind and one for the “west” wind. The sum of the values for the 2 matrix meant to simulate the wind will be equal to 0 (as it will be add to the diffusion matrix).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>matrix&lt;float&gt; mat_diff &lt;- matrix([
		[1/9,1/9,1/9],
		[1/9,1/9,1/9],
		[1/9,1/9,1/9]]);
								
matrix&lt;float&gt; mat_wind_from_west &lt;- matrix([
		[-1/9,0.0,1/9],
		[-1/9,0.0,1/9],
		[-1/9,0.0,1/9]]);
								
matrix&lt;float&gt; mat_wind_from_north &lt;- matrix([
		[-1/9,-1/9,-1/9],
		[0.0,0.0,0.0],
		[1/9,1/9,1/9]]);

reflex diff { 
	diffuse var: phero on: cells matrix:mat_diff;
	diffuse var: phero on: cells matrix:mat_wind_from_north;
	diffuse var: phero on: (cells where (each.grid_y&gt;=32)) matrix:mat_wind_from_west;
}
</code></pre>
</div>

<p><img src="resources/images/recipes/diffusion_with_wind.png" alt="resources/images/recipes/diffusion_with_wind.png" /></p>

<h4 id="endless-world">Endless world</h4>

<p>Note that when your world is not a torus, it has the same effect as a <em>mask</em>, since all the values outside from the world cannot diffuse some values back :</p>

<p><img src="resources/images/recipes/uniform_diffusion_near_edge.png" alt="resources/images/recipes/uniform_diffusion_near_edge.png" /></p>

<p>You can “fake” the fact that your world is endless by adding a different diffusion for the cells with <code class="highlighter-rouge">grid_x=0</code> to have almost the same result :</p>

<p><img src="resources/images/recipes/uniform_diffusion_near_edge_with_mask.png" alt="resources/images/recipes/uniform_diffusion_near_edge_with_mask.png" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>matrix&lt;float&gt; mat_diff &lt;- matrix([
			[1/9,1/9,1/9],
			[1/9,1/9,1/9],
			[1/9,1/9,1/9]]);
								
matrix&lt;float&gt; mat_diff_upper_edge &lt;- matrix([
			[0.0,0.0,0.0],
			[1/9+7/81,2/9+1/81,1/9+7/81],
			[1/9,1/9,1/9]]);

reflex diff { 
	diffuse var: phero on: (cells where(each.grid_y&gt;0)) matrix:mat_diff;
	diffuse var: phero on: (cells where(each.grid_y=0)) matrix:mat_diff_upper_edge;
}
</code></pre>
</div>

<h2 id="pseudo-code">Pseudo code</h2>

<p><em>This section is more for a better understanding of the source code.</em></p>

<p>Here is the pseudo code for the computation of diffusion :</p>

<p>1) : Execute the statement <code class="highlighter-rouge">diffuse</code>, store the diffusions in a map (from class <em>DiffusionStatement</em> to class <em>GridDiffuser</em>) :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- Get all the facet values
- Compute the "real" mask, from the facet "mask:" and the facet "on:".
  - If no value for "mask:" and "on:" all the grid, the mask is equal to null.
- Compute the matrix of diffusion
  - If no value for "matrix:", compute with "nb_neighbors", "is_gradient", "proportion", "propagation", "variation", "range".
  - Then, compute the matrix of diffusion with "cycle_length".
- Store the diffusion properties in a map
  - Map : ["method_diffu", "is_gradient", "matrix", "mask", "min_value"] is value, ["var_diffu", "grid_name"] is key.
  - If the key exists in the map, try to "mix" the diffusions
    - If "method_diffu", "mask" and "is_gradient" equal for the 2 diffusions, mix the diffusion matrix.
</code></pre>
</div>

<p>2) : At the end of the step, execute the diffusions (class <em>GridDiffuser</em>) :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- For each key of the map,
  - Load the couple "var_diffu" / "grid_name"
  - Build the "output" and "input" array with the dimension of the grid. 
  - Initialize the "output" array with -Double.MAX_VALUE.
  - For each value of the map for that key,
    - Load all the properties : "method_diffu", "is_gradient", "matrix", "mask", "min_value"
    - Compute :
      - If the cell is not masked, if the value of input is &gt; min_value, diffuse to the neighbors.
        - If the value of the cell is equal to -Double.MAX_VALUE, remplace it by input[idx] * matDiffu[i][j].
        - Else, do the computation (gradient or diffusion).
    - Finish the diffusion :
      - If output[idx] &gt; -Double.MAX_VALUE, write the new value in the cell.
</code></pre>
</div>

    </div>
    </div>
    </div>
    </body></html>
