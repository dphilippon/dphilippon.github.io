
    <!doctype html><html lang="en"><head><meta charset="utf-8"><title>Graph Species</title></head>
    <body>
    <link rel="stylesheet" href="/style.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script src="//connect.facebook.net/en_US/all.js"></script>
<script src="/linkify.min.js"></script>
<script src="/linkify-jquery.min.js"></script>
<script>
  $(document).ready(function(){
	  		$.getJSON('https://graph.facebook.com/238065426321929/feed?access_token=229040647557399|MQKFlFYX7YW25XGj4GUYZ7B1lcY', function(data) {
		var ahtml="";
		for(var i = 0; i < 5; i++) {
			ahtml=ahtml+"<li>"+data["data"][i]["message"]+"</li>";
		}
		ahtml=ahtml+"";
		$("#fbquotes").html(ahtml);
		$("#fbquotes").linkify();
	});
	 
		$.getJSON('https://api.github.com/repos/gama-platform/gama/commits', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data[i]["commit"]["message"]+" by "+data[i]["commit"]["author"]["name"]+" <a href='"+data[i]["commit"]["html_url"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#commitquotes").html(ahtml);
			$("#commitquotes").linkify();
		});
				
				
		$.getJSON('https://api.github.com/repos/gama-platform/gama/issues', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data[i]["title"]+" by "+data[i]["user"]["login"]+" <a href='"+data[i]["html_url"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#issuequotes").html(ahtml);
			$("#issuequotes").linkify();
		});
		
		$.getJSON('https://api.rss2json.com/v1/api.json?rss_url=https%3A%2F%2Fgroups.google.com%2Fforum%2Ffeed%2Fgama-platform%2Ftopics%2Frss.xml%3Fnum%3D15', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data["items"][i]["title"]+" by "+data["items"][i]["author"]+" <a href='"+data["items"][i]["link"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#googleusersquotes").html(ahtml);
			$("#googleusersquotes").linkify();
			
		});
 });
  
</script>

      <div id="left">

		<ul class="mcd-menu"><li><a href="/">Home</a></li><li><a href="/">Discussions</a></li>
<li><a href='/wiki/Tutorials'>Tutorials
</a></li>
<ul class='sub'>
<li><a href='/wiki/LearnGAMLStepByStep'>Learn GAML Step by Step
</a></li>
<ul class='sub'>
<li><a href='/wiki/Introduction'>Introduction
</a></li>
<li><a href='/wiki/StartWithGAML'>Start with GAML
</a></li>
<ul class='sub'>
<li><a href='/wiki/ModelOrganization'>Organization of a model
</a></li>
<li><a href='/wiki/BasicProgrammingConceptsInGAML'>Basic programming concepts in GAML
</a></li>
</ul>
<li><a href='/wiki/ManipulateBasicSpecies'>Manipulate basic species
</a></li>
<ul class='sub'>
<li><a href='/wiki/GlobalSpecies'>The global species
</a></li>
<li><a href='/wiki/RegularSpecies'>Regular species
</a></li>
<li><a href='/wiki/DefiningActionsAndBehaviors'>Defining actions and behaviors
</a></li>
<li><a href='/wiki/InteractionBetweenAgents'>Interaction between agents
</a></li>
<li><a href='/wiki/AttachingSkills'>Attaching Skills
</a></li>
<li><a href='/wiki/Inheritance'>Inheritance
</a></li>
</ul>
<li><a href='/wiki/DefiningAdvancedSpecies'>Defining advanced species
</a></li>
<ul class='sub'>
<li><a href='/wiki/GridSpecies'>Grid Species
</a></li>
<li><a href='/wiki/GraphSpecies'>Graph Species
</a></li>
<li><a href='/wiki/MirrorSpecies'>Mirror species
</a></li>
<li><a href='/wiki/MultiLevelArchitecture'>Multi-level architecture
</a></li>
</ul>
<li><a href='/wiki/DefiningGUIExperiment'>Defining GUI Experiment
</a></li>
<ul class='sub'>
<li><a href='/wiki/DefiningParameters'>Defining Parameters
</a></li>
<li><a href='/wiki/DefiningDisplaysGeneralities'>Defining displays (Generalities)
</a></li>
<li><a href='/wiki/DefiningCharts'>Defining Charts
</a></li>
<li><a href='/wiki/Defining3DDisplays'>Defining 3D Displays
</a></li>
<li><a href='/wiki/DefiningMonitorsAndInspectors'>Defining monitors and inspectors
</a></li>
<li><a href='/wiki/DefiningExportFiles'>Defining export files
</a></li>
<li><a href='/wiki/DefiningUserInteraction'>Defining user interaction
</a></li>
</ul>
<li><a href='/wiki/ExploringModels'>Exploring Models
</a></li>
<ul class='sub'>
<li><a href='/wiki/RunSeveralSimulations'>Run Several Simulations
</a></li>
<li><a href='/wiki/BatchExperiments'>Defining Batch Experiments
</a></li>
<li><a href='/wiki/ExplorationMethods'>Exploration Methods
</a></li>
</ul>
<li><a href='/wiki/OptimizingModels'>Optimizing Models
</a></li>
<ul class='sub'>
<li><a href='/wiki/RuntimeConcepts'>Runtime Concepts
</a></li>
<li><a href='/wiki/OptimizingModels'>Optimizing Models
</a></li>
</ul>
<li><a href='/wiki/MultiParadigmModeling'>Multi-Paradigm Modeling
</a></li>
<ul class='sub'>
<li><a href='/wiki/ControlArchitecture'>Control Architectures
</a></li>
<li><a href='/wiki/Equations'>Using Equations
</a></li>
</ul>
</ul>
<li><a href='/wiki/Recipes'>Recipes
</a></li>
<ul class='sub'>
<li><a href='/wiki/ManipulateOSMDatas'>Manipulate OSM Datas
</a></li>
<li><a href='/wiki/Diffusion'>Implementing diffusion
</a></li>
<li><a href='/wiki/UsingDatabase'>Using Database Access
</a></li>
<li><a href='/wiki/CallingR'>Calling R
</a></li>
<li><a href='/wiki/UsingFIPAACL'>Using FIPA ACL
</a></li>
<li><a href='/wiki/GamAnalyzer'>Using GAMAnalyzer
</a></li>
<li><a href='/wiki/UsingBDI'>Using BDI
</a></li>
<li><a href='/wiki/UsingDrivingSkill'>Advanced Driving Skill
</a></li>
<li><a href='/wiki/ManipulateDates'>Manipulate Dates
</a></li>
<li><a href='/wiki/ManipulateLight'>Implementing light
</a></li>
<li><a href='/wiki/Comodel'>Using Comodel
</a></li>
</ul>
<li><a href='/wiki/Tutorials'>Tutorials
</a></li>
<ul class='sub'>
<li><a href='/wiki/LuneraysFlu'>Luneray's flu
</a></li>
<ul class='sub'>
<li><a href='/wiki/LuneraysFlu_step1'>1. Creation of a first basic disease spreading model
</a></li>
<li><a href='/wiki/LuneraysFlu_step2'>2. Definition of monitors and chart outputs
</a></li>
<li><a href='/wiki/LuneraysFlu_step3'>3. Importation of GIS data
</a></li>
<li><a href='/wiki/LuneraysFlu_step4'>4. Use of a graph to constraint the movements of people]
</a></li>
<li><a href='/wiki/LuneraysFlu_step5'>5. Definition of 3D displays
</a></li>
</ul>
<li><a href='/wiki/IncrementalModel'>Incremental Model
</a></li>
<ul class='sub'>
<li><a href='/wiki/IncrementalModel_step1'>1. Simple SI Model
</a></li>
<li><a href='/wiki/IncrementalModel_step2'>2. Charts
</a></li>
<li><a href='/wiki/IncrementalModel_step3'>3. Integration of GIS Data
</a></li>
<li><a href='/wiki/IncrementalModel_step4'>4. Movement on Graph
</a></li>
<li><a href='/wiki/IncrementalModel_step5'>5. Visualizing in 3D
</a></li>
<li><a href='/wiki/IncrementalModel_step6'>6. Multi-Level
</a></li>
<li><a href='/wiki/IncrementalModel_step7'>7. Differential Equations
</a></li>
</ul>
<li><a href='/wiki/PredatorPrey'>Predator Prey
</a></li>
<ul class='sub'>
<li><a href='/wiki/PredatorPrey_step1'>1. Basic Model
</a></li>
<li><a href='/wiki/PredatorPrey_step2'>2. Vegetation Dynamic
</a></li>
<li><a href='/wiki/PredatorPrey_step3'>3. Prey Agent Behavior
</a></li>
<li><a href='/wiki/PredatorPrey_step4'>4. Inspectors and Monitors
</a></li>
<li><a href='/wiki/PredatorPrey_step5'>5. Predator Agent
</a></li>
<li><a href='/wiki/PredatorPrey_step6'>6. Breeding
</a></li>
<li><a href='/wiki/PredatorPrey_step7'>7. Agent Aspect
</a></li>
<li><a href='/wiki/PredatorPrey_step8'>8. Complex Behavior
</a></li>
<li><a href='/wiki/PredatorPrey_step9'>9. Stopping condition
</a></li>
<li><a href='/wiki/PredatorPrey_step10'>10. Charts
</a></li>
<li><a href='/wiki/PredatorPrey_step11'>11. Writing Files
</a></li>
<li><a href='/wiki/PredatorPrey_step12'>12. Image loading
</a></li>
</ul>
<li><a href='/wiki/RoadTrafficModel'>Road Traffic
</a></li>
<ul class='sub'>
<li><a href='/wiki/RoadTrafficModel_step1'>1. Loading of GIS Data
</a></li>
<li><a href='/wiki/RoadTrafficModel_step2'>2. People Agents
</a></li>
<li><a href='/wiki/RoadTrafficModel_step3'>3. Movement of People
</a></li>
<li><a href='/wiki/RoadTrafficModel_step4'>4. Weight for Road Network
</a></li>
<li><a href='/wiki/RoadTrafficModel_step5'>5. Dynamic weights
</a></li>
<li><a href='/wiki/RoadTrafficModel_step6'>6. Charts
</a></li>
<li><a href='/wiki/RoadTrafficModel_step7'>7. Automatic Road Repair
</a></li>
</ul>
<li><a href='/wiki/ThreeD'>3D Tutorial
</a></li>
<ul class='sub'>
<li><a href='/wiki/ThreeD_step1'>1. Basic Model
</a></li>
<li><a href='/wiki/ThreeD_step2'>2. Moving Cells
</a></li>
<li><a href='/wiki/ThreeD_step3'>3. Connections
</a></li>
</ul>
</ul>
</ul>
<li><a href='/wiki/References'>References
</a></li>
<ul class='sub'>
<li><a href='/wiki/PlatformDocumentation'>Platform
</a></li>
<ul class='sub'>
<li><a href='/wiki/InstallationAndLaunching'>Installation and Launching
</a></li>
<ul class='sub'>
<li><a href='/wiki/Installation'>Installation
</a></li>
<li><a href='/wiki/Launching'>Launching GAMA
</a></li>
<li><a href='/wiki/Headless'>Headless Mode
</a></li>
<li><a href='/wiki/Updating'>Updating GAMA
</a></li>
<li><a href='/wiki/InstallingPlugins'>Installing Plugins
</a></li>
<li><a href='/wiki/Troubleshooting'>Troubleshooting
</a></li>
</ul>
<li><a href='/wiki/WorkspaceProjectsAndModels'>Workspace, Projects and Models
</a></li>
<ul class='sub'>
<li><a href='/wiki/NavigatingWorkspace'>Navigating in the Workspace
</a></li>
<li><a href='/wiki/ChangingWorkspace'>Changing Workspace
</a></li>
<li><a href='/wiki/ImportingModels'>Importing Models
</a></li>
</ul>
<li><a href='/wiki/EditingModels'>Editing models
</a></li>
<ul class='sub'>
<li><a href='/wiki/GamlEditorGeneralities'>The GAML Editor - Generalities
</a></li>
<li><a href='/wiki/GamlEditorToolbar'>The GAML Editor Toolbar
</a></li>
<li><a href='/wiki/ValidationOfModels'>Validation of Models
</a></li>
</ul>
<li><a href='/wiki/RunningExperiments'>Running Experiments
</a></li>
<ul class='sub'>
<li><a href='/wiki/LaunchingExperiments'>Launching Experiments from the User Interface
</a></li>
<li><a href='/wiki/ExperimentsUserInterface'>Experiments User Interface
</a></li>
<li><a href='/wiki/MenusAndCommands'>Menus and Commands
</a></li>
<li><a href='/wiki/ParametersView'>Parameters View
</a></li>
<li><a href='/wiki/InspectorsAndMonitors'>Inspectors and monitors
</a></li>
<li><a href='/wiki/Displays'>Displays
</a></li>
<li><a href='/wiki/BatchSpecific'>Batch Specific UI
</a></li>
<li><a href='/wiki/ErrorsView'>Errors View
</a></li>
</ul>
<li><a href='/wiki/Preferences'>Preferences
</a></li>
</ul>
<li><a href='/wiki/GamlReferences'>Gaml Reference
</a></li>
<ul class='sub'>
<li><a href='/wiki/BuiltInSpecies'>Built-in Species
</a></li>
<ul class='sub'>
<li><a href='/wiki/AgentBuiltIn'>The 'agent' built-in species (Under Construction)
</a></li>
<li><a href='/wiki/ModelBuiltIn'>The 'model' built-in species (Under Construction)
</a></li>
<li><a href='/wiki/ExperimentBuiltIn'>The 'experiment' built-in species (Under Construction)
</a></li>
</ul>
<li><a href='/wiki/BuiltInSkills'>Built-in Skills
</a></li>
<li><a href='/wiki/BuiltInArchitectures'>Built-in Architectures
</a></li>
<li><a href='/wiki/Statements'>Statements
</a></li>
<li><a href='/wiki/DataTypes'>Types
</a></li>
<li><a href='/wiki/FileTypes'>File Types
</a></li>
<li><a href='/wiki/Expressions'>Expressions
</a></li>
<ul class='sub'>
<li><a href='/wiki/Literals'>Literals
</a></li>
<li><a href='/wiki/UnitsAndConstants'>Units and constants
</a></li>
<li><a href='/wiki/PseudoVariables'>Pseudo-variables
</a></li>
<li><a href='/wiki/VariablesAndAttributes'>Variables and Attributes
</a></li>
<li><a href='/wiki/Operators'>Operators 
</a></li>
</ul>
</ul>
</ul>
<li>Community
</li>
<ul class='sub'>
<li><a href='/wiki/Contribute'>Contribute
</a></li>
<li><a href='/wiki/Projects'>Projects
</a></li>
<li><a href='/wiki/TrainingSession'>Training Session
</a></li>
</ul></ul></div><div id="right">
<h3>Facebook Activities</h3>
<ul id="fbquotes">
</ul>
<h3>Commit Activities</h3>
<ul id="commitquotes">
</ul>
<h3>Issue Activities</h3>
<ul id="issuequotes">
</ul>
<h3>Gama Platform Users Activities</h3>
<ul id="googleusersquotes">
</ul>
</div><div id="content"><h1 id="graph-species">Graph Species</h1>

<p>Using a graph species enables to easily show interaction between agents of a same species. This kind of species is particularly useful when trying to show the interaction (especially the non-spatial one) that exist between agents.</p>

<h2 id="index">Index</h2>

<ul>
  <li><a href="#declaration">Declaration</a>
    <ul>
      <li><a href="#declare-a-graph-with-handmade-agents">Declare a graph with handmade agents</a></li>
      <li><a href="#declare-a-graph-by-using-an-geometry-file">Declare a graph by using an geometry file</a></li>
      <li><a href="#declare-a-graph-with-nodes-and-edges">Declare a graph with nodes and edges</a></li>
    </ul>
  </li>
  <li><a href="#useful-operators-with-graph">Useful operators with graph</a>
    <ul>
      <li><a href="#knowing-the-degree-of-a-node">Knowing the degree of a node</a></li>
      <li><a href="#get-the-neighbors-of-a-node">Get the neighbors of a node</a></li>
      <li><a href="#compute-the-shortest-path">Compute the shortest path</a></li>
      <li><a href="#control-the-weight-in-graph">Control the weight in graph</a></li>
    </ul>
  </li>
  <li><a href="#example">Example</a></li>
</ul>

<h2 id="declaration">Declaration</h2>

<h3 id="declare-a-graph-with-handmade-agents">Declare a graph with handmade agents</h3>

<p>To instantiate this <code class="highlighter-rouge">graph</code> species, several steps must be followed. First the graph species must inherit from the abstract species <code class="highlighter-rouge">graph_node</code>, then the method <code class="highlighter-rouge">related_to</code> must be redefined and finally an auxiliary species that inherits from <code class="highlighter-rouge">base_edge</code> used to represent the edges of the generated graph must be declared.
A graph node is an abstract species that must redefine one method called <code class="highlighter-rouge">related_to</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>species graph_agent parent: graph_node edge_species: edge_agent{
  bool related_to(graph_agent other){
  	return true;
  }
}

species edge_agent parent: base_edge {
}
</code></pre>
</div>

<p>The method <code class="highlighter-rouge">related_to</code> returns a boolean, and take the agents from the current species in argument. If the method returns true, the two agents (the current instance and the one as argument) will be linked.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>global{
	int number_of_agents &lt;- 5;
	init {
		create graph_agent number:number_of_agents;
	}
}

species graph_agent parent: graph_node edge_species: edge_agent{
  bool related_to(graph_agent other){
  	return true;
  }
  aspect base {
  	draw circle(1) color:#green;
  }
}

species edge_agent parent: base_edge {
	aspect base {
  	draw shape color:#blue;
  }
}

experiment MyExperiment type: gui {
    output {
        display MyDisplay type: java2D {
            species graph_agent aspect:base;
            species edge_agent aspect:base;
        }
    }
}
</code></pre>
</div>

<p><img src="resources/images/definingAdvancedSpecies/graph_related_to.png" alt="graph_related_to.png" /></p>

<p>You can for example link 2 agents when they are closer than a certain distance.
Beware: The topology used in graph species is the graph topology, and not the continuous topology. You can force the use of the continuous topology with the action <code class="highlighter-rouge">using</code> as follow:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>bool related_to(graph_agent other){
  	using topology:topology(world) {
  		return (self.location distance_to other.location &lt; 20);
  	}
}
</code></pre>
</div>

<p><img src="resources/images/definingAdvancedSpecies/graph_related_to2.png" alt="graph_related_to2.png" /></p>

<p>The abstract mother species “graph_node” has an attribute “my_graph”, with the type “graph”. The graph type represent a graph composed of vertices linked with edges. This type has built-in attributes such as <code class="highlighter-rouge">edges</code> (the list of all the edges agents), or <code class="highlighter-rouge">vertices</code> (the list of all the vertices agents).</p>

<h3 id="declare-a-graph-by-using-an-geometry-file">Declare a graph by using an geometry file</h3>

<p>In most cases, you will have to construct a graph from an existing file (example: a “shp” file). In that case, you will have to first instantiate a species from the shape file (with the <code class="highlighter-rouge">create</code> statement, using the facet <code class="highlighter-rouge">from</code>). When, you will have to extract a graph from the agent, using the operator <code class="highlighter-rouge">as_edge_graph</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>model load_shape_file 
 
global {
	file roads_shapefile &lt;- file("../includes/road.shp");
	geometry shape &lt;- envelope(roads_shapefile);
	graph road_network;

	init {
		create road from: roads_shapefile;
		road_network &lt;- as_edge_graph(road);
	}
}

species road {
	aspect geom {
		draw shape color: #black;
	}
}

experiment main_experiment type:gui{
	output {
		display map {
			species road aspect:geom;		
		}
	}
}
</code></pre>
</div>

<h3 id="declare-a-graph-with-nodes-and-edges">Declare a graph with nodes and edges</h3>

<p>Another way to create a graph is building it manually nodes by nodes, and then edges by edges, without using agent structures. Use the <code class="highlighter-rouge">add_node</code> operator and the <code class="highlighter-rouge">add_edge</code> operator to do so. Here is an example of how to do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>add point(0.0,0.0) to:nodes;
add point(90.0,90.0) to:nodes;
add point(20.0,20.0) to:nodes;
add point(40.0,50.0) to:nodes;
add point(100.0,0.0) to:nodes;

loop nod over:nodes {
	my_graph &lt;- my_graph add_node(nod);
}
		
my_graph &lt;- my_graph add_edge (nodes at 0::nodes at 2);
my_graph &lt;- my_graph add_edge (nodes at 2::nodes at 3);
my_graph &lt;- my_graph add_edge (nodes at 3::nodes at 1);
my_graph &lt;- my_graph add_edge (nodes at 0::nodes at 4);
my_graph &lt;- my_graph add_edge (nodes at 4::nodes at 1);
</code></pre>
</div>

<p>Using this solution, my_graph can have two types: it can be an a-spatial graph, or a spatial graph. The spatial graph will have a proper geometry, with segments that follow the position of your graph (you can access to the segments by using the built-in “segments”). The a-spatial graph will not have any shape.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>global
{
	graph my_spatial_graph&lt;-spatial_graph([]);
	graph my_aspatial_graph&lt;-graph([]);
	
	init {
		point node1 &lt;- {0.0,0.0};
		point node2 &lt;- {10.0,10.0};
		my_spatial_graph &lt;- my_spatial_graph add_node(node1);
		my_spatial_graph &lt;- my_spatial_graph add_node(node2);
		my_spatial_graph &lt;- my_spatial_graph add_edge(node1::node2);
		write my_spatial_graph.edges;
		// the output is [polyline ([{0.0,0.0,0.0},{10.0,10.0,0.0}])]
		my_aspatial_graph &lt;- my_aspatial_graph add_node(node1);
		my_aspatial_graph &lt;- my_aspatial_graph add_node(node2);
		my_aspatial_graph &lt;- my_aspatial_graph add_edge(node1::node2);
		write my_aspatial_graph.edges;
		// the output is [{0.0,0.0,0.0}::{10.0,10.0,0.0}]
	}
}
</code></pre>
</div>

<h2 id="useful-operators-with-graph">Useful operators with graph</h2>

<h3 id="knowing-the-degree-of-a-node">Knowing the degree of a node</h3>

<p>The operator <code class="highlighter-rouge">degree_of</code> returns the number of edge attached to a node. To use it, you have to specify a graph (on the left side of the operator), and a node (on the right side of the operator).</p>

<p>The following code (to put inside the node species) displays the number of edges attached to each node:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>aspect base
{
	draw text:string(my_graph degree_of node(5)) color:# black;
	status &lt;- 0;
}
</code></pre>
</div>

<h3 id="get-the-neighbors-of-a-node">Get the neighbors of a node</h3>

<p>To get the list of neighbors of a node, you should use the neighbors_of operator. On the left side of the operator, specify the graph you are using, and on the right side, specify the node. The operator returns the list of nodes located at a distance inferior or equal to 1, considering the graph topology.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>species graph_agent parent: graph_node edge_species: edge_agent
{
  list&lt;graph_agent&gt; list_neighbors &lt;- list&lt;graph_agent&gt;(my_graph neighbors_of (self));
}
</code></pre>
</div>

<p>Here is an example of model using those two previous concepts (a random node is chosen each step, displayed in red, and his neighbors are displayed in yellow):</p>

<p><img src="resources/images/definingAdvancedSpecies/graph_model.png" alt="graph_model.png" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>model graph_model

global
{
	int number_of_agents &lt;- 50;
	init
	{
		create graph_agent number: number_of_agents;
	}
	
	reflex update {
		ask graph_agent(one_of(graph_agent)) {
			status &lt;- 2;
			do update_neighbors;
		}
	}
}

species graph_agent parent: graph_node edge_species: edge_agent
{
	int status &lt;- 0;
	list&lt;int&gt; list_connected_index;
	
	init {
		int i&lt;-0;
		loop over:graph_agent {
			if (flip(0.1)) {
				add i to:list_connected_index;
			}
			i &lt;- i+1;
		}
	}
	
	bool related_to(graph_agent other){
	  	if (list_connected_index contains (graph_agent index_of other)) {
	  		return true;
	  	}
	  	return false;
	}
	
	action update_neighbors {

		list&lt;graph_agent&gt; list_neighbors &lt;- list&lt;graph_agent&gt;(my_graph neighbors_of (self));

		loop neighb over:list_neighbors {
			neighb.status &lt;- 1;
		}
	}

	aspect base
	{
		if (status = 0) {
			draw circle(2) color: # green;
		}
		else if (status = 1) {
			draw circle(2) color: # yellow;
		}
		else if (status = 2) {
			draw circle(2) color: # red;
		}
		draw text:string(my_graph degree_of self) color:# black size:4 at:point(self.location.x-1,self.location.y-2);
		status &lt;- 0;
	}
}

species edge_agent parent: base_edge
{
	aspect base
	{
		draw shape color: # blue;
	}
}

experiment MyExperiment type: gui
{
	output
	{
		display MyDisplay type: java2D
		{
			species graph_agent aspect: base;
			species edge_agent aspect: base;
		}
	}
}
</code></pre>
</div>

<h3 id="compute-the-shortest-path">Compute the shortest path</h3>

<p>To compute the shortest path to go from a point to another, pick a source and a destination among the vertices you have for your graph. Store those values as point type.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>point source;
point destination;
source &lt;- point(one_of(my_graph.vertices));
destination &lt;- point(one_of(my_graph.vertices));
</code></pre>
</div>

<p>Then, you can use the operator <code class="highlighter-rouge">path_between</code> to return the shortest path. To use this action, you have to give the graph, then the source point, and the destination point. This action returns a path type.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>path shortest_path;
shortest_path &lt;- path_between (my_graph, source,destination);
</code></pre>
</div>

<p>Another operator exists, <code class="highlighter-rouge">paths_between</code>, that returns a list of shortest paths between two points. Please read the documentation to learn more about this operator.</p>

<p>Here is an example of code that show the shortest path between two points of a graph:</p>

<p><img src="resources/images/definingAdvancedSpecies/shortest_path.png" alt="shortest_path.png" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>model graph_model

global
{
	int number_of_agents &lt;- 50;
	point source;
	point target;
	graph my_graph;
	path shortest_path;
		
	init
	{
		create graph_agent number: number_of_agents;
	}
	
	reflex pick_two_points {
		if (my_graph=nil) {
			ask graph_agent {
				myself.my_graph &lt;- self.my_graph;
				break;
			}
		}
		shortest_path &lt;- nil;
		loop while:shortest_path=nil {
			source &lt;- point(one_of(my_graph.vertices));
			target &lt;- point(one_of(my_graph.vertices));
			if (source != target) {
				shortest_path &lt;- path_between (my_graph, source,target);
			}
		}
	}
}

species graph_agent parent: graph_node edge_species: edge_agent
{
	list&lt;int&gt; list_connected_index;
	
	init {
		int i&lt;-0;
		loop over:graph_agent {
			if (flip(0.1)) {
				add i to:list_connected_index;
			}
			i &lt;- i+1;
		}
	}
	
	bool related_to(graph_agent other) {
	  	using topology:topology(world) {
  			return (self.location distance_to other.location &lt; 20);
  		}
	}

	aspect base	{
		draw circle(2) color: # green;
	}
}

species edge_agent parent: base_edge
{
	aspect base	{
		draw shape color: # blue;
	}
}

experiment MyExperiment type: gui {
	output {
		display MyDisplay type: java2D {
			species graph_agent aspect: base;
			species edge_agent aspect: base;
			graphics "shortest path" {
				if (shortest_path != nil) {
					draw circle(3) at: source color: #yellow;
					draw circle(3) at: target color: #cyan;
					draw (shortest_path.shape+1) color: #magenta;
				}
			}
		}
	}
}
</code></pre>
</div>

<h3 id="control-the-weight-in-graph">Control the weight in graph</h3>

<p>You can add a map of weight for the edges that compose the graph. Use the operator <code class="highlighter-rouge">with_weights</code> to put weights in your graph. The graph has to be on the left side of the operator, and the map has to be on the right side. In the map, you have to put edges as key, and the weight for that edge as value. One common use is to put the distance as weight:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>my_graph &lt;- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));
</code></pre>
</div>

<p>The calculation of shortest path can change according to the weight you choose for your edges. For example, here is the result of the calculation of the shortest path when all the edges have 1 as weight value (it is the default graph topology), and when the edges have their length as weight.</p>

<p><img src="resources/images/definingAdvancedSpecies/path_weight.png" alt="path_weight.png" /></p>

<p>Here is an example of implementation:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>model shortest_path_with_weight

global
{
	graph my_graph&lt;-spatial_graph([]);
	path shortest_path;
	list&lt;point&gt; nodes;
		
	init
	{
		add point(10.0,10.0) to:nodes;
		add point(90.0,90.0) to:nodes;
		add point(40.0,20.0) to:nodes;
		add point(80.0,50.0) to:nodes;
		add point(90.0,20.0) to:nodes;

		loop nod over:nodes {
			my_graph &lt;- my_graph add_node(nod);
		}
		
		my_graph &lt;- my_graph add_edge (nodes at 0::nodes at 2);
		my_graph &lt;- my_graph add_edge (nodes at 2::nodes at 3);
		my_graph &lt;- my_graph add_edge (nodes at 3::nodes at 1);
		my_graph &lt;- my_graph add_edge (nodes at 0::nodes at 4);
		my_graph &lt;- my_graph add_edge (nodes at 4::nodes at 1);
		
		// comment/decomment the following line to see the difference.
		my_graph &lt;- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));
		
		shortest_path &lt;- path_between(my_graph,nodes at 0, nodes at 1);
	}
}

experiment MyExperiment type: gui {
	output {
		display MyDisplay type: java2D {
			graphics "shortest path" {
				if (shortest_path != nil) {
					draw circle(3) at: point(shortest_path.source) color: #yellow;
					draw circle(3) at: point(shortest_path.target) color: #cyan;
					draw (shortest_path.shape+1) color: #magenta;
				}
				loop edges over: my_graph.edges {
					draw edges color: #black;
				}
			}
		}
	}
}
</code></pre>
</div>
</div></body></html>
