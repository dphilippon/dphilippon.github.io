
    <!doctype html><html lang="en"><head><meta charset="utf-8"><title>SIR_switch</title></head>
    <body>
    <link rel="stylesheet" href="/style.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script src="//connect.facebook.net/en_US/all.js"></script>
<script src="/linkify.min.js"></script>
<script src="/linkify-jquery.min.js"></script>
<script>
  $(document).ready(function(){
	  		$.getJSON('https://graph.facebook.com/238065426321929/feed?access_token=229040647557399|MQKFlFYX7YW25XGj4GUYZ7B1lcY', function(data) {
		var ahtml="";
		for(var i = 0; i < 5; i++) {
			ahtml=ahtml+"<li>"+data["data"][i]["message"]+"</li>";
		}
		ahtml=ahtml+"";
		$("#fbquotes").html(ahtml);
		$("#fbquotes").linkify();
	});
	 
		$.getJSON('https://api.github.com/repos/gama-platform/gama/commits', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data[i]["commit"]["message"]+" by "+data[i]["commit"]["author"]["name"]+" <a href='"+data[i]["html_url"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#commitquotes").html(ahtml);
			$("#commitquotes").linkify();
		});
				
				
		$.getJSON('https://api.github.com/repos/gama-platform/gama/issues', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data[i]["title"]+" by "+data[i]["user"]["login"]+" <a href='"+data[i]["html_url"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#issuequotes").html(ahtml);
			$("#issuequotes").linkify();
		});
		
		$.getJSON('https://api.rss2json.com/v1/api.json?rss_url=https%3A%2F%2Fgroups.google.com%2Fforum%2Ffeed%2Fgama-platform%2Ftopics%2Frss.xml%3Fnum%3D15', function(data) {
			var ahtml="";
			for(var i = 0; i < 5; i++) {
				ahtml=ahtml+"<li>"+data["items"][i]["title"]+" by "+data["items"][i]["author"]+" <a href='"+data["items"][i]["link"]+"'> See more</a></li>";
			}
			ahtml=ahtml+"";
			$("#googleusersquotes").html(ahtml);
			$("#googleusersquotes").linkify();
			
		});
 });
  
</script>

      <div id="left">

		<ul class="mcd-menu"><li><a href="/">Home</a></li><li><a href="/">Discussions</a></li>
<li><a href='/wiki/Tutorials'>Tutorials
</a></li>
<ul class='sub'>
<li><a href='/wiki/LearnGAMLStepByStep'>Learn GAML Step by Step
</a></li>
<ul class='sub'>
<li><a href='/wiki/Introduction'>Introduction
</a></li>
<li><a href='/wiki/StartWithGAML'>Start with GAML
</a></li>
<ul class='sub'>
<li><a href='/wiki/ModelOrganization'>Organization of a model
</a></li>
<li><a href='/wiki/BasicProgrammingConceptsInGAML'>Basic programming concepts in GAML
</a></li>
</ul>
<li><a href='/wiki/ManipulateBasicSpecies'>Manipulate basic species
</a></li>
<ul class='sub'>
<li><a href='/wiki/GlobalSpecies'>The global species
</a></li>
<li><a href='/wiki/RegularSpecies'>Regular species
</a></li>
<li><a href='/wiki/DefiningActionsAndBehaviors'>Defining actions and behaviors
</a></li>
<li><a href='/wiki/InteractionBetweenAgents'>Interaction between agents
</a></li>
<li><a href='/wiki/AttachingSkills'>Attaching Skills
</a></li>
<li><a href='/wiki/Inheritance'>Inheritance
</a></li>
</ul>
<li><a href='/wiki/DefiningAdvancedSpecies'>Defining advanced species
</a></li>
<ul class='sub'>
<li><a href='/wiki/GridSpecies'>Grid Species
</a></li>
<li><a href='/wiki/GraphSpecies'>Graph Species
</a></li>
<li><a href='/wiki/MirrorSpecies'>Mirror species
</a></li>
<li><a href='/wiki/MultiLevelArchitecture'>Multi-level architecture
</a></li>
</ul>
<li><a href='/wiki/DefiningGUIExperiment'>Defining GUI Experiment
</a></li>
<ul class='sub'>
<li><a href='/wiki/DefiningParameters'>Defining Parameters
</a></li>
<li><a href='/wiki/DefiningDisplaysGeneralities'>Defining displays (Generalities)
</a></li>
<li><a href='/wiki/DefiningCharts'>Defining Charts
</a></li>
<li><a href='/wiki/Defining3DDisplays'>Defining 3D Displays
</a></li>
<li><a href='/wiki/DefiningMonitorsAndInspectors'>Defining monitors and inspectors
</a></li>
<li><a href='/wiki/DefiningExportFiles'>Defining export files
</a></li>
<li><a href='/wiki/DefiningUserInteraction'>Defining user interaction
</a></li>
</ul>
<li><a href='/wiki/ExploringModels'>Exploring Models
</a></li>
<ul class='sub'>
<li><a href='/wiki/RunSeveralSimulations'>Run Several Simulations
</a></li>
<li><a href='/wiki/BatchExperiments'>Defining Batch Experiments
</a></li>
<li><a href='/wiki/ExplorationMethods'>Exploration Methods
</a></li>
</ul>
<li><a href='/wiki/OptimizingModels'>Optimizing Models
</a></li>
<ul class='sub'>
<li><a href='/wiki/RuntimeConcepts'>Runtime Concepts
</a></li>
<li><a href='/wiki/OptimizingModels'>Optimizing Models
</a></li>
</ul>
<li><a href='/wiki/MultiParadigmModeling'>Multi-Paradigm Modeling
</a></li>
<ul class='sub'>
<li><a href='/wiki/ControlArchitecture'>Control Architectures
</a></li>
<li><a href='/wiki/Equations'>Using Equations
</a></li>
</ul>
</ul>
<li><a href='/wiki/Recipes'>Recipes
</a></li>
<ul class='sub'>
<li><a href='/wiki/ManipulateOSMDatas'>Manipulate OSM Datas
</a></li>
<li><a href='/wiki/Diffusion'>Implementing diffusion
</a></li>
<li><a href='/wiki/UsingDatabase'>Using Database Access
</a></li>
<li><a href='/wiki/CallingR'>Calling R
</a></li>
<li><a href='/wiki/UsingFIPAACL'>Using FIPA ACL
</a></li>
<li><a href='/wiki/GamAnalyzer'>Using GAMAnalyzer
</a></li>
<li><a href='/wiki/UsingBDI'>Using BDI
</a></li>
<li><a href='/wiki/UsingDrivingSkill'>Advanced Driving Skill
</a></li>
<li><a href='/wiki/ManipulateDates'>Manipulate Dates
</a></li>
<li><a href='/wiki/ManipulateLight'>Implementing light
</a></li>
<li><a href='/wiki/Comodel'>Using Comodel
</a></li>
</ul>
<li><a href='/wiki/Tutorials'>Tutorials
</a></li>
<ul class='sub'>
<li><a href='/wiki/LuneraysFlu'>Luneray's flu
</a></li>
<ul class='sub'>
<li><a href='/wiki/LuneraysFlu_step1'>1. Creation of a first basic disease spreading model
</a></li>
<li><a href='/wiki/LuneraysFlu_step2'>2. Definition of monitors and chart outputs
</a></li>
<li><a href='/wiki/LuneraysFlu_step3'>3. Importation of GIS data
</a></li>
<li><a href='/wiki/LuneraysFlu_step4'>4. Use of a graph to constraint the movements of people]
</a></li>
<li><a href='/wiki/LuneraysFlu_step5'>5. Definition of 3D displays
</a></li>
</ul>
<li><a href='/wiki/IncrementalModel'>Incremental Model
</a></li>
<ul class='sub'>
<li><a href='/wiki/IncrementalModel_step1'>1. Simple SI Model
</a></li>
<li><a href='/wiki/IncrementalModel_step2'>2. Charts
</a></li>
<li><a href='/wiki/IncrementalModel_step3'>3. Integration of GIS Data
</a></li>
<li><a href='/wiki/IncrementalModel_step4'>4. Movement on Graph
</a></li>
<li><a href='/wiki/IncrementalModel_step5'>5. Visualizing in 3D
</a></li>
<li><a href='/wiki/IncrementalModel_step6'>6. Multi-Level
</a></li>
<li><a href='/wiki/IncrementalModel_step7'>7. Differential Equations
</a></li>
</ul>
<li><a href='/wiki/PredatorPrey'>Predator Prey
</a></li>
<ul class='sub'>
<li><a href='/wiki/PredatorPrey_step1'>1. Basic Model
</a></li>
<li><a href='/wiki/PredatorPrey_step2'>2. Vegetation Dynamic
</a></li>
<li><a href='/wiki/PredatorPrey_step3'>3. Prey Agent Behavior
</a></li>
<li><a href='/wiki/PredatorPrey_step4'>4. Inspectors and Monitors
</a></li>
<li><a href='/wiki/PredatorPrey_step5'>5. Predator Agent
</a></li>
<li><a href='/wiki/PredatorPrey_step6'>6. Breeding
</a></li>
<li><a href='/wiki/PredatorPrey_step7'>7. Agent Aspect
</a></li>
<li><a href='/wiki/PredatorPrey_step8'>8. Complex Behavior
</a></li>
<li><a href='/wiki/PredatorPrey_step9'>9. Stopping condition
</a></li>
<li><a href='/wiki/PredatorPrey_step10'>10. Charts
</a></li>
<li><a href='/wiki/PredatorPrey_step11'>11. Writing Files
</a></li>
<li><a href='/wiki/PredatorPrey_step12'>12. Image loading
</a></li>
</ul>
<li><a href='/wiki/RoadTrafficModel'>Road Traffic
</a></li>
<ul class='sub'>
<li><a href='/wiki/RoadTrafficModel_step1'>1. Loading of GIS Data
</a></li>
<li><a href='/wiki/RoadTrafficModel_step2'>2. People Agents
</a></li>
<li><a href='/wiki/RoadTrafficModel_step3'>3. Movement of People
</a></li>
<li><a href='/wiki/RoadTrafficModel_step4'>4. Weight for Road Network
</a></li>
<li><a href='/wiki/RoadTrafficModel_step5'>5. Dynamic weights
</a></li>
<li><a href='/wiki/RoadTrafficModel_step6'>6. Charts
</a></li>
<li><a href='/wiki/RoadTrafficModel_step7'>7. Automatic Road Repair
</a></li>
</ul>
<li><a href='/wiki/ThreeD'>3D Tutorial
</a></li>
<ul class='sub'>
<li><a href='/wiki/ThreeD_step1'>1. Basic Model
</a></li>
<li><a href='/wiki/ThreeD_step2'>2. Moving Cells
</a></li>
<li><a href='/wiki/ThreeD_step3'>3. Connections
</a></li>
</ul>
</ul>
</ul>
<li><a href='/wiki/References'>References
</a></li>
<ul class='sub'>
<li><a href='/wiki/PlatformDocumentation'>Platform
</a></li>
<ul class='sub'>
<li><a href='/wiki/InstallationAndLaunching'>Installation and Launching
</a></li>
<ul class='sub'>
<li><a href='/wiki/Installation'>Installation
</a></li>
<li><a href='/wiki/Launching'>Launching GAMA
</a></li>
<li><a href='/wiki/Headless'>Headless Mode
</a></li>
<li><a href='/wiki/Updating'>Updating GAMA
</a></li>
<li><a href='/wiki/InstallingPlugins'>Installing Plugins
</a></li>
<li><a href='/wiki/Troubleshooting'>Troubleshooting
</a></li>
</ul>
<li><a href='/wiki/WorkspaceProjectsAndModels'>Workspace, Projects and Models
</a></li>
<ul class='sub'>
<li><a href='/wiki/NavigatingWorkspace'>Navigating in the Workspace
</a></li>
<li><a href='/wiki/ChangingWorkspace'>Changing Workspace
</a></li>
<li><a href='/wiki/ImportingModels'>Importing Models
</a></li>
</ul>
<li><a href='/wiki/EditingModels'>Editing models
</a></li>
<ul class='sub'>
<li><a href='/wiki/GamlEditorGeneralities'>The GAML Editor - Generalities
</a></li>
<li><a href='/wiki/GamlEditorToolbar'>The GAML Editor Toolbar
</a></li>
<li><a href='/wiki/ValidationOfModels'>Validation of Models
</a></li>
</ul>
<li><a href='/wiki/RunningExperiments'>Running Experiments
</a></li>
<ul class='sub'>
<li><a href='/wiki/LaunchingExperiments'>Launching Experiments from the User Interface
</a></li>
<li><a href='/wiki/ExperimentsUserInterface'>Experiments User Interface
</a></li>
<li><a href='/wiki/MenusAndCommands'>Menus and Commands
</a></li>
<li><a href='/wiki/ParametersView'>Parameters View
</a></li>
<li><a href='/wiki/InspectorsAndMonitors'>Inspectors and monitors
</a></li>
<li><a href='/wiki/Displays'>Displays
</a></li>
<li><a href='/wiki/BatchSpecific'>Batch Specific UI
</a></li>
<li><a href='/wiki/ErrorsView'>Errors View
</a></li>
</ul>
<li><a href='/wiki/Preferences'>Preferences
</a></li>
</ul>
<li><a href='/wiki/GamlReferences'>Gaml Reference
</a></li>
<ul class='sub'>
<li><a href='/wiki/BuiltInSpecies'>Built-in Species
</a></li>
<ul class='sub'>
<li><a href='/wiki/AgentBuiltIn'>The 'agent' built-in species (Under Construction)
</a></li>
<li><a href='/wiki/ModelBuiltIn'>The 'model' built-in species (Under Construction)
</a></li>
<li><a href='/wiki/ExperimentBuiltIn'>The 'experiment' built-in species (Under Construction)
</a></li>
</ul>
<li><a href='/wiki/BuiltInSkills'>Built-in Skills
</a></li>
<li><a href='/wiki/BuiltInArchitectures'>Built-in Architectures
</a></li>
<li><a href='/wiki/Statements'>Statements
</a></li>
<li><a href='/wiki/DataTypes'>Types
</a></li>
<li><a href='/wiki/FileTypes'>File Types
</a></li>
<li><a href='/wiki/Expressions'>Expressions
</a></li>
<ul class='sub'>
<li><a href='/wiki/Literals'>Literals
</a></li>
<li><a href='/wiki/UnitsAndConstants'>Units and constants
</a></li>
<li><a href='/wiki/PseudoVariables'>Pseudo-variables
</a></li>
<li><a href='/wiki/VariablesAndAttributes'>Variables and Attributes
</a></li>
<li><a href='/wiki/Operators'>Operators 
</a></li>
</ul>
</ul>
</ul>
<li>Community
</li>
<ul class='sub'>
<li><a href='/wiki/Contribute'>Contribute
</a></li>
<li><a href='/wiki/Projects'>Projects
</a></li>
<li><a href='/wiki/TrainingSession'>Training Session
</a></li>
</ul></ul></div><div id="right">
<h3>Facebook Activities</h3>
<ul id="fbquotes">
</ul>
<h3>Commit Activities</h3>
<ul id="commitquotes">
</ul>
<h3>Issue Activities</h3>
<ul id="issuequotes">
</ul>
<h3>Gama Platform Users Activities</h3>
<ul id="googleusersquotes">
</ul>
</div><div id="content"><h1 id="sir_switch">SIR_switch</h1>

<p>_Author : tri and hqnghi _</p>

<p>A model which show how to implement ODE system, IBM model, and to switch from one to another using a threshold. Another interesting point seen in this model is the the minimization of the execution time by reducing the number of agents to compute infections.</p>

<p>Code of the model :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>model SIR_switch

global {
	// Parameters
	int initial_S &lt;- 495 ; // The number of susceptible
	int initial_I &lt;- 5   ; // The number of infected
	int initial_R &lt;- 0   ; // The number of removed 

	float beta &lt;- 0.1   ; // The parameter Beta 
	float delta &lt;- 0.01 ; // The parameter Delta	
	
	int switch_threshold &lt;- 120 ; // threshold for switching models
	bool local_infection &lt;- true ;
	int neighbours_range &lt;- 2 ;
	bool local_random_walk &lt;- true ; 
	
	
	// Global variables
	int grid_size &lt;- 50;
geometry shape &lt;- square(grid_size);
	int number_Hosts &lt;- initial_S + initial_I + initial_R; // Total number of individuals
	SIR_model current_model; // serves as an interface, it is transparent to user if model is maths or IBM

	float beta_maths;
	int gridSize &lt;- 1; //size of the grid
	float neighbourhoodSize &lt;- 1.0; // average size of the neighbourhood (in number of cells)	
	float adjust &lt;- 0.721; // to adjust math model to ABM when using random walk
	bool computeInfectionFromS &lt;- initial_S &lt; initial_I; // if true, use the S list to compute infections. If false, use I list.
	// the purpose is to minimize the number of evaluation by using the smallest list.
	
	init {
		create new_scheduler;
		/* determine the size of the neighbourhood and the average count of hosts neighbours */
		gridSize &lt;- length(sir_grid);
		int nbCells &lt;- 0;
		
		loop cell over: sir_grid {
			nbCells &lt;- nbCells + length(cell.neighbours);
		}

		neighbourhoodSize &lt;- nbCells / gridSize + 1; // +1 to count itself in the neighbourhood;
		beta_maths &lt;- beta * neighbourhoodSize * number_Hosts / gridSize * adjust;
		
		write 'Switch will happen at population sizes around ' +switch_threshold;
		write 'Basic Reproduction Number (R0): ' + string(beta / delta) + '\n';
		
		//Creation of the switch_model agent that will manage the switch between the mathematical and the individual based models
		create switch_model {
			threshold_to_IBM &lt;- switch_threshold;
			threshold_to_Maths &lt;- switch_threshold;
		}
		//Creation of the model according to the one to begin with
		if (first(switch_model).start_with_IBM) {
		//		write 'Starting with IBM model';
			create IBM_model;
			current_model &lt;- first(IBM_model);
		} else {
		//		write 'Starting with Maths model';
			create Math_model;
			current_model &lt;- first(Math_model);
		}
		//Initialization of the Susceptible, Infected, Resistant and Total Compartiment
		current_model.S &lt;- float(initial_S);
		current_model.I &lt;- float(initial_I);
		current_model.R &lt;- float(initial_R);
		current_model.N &lt;- number_Hosts;
		
		//Ask to the model to initialize itself according to the value initialized
		ask current_model {
			do initialize;
		}
		
		//Create the SIR maths with ODE to compare
		create my_SIR_maths {
			self.S &lt;- float(myself.initial_S);
			self.I &lt;- float(myself.initial_I);
			self.R &lt;- float(myself.initial_R);
			self.N &lt;- number_Hosts;
			self.beta1 &lt;- beta * neighbourhoodSize * (N / gridSize)* adjust;
			self.alpha &lt;- delta;
		}

	}

	reflex infection_computation_method {
	/* computing infection from S has a complexity of S*ngb, where ngb is the size of the neighbourhood.
	 * computing infection from I has a complexity of I*ngb.
	 * this reflex determine which method has the lowest cost.
	 * */
		computeInfectionFromS &lt;- (Host count (each.is_susceptible)) &lt; (Host count (each.is_infected));
	}

}
//Grid which represent the discretized space for the host agents
	grid sir_grid width: grid_size height: grid_size {
		rgb color &lt;- #black;
		list&lt;sir_grid&gt; neighbours &lt;- (self neighbors_at neighbours_range) of_species sir_grid;
	}


//Species which allows the execution of only Host, IBM_model, Math_model and switch_model at each cycle
species new_scheduler schedules: (Host + IBM_model + Math_model + switch_model) ;

//Species which represent the manager between IBM and Math model
species switch_model schedules: [] {
	int threshold_to_IBM &lt;- 45; // threshold under which the model swith to IBM
	int threshold_to_Maths &lt;- 50; // threshold under which the model swith to Maths model 
	bool start_with_IBM function: { (initial_S &lt; threshold_to_IBM or initial_I &lt; threshold_to_IBM) };

	//Switch the model used to IBM when the threshold is higher than the population
	reflex switch_to_IBM when: (current_model.model_type = 'Maths') {
		if (current_model.S &lt; threshold_to_IBM or current_model.I &lt; threshold_to_IBM) {
			write 'Switch to IBM model at cycle ' + string(cycle);
			create IBM_model {
				self.S &lt;- current_model.S;
				self.I &lt;- current_model.I;
				self.R &lt;- current_model.R;
				self.N &lt;- current_model.N;
				do initialize;
			}

			ask current_model {
				do remove_model;
			}

			current_model &lt;- first(IBM_model);
		}

	}
	//Switch the model used to Maths when the threshold is lower than the population
	reflex switch_to_Maths when: (current_model.model_type = 'IBM') {
		if (current_model.S &gt; threshold_to_Maths and current_model.I &gt; threshold_to_Maths) {
			write 'Switch to Maths model at cycle ' + cycle;
			create Math_model {
				self.S &lt;- current_model.S;
				self.I &lt;- current_model.I;
				self.R &lt;- current_model.R;
				self.N &lt;- current_model.N;
				do initialize;
			}

			ask current_model {
				do remove_model;
			}

			current_model &lt;- first(Math_model);
		}

	}

}
//Species which represent the SIR model used by the IBM and the Math models 
species SIR_model schedules: [] {
	float S;
	float I;
	float R;
	int N;
	string model_type &lt;- 'none';
	
	action remove_model {
		do die;
	}

	action initialize ;

}

//Species IBM Model which represent the Individual based model, derivated from SIR_model
species IBM_model schedules: [] parent: SIR_model {
	string model_type &lt;- 'IBM';
	
	//Action to initialize the Model with SIR compartiments
	action initialize {
		
		write 'Initializing IBM model with S=' + round(S) + ', I=' + round(I) + ', R=' + round(R) + '\n';
		//Creation of the host agents
		create Host number: round(S) {
			is_susceptible &lt;- true;
			is_infected &lt;- false;
			is_immune &lt;- false;
			color &lt;- #green;
		}

		create Host number: round(I) {
			is_susceptible &lt;- false;
			is_infected &lt;- true;
			is_immune &lt;- false;
			color &lt;- #red;
		}

		create Host number: round(R) {
			is_susceptible &lt;- false;
			is_infected &lt;- false;
			is_immune &lt;- true;
			color &lt;- #yellow;
		}
		do count;
	}

	reflex count {
		do count;
	}
	//Action to update the different compartiments
	action count {
		S &lt;- float(Host count (each.is_susceptible));
		I &lt;- float(Host count (each.is_infected));
		R &lt;- float(Host count (each.is_immune));
	}
	//Action to remove the model and kill all the agents it contains
	action remove_model {
		ask Host {
			do die;
		}

		do die;
	}

}

//Species Math Model which represent the mathematical Ordinary Differential Equations model, derivated from SIR_model
species Math_model schedules: [] parent: SIR_model {
	string model_type &lt;- 'Maths';
	float t;
	
	action initialize {
		write 'Initializing Maths model with S=' + S + ', I=' + I + ', R=' + R + '\n';
	}

	equation SIR {
		diff(S, t) = (-beta_maths * S * I / N);
		diff(I, t) = (beta_maths * S * I / N) - (delta * I);
		diff(R, t) = (delta * I);
	}

	reflex solving {solve SIR method: "rk4" step: 0.01 ;}
}
//Species host used by the Individual Based Model which move from one cell to another
species Host schedules: [] skills: [moving] {
	bool is_susceptible &lt;- true;
	bool is_infected &lt;- false;
	bool is_immune &lt;- false;
	rgb color &lt;- #green;
	sir_grid myPlace;
	
	/* next function computes the number of neighbours of the agent */
	int ngb_number function: {
		length(((self) neighbors_at (2)) of_species Host) - 1 // -1 is because the agent counts itself
	};
	
	init {
		myPlace &lt;- one_of(sir_grid as list);
		location &lt;- myPlace.location;
	}

	//Reflex to move the agents among the cells
	reflex basic_move {
		if (!local_random_walk) {
		/* random walk among neighbours */
			myPlace &lt;- one_of(myPlace.neighbours);
			location &lt;- myPlace.location;
		} else {
		/* move agent to a random place anywhere in the grid */
			myPlace &lt;- any(sir_grid);
			location &lt;- myPlace.location;
		}

	}
	//Reflex to make the agent infected when the infection is computed from S for a better execution time
	reflex become_infected when: (is_susceptible and computeInfectionFromS) {
		if (flip(1 - (1 - beta) ^ (((self) neighbors_at (2)) of_species Host) count (each.is_infected))) {
			is_susceptible &lt;- false;
			is_infected &lt;- true;
			is_immune &lt;- false;
			color &lt;- #red;
		}

	}
	//Reflex to make the agent infect others when the infection is not computed from S for a better execution time
	reflex infecte_others when: (is_infected and not (computeInfectionFromS)) {
		loop hst over: ((self) neighbors_at (2)) {
			if (hst.is_susceptible) {
				if (flip(beta)) {
					hst.is_susceptible &lt;- false;
					hst.is_infected &lt;- true;
					hst.is_immune &lt;- false;
					hst.color &lt;- #red;
				}
			}
		}
	}
	//Reflex to make the agent resistant
	reflex become_immune when: (is_infected and flip(delta)) {
		is_susceptible &lt;- false;
		is_infected &lt;- false;
		is_immune &lt;- true;
		color &lt;- #yellow;
	}

	aspect basic {
		draw circle(1) color: color;
	}

}
//Species which represent the SIR mathematical model 
species my_SIR_maths {
	float t;
	float I &lt;- float(iInit);
	float S &lt;- N - I;
	float R &lt;- 0.0;
			
	float alpha &lt;- 0.01 min: 0.0 max: 1.0;
	float beta1 &lt;- 0.1 min: 0.0 max: 1000.0;
	int N &lt;- 500 min: 1 max: 3000;
	int iInit &lt;- 1;

	equation SIR {
		diff(S, t) = (-beta1 * S * I / N);
		diff(I, t) = (beta1 * S * I / N) - (alpha * I);
		diff(R, t) = (alpha * I);
	}
	
	reflex solving {solve SIR method:"rk4" step:0.01;}

}



experiment mysimulation type: gui {
	parameter 'Number of Susceptible' type: int var: initial_S &lt;- 495 category: "Initial population"; 
	parameter 'Number of Infected'    type: int var: initial_I &lt;- 5   category: "Initial population";
	parameter 'Number of Removed'     type: int var: initial_R &lt;- 0   category: "Initial population";

	parameter 'Beta (S-&gt;I)'  type: float var: beta &lt;- 1.0   category: "Parameters";
	parameter 'Delta (I-&gt;R)' type: float var: delta &lt;- 0.01 category: "Parameters";	
	
	parameter 'Is the infection is computed locally?' type: bool var: local_infection &lt;- true category: "Infection";
	parameter 'Size of the neighbours' type: int var: neighbours_range &lt;- 2 min:1 max: 5 category: "Infection";

	parameter 'Local Random Walk' type: bool var: local_random_walk &lt;- true category: "Agents";	
	
	parameter 'Switch models at' type: int var: switch_threshold &lt;- 120 category: "Model";
	
	output {
		display 'sir display' {
			grid sir_grid lines: #black;
			species Host aspect: basic;
		}
	
		display 'Switch model' {
			chart 'Susceptible' type: series background: #lightgray style: exploded {
				data 'susceptible' value: current_model.S color: #green;
				data 'infected' value: current_model.I color: #red;
				data 'immune' value: current_model.R color: #yellow;
			}

		}

		display SI_maths  {
			chart "SI" type: series background: #white {
				data 'S' value: first((my_SIR_maths)).S color: #green;
				data 'I' value: first((my_SIR_maths)).I color: #red;
				data 'R' value: first((my_SIR_maths)).R color: #yellow;
			}

		}

	}

}
</code></pre>
</div>
</div></body></html>
