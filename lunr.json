{"Contribute.md":{"title":" Contribute","content":"# Contribute\n\nSince GAMA is a free opensource software, we are proud to share the source code with anyone who wants to contribute to the platform. Note that GAMA is easy to extand through the use of additionnal plugins.\n\n## Table of content\n\n* [Developer documentation](#developer-documentation)\n* [Source code](#source-code)\n* [GAMA Dev mailing list](#gama-dev-mailing-list)\n* [Developers](#developers)\n* [Citing GAMA](#citing-gama)\n\n## Developer documentation\n\nA more complete documentation exists on Github at the following address : [https://github.com/gama-platform/gama/wiki](https://github.com/gama-platform/gama/wiki). You can find here the last updated version of the documentation (the documentation of the latest git version), and also a [developer documentation](https://github.com/gama-platform/gama/wiki/DevelopingExtensions) (which is not available in the \"regular\" website).\n\n## Source Code\n\nGAMA can be downloaded as a regular application or [built from source](https://github.com/gama-platform/gama), which is necessary if you want to contribute to the platform.\nThe source code is available from this GITHub repository:\n\n```\nhttps://github.com/gama-platform/gama\n```\n\nWhich you can also browse from the web [here](https://github.com/gama-platform/gama).\nIt is, in any case, recommended to follow the instructions on [this page](https://github.com/gama-platform/gama/wiki/InstallingGitVersion) in order to build GAMA from source.\n\n## GAMA Dev mailing list\n\nIf you want to contribute to the platform, you can send a request to the developping team to be in the [gama-dev@googlegroups.com mailing list](http://groups.google.com/group/gama-dev).\n\n## Developers\n\nGAMA is being designed, developed and maintained by an active group of researchers coming from different institutions in France and Vietnam. Please find below a short introduction to each of them and a summary of their contributions to the platform:\n\n* **[Alexis Drogoul](https://www.researchgate.net/profile/Alexis_Drogoul)**, Senior Researcher at the [IRD](http://www.ird.fr), member of the [UMMISCO](http://www.ummisco.ird.fr) International Research Unit. Mostly working on agent-based modeling and simulation. Has contributed and still contributes to the original design of the platform, including the GAML language (from the meta-model to the editor) and simulation facilities like Java2D displays.\n* **[Patrick Taillandier](https://www.researchgate.net/profile/Patrick_Taillandier)**, Associate Professor at the [University of Rouen](http://www.univ-rouen.fr/), member of the [IDEES](http://www.umr-idees.fr/) CNRS Mixed Research Unit. Contributes since 2008 to the spatial and graph features (GIS integration, spatial operators) and to parameter space search algorithms. Currently working on new features related to graphical modeling and traffic simulation.\n* **[Benoit Gaudou](http://www.researchgate.net/profile/Benoit_Gaudou)**, Associate Professor at the [University Toulouse 1 Capitole](http://www.ut-capitole.fr/), member of the [IRIT](http://www.irit.fr/) CNRS Mixed Research Unit. Contributes since 2010 to documentation and unit test generation and coupling mathematical (ODE and PDE) and agent paradigms.\n* **[Arnaud Grignard](https://www.researchgate.net/profile/Arnaud_Grignard)**, software engineer and PhD fellow ([PDI-MSC](http://www.ummisco.ird.fr/pdi/)) at [UPMC](http://www.upmc.fr/). Contributes since 2011 to the development of new features related to visualization (3D Display), online analysis and interaction.\n* **[Huynh Quang Nghi](https://www.researchgate.net/profile/Huynh_Nghi)**, software engineering lecturer at [CTU](http://www.ctu.edu.vn) and PhD fellow ([PDI-MSC](http://www.ummisco.ird.fr/pdi/)) at [UPMC](http://www.upmc.fr/). Contributes since 2012 to the development of new features related to GAML parser, coupling formalisms in EBM-ABM and ABM-ABM.\n* **[Truong Minh Thai](https://www.researchgate.net/profile/Thai_Truong_Minh)**, software engineering lecturer at [CTU](http://www.ctu.edu.vn/) and PhD fellow (PRJ322-MOET) at [IRIT](http://www.irit.fr/)-[UT1](http://www.ut-capitole.fr/). Contributes since 2012 to the development of new features related to data management and analysis.\n* **[Nicolas Marilleau](http://www.ummisco.ird.fr/index.php?option=com_members&view=member&uid=62&Itemid=70)**, Researcher at the [IRD](http://www.ird.fr), member of the [UMMISCO](http://www.ummisco.ird.fr) International Research Unit and associate researcher at [DISC](http://disc.univ-fcomte.fr) team of [FEMTO-ST](http://www.femto-st.fr) institute. Contributes since 2010 to the development of headless mode and the high performance computing module.\n* **[Philippe Caillou](https://www.lri.fr/~caillou)**, Associate professor at the [University Paris Sud 11](http://www.u-psud.fr), member of the [LRI](http://www.lri.fr) and [INRIA](http://www.inria.fr) project-team [TAO](https://tao.lri.fr/tiki-index.php). Contributes since 2012 and actually working on charts, simulation analysis and BDI agents.\n* **[Vo Duc An](https://www.researchgate.net/profile/Duc-An_Vo)**, Post-doctoral Researcher, working on synthetic population generation in agent-based modelling, at the [UMMISCO](http://www.ummisco.ird.fr) International Research Unit of the [IRD](http://www.ird.fr). Has contributed to bringing the platform to the Eclipse RCP environment and to the development of several features (e.g., the FIPA-compliant agent communication capability, the multi-level architecture).\n* **[Truong Xuan Viet](https://www.researchgate.net/profile/Viet_Truong_Xuan)**, software engineering lecturer at [CTU](http://www.ctu.edu.vn) and PhD fellow ([PDI-MSC](http://www.ummisco.ird.fr/pdi/)) at [UPMC](http://www.upmc.fr/). Contributes since 2011 to the development of new features related to R caller, online GIS (OPENGIS: Web Map Service - WMS, Web Feature Services - WMS, Google map, etc).\n  * Samuel Thiriot\n\n\n## Citing GAMA\nIf you use GAMA in your research and want to cite it (in a paper, presentation, whatever), please use this reference:\n\n> A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems', Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.\n\nor you can choose to cite the website instead:\n\n> GAMA Platform website, http://gama-platform.org\n\nA complete list of references (papers and PhD theses on or using GAMA) is available on the [references](References) page.","url":"wiki/Contribute.md"},"Projects.md":{"title":" Projects","content":"## Projects\n\n___________________________________________________________\n\n## References\n\n\nThis page contains a subset of the scientific papers that have been written either about GAMA or using the platform as an experimental/modeling support.\n\nIf you happen to publish a paper that uses or discusses GAMA, please let us know, so that we can include it in this list.\n\nIf you need to cite GAMA in a paper, we kindly ask you to use this reference:\n\n  * [A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems', Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.](http://link.springer.com/chapter/10.1007/978-3-642-44927-7_9)\n\n\n\n\n### Papers about GAMA\n  * [Taillandier, Patrick, Arnaud Grignard, Benoit Gaudou, and Alexis Drogoul. \"Des données géographiques à la simulation à base d’agents: application de la plate-forme GAMA.\" Cybergeo: European Journal of Geography (2014).](http://spi.cybergeo.revues.org/26263)\n\n  * [A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems', Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.](http://link.springer.com/chapter/10.1007/978-3-642-44927-7_9)\n\n  * [Grignard, Arnaud, Alexis Drogoul, and Jean-Daniel Zucker. \"Online analysis and visualization of agent based models.\" Computational Science and Its Applications–ICCSA 2013. Springer Berlin Heidelberg, 2013. 662-672.](http://link.springer.com/chapter/10.1007/978-3-642-39637-3_52#page-1)\n\n  * [Taillandier, P., Drogoul, A., Vo, D.A. and Amouroux, E. (2012), GAMA: a simulation platform that integrates geographical information data, agent-based modeling and multi-scale control. In ‘The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, India, Volume 7057/2012, pp 242-258.](http://www.springerlink.com/content/j7135j8722742j82/)\n\n  * [Taillandier, P. & Drogoul, A. (2011), From Grid Environment to Geographic Vector Agents, Modeling with the GAMA simulation platform. In ‘25th Conference of the International Cartographic Association’, Paris, France.](http://icaci.org/files/documents/ICC_proceedings/ICC2011/Oral Presentations PDF/C4-Simulation, spatio-temporal modelling, visualisation/CO-288.pdf)\n\n  * Taillandier, P. ; Drogoul A. ; Vo D.A. & Amouroux, E. (2010), GAMA : bringing GIS and multi-level capabilities to multi-agent simulation, in ‘the 8th European Workshop on Multi-Agent Systems', Paris, France.\n\n  * Amouroux, E., Taillandier, P. &  Drogoul, A. (2010), Complex environment representation in epidemiology ABM: application on `H5N1` propagation. In ‘the 3rd International Conference on Theories and Applications of Computer Science’ (ICTACS'10).\n\n  * [Amouroux, E., Chu, T.Q., Boucher, A. and Drogoul, A. (2007), GAMA: an environment for implementing and running spatially explicit multi-agent simulations. In ‘Pacific Rim International Workshop on Multi-Agents', Bangkoku, Thailand, pp. 359--371.](http://www.springerlink.com/content/88006131542n1204/)\n\n\n\n\n### PhD theses\n  * **Truong Xuan Viet**, [\"Optimization by Simulation of an Environmental Surveillance Network: Application to the Fight against Rice Pests in the Mekong Delta (Vietnam)\"](https://drive.google.com/a/ctu.edu.vn/file/d/0B7ArAu2_CEjCaTVzZURNUGlfWmc/edit?usp=sharing), University of Paris 6 & Ho Chi Minh University of Technology, defended June 24th, 2014.\n\n  * **Nguyen Nhi Gia Vinh**, [\"Designing multi-scale models to support environmental decision: application to the control of Brown Plant Hopper invasions in the Mekong Delta (Vietnam)\"](https://drive.google.com/file/d/0BwzSY8KTNM0nLUVMVXR3WDVJSjQ/edit?usp=sharing), University of Paris 6, defended Oct. 31st, 2013.\n\n  * **Vo Duc An**, [\"An operational architecture to handle multiple levels of representation in agent-based models\"](https://dl.dropboxusercontent.com/u/70529600/manuscrit_VoDucAn.pdf), University of Paris 6, defended Nov. 30th 2012.\n\n  * **Amouroux Edouard**, [\"KIMONO: a descriptive agent-based modeling methodology for the exploration of complex systems: an application to epidemiology\"](http://tel.archives-ouvertes.fr/tel-00630779), University of Paris 6, defended Sept. 30th, 2011.\n\n  * **Chu Thanh Quang**, [\"Using agent-based models and machine learning to enhance spatial decision support systems: Application to resource allocation in situations of urban catastrophes\"](https://www.dropbox.com/s/i5ifnigqv7qltc9/CHU-Thanh-Quang_manuscrit.pdf), University of Paris 6, defended July 1st, 2011.\n\n  * **Nguyen Ngoc Doanh**, [\"Coupling Equation-Based and Individual-Based Models in the Study of Complex Systems: A Case Study in Theoretical Population Ecology\"](https://docs.google.com/file/d/0B5s1B4Qq19ycMDg4MTNhMmUtMDNlMC00NzQyLWFlZjEtMjZhOGY5YjRhNWU5/edit?hl=fr), University of Paris 6, defended Dec. 14th, 2010.\n\n\n\n\n### Research papers that use GAMA as modeling/simulation support\n**2014**\n\n  * E. G. Macatulad , A. C. Blanco (2014) 3DGIS-BASED MULTI-AGENT GEOSIMULATION AND VISUALIZATION OF BUILDING EVACUATION USING GAMA PLATFORM. The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, Volume XL-2, 2014. ISPRS Technical Commission II Symposium, 6 – 8 October 2014, Toronto, Canada. Retrieved from http://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XL-2/87/2014/isprsarchives-XL-2-87-2014.pdf\n\n\n  * S. Bhamidipati (2014) A simulation framework for asset management in climate-change adaptation of transportation infrastructure. In: Proceedings of 42nd European Transport Conference. Frankfurt, Germany. Retrieved from http://abstracts.aetransport.org/paper/download/id/4317\n\n  * [Gaudou, B., Sibertin-Blanc, C., Thérond, O., Amblard, F., Auda, Y., Arcangeli, J.-P., Balestrat, M., Charron-Moirez, M.-H., Gondet, E., Hong, Y., Lardy, R., Louail, T., Mayor, E., Panzoli, D., Sauvage, S., Sanchez-Perez, J., Taillandier, P., Nguyen, V. B., Vavasseur, M., Mazzega, P. (2014). The MAELIA multi-agent platform for integrated assessment of low-water management issues. In: International Workshop on Multi-Agent-Based Simulation (MABS 2013), Saint-Paul, MN, USA, 06/05/2013-07/05/2013, Vol. 8235, Shah Jamal Alam, H. Van Dyke Parunak, (Eds.), Springer, Lecture Notes in Computer Science, p. 85-110.](http://simsoc.free.fr/ressources/articles/2013/MAELIAmabs13.pdf)\n\n  * [Gaudou, B., Lorini, E., Mayor, E. (2014.) Moral Guilt: An Agent-Based Model Analysis. In: Conference of the European Social Simulation Association (ESSA 2013), Warsaw, 16/09/2013-20/09/2013, Vol. 229, Springer, Advances in Intelligent Systems and Computing, p. 95-106.](http://www.irit.fr/EmoTES/Documents/Conference/Conf_ic_2013_Gaudou_et_al.pdf)\n\n**2013**\n  * [Drogoul, A., Gaudou, B., Grignard, A., Taillandier, P., & Vo, D. A. (2013). Practical Approach To Agent-Based Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, p. 277-300, Regional Social Sciences Summer University.](http://hal.archives-ouvertes.fr/docs/00/93/24/23/PDF/JTD2012_-_Atelier_-_EN.pdf)\n\n  * [Drogoul, A., Gaudou, B. (2013) Methods for Agent-Based Computer Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, 1.6, p. 130-154, Regional Social Sciences Summer University. ](http://www.tamdaoconf.com/tamdao/wp-content/plugins/download-monitor/download.php?id=185)\n\n  * [Truong, M.-T., Amblard, F., Gaudou, B., Sibertin-Blanc, C., Truong, V. X., Drogoul, A., Hyunh, X. H., Le, M. N. (2013). An implementation of framework of business intelligence for agent-based simulation. In: Symposium on Information and Communication Technology (SoICT 2013), Da Nang, Viet Nam, 05/12/2013-06/12/2013, Quyet Thang Huynh, Thanh Binh Nguyen, Van Tien Do, Marc Bui, Hong Son Ngo (Eds.), ACM, p. 35-44.](http://dl.acm.org/citation.cfm?id=2542069)\n\n  * [Le, V. M., Gaudou, B., Taillandier, P., Vo, D. A (2013). A New BDI Architecture To Formalize Cognitive Agent Behaviors Into Simulations. In: Advanced Methods and Technologies for Agent and Multi-Agent Systems (KES-AMSTA 2013), Hue, Vietnam, 27/05/2013-29/05/2013, Vol. 252, Dariusz Barbucha, Manh Thanh Le, Robert J. Howlett, C. Jain Lakhmi (Eds.), IOS Press, Frontiers in Artificial Intelligence and Applications, p. 395-403.](http://ebooks.iospress.nl/publication/32865)\n\n**2012**\n  * [Taillandier, P., Therond, O., Gaudou B. (2012), A new BDI agent architecture based on the belief theory. Application to the modelling of cropping plan decision-making. In 'International Environmental Modelling and Software Society', Germany, pp. 107-116.](http://www.iemss.org/sites/iemss2012//proceedings/H2_0404_Taillandier_et_al.pdf)\n\n  * Taillandier, P., Therond, O., Gaudou B. (2012), Une architecture d'agent BDI basée sur la théorie des fonctions de croyance: application à la simulation du comportement des agriculteurs. In 'Journées Francophones sur les Systèmes Multi-Agents', France, pp. 107-116.\n\n  * [NGUYEN, Quoc Tuan, Alain BOUJU, and Pascal ESTRAILLIER. \"Multi-agent architecture with space-time components for the simulation of urban transportation systems.\" (2012).](http://www.sciencedirect.com.accesdistant.upmc.fr/science/article/pii/S1877042812042188)\n\n  * [Cisse, A., Bah, A., Drogoul, A., Cisse, A.T., Ndione, J.A., Kebe, C.M.F. & Taillandier P. (2012), Un modèle à base d’agents sur la transmission et la diffusion de la fièvre de la Vallée du Rift à Barkédji (Ferlo, Sénégal), Studia Informatica Universalis 10 (1), pp. 77-97.](http://studia.complexica.net/Art/RI100104.pdf)\n\n  * [Taillandier, P., Amouroux, E., Vo, D.A. and Olteanu-Raimond A.M. (2012), Using Belief Theory to formalize the agent behavior: application to the simulation of avian flu propagation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 575-587.](http://www.springerlink.com/content/8qg53u75q46252l2/)\n\n  * [Le, V.M., Adam, C., Canal, R., Gaudou, B., Ho, T.V. and Taillandier, P. (2012), Simulation of the emotion dynamics in a group of agents in an evacuation situation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 604-619.](http://www.springerlink.com/content/c838365603qr7tx0/)\n\n  * [Nguyen Vu, Q. A., Canal, R., Gaudou, B., Hassas, S., Armetta, F. (2012), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system. In: Journal of Ambient Intelligence and Humanized Computing, Springer-Verlag, Vol. 3 N. 4, p. 251-263.](http://link.springer.com/article/10.1007%2Fs12652-012-0140-0)\n\n**2011**\n  * Taillandier, P. & Therond, O. (2011), Use of the Belief Theory to formalize Agent Decision Making Processes : Application to cropping Plan Decision Making. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 138-142.\n\n  * Taillandier, P. & Amblard, F. (2011), Cartography of Multi-Agent Model Parameter Space through a reactive Dicotomous Approach. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 38-42.\n\n  * [Taillandier, P. & Stinckwich, S. (2011), Using the PROMETHEE Multi-Criteria Decision Making Method to Define New Exploration Strategies for Rescue Robots', IEEE International Symposium on Safety, Security, and Rescue Robotics, Kyoto, Japon, pp. 321 - 326.](http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6106747&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D6106747)\n\n**2010**\n  * [Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), A cluster-based approach for disturbed, spatialized, distributed information gathering systems,  in ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, pp. 588-603.](http://www.springerlink.com/content/u02nq35387418q11/)\n\n  * [Nguyen, N.D., Taillandier, P., Drogoul, A. and Augier, P. (2010), Inferring Equation-Based Models from Agent-Based Models: A Case Study in Competition Dynamics.In ‘The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, India, Volume 7057/2012, pp. 413-427.](http://www.springerlink.com/content/n23314gm326l4p27/)\n\n  * [Amouroux, E., Gaudou, B. Desvaux, S. and Drogoul, A. (2010), O.D.D.: a Promising but Incomplete Formalism For Individual-Based Model Specification. in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF'), pp. 1-4.](http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=5633421&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5633421)\n\n  * Nguyen, N.D., Phan, T.H.D., Nguyen, T.N.A., Drogoul, A. and Zucker, J-D. (2010), Disk Graph-Based Model for Competition Dynamic, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF').\n\n  * Nguyen, T.K., Marilleau, N., Ho T.V. and El Fallah Seghrouchni, A. (2010), A meta-model for specifying collaborative simulation, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF').\n\n  * [Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), `TrustSets` - Using trust to detect deceitful agents in a distributed information collecting system, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF'), the best student paper award.](http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5633080)\n\n  * [Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S., Armetta, F. and Stinckwich, S. (2010), Using trust and cluster organisation to improve robot swarm mapping, Paper to appear in ‘Workshop on Robots and Sensors integration in future rescue INformation system ’ (ROSIN 2010).](http://users.info.unicaen.fr/~serge/share/ROSIN10/rosin10_submission_8.pdf)\n\n**2009**\n  * [Taillandier, P. and Buard, E. (2009), Designing Agent Behaviour in Agent-Based Simulation through participatory method. In ‘The 12th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, Nagoya, Japan, pp. 571--578.](http://www.springerlink.com/content/hu37551467646471/)\n\n  * [Taillandier, P. and Chu, T.Q. (2009), Using Participatory Paradigm to Learn Human Behaviour. In ‘International Conference on Knowledge and Systems Engineering’, Ha noi, Viet Nam, pp. 55--60.](http://www.computer.org/portal/web/csdl/doi/10.1109/KSE.2009.33)\n\n  * [Gaudou, B., Ho, T.V. and Marilleau, N. (2009), Introduce collaboration in methodologies of modeling and simulation of Complex Systems. In ‘International Conference on Intelligent Networking and Collaborative Systems (INCOS '09)’. Barcelona, pp. 1--8.](http://portal2.acm.org/citation.cfm?id=1681504.1681534&coll=GUIDE&dl=GUIDE&CFID=://www.google.com.vn/search?hl=fr&CFTOKEN=www.google.com.vn/search?hl=fr)\n\n  * [Nguyen, T.K., Gaudou B., Ho T.V. and Marilleau N. (2009), Application of PAMS Collaboration Platform to Simulation-Based Researches in Soil Science: The Case of the MIcro-ORganism Project. In ‘IEEE International Conference on Computing and Telecommunication Technologies (IEEE-RIVF 09)’. Da Nang, Viet Nam, pp. 296--303.](http://ieeexplore.ieee.org/Xplore/login.jsp?url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel5%2F5174598%2F5174599%2F05174623.pdf%3Farnumber%3D5174623&authDecision=-203)\n\n  * [Nguyen, V.Q., Gaudou B., Canal R., Hassas S. and Armetta F. (2009), Stratégie de communication dans un système de collecte d’information à base d’agents perturbés. In ‘Journées Francophones sur les Systèmes Multi-Agents (JFSMA'09)’.](http://liesp.insa-lyon.fr/v2/?q=fr/node/100911)\n\n**2008**\n  * [Chu, T.Q., Boucher, A., Drogoul, A., Vo, D.A., Nguyen, H.P. and Zucker, J.D. (2008). Interactive Learning of Expert Criteria for Rescue Simulations. In ‘Pacific Rim International Workshop on Multi-Agents', Ha Noi, Viet Nam, pp. 127--138.](http://www.springerlink.com/content/r83v0125vl0430l1/)\n\n  * [Amouroux, E., Desvaux, S. and Drogoul, A. (2008), Towards Virtual Epidemiology: An Agent-Based Approach to the Modeling of H5N1 Propagation and Persistence in North-Vietnam. In ‘Pacific Rim International Workshop on Multi-Agents', Ha Noi, Viet Nam, pp. 26--33.](http://www.springerlink.com/content/v6471t1453k17244/)","url":"wiki/Projects.md"},"TrainingSession.md":{"title":" Training Session","content":"# Training Session\n\n## Modeling for supporting decision in urban management issues\n\n**_7-11 December 2015 - Siem Reap (Cambodia)_**\n\n![resources/other/trainingSession/SiemReap2015/photos/group.JPG](resources/other/trainingSession/SiemReap2015/photos/group.JPG)\n\nThis training session took place at the Apsara Authorities, where we introduced how to build a model with agent-based approach, using GAMA. In a new and very fast growing city such as Siem Reap, some measures have to be taken to anticipate the future of the city, and modeling is a science that can give some solutions to face those problems.\n\nThe training session was divided into 2 parts :\n* A theoretical part (3 days) dealing with the following subjects :\n  * Urban issues and introduction to Agent-Based Modeling\n  * Presentation of the modeling methodology\n  * Introduction to GAMA with a model on urban segregation\n  * GIS datas and graphs to model urban mobility\n  * GIS, Raster datas and graphs to model urban growth\n  * Use of experiments to calibrate and explore models\n* A practical part (2 days) to build a model about urban mobility in Siem Reap (by groups of 4/5 people)\n\n|![resources/other/trainingSession/SiemReap2015/photos/theorie.JPG](resources/other/trainingSession/SiemReap2015/photos/theorie.JPG)|![resources/other/trainingSession/SiemReap2015/photos/group_Alexis.JPG](resources/other/trainingSession/SiemReap2015/photos/group_Alexis.JPG)|\n|---|---|\n\nTrainers : Drogoul Alexis, Gaudou Benoit, Trung Quang, Philippon Damien, Mazars Julien.\n\n[Here the link to download the different projects](notDoneYet) (Gama version : 1.61)\n\n## A Glance at Sustainable Urban Development (JTD)\n\n**_July 2014 - Da lat (Vietnam)_**\n\nThe JTD ([Journées de Tam Dao](http://www.tamdaoconf.com/)) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 8th JTD, the topic was about sustainable urban development, and a workshop has been made especially about how to use tools as GAMA to build models in order to explore and understand urban spatial dynamics.\n\nTrainers : Drogoul Alexis, Banos Arnaud, Huỳnh Quang Nghi, Trương Chí Quang, Võ Đức Ân.\n\nHere is the link to download the pdf report of the JTD 2014 : https://drive.google.com/file/d/0B2Go6pohIhQcbERhczZRd253UUU/view.\n\n## The perception and Management of Risk (JTD)\n\n**_July 2013 - Da lat (Vietnam)_**\n\nThe JTD ([Journées de Tam Dao](http://www.tamdaoconf.com/)) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 7th JTD, the topic was about the perception and management of risks, and a workshop has been made especially about how to use tools as GAMA to build models in order to understand past crises to better understand the present.\n\nTrainers : Alexis Drogoul, Benoit Gaudou, Nasser Gasmi, Arnaud Grignard, Patrick Taillandier, Olivier Tessier, Võ Đức Ân\n\nHere is the link to download the pdf report of the JTD 2013 : https://drive.google.com/file/d/0B2Go6pohIhQcNXFwVllHd2pFdlk/view.\n\n## Water and its many Issues (JTD)\n\n**_July 2012 - Vietnam_**\n\nThe JTD ([Journées de Tam Dao](http://www.tamdaoconf.com/)) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 6th JTD, the topic was about the perception and management of risks, and a workshop has been made especially about how to use tools as GAMA to build models with an agent-based approach.\n\nTrainers : Alexis Drogoul, Benoit Gaudou, Arnaud Grignard, Patrick Taillandier, Vỗ Đức Ân\n\nHere is the link to download the pdf report of the JTD 2012 : https://docs.google.com/file/d/0B2Go6pohIhQcUWRKU2hPelNqQmc/view.","url":"wiki/TrainingSession.md"},"AgentBuiltIn.md":{"title":" The 'agent' built-in species (Under Construction)","content":"# The 'agent' built-in species (Under Construction)\n\n\nAs described in the [presentation of GAML](Introduction), the hierarchy of species derives from a single built-in species called `agent`. All its components (attributes, actions) will then be inherited by all direct or indirect children species (including [`model`](ModelBuiltIn) and [`experiment`](ExperimentBuiltIn)), with the exception of species that explicitly mention `use_minimal_agents: true` as a facet, which inherit from a stripped-down version of `agent` (see below).\n\n\n\n## `agent` attributes\n`agent` defines several attributes, which form the minimal set of knowledge any agent will have in a model.\n  * \n\n\n## `agent` actions","url":"wiki/AgentBuiltIn.md"},"BuiltInArchitectures.md":{"title":" Built-in Architectures","content":"# Built-in Architectures\n \t\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n\n## INTRODUCTION\n\n----\n\n## Table of Contents\n<wiki:toc max_depth=\"3\" />\n\t[fsm](#fsm), [parallel_bdi](#parallel_bdi), [probabilistic_tasks](#probabilistic_tasks), [reflex](#reflex), [simple_bdi](#simple_bdi), [sorted_tasks](#sorted_tasks), [user_first](#user_first), [user_last](#user_last), [user_only](#user_only), [weighted_tasks](#weighted_tasks), \n\n----\n\n[//]: # (keyword|architecture_fsm)\n## fsm \n### Variables\n\t   \n* **`state`** (string): Returns the current state in which the agent is   \n* **`states`** (list): Returns the list of all possible states the agents can be in \n \t\n### Actions \n\t\n\n----\n\n[//]: # (keyword|architecture_parallel_bdi)\n## parallel_bdi \n### Variables\n\t \n \t\n### Actions \n\t\n\n----\n\n[//]: # (keyword|architecture_probabilistic_tasks)\n## probabilistic_tasks \n### Variables\n\t \n \t\n### Actions \n\t\n\n----\n\n[//]: # (keyword|architecture_reflex)\n## reflex \n### Variables\n\t \n \t\n### Actions \n\t\n\n----\n\n[//]: # (keyword|architecture_simple_bdi)\n## simple_bdi \n### Variables\n\t   \n* **`belief_base`** (list):    \n* **`charisma`** (float):    \n* **`current_plan`** (any type):    \n* **`desire_base`** (list):    \n* **`emotion_base`** (list):    \n* **`intention_base`** (list):    \n* **`intention_persistence`** (float): intention persistence   \n* **`plan_base`** (list):    \n* **`plan_persistence`** (float): plan persistence   \n* **`probabilistic_choice`** (boolean):    \n* **`receptivity`** (float):    \n* **`social_link_base`** (list):    \n* **`thinking`** (list):    \n* **`uncertainty_base`** (list):    \n* **`use_emotions_architecture`** (boolean):    \n* **`use_social_architecture`** (boolean):  \n \t\n### Actions \n\t  \n\t \n#### **`add_belief`**\nadd the predicate in the belief base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to add as a belief  \n\t \n#### **`add_desire`**\nadds the predicates is in the desire base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to add \t\t\t\n* **`todo`** (546704): add the desire as a subintention of this parameter  \n\t \n#### **`add_emotion`**\nadd the emotion to the emotion base.\n* returns: bool \t\t\t\n* **`emotion`** (546706): emotion to add to the base  \n\t \n#### **`add_intention`**\ncheck if the predicates is in the desire base.\n* returns: bool \t\t\t\n* **`predicate`** (map): predicate to check  \n\t \n#### **`add_social_link`**\nadd the social link to the social link base.\n* returns: bool \t\t\t\n* **`social_link`** (546707): social link to add to the base  \n\t \n#### **`add_subintention`**\nadds the predicates is in the desire base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate name \t\t\t\n* **`subintentions`** (546704): the subintention to add to the predicate \t\t\t\n* **`add_as_desire`** (boolean): add the subintention as a desire as well (by default, false)  \n\t \n#### **`add_uncertainty`**\nadd a predicate in the uncertainty base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to check  \n\t \n#### **`clear_beliefs`**\nclear the belief base\n* returns: bool  \n\t \n#### **`clear_desires`**\nclear the desire base\n* returns: bool  \n\t \n#### **`clear_emotions`**\nclear the emotion base\n* returns: bool  \n\t \n#### **`clear_intentions`**\nclear the intention base\n* returns: bool  \n\t \n#### **`clear_social_links`**\nclear the intention base\n* returns: bool  \n\t \n#### **`clear_uncertainties`**\nclear the uncertainty base\n* returns: bool  \n\t \n#### **`current_intention_on_hold`**\nputs the current intention on hold until the specified condition is reached or all subintentions are reached (not in desire base anymore).\n* returns: bool \t\t\t\n* **`until`** (any type): the current intention is put on hold (fited plan are not considered) until specific condition is reached. Can be an expression (which will be tested), a list (of subintentions), or nil (by default the condition will be the current list of subintentions of the intention)  \n\t \n#### **`get_belief`**\nget the predicate in the belief base (if several, returns the first one).\n* returns: predicate \t\t\t\n* **`predicate`** (546704): predicate to get  \n\t \n#### **`get_belief_with_name`**\nget the predicates is in the belief base (if several, returns the first one).\n* returns: predicate \t\t\t\n* **`name`** (string): name of the predicate to check  \n\t \n#### **`get_beliefs`**\nget the list of predicates is in the belief base\n* returns: msi.gama.util.IList<msi.gaml.architecture.simplebdi.Predicate> \t\t\t\n* **`predicate`** (546704): name of the predicates to check  \n\t \n#### **`get_beliefs_with_name`**\nget the list of predicates is in the belief base with the given name.\n* returns: msi.gama.util.IList<msi.gaml.architecture.simplebdi.Predicate> \t\t\t\n* **`name`** (string): name of the predicates to check  \n\t \n#### **`get_current_intention`**\nreturns the current intention (last entry of intention base).\n* returns: predicate  \n\t \n#### **`get_desire`**\nget the predicates is in the desire base (if several, returns the first one).\n* returns: predicate \t\t\t\n* **`predicate`** (546704): predicate to check  \n\t \n#### **`get_desire_with_name`**\nget the predicates is in the belief base (if several, returns the first one).\n* returns: predicate \t\t\t\n* **`name`** (string): name of the predicate to check  \n\t \n#### **`get_desires`**\nget the list of predicates is in the belief base\n* returns: msi.gama.util.IList<msi.gaml.architecture.simplebdi.Predicate> \t\t\t\n* **`predicate`** (546704): name of the predicates to check  \n\t \n#### **`get_desires_with_name`**\nget the list of predicates is in the belief base with the given name.\n* returns: java.util.List<msi.gaml.architecture.simplebdi.Predicate> \t\t\t\n* **`name`** (string): name of the predicates to check  \n\t \n#### **`get_emotion`**\nget the emotion in the emotion base (if several, returns the first one).\n* returns: emotion \t\t\t\n* **`emotion`** (546706): emotion to get  \n\t \n#### **`get_intention`**\nget the predicates is in the belief base (if several, returns the first one).\n* returns: predicate \t\t\t\n* **`predicate`** (546704): predicate to check  \n\t \n#### **`get_intention_with_name`**\nget the predicates is in the belief base (if several, returns the first one).\n* returns: predicate \t\t\t\n* **`name`** (string): name of the predicate to check  \n\t \n#### **`get_intentions`**\nget the list of predicates is in the belief base\n* returns: msi.gama.util.IList<msi.gaml.architecture.simplebdi.Predicate> \t\t\t\n* **`predicate`** (546704): name of the predicates to check  \n\t \n#### **`get_intentions_with_name`**\nget the list of predicates is in the belief base with the given name.\n* returns: java.util.List<msi.gaml.architecture.simplebdi.Predicate> \t\t\t\n* **`name`** (string): name of the predicates to check  \n\t \n#### **`get_plans`**\nget the list of plans.\n* returns: java.util.List<msi.gaml.architecture.simplebdi.BDIPlan>  \n\t \n#### **`get_social_link`**\nget the social linke (if several, returns the first one).\n* returns: msi.gaml.architecture.simplebdi.SocialLink \t\t\t\n* **`social_link`** (546707): social link to check  \n\t \n#### **`get_uncertainty`**\nget the predicates is in the uncertainty base (if several, returns the first one).\n* returns: predicate \t\t\t\n* **`predicate`** (546704): predicate to check  \n\t \n#### **`has_belief`**\ncheck if the predicates is in the belief base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to check  \n\t \n#### **`has_desire`**\ncheck if the predicates is in the desire base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to check  \n\t \n#### **`has_emotion`**\ncheck if the emotion is in the belief base.\n* returns: bool \t\t\t\n* **`emotion`** (546706): emotion to check  \n\t \n#### **`has_social_link`**\ncheck if the social link base.\n* returns: bool \t\t\t\n* **`social_link`** (546707): social link to check  \n\t \n#### **`has_uncertainty`**\ncheck if the predicates is in the uncertainty base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to check  \n\t \n#### **`is_current_intention`**\ncheck if the predicates is the current intention (last entry of intention base).\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to check  \n\t \n#### **`remove_all_beliefs`**\nremoves the predicates from the belief base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to remove  \n\t \n#### **`remove_belief`**\nremoves the predicate from the belief base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to remove  \n\t \n#### **`remove_desire`**\nremoves the predicates from the desire base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to add  \n\t \n#### **`remove_emotion`**\nremoves the emotion from the emotion base.\n* returns: bool \t\t\t\n* **`emotion`** (546706): emotion to remove  \n\t \n#### **`remove_intention`**\nremoves the predicates from the desire base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to add \t\t\t\n* **`desire_also`** (boolean): removes also desire  \n\t \n#### **`remove_social_link`**\nremoves the social link from the social relation base.\n* returns: bool \t\t\t\n* **`social_link`** (546707): social link to remove  \n\t \n#### **`remove_uncertainty`**\nremoves the predicates from the desire base.\n* returns: bool \t\t\t\n* **`predicate`** (546704): predicate to add  \n\t \n#### **`replace_belief`**\nreplace the old predicate by the new one.\n* returns: bool \t\t\t\n* **`old_predicate`** (546704): predicate to remove \t\t\t\n* **`predicate`** (546704): predicate to add\n\n----\n\n[//]: # (keyword|architecture_sorted_tasks)\n## sorted_tasks \n### Variables\n\t \n \t\n### Actions \n\t\n\n----\n\n[//]: # (keyword|architecture_user_first)\n## user_first \n### Variables\n\t \n \t\n### Actions \n\t\n\n----\n\n[//]: # (keyword|architecture_user_last)\n## user_last \n### Variables\n\t \n \t\n### Actions \n\t\n\n----\n\n[//]: # (keyword|architecture_user_only)\n## user_only \n### Variables\n\t \n \t\n### Actions \n\t\n\n----\n\n[//]: # (keyword|architecture_weighted_tasks)\n## weighted_tasks \n### Variables\n\t \n \t\n### Actions \n\t","url":"wiki/BuiltInArchitectures.md"},"BuiltInSkills.md":{"title":" Built-in Skills","content":"# Built-in Skills\n\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Introduction\n\nSkills are built-in modules, written in Java, that provide a set of related built-in variables and built-in actions (in addition to those already provided by GAMA) to the species that declare them. A declaration of skill is done by filling the skills attribute in the species definition:\n\n```\nspecies my_species skills: [skill1, skill2] {\n    ...\n}\n```\n\nSkills have been designed to be mutually compatible so that any combination of them will result in a functional species. An example of skill is the `moving` skill.\n  \nSo, for instance, if a species is declared as:\n\n```\nspecies foo skills: [moving]{\n...\n}\n```\n\nIts agents will automatically be provided with the following variables : `speed`, `heading`, `destination` and the following actions: `move`, `goto`, `wander`, `follow` in addition to those built-in in species and declared by the modeller. Most of these variables, except the ones marked read-only, can be customized and modified like normal variables by the modeller. For instance, one could want to set a maximum for the speed; this would be done by redeclaring it like this:\n\n```\nfloat speed max:100 min:0;\n```\n\nOr, to obtain a speed increasing at each simulation step:\n\n```\nfloat speed max:100 min:0  <- 1 update: speed * 1.01;\n```\n\nOr, to change the speed in a behavior:\n\n```\nif speed = 5 {\n    speed <- 10;\n}\n```\n\n----\n\n\n## Table of Contents\n<wiki:toc max_depth=\"3\" />\n\n[advanced_driving](#advanced_driving), [driving](#driving), [fipa](#fipa), [GAMASQL](#gamasql), [grid](#grid), [MDXSKILL](#mdxskill), [messaging](#messaging), [moving](#moving), [moving3D](#moving3d), [network](#network), [physics](#physics), [skill_road](#skill_road), [skill_road_node](#skill_road_node), [SQLSKILL](#sqlskill), \n    \t\n----\n\n[//]: # (keyword|skill_advanced_driving)\n## advanced_driving\n\n \n### Variables\n\t   \n  * **`current_index`** (`int`): the current index of the agent target (according to the targets list)   \n  * **`current_lane`** (`int`): the current lane on which the agent is   \n  * **`current_path`** (`path`): the current path that tha agent follow   \n  * **`current_road`** (`agent`): current road on which the agent is   \n  * **`current_target`** (`point`): the current target of the agent   \n  * **`distance_to_goal`** (`float`): euclidean distance to the next point of the current segment   \n  * **`final_target`** (`point`): the final target of the agent   \n  * **`max_acceleration`** (`float`): maximum acceleration of the car for a cycle   \n  * **`max_speed`** (`float`): maximal speed of the vehicle   \n  * **`on_linked_road`** (`boolean`): is the agent on the linked road?   \n  * **`proba_block_node`** (`float`): probability to block a node (do not let other driver cross the crossroad)   \n  * **`proba_lane_change_down`** (`float`): probability to change lane to a lower lane (right lane if right side driving) if necessary   \n  * **`proba_lane_change_up`** (`float`): probability to change lane to a upper lane (left lane if right side driving) if necessary   \n  * **`proba_respect_priorities`** (`float`): probability to respect priority (right or left) laws   \n  * **`proba_respect_stops`** (`list`): probability to respect stop laws - one value for each type of stop   \n  * **`proba_use_linked_road`** (`float`): probability to change lane to a linked road lane if necessary   \n  * **`real_speed`** (`float`): the actual speed of the agent (in meter/second)   \n  * **`right_side_driving`** (`boolean`): are drivers driving on the right size of the road?   \n  * **`security_distance_coeff`** (`float`): the coefficient for the computation of the the min distance between two drivers (according to the vehicle speed - security_distance = 1#m + security_distance_coeff `*` real_speed )   \n  * **`segment_index_on_road`** (`int`): current segment index of the agent on the current road   \n  * **`speed`** (`float`): the speed of the agent (in meter/second)   \n  * **`speed_coeff`** (`float`): speed coefficient for the speed that the driver want to reach (according to the max speed of the road)   \n  * **`targets`** (`list`): the current list of points that the agent has to reach (path)   \n  * **`vehicle_length`** (`float`): the length of the vehicle (in meters) \n \t\n### Actions\n\t  \n\t \n#### **`advanced_follow_driving`**\nmoves the agent towards along the path passed in the arguments while considering the other agents in the network (only for graph topology)\n\n* returns: float \t\t\t\n* **`path`** (path): a path to be followed. \t\t\t\n* **`target`** (point): the target to reach \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`time`** (float): time to travel  \n\t \n#### **`compute_path`**\naction to compute a path to a target location according to a given graph\n\n* returns: path \t\t\t\n* **`graph`** (graph): the graph on wich compute the path \t\t\t\n* **`target`** (agent): the target node to reach \t\t\t\n* **`source`** (agent): the source node (optional, if not defined, closest node to the agent location) \t\t\t\n* **`on_road`** (agent): the road on which the agent is located (optional)  \n\t \n#### **`drive`**\naction to drive toward the final target\n\n* returns: void  \n\t \n#### **`drive_random`**\naction to drive by chosen randomly the next road\n\n* returns: void \t\t\t\n* **`proba_roads`** (map): a map containing for each road (key), the probability to be selected as next road (value)  \n\t \n#### **`external_factor_impact`**\naction that allows to define how the remaining time is impacted by external factor\n\n* returns: float \t\t\t\n* **`new_road`** (agent): the road on which to the driver wants to go \t\t\t\n* **`remaining_time`** (float): the remaining time  \n\t \n#### **`is_ready_next_road`**\naction to test if the driver can take the given road at the given lane\n\n* returns: bool \t\t\t\n* **`new_road`** (agent): the road to test \t\t\t\n* **`lane`** (int): the lane to test  \n\t \n#### **`lane_choice`**\naction to choose a lane\n\n* returns: int \t\t\t\n* **`new_road`** (agent): the road on which to choose the lane  \n\t \n#### **`path_from_nodes`**\naction to compute a path from a list of nodes according to a given graph\n\n* returns: path \t\t\t\n* **`graph`** (graph): the graph on wich compute the path \t\t\t\n* **`nodes`** (list): the list of nodes composing the path  \n\t \n#### **`speed_choice`**\naction to choose a speed\n\n* returns: float \t\t\t\n* **`new_road`** (agent): the road on which to choose the speed  \n\t \n#### **`test_next_road`**\naction to test if the driver can take the given road\n\n* returns: bool \t\t\t\n* **`new_road`** (agent): the road to test\n    \t\n----\n\n[//]: # (keyword|skill_driving)\n## driving\n\n \n### Variables\n\t   \n  * **`lanes_attribute`** (`string`): the name of the attribut of the road agent that determine the number of road lanes   \n  * **`living_space`** (`float`): the min distance between the agent and an obstacle (in meter)   \n  * **`obstacle_species`** (`list`): the list of species that are considered as obstacles   \n  * **`speed`** (`float`): the speed of the agent (in meter/second)   \n  * **`tolerance`** (`float`): the tolerance distance used for the computation (in meter) \n \t\n### Actions\n\t  \n\t \n#### **`follow_driving`**\nmoves the agent along a given path passed in the arguments while considering the other agents in the network.\n\n* returns: path \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`path`** (path): a path to be followed. \t\t\t\n* **`return_path`** (boolean): if true, return the path followed (by default: false) \t\t\t\n* **`move_weights`** (map): Weigths used for the moving. \t\t\t\n* **`living_space`** (float): min distance between the agent and an obstacle (replaces the current value of living_space) \t\t\t\n* **`tolerance`** (float): tolerance distance used for the computation (replaces the current value of tolerance) \t\t\t\n* **`lanes_attribute`** (string): the name of the attribut of the road agent that determine the number of road lanes (replaces the current value of lanes_attribute)  \n\t \n#### **`goto_driving`**\nmoves the agent towards the target passed in the arguments while considering the other agents in the network (only for graph topology)\n\n* returns: path \t\t\t\n* **`target`** (geometry): the location or entity towards which to move. \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`on`** (any type): list, agent, graph, geometry that restrains this move (the agent moves inside this geometry) \t\t\t\n* **`return_path`** (boolean): if true, return the path followed (by default: false) \t\t\t\n* **`move_weights`** (map): Weigths used for the moving. \t\t\t\n* **`living_space`** (float): min distance between the agent and an obstacle (replaces the current value of living_space) \t\t\t\n* **`tolerance`** (float): tolerance distance used for the computation (replaces the current value of tolerance) \t\t\t\n* **`lanes_attribute`** (string): the name of the attribut of the road agent that determine the number of road lanes (replaces the current value of lanes_attribute)\n    \t\n----\n\n[//]: # (keyword|skill_fipa)\n## fipa\nThe fipa skill offers some primitives and built-in variables which enable agent to communicate with each other using the FIPA interaction protocol.\n \n### Variables\n\t   \n  * **`accept_proposals`** (`list`): A list of 'accept_proposal' performative messages of the agent's mailbox having .   \n  * **`agrees`** (`list`): A list of 'accept_proposal' performative messages.   \n  * **`cancels`** (`list`): A list of 'cancel' performative messages.   \n  * **`cfps`** (`list`): A list of 'cfp' (call for proposal) performative messages.   \n  * **`conversations`** (`list`): A list containing the current conversations of agent. Ended conversations are automatically removed from this list.   \n  * **`failures`** (`list`): A list of 'failure' performative messages.   \n  * **`informs`** (`list`): A list of 'inform' performative messages.   \n  * **`proposes`** (`list`): A list of 'propose' performative messages .   \n  * **`queries`** (`list`): A list of 'query' performative messages.   \n  * **`refuses`** (`list`): A list of 'propose' performative messages.   \n  * **`reject_proposals`** (`list`): A list of 'reject_proposals' performative messages.   \n  * **`requests`** (`list`): A list of 'request' performative messages.   \n  * **`requestWhens`** (`list`): A list of 'request-when' performative messages.   \n  * **`subscribes`** (`list`): A list of 'subscribe' performative messages. \n \t\n### Actions\n\t  \n\t \n#### **`accept_proposal`**\nReplies a message with an 'accept_proposal' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`agree`**\nReplies a message with an 'agree' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`cancel`**\nReplies a message with a 'cancel' peformative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`cfp`**\nReplies a message with a 'cfp' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`end_conversation`**\nReply a message with an 'end_conversation' peprformative message. This message marks the end of a conversation. In a 'no-protocol' conversation, it is the responsible of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`failure`**\nReplies a message with a 'failure' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`inform`**\nReplies a message with an 'inform' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`propose`**\nReplies a message with a 'propose' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`query`**\nReplies a message with a 'query' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`refuse`**\nReplies a message with a 'refuse' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The contents of the replying message  \n\t \n#### **`reject_proposal`**\nReplies a message with a 'reject_proposal' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`reply`**\nReplies a message. This action should be only used to reply a message in a 'no-protocol' conversation and with a 'user defined performative'. For performatives supported by GAMA (i.e., standard FIPA performatives), please use the 'action' with the same name of 'performative'. For example, to reply a message with a 'request' performative message, the modeller should use the 'request' action.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`performative`** (string): The performative of the replying message \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`request`**\nReplies a message with a 'request' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message  \n\t \n#### **`send`**\nStarts a conversation/interaction protocol.\n\n* returns: msi.gaml.extensions.fipa.FIPAMessage \t\t\t\n* **`to`** (list): A list of receiver agents \t\t\t\n* **`contents`** (list): The content of the message. A list of any GAML type \t\t\t\n* **`performative`** (string): A string, representing the message performative \t\t\t\n* **`protocol`** (string): A string representing the name of interaction protocol  \n\t \n#### **`start_conversation`**\nStarts a conversation/interaction protocol.\n\n* returns: msi.gaml.extensions.fipa.FIPAMessage \t\t\t\n* **`to`** (list): A list of receiver agents \t\t\t\n* **`contents`** (list): The content of the message. A list of any GAML type \t\t\t\n* **`performative`** (string): A string, representing the message performative \t\t\t\n* **`protocol`** (string): A string representing the name of interaction protocol  \n\t \n#### **`subscribe`**\nReplies a message with a 'subscribe' performative message.\n\n* returns: unknown \t\t\t\n* **`message`** (24): The message to be replied \t\t\t\n* **`contents`** (list): The content of the replying message\n    \t\n----\n\n[//]: # (keyword|skill_GAMASQL)\n## GAMASQL\n\n \n### Variables\n\t \n \t\n### Actions\n\t  \n\t \n#### **`read`**\n\n\n* returns: void \t\t\t\n* **`params`** (map): Connection parameters \t\t\t\n* **`table`** (string): select string with question marks \t\t\t\n* **`filter`** (list): List of values that are used to replace question marks  \n\t \n#### **`SqlObject`**\n\n\n* returns: msi.gama.database.geosql.GamaSqlConnection \t\t\t\n* **`params`** (map): Connection parameters \t\t\t\n* **`table`** (string): select string with question marks \t\t\t\n* **`filter`** (string): Filter for select  \n\t \n#### **`testConnection`**\n\n\n* returns: bool \t\t\t\n* **`params`** (map): Connection parameters\n    \t\n----\n\n[//]: # (keyword|skill_grid)\n## grid\n\n \n### Variables\n\t   \n  * **`bands`** (`list`): Represents the values of the different bands of the cell (list of floating point value automatically set when the grid is initialized from a grid file)   \n  * **`color`** (`rgb`): Represents the color of the cell, used by default to represent the grid on displays   \n  * **`grid_value`** (`float`): Represents a floating point value (automatically set when the grid is initialized from a grid file, and used by default to represent the elevation of the cell when displaying it on a display)   \n  * **`grid_x`** (`int`): Returns the 0-based index of the column of the cell in the grid   \n  * **`grid_y`** (`int`): Returns the 0-based index of the row of the cell in the grid   \n  * **`neighbors`** (`list`): Represents the neighbor at distance 1 of the cell \n \t\n### Actions\n\t\n    \t\n----\n\n[//]: # (keyword|skill_MDXSKILL)\n## MDXSKILL\n\n \n### Variables\n\t \n \t\n### Actions\n\t  \n\t \n#### **`select`**\n\n\n* returns: list \t\t\t\n* **`params`** (map): Connection parameters \t\t\t\n* **`onColumns`** (string): select string with question marks \t\t\t\n* **`onRows`** (list): List of values that are used to replace question marks \t\t\t\n* **`from`** (list): List of values that are used to replace question marks \t\t\t\n* **`where`** (list): List of values that are used to replace question marks \t\t\t\n* **`values`** (list): List of values that are used to replace question marks  \n\t \n#### **`testConnection`**\n\n\n* returns: bool \t\t\t\n* **`params`** (map): Connection parameters  \n\t \n#### **`timeStamp`**\n\n\n* returns: float\n    \t\n----\n\n[//]: # (keyword|skill_messaging)\n## messaging\nA simple skill that provides agents with a mailbox than can be filled with messages\n \n### Variables\n\t   \n  * **`mailbox`** (`list`): The list of messages that can be consulted by the agent \n \t\n### Actions\n\t  \n\t \n#### **`send`**\n\n\n* returns: msi.gama.extensions.messaging.GamaMessage \t\t\t\n* **`to`** (any type): The agent, or server, to which this message will be sent to \t\t\t\n* **`contents`** (any type): The contents of the message, an arbitrary object\n    \t\n----\n\n[//]: # (keyword|skill_moving)\n## moving\nThe moving skill is intended to define the minimal set of behaviours required for agents that are able to move on different topologies\n \n### Variables\n\t   \n  * **`current_edge`** (`geometry`): Represents the agent/geometry on which the agent is located (only used with a graph)   \n  * **`current_path`** (`path`): Represents the path on which the agent is moving on (goto action on a graph)   \n  * **`destination`** (`point`): Represents the next location of the agent if it keeps its current speed and heading (read-only)   \n  * **`heading`** (`int`): Represents the absolute heading of the agent in degrees.   \n  * **`location`** (`point`): Represents the current position of the agent   \n  * **`real_speed`** (`float`): Represents the actual speed of the agent (in meter/second)   \n  * **`speed`** (`float`): Represents the speed of the agent (in meter/second) \n \t\n### Actions\n\t  \n\t \n#### **`follow`**\nmoves the agent along a given path passed in the arguments.\n\n* returns: path \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`path`** (path): a path to be followed. \t\t\t\n* **`move_weights`** (map): Weights used for the moving. \t\t\t\n* **`return_path`** (boolean): if true, return the path followed (by default: false)  \n\t \n#### **`goto`**\nmoves the agent towards the target passed in the arguments.\n\n* returns: path \t\t\t\n* **`target`** (geometry): the location or entity towards which to move. \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`on`** (any type): graph, topology, list of geometries that restrain this move \t\t\t\n* **`recompute_path`** (boolean): if false, the path is not recompute even if the graph is modified (by default: true) \t\t\t\n* **`return_path`** (boolean): if true, return the path followed (by default: false) \t\t\t\n* **`move_weights`** (map): Weights used for the moving.  \n\t \n#### **`move`**\nmoves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.\n\n* returns: path \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`heading`** (int): the angle (in degree) of the target direction. \t\t\t\n* **`bounds`** (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry  \n\t \n#### **`wander`**\nMoves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.\n\n* returns: void \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`amplitude`** (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2) \t\t\t\n* **`bounds`** (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry) \t\t\t\n* **`on`** (graph): the graph that restrains this move (the agent moves on the graph \t\t\t\n* **`proba_edges`** (map): When the agent moves on a graph, the probability to choose another edge. If not defined, each edge has the same probability to be chosen\n    \t\n----\n\n[//]: # (keyword|skill_moving3D)\n## moving3D\nThe moving skill 3D is intended to define the minimal set of behaviours required for agents that are able to move on different topologies\n \n### Variables\n\t   \n  * **`destination`** (`point`): continuously updated destination of the agent with respect to its speed and heading (read-only)   \n  * **`heading`** (`int`): the absolute heading of the agent in degrees (in the range 0-359)   \n  * **`pitch`** (`int`): the absolute pitch of the agent in degrees (in the range 0-359)   \n  * **`roll`** (`int`): the absolute roll of the agent in degrees (in the range 0-359)   \n  * **`speed`** (`float`): the speed of the agent (in meter/second) \n \t\n### Actions\n\t  \n\t \n#### **`move`**\nmoves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.\n\n* returns: path \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`heading`** (int): int, optional, the direction to take for this move (replaces the current value of heading) \t\t\t\n* **`pitch`** (int): int, optional, the direction to take for this move (replaces the current value of pitch) \t\t\t\n* **`heading`** (int): int, optional, the direction to take for this move (replaces the current value of roll) \t\t\t\n* **`bounds`** (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry\n    \t\n----\n\n[//]: # (keyword|skill_network)\n## network\n\n \n### Variables\n\t   \n  * **`network_groups`** (`list`): Net ID of the agent   \n  * **`network_name`** (`string`): Net ID of the agent   \n  * **`network_server`** (`list`): Net ID of the agent \n \t\n### Actions\n\t  \n\t \n#### **`connect`**\n\n\n* returns: void \t\t\t\n* **`protocol`** (string): protocol type (udp, tcp, mqqt) \t\t\t\n* **`port`** (int): port number \t\t\t\n* **`with_name`** (string): server nameL \t\t\t\n* **`login`** (string): server nameL \t\t\t\n* **`password`** (string): server nameL \t\t\t\n* **`to`** (string): server URL  \n\t \n#### **`execute`**\n\n\n* returns: string \t\t\t\n* **`command`** (string): command to execute  \n\t \n#### **`fetch_message`**\n\n\n* returns: msi.gama.extensions.messaging.GamaMessage  \n\t \n#### **`has_more_message`**\n\n\n* returns: bool  \n\t \n#### **`leave_the_group`**\nleave a group of agent\n\n* returns: void \t\t\t\n* **`with_name`** (string): name of the group agent want to leave\n    \t\n----\n\n[//]: # (keyword|skill_physics)\n## physics\n\n \n### Variables\n\t   \n  * **`collisionBound`** (`map`):    \n  * **`density`** (`float`):    \n  * **`mass`** (`float`):    \n  * **`motor`** (`point`):    \n  * **`space`** (`agent`):    \n  * **`velocity`** (`list`):  \n \t\n### Actions\n\t\n    \t\n----\n\n[//]: # (keyword|skill_skill_road)\n## skill_road\n\n \n### Variables\n\t   \n  * **`agents_on`** (`list`): for each lane of the road, the list of agents for each segment   \n  * **`all_agents`** (`list`): the list of agents on the road   \n  * **`lanes`** (`int`): the number of lanes   \n  * **`linked_road`** (`-18`): the linked road: the lanes of this linked road will be usable by drivers on the road   \n  * **`maxspeed`** (`float`): the maximal speed on the road   \n  * **`source_node`** (`agent`): the source node of the road   \n  * **`target_node`** (`agent`): the target node of the road \n \t\n### Actions\n\t  \n\t \n#### **`register`**\nregister the agent on the road at the given lane\n\n* returns: void \t\t\t\n* **`agent`** (agent): the agent to register on the road. \t\t\t\n* **`lane`** (int): the lane index on which to register; if lane index >= number of lanes, then register on the linked road  \n\t \n#### **`unregister`**\nunregister the agent on the road\n\n* returns: void \t\t\t\n* **`agent`** (agent): the agent to unregister on the road.\n    \t\n----\n\n[//]: # (keyword|skill_skill_road_node)\n## skill_road_node\n\n \n### Variables\n\t   \n  * **`block`** (`map`): define the list of agents blocking the node, and for each agent, the list of concerned roads   \n  * **`priority_roads`** (`list`): the list of priority roads   \n  * **`roads_in`** (`list`): the list of input roads   \n  * **`roads_out`** (`list`): the list of output roads   \n  * **`stop`** (`list`): define for each type of stop, the list of concerned roads \n \t\n### Actions\n\t\n    \t\n----\n\n[//]: # (keyword|skill_SQLSKILL)\n## SQLSKILL\n\n \n### Variables\n\t \n \t\n### Actions\n\t  \n\t \n#### **`executeUpdate`**\n\n\n* returns: int \t\t\t\n* **`params`** (map): Connection parameters \t\t\t\n* **`updateComm`** (string): SQL commands such as Create, Update, Delete, Drop with question mark \t\t\t\n* **`values`** (list): List of values that are used to replace question mark  \n\t \n#### **`getCurrentDateTime`**\n\n\n* returns: string \t\t\t\n* **`dateFormat`** (string): date format examples: 'yyyy-MM-dd' , 'yyyy-MM-dd HH:mm:ss'  \n\t \n#### **`getDateOffset`**\n\n\n* returns: string \t\t\t\n* **`dateFormat`** (string): date format examples: 'yyyy-MM-dd' , 'yyyy-MM-dd HH:mm:ss' \t\t\t\n* **`dateStr`** (string): Start date \t\t\t\n* **`offset`** (string): number on day to increase or decrease  \n\t \n#### **`insert`**\n\n\n* returns: int \t\t\t\n* **`params`** (map): Connection parameters \t\t\t\n* **`into`** (string): Table name \t\t\t\n* **`columns`** (list): List of column name of table \t\t\t\n* **`values`** (list): List of values that are used to insert into table. Columns and values must have same size  \n\t \n#### **`list2Matrix`**\n\n\n* returns: matrix \t\t\t\n* **`param`** (list): Param: a list of records and metadata \t\t\t\n* **`getName`** (boolean): getType: a boolean value, optional parameter \t\t\t\n* **`getType`** (boolean): getType: a boolean value, optional parameter  \n\t \n#### **`select`**\n\n\n* returns: container \t\t\t\n* **`params`** (map): Connection parameters \t\t\t\n* **`select`** (string): select string with question marks \t\t\t\n* **`values`** (list): List of values that are used to replace question marks  \n\t \n#### **`testConnection`**\n\n\n* returns: bool \t\t\t\n* **`params`** (map): Connection parameters  \n\t \n#### **`timeStamp`**\n\n\n* returns: float","url":"wiki/BuiltInSkills.md"},"BuiltInSpecies.md":{"title":" Built-in Species","content":"# Built-in Species\n \t\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n\nIt is possible to use in the models a set of built-in agents. These agents allow to directly use some advance features like clustering, multi-criteria analysis, etc. The creation of these agents are similar as for other kinds of agents:\n\n```\ncreate species: my_built_in_agent returns: the_agent;\n```\n    \nSo, for instance, to be able to use clustering techniques in the model:\n\n```\ncreate cluster_builder returns: clusterer;\n```\n\t\n\n\n## Table of Contents\n<wiki:toc max_depth=\"3\" />\n[agent](#agent), [AgentDB](#agentdb), [base_edge](#base_edge), [experiment](#experiment), [graph_edge](#graph_edge), [graph_node](#graph_node), [model](#model), [physical_world](#physical_world), \n    \t\n----\n\n[//]: # (keyword|species_agent)\n## `agent`\t\n\n### Actions\n\t  \n\t \n#### **`_init_`**\n\n* returns: `unknown`\n  \n\t \n#### **`_step_`**\n\n* returns: `unknown`\n\n    \t\n----\n\n[//]: # (keyword|species_AgentDB)\n## `AgentDB`\t\n\n### Actions\n\t  \n\t \n#### **`close`**\n\n* returns: `unknown`\n  \n\t \n#### **`connect`**\n\n* returns: `unknown`\n \t\t\t\n* → **`params`** (`map`): Connection parameters  \n\t \n#### **`executeUpdate`**\n\n* returns: `int`\n \t\t\t\n* → **`updateComm`** (`string`): SQL commands such as Create, Update, Delete, Drop with question mark \t\t\t\n* → **`values`** (`list`): List of values that are used to replace question mark  \n\t \n#### **`getParameter`**\n\n* returns: `unknown`\n  \n\t \n#### **`insert`**\n\n* returns: `int`\n \t\t\t\n* → **`into`** (`string`): Table name \t\t\t\n* → **`columns`** (`list`): List of column name of table \t\t\t\n* → **`values`** (`list`): List of values that are used to insert into table. Columns and values must have same size  \n\t \n#### **`isConnected`**\n\n* returns: `bool`\n  \n\t \n#### **`select`**\n\n* returns: `container`\n \t\t\t\n* → **`select`** (`string`): select string \t\t\t\n* → **`values`** (`list`): List of values that are used to replace question marks  \n\t \n#### **`setParameter`**\n\n* returns: `unknown`\n \t\t\t\n* → **`params`** (`map`): Connection parameters  \n\t \n#### **`testConnection`**\n\n* returns: `bool`\n \t\t\t\n* → **`params`** (`map`): Connection parameters  \n\t \n#### **`timeStamp`**\n\n* returns: `float`\n\n    \t\n----\n\n[//]: # (keyword|species_base_edge)\n## `base_edge`\t\n\n### Actions\n\t\n    \t\n----\n\n[//]: # (keyword|species_experiment)\n## `experiment`\t\n\n### Actions\n\t  \n\t \n#### **`update_outputs`**\nForces all outputs to refresh, optionally recomputing their values\n* returns: `unknown`\n \t\t\t\n* → **`recompute`** (`boolean`): Whether or not to force the outputs to make a computation step\n    \t\n----\n\n[//]: # (keyword|species_graph_edge)\n## `graph_edge`\t\n\n### Actions\n\t\n    \t\n----\n\n[//]: # (keyword|species_graph_node)\n## `graph_node`\t\n\n### Actions\n\t  \n\t \n#### **`related_to`**\n\n* returns: `bool`\n \t\t\t\n* → **`other`** (`agent`): \n    \t\n----\n\n[//]: # (keyword|species_model)\n## `model`\t\n\n### Actions\n\t  \n\t \n#### **`halt`**\nAllows to stop the current simulation so that cannot be continued after. All the behaviors and updates are stopped.\n* returns: `unknown`\n  \n\t \n#### **`pause`**\nAllows to pause the current simulation **ACTUALLY EXPERIMENT FOR THE MOMENT**. It can be set to continue with the manual intervention of the user.\n* returns: `unknown`\n\n    \t\n----\n\n[//]: # (keyword|species_physical_world)\n## `physical_world`\t\n\n### Actions\n\t  \n\t \n#### **`compute_forces`**\n\n* returns: `unknown`\n","url":"wiki/BuiltInSpecies.md"},"DataTypes.md":{"title":" Types","content":"# Types\n\nA variable's or expression's *type* (or *data type*) determines the values it can take, plus the operations that can be performed on or with it. GAML is a statically-typed language, which means that the type of an expression is always known at compile time, and is even enforced with casting operations.\nThere are 4 categories of types:\n\n* primitive types, declared as keyword in the language,\n* complex types, also declared as keyword in the language,\n* parametric types, a refinement of complex types (mainly children of container) that is dynamically constructed using an enclosing type, a contents type and a key type,\n* species types, dynamically constructed from the species declarations made by the modeler (and the built-in species present).\n\nThe hierarchy of types in GAML (only primitive and complex types are displayed here, of course, as the other ones are model-dependent) is the following:\n\n![images/types_hierarchy.png](resources/images/gamlReferences/types_hierarchy.png)\n\n\n\n## Table of contents \n\n* [Types (Under Construction)](#types-under-construction)\n\t* [Primitive built-in types](#primitive-built-in-types)\n\t\t* [bool](#bool)\n\t\t* [float](#float)\n\t\t* [int](#int)\n\t\t* [string](#string)\n\t* [Complex built-in types](#complex-built-in-types)\n\t\t* [agent](#agent)\n\t\t* [container](#container)\n\t\t* [file](#file)\n\t\t* [geometry](#geometry)\n\t\t* [graph](#graph)\n\t\t* [list](#list)\n\t\t* [map](#map)\n\t\t* [matrix](#matrix)\n\t\t* [pair](#pair)\n\t\t* [path](#path)\n\t\t* [point](#point)\n\t\t* [rgb](#rgb)\n\t\t* [species](#species)\n\t\t* [Species names as types](#species-names-as-types)\n\t\t* [topology](#topology)\n\t* [Defining custom types](#defining-custom-types)\n\n\n\n\n## Primitive built-in types\n\n### bool\n  * **Definition:** primitive datatype providing two values: `true` or `false`.\n  * **Litteral declaration:** both `true` or `false` are interpreted as boolean constants.\n  * **Other declarations:** expressions that require a boolean operand often directly apply a casting to bool to their operand. It is a convenient way to directly obtain a bool value.\n\n```\nbool (0) -> false\n```\n[Top of the page](#table-of-contents)\n\n[//]: # (keyword|type_float)\n### float\n  * **Definition:** primitive datatype holding floating point values, its absolute value is comprised between 4.9E-324 and 1.8E308.\n  * **Comments:** this datatype is internally backed up by the Java double datatype.\n  * **Litteral declaration:** decimal notation 123.45 or exponential notation 123e45 are supported.\n  * **Other declarations:** expressions that require an integer operand often directly apply a casting to float to their operand. Using it is a way to obtain a float constant.\n\n```\nfloat (12) -> 12.0\n```\n[Top of the page](#table-of-contents)\n\n[//]: # (keyword|type_int)\n### int\n  * **Definition:** primitive datatype holding integer values comprised between -2147483648 and 2147483647 (i.e. between `-2^31` and `2^31 - 1`.\n  * **Comments:** this datatype is internally backed up by the Java int datatype.\n  * **Litteral declaration:** decimal notation like 1, 256790 or hexadecimal notation like #1209FF are automatically interpreted.\n  * **Other declarations:** expressions that require an integer operand often directly apply a casting to int to their operand. Using it is a way to obtain an integer constant.\n\n```\nint (234.5) -> 234.\n```\n[Top of the page](#table-of-contents)\n\n[//]: # (keyword|type_string)\n### string\n  * **Definition:** a datatype holding a sequence of characters.\n  * **Comments:** this datatype is internally backed up by the Java String class. However, contrary to Java, strings are considered as a primitive type, which means they do not contain character objects. This can be seen when casting a string to a list using the list operator: the result is a list of one-character strings, not a list of characters.\n  * **Litteral declaration:** a sequence of characters enclosed in quotes, like 'this is a string' . If one wants to literally declare strings that contain quotes, one has to double these quotes in the declaration. Strings accept escape characters like `\\n` (newline), `\\r` (carriage return), `\\t` (tabulation), as well as any Unicode character (`\\uXXXX`).\n  * **Other declarations:** see string\n  * **Example:** see [string operators](Operators#strings-related-operators).\n\n[Top of the page](#table-of-contents)\n\n\n\n\n\n## Complex built-in types\n\nContrarily to primitive built-in types, complex types have often various attributes. They can be accessed in the same way as attributes of agents:\n```\ncomplex_type nom_var <- init_var;\nltype_attr attr_var <- nom_var.attr_name;\n```\nFor example:\n```\nfile fileText <- file(\"../data/cell.Data\");\nbool fileTextReadable <- fileText.readable;\n```\n\n[//]: # (keyword|type_agent)\n### agent\n  * **Definition:** a generic datatype that represents an agent whatever its actual species.\n  * **Comments:** This datatype is barely used, since species can be directly used as datatypes themselves.\n  * **Declaration:** the agent casting operator can be applied to an int (to get the agent with this unique index), a string (to get the agent with this name).\n\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_container)\n### container\n  * **Definition:** a generic datatype that represents a collection of data.\n  * **Comments:**  a container variable can be a list, a matrix, a map... Conversely each list, matrix and map is a kind of container. In consequence every container can be used in container-related operators.\n  * **See also:** [Container operators](Operators#containers-related-operators)\n  * **Declaration:**\n```\ncontainer c  <- [1,2,3];\ncontainer c  <- matrix [[1,2,3],[4,5,6]];\ncontainer c  <- map [\"x\"::5, \"y\"::12];\ncontainer c  <- list species1;\n```\n[Top of the page](#table-of-contents)\n\n[//]: # (keyword|type_file)\n### file\n  * **Definition:** a datatype that represents a file.\n  * **Built-in attributes:**\n    * name (type = string): the name of the represented file (with its extension)\n    * extension(type = string): the extension of the file\n    * path (type = string): the absolute path of the file\n    * readable (type = bool, read-only): a flag expressing whether the file is readable\n    * writable (type = bool, read-only): a flag expressing whether the file is writable\n    * exists (type = bool, read-only): a flag expressing whether the file exists\n    * is\\_folder (type = bool, read-only): a flag expressing whether the file is folder\n    * contents (type = container): a container storing the content of the file\n  * **Comments:** a variable with the `file` type can handle any kind of file (text, image or shape files...). The type of the `content` attribute will depend on the kind of file. Note that the allowed kinds of file are the followings:\n    * text files: files with the extensions .txt, .data, .csv, .text, .tsv, .asc. The `content` is by default a list of string.\n    * image files: files with the extensions .pgm, .tif, .tiff, .jpg, .jpeg, .png, .gif, .pict, .bmp. The `content` is by default a matrix of int.\n    * shapefiles: files with the extension .shp. The `content` is by default a list of geometry.\n    * properties files: files with the extension .properties. The `content` is by default a map of string::string.\n    * folders. The `content` is by default a list of string.\n  * **Remark:** Files are also a particular kind of container and can thus be read, written or iterated using the container operators and commands.\n  * **See also:** [File operators](Operators#files-related-operators)\n  * **Declaration:** a file can be created using the generic `file` (that opens a file in read only mode and tries to determine its contents), `folder` or the `new_folder` (to open an existing folder or create a new one) unary operators. But things can be specialized with the combination of the `read`/`write` and `image`/`text`/`shapefile`/`properties` unary operators.\n\n```\nfolder(a_string)  // returns a file managing a existing folder\nfile(a_string) // returns any kind of file in read-only mode\nread(text(a_string)) // returns a text file in read-only mode\nread(image(a_string)) // does the same with an image file.\nwrite(properties(a_string)) // returns a property file which is available for writing \n                            // (if it exists, contents will be appended unless it is cleared \n                            // using the standard container operations).\n\n```\n\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_geometry)\n### geometry\n  * **Definition:** a datatype that represents a vector geometry, i.e. a list of georeferenced points.\n  * **Built-in attributes:**\n    * location (type = point): the centroid of the geometry\n    * area (type = float): the area of the geometry\n    * perimeter (type = float): the perimeter of the geometry\n    * holes (type = list of geometry): the list of the hole inside the given geometry\n    * contour (type = geometry): the exterior ring of the given geometry and of his holes\n    * envelope (type = geometry): the geometry bounding box\n    * width (type = float): the width of the bounding box\n    * height (type = float): the height of the bounding box\n    * points (type = list of point): the set of the points composing the geometry\n  * **Comments:** a geometry can be either a point, a polyline or a polygon. Operators working on geometries handle transparently these three kinds of geometry. The envelope (a.k.a. the bounding box) of the geometry depends on the kind of geometry:\n    * If this Geometry is the empty geometry, it is an empty point.\n    * If the Geometry is a point, it is a non-empty point.\n    * Otherwise, it is a Polygon whose points are (minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny).\n  * **See also:** [Spatial operators](Operators#spatial-operators)\n  * **Declaration:** geometries can be built from a point, a list of points or by using specific operators (circle, square, triangle...).\n\n```\ngeometry varGeom <- circle(5);\ngeometry polygonGeom <- polygon([{3,5}, {5,6},{1,4}]);\n```\n\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_graph)\n### graph\n  * **Definition:** a datatype that represents a graph composed of vertices linked by edges.\n  * **Built-in attributes:**\n    * edges(type = list of agent/geometry): the list of all edges\n    * vertices(type = list of agent/geometry): the list of all vertices\n    * circuit (type = path): an approximate minimal traveling salesman tour (hamiltonian cycle)\n    * spanning\\_tree (type = list of agent/geometry): minimum spanning tree of the graph, i.e. a sub-graph such as every vertex lies in the tree, and as much edges lies in it but no cycles (or loops) are formed.\n    * connected(type = bool): test whether the graph is connected\n  * **Remark:**\n    * graphs are also a particular kind of container and can thus be manipulated using the container operators and commands.\n    * This algorithm used to compute the circuit requires that the graph be complete and the triangle inequality exists (if x,y,z are vertices then d(x,y)+d(y,z)<d(x,z) for all x,y,z) then this algorithm will guarantee a hamiltonian cycle such that the total weight of the cycle is less than or equal to double the total weight of the optimal hamiltonian cycle.\n    * The computation of the spanning tree uses an implementation of  the Kruskal's minimum spanning tree algorithm. If the given graph is connected it computes the minimum spanning tree, otherwise it computes the minimum spanning forest.\n  * **See also:** [Graph operators](Operators#graph-related-operators)\n  * **Declaration:** graphs can be built from a list of vertices (agents or geometries) or from a list of edges (agents or geometries) by using specific operators. They are often used to deal with a road network and are built from a shapefile.\n\n```\ncreate road from: shape_file_road;\ngraph the_graph <- as_edge_graph(road);\n\ngraph([1,9,5])        --: ([1: in[] + out[], 5: in[] + out[], 9: in[] + out[]], [])\ngraph([node(0), node(1), node(2)]      // if node is a species\ngraph(['a'::345, 'b'::13])  --:  ([b: in[] + out[b::13], a: in[] + out[a::345], 13: in[b::13] + out[], 345: in[a::345] + out[]], [a::345=(a,345), b::13=(b,13)])\ngraph(a_graph)  --: a_graph\ngraph(node1)    --: null\n```\n\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_list)\n### list\n  * **Definition:** a composite datatype holding an ordered collection of values.\n  * **Comments:** lists are more or less equivalent to instances of ArrayList in Java (although they are backed up by a specific class). They grow and shrink as needed, can be accessed via an index (see @ or index\\_of), support set operations (like union and difference), and provide the modeller with a number of utilities that make it easy to deal with collections of agents (see, for instance, shuffle, reverse,where,sort\\_by,...).\n  * **Remark:** lists can contain values of any datatypes, including other lists. Note, however, that due to limitations in the current parser, lists of lists cannot be declared litteraly; they have to be built using assignments. Lists are also a particular kind of container and can thus be manipulated using the container operators and commands.\n  * **Litteral declaration:** a set of expressions separated by commas, enclosed in square brackets, like [12, 14, 'abc', self]. An empty list is noted []().\n  * **Other declarations:** lists can be build litteraly from a point, or a string, or any other element by using the list casting operator.\n\n```\nlist (1) -> [1]\n```\n```\nlist<int> myList <- [1,2,3,4]; \nmyList[2] => 3\n```\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_map)\n### map\n  * **Definition:** a composite datatype holding an ordered collection of pairs (a key, and its associated value).\n  * **Built-in attributes:**\n    * keys (type = list): the list of all keys\n    * values (type = list): the list of all values\n    * pairs (type = list of pairs): the list of all pairs key::value\n  * **Comments:** maps are more or less equivalent to instances of Hashtable in Java (although they are backed up by a specific class).\n  * **Remark:** maps can contain values of any datatypes, including other maps or lists. Maps are also a particular kind of container and can thus be manipulated using the container operators and commands.\n  * **Litteral declaration:** a set of pair expressions separated by commas, enclosed in square brackets; each pair is represented by a key and a value sperarated by '::'. An example of map is [agentA::'big', agentB::'small', agentC::'big']. An empty map is noted []().\n  * **Other declarations:** lists can be built litteraly from a point, or a string, or any other element by using the map casting operator.\n\n```\nmap (1) -> [1::1]\nmap ({1,5}) -> [x::1, y::5]\n[]   // empty map \n```\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_matrix)\n### matrix\n  * **Definition:** a composite datatype that represents either a two-dimension array (matrix) or a one-dimension array (vector), holding any type of data (including other matrices).\n  * **Comments:** Matrices are fixed-size structures that can be accessed by index (point for two-dimensions matrices, integer for vectors).\n  * **Litteral declaration:** Matrices cannot be defined literally. One-dimensions matrices can be built by using the matrix casting operator applied on a list. Two-dimensions matrices need to to be declared as variables first, before being filled.\n\n```\n//builds a one-dimension matrix, of size 5\nmatrix mat1 <- matrix ([10, 20, 30, 40, 50]);\n//  builds a two-dimensions matrix with 10 columns and 5 rows, where each cell is initialized to 0.0\nmatrix mat2 <- 0.0 as_matrix({10,5}); \n// builds a two-dimensions matrix with 2 columns and 3 rows, with initialized cells\nmatrix mat3 <- matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]]);     \n    -> c11;c21\n       c12;c22\n       c13;c23\n```\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_pair)\n### pair\n  * **Definition:** a datatype holding a key and its associated value.\n  * **Built-in attributes:**\n    * key (type = string): the key of the pair, i.e. the first element of the pair\n    * value (type = string): the value of the pair, i.e. the second element of the pair\n  * **Remark:** pairs are also a particular kind of container and can thus be manipulated using the container operators and commands.\n  * **Litteral declaration:** a pair is defined by a key and a value sperarated by '::'.\n  * **Other declarations:** a pair can also be built from:\n    * a point,\n    * a map (in this case the first element of the pair is the list of all the keys of the map and the second element is the list of all the values of the map),\n    * a list (in this case the two first element of the list are used to built the pair)\n\n```\npair testPair <- \"key\"::56;\npair testPairPoint <- {3,5};             // 3::5\npair testPairList2 <- [6,7,8];           // 6::7\npair testPairMap <- [2::6,5::8,12::45];  // [12,5,2]::[45,8,6]\n```\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_path)\n### path\n  * **Definition:** a datatype representing a path linking two agents or geometries in a graph.\n  * **Built-in attributes:**\n    * source (type = point): the source point, i.e. the first point of the path\n    * target (type = point): the target point, i.e. the last point of the path\n    * graph (type = graph): the current topology (in the case it is a spatial graph), null otherwise\n    * edges (type = list of agents/geometries) :  the edges of the graph composing the path\n    * vertices (type = list of agents/geometries) :  the vertices of the graph composing the path\n    * segments (type = list of geometries): the list of the geometries composing the path\n    * shape (type = geometry) : the global geometry of the path (polyline)\n  * **Comments:** the path created between two agents/geometries or locations will strongly depends on the topology in which it is created.\n  * **Remark:** a path is **immutable**, i.e. it can not be modified after it is created.\n  * **Declaration:** paths are very barely defined litterally. We can nevertheless use the `path` unary operator on a list of points to build a path. Operators dedicated to the computation of paths (such as path\\_to or path\\_between) are often used to build a path.\n\n```\npath([{1,5},{2,9},{5,8}]) // a path from {1,5} to {5,8} through {2,9}\n       \ngeometry rect <- rectangle(5);\ngeometry poly <- polygon([{10,20},{11,21},{10,21},{11,22}]);\npath pa <- rect path_to poly;  // built a path between rect and poly, in the topolopy   \n                                            // of the current agent (i.e. a line in a& continuous topology, \n                                            // a path in a graph  in a graph topology )\n\na_topology path_between a_container_of_geometries // idem with an explicit topology and the possiblity \n                                                  // to have more than 2 geometries \n                                                  // (the path is then built incrementally)\n\n\npath_between (a_graph, a_source, a_target) // idem with a the given graph as topology\n\n```\n\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_point)\n### point\n  * **Definition:** a datatype normally holding two positive float values. Represents the absolute coordinates of agents in the model.\n  * **Built-in attributes:**\n    * x (type = float): coordinate of the point on the x-axis\n    * y (type = float): coordinate of the point on the y-axis\n  * **Comments:** point coordinates should be positive, if a negative value is used in its declaration, the point is built with the absolute value.\n  * **Remark:** points are particular cases of geometries and containers. Thus they have also all the built-in attributes of both the geometry and the container datatypes and can be used with every kind of operator or command admitting geometry and container.\n  * **Litteral declaration:** two numbers, separated by a comma, enclosed in braces, like {12.3, 14.5}\n  * **Other declarations:** points can be built litteraly from a list, or from an integer or float value by using the point casting operator.\n\n```\npoint ([12,123.45]) -> {12.0, 123.45} \npoint (2) -> {2.0, 2.0}\n```\n[Top of the page](#table-of-contents)\n\n[//]: # (keyword|type_rgb)\n### rgb\n  * **Definition:** a datatype that represents a color in the RGB space.\n  * **Built-in attributes:**\n    * red(type = int): the red component of the color\n    * green(type = int): the green component of the color\n    * blue(type = int): the blue component of the color\n    * darker(type = rgb): a new color that is a darker version of this color\n    * brighter(type = rgb): a new color that is a brighter version of this color\n  * **Remark:** rgbs are also a particular kind of container and can thus be manipulated using the container operators and commands.\n  * **Litteral declaration:** there exist lot of ways to declare a color. We use the `rgb` casting operator applied to:\n    * a string. The allowed color names are the constants defined in the Color Java class, i.e.: black, blue, cyan, darkGray, lightGray, gray, green, magenta, orange, pink, red, white, yellow.\n    * a list. The integer value associated to the three first elements of the list are used to define the three red (element 0 of the list), green (element 1 of the list) and blue (element 2 of the list) components of the color.\n    * a map. The red, green, blue compoenents take the value associated to the keys \"r\", \"g\", \"b\" in the map.\n    * an integer <- the decimal integer is translated into a hexadecimal <- OxRRGGBB. The red (resp. green, blue) component of the color take the value RR (resp. GG, BB) translated in decimal.\n    * Since GAMA 1.6.1, colors can be directly obtained like units, by using the ° or # symbol followed by the name in lowercase of one of the 147 CSS colors (see http://www.cssportal.com/css3-color-names/).\n  * **Declaration:**\n\n```\nrgb cssRed <- #red;   // Since 1.6.1\nrgb testColor <- rgb('white');                 // rgb [255,255,255]\nrgb test <- rgb(3,5,67);                     // rgb [3,5,67]\nrgb te <- rgb(340);                            // rgb [0,1,84]\nrgb tete <- rgb([\"r\"::34, \"g\"::56, \"b\"::345]); // rgb [34,56,255]\n```\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_species)\n### species\n  * Definition: a generic datatype that represents a species\n  * **Built-in attributes:**\n    * topology (type=topology): the topology is which lives the population of agents\n  * Comments: this datatype is actually a \"meta-type\". It allows to manipulate (in a rather limited fashion, however) the species themselves as any other values.\n  * Litteral declaration: the name of a declared species is already a litteral declaration of species.\n  * Other declarations: the species casting operator, or its variant called species\\_of can be applied to an agent in order to get its species.\n\n[Top of the page](#table-of-contents)\n\n\n### Species names as types\n\nOnce a species has been declared in a model, it automatically becomes a datatype. This means that :\n  * It can be used to declare variables, parameters or constants,\n  * It can be used as an operand to commands or operators that require species parameters,\n  * It can be used as a casting operator (with the same capabilities as the built-in type agent)\n\nIn the simple following example, we create a set of \"humans\" and initialize a random \"friendship network\" among them. See how the name of the species, human, is used in the create command, as an argument to the list casting operator, and as the type of the variable named friend.\n\n```\nglobal {\n    init {\n         create human number: 10;\n         ask human {\n               friend <- one_of (human - self);\n         }\n     }\n}\nentities {\n    species human {\n        human friend <- nil;\n    }\n}\n```\n\n[Top of the page](#table-of-contents)\n\n\n[//]: # (keyword|type_topology)\n### topology\n  * **Definition:** a topology is basically on neighborhoods, distance,... structures in which agents evolves. It is the environment or the context in which all these values are computed. It also provides the access to the spatial index shared by all the agents. And it maintains a (eventually dynamic) link with the 'environment' which is a geometrical border.\n  * **Built-in attributes:**\n    * places(type = container): the collection of places (geometry) defined by this topology.\n    * environment(type = geometry): the environment of this topology (i.e. the geometry that defines its boundaries)\n  * **Comments:** the attributes `places` depends on the kind of the considered topolopy.  For continuous topologies, it is a list with their environment. For discrete topologies, it can be any of the container supporting the inclusion of geometries (list, graph, map, matrix)\n  * **Remark:** There exist various kinds of topology: continuous topology and discrete topology (e.g. grid, graph...)\n  * **Declaration:** To create a topology, we can use the `topology` unary casting operator applied to:\n    * an agent: returns a continuous topology built from the agent's geometry\n    * a species name: returns the topology defined for this species population\n    * a geometry: returns a continuous topology built on this geometry\n    * a geometry container (list, map, shapefile): returns an half-discrete (with corresponding places), half-continuous topology (to compute distances...)\n    * a geometry matrix (i.e. a grid): returns a grid topology which computes specifically neighborhood and distances\n    * a geometry graph: returns a graph topology which computes specifically neighborhood and distances\nMore complex topologies can also be built using dedicated operators, e.g. to decompose a geometry...\n\n[Top of the page](#table-of-contents)\n\n\n\n\n\n## Defining custom types\n\nSometimes, besides the species of agents that compose the model, it can be necessary to declare custom datatypes. Species serve this purpose as well, and can be seen as \"classes\" that can help to instantiate simple \"objects\". In the following example, we declare a new kind of \"object\", bottle, that lacks the skills habitually associated with agents (moving, visible, etc.), but can nevertheless group together attributes and behaviors within the same closure. The following example demonstrates how to create the species:\n\n```\nspecies bottle {\n    float volume <- 0.0 max:1 min:0.0;\n    bool is_empty -> {volume = 0.0};\n    action fill {\n         volume <- 1.0;\n    }\n}\n```\n\nHow to use this species to declare new bottles :\n\n```\ncreate bottle {\n    volume <- 0.5;\n}\n```\n\nAnd how to use bottles as any other agent in a species (a drinker owns a bottle; when he gets thirsty, it drinks a random quantity from it; when it is empty, it refills it):\n\n```\nspecies drinker {\n     ...\n    bottle my_bottle<- nil;\n    float quantity <- rnd (100) / 100;\n    bool thirsty <- false update: flip (0.1);\n    ...\n    action drink {\n         if condition: ! bottle.is_empty {\n              bottle.volume <-bottle.volume - quantity;\n              thirsty <- false;\n         }\n    }\n    ...\n    init {\n          create bottle return: created_bottle;\n              volume <- 0.5;\n          }\n          my_bottle <- first(created_bottle);\n    }\n    ...\n    reflex filling_bottle when: bottle.is_empty {\n         ask  my_bottle {\n              do fill;\n         }\n    }\n    ...\n    reflex drinking when: thirsty {\n         do drink;\n    }\n}\n```\n[Top of the page](#table-of-contents)","url":"wiki/DataTypes.md"},"ExperimentBuiltIn.md":{"title":" The 'experiment' built-in species (Under Construction)","content":"# The 'experiment' built-in species (Under Construction)\n\n\n\nAs described in the [presentation of GAML](Introduction), any experiment attached to a model is a species (introduced by the keyword `experiment` which directly or indirectly inherits from an abstract species called `experiment` itself. This abstract species (sub-species of `agent`) defines several attributes and actions that can then be used in any experiment.\n\n\n\n\n\n\n## `experiment` attributes\n`experiment` defines several attributes, which, in addition to the attributes inherited from [`agent`](AgentBuiltIn), form the minimal set of knowledge any experiment will have access to.\n \n\n\n## `experiment` actions","url":"wiki/ExperimentBuiltIn.md"},"Expressions.md":{"title":" Expressions","content":"# Expressions\n\n\n\nExpressions in GAML are the value part of the [statements](Statements)' facets. They represent or compute data that will be used as the value of the facet when the statement will be executed.\n\nAn expression can be either a [literal](Literals), a [unit](UnitsAndConstants), a [constant](UnitsAndConstants), a [variable](PseudoVariables), an [attribute](VariablesAndAttributes) or the application of one or several [operators](Operators) to compose a complex expression.","url":"wiki/Expressions.md"},"FileTypes.md":{"title":" File Types","content":"[//]: # (startConcept|load_complex_datas)\n# File Types\n\n\nGAMA provides modelers with a generic type for files called **file**. It is possible to load a file using the _file_ operator:\n\n```\nfile my_file <- file(\"../includes/data.csv\");\n```\n\nHowever, internally, GAMA makes the difference between the different types of files.\nIndeed, for instance:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- file(\"../includes/data.csv\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nsepallength\nsepalwidth\npetallength\npetalwidth\ntype\n5.1\n3.5\n1.4\n0.2\nIris-setosa\n4.9\n3.0\n1.4\n0.2\nIris-setosa\n...\n```\nIndeed, the content of CSV file is a matrix: each row of the matrix is a line of the file; each column of the matrix is value delimited by the separator (by default \",\").\n\nIn contrary:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- file(\"../includes/data.shp\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nPolygon\nPolygon\nPolygon\nPolygon\nPolygon\nPolygon\nPolygon\n```\nThe content of a shapefile is a list of geometries corresponding to the objects of the shapefile.\n\nIn order to know how to load a file, GAMA analyzes its extension. For instance for a file with a \".csv\" extension, GAMA knows that the file is a **csv** one and will try to split each line with the _,_ separator. However, if the modeler wants to split each line with a different separator (for instance **;**) or load it as a text file, he/she will have to use a specific file operator.\n\nIndeed, GAMA integrates specific operators corresponding to different types of files.\n\n\n\n## Table of contents \n\n* [File Types](#file-types)\n\t* [Text File](#text-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [CSV File](#csv-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [Shapefile](#shapefile)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [OSM File](#osm-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [Grid File](#grid-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [Image File](#image-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [SVG File](#svg-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [Property File](#property-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [R File](#r-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [3DS File](#3ds-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\t* [OBJ File](#obj-file)\n\t\t* [Extensions](#extensions)\n\t\t* [Content](#content)\n\t\t* [Operators](#operators)\n\n\n\n\n## Text File\n### Extensions\nHere the list of possible extensions for text file:\n  * \"txt\"\n  * \"data\"\n  * \"csv\"\n  * \"text\"\n  * \"tsv\"\n  * \"xml\"\n\nNote that when trying to define the type of a file with the default file loading operator (**file**), GAMA will first try to test the other type of file. For example, for files with \".csv\" extension, GAMA will cast them as csv file and not as text file.\n\n### Content\nThe content of a text file is a list of string corresponding to each line of the text file.\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- text_file(\"../includes/data.txt\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nsepallength,sepalwidth,petallength,petalwidth,type\n5.1,3.5,1.4,0.2,Iris-setosa\n4.9,3.0,1.4,0.2,Iris-setosa\n4.7,3.2,1.3,0.2,Iris-setosa\n```\n\n### Operators\nList of operators related to text files:\n  * **text\\_file(string path)**: load a file (with an authorized extension) as a text file.\n  * **text\\_file(string path, list content)**: load a file (with an authorized extension) as a text file and fill it with the given content.\n  * **is\\_text(op)**: tests whether the operand is a text file\n\n\n\n\n## CSV File\n### Extensions\nHere the list of possible extensions for csv file:\n    * \"csv\"\n    * \"tsv\"\n\n### Content\nThe content of a csv file is a matrix of string: each row of the matrix is a line of the file; each column of the matrix is value delimited by the separator (by default \",\").\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- csv_file(\"../includes/data.csv\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nsepallength\nsepalwidth\npetallength\npetalwidth\ntype\n5.1\n3.5\n1.4\n0.2\nIris-setosa\n4.9\n3.0\n1.4\n0.2\nIris-setosa\n...\n```\n\n### Operators\nList of operators related to csv files:\n  * **csv\\_file(string path)**: load a file (with an authorized extension) as a csv file with default separator (\",\").\n  * **csv\\_file(string path, string separator)**: load a file (with an authorized extension) as a csv file with the given separator.\n```\nfile my_file <- csv_file(\"../includes/data.csv\", \";\");\n```\n\n  * **csv\\_file(string path, matrix content)**: load a file (with an authorized extension) as a csv file and fill it with the given content.\n  * **is\\_csv(op)**: tests whether the operand is a csv file\n\n\n\n\n\n\n## Shapefile\nShapefiles are classical GIS data files. A shapefile is not simple file, but a set of several files (source: wikipedia):\n  * Mandatory files :\n    * .shp — shape format; the feature geometry itself\n    * .shx — shape index format; a positional index of the feature geometry to allow seeking forwards and backwards quickly\n    * .dbf — attribute format; columnar attributes for each shape, in dBase IV format\n\n  * Optional files :\n    * .prj — projection format; the coordinate system and projection information, a plain text file describing the projection using well-known text format\n    * .sbn and .sbx — a spatial index of the features\n    * .fbn and .fbx — a spatial index of the features for shapefiles that are read-only\n    * .ain and .aih — an attribute index of the active fields in a table\n    * .ixs — a geocoding index for read-write shapefiles\n    * .mxs — a geocoding index for read-write shapefiles (ODB format)\n    * .atx — an attribute index for the .dbf file in the form of shapefile.columnname.atx (ArcGIS 8 and later)\n    * .shp.xml — geospatial metadata in XML format, such as ISO 19115 or other XML schema\n    * .cpg — used to specify the code page (only for .dbf) for identifying the character encoding to be used\n\nMore details about shapefiles can be found [here](http://en.wikipedia.org/wiki/Shapefile).\n\n### Extensions\nHere the list of possible extension for shapefile:\n  * \"shp\"\n\n### Content\nThe content of a shapefile is a list of geometries corresponding to the objects of the shapefile.\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- shape_file(\"../includes/data.shp\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nPolygon\nPolygon\nPolygon\nPolygon\nPolygon\nPolygon\nPolygon\n...\n```\n\nNote that the attributes of each object of the shapefile is stored in their corresponding GAMA geometry. The operator \"get\" (or \"read\") allows to get the value of a corresponding attributes.\n\nFor example:\n```\nfile my_file <- shape_file(\"../includes/data.shp\");\nwrite \"my_file: \" + my_file.contents;\nloop el over: my_file {\n\twrite (el get \"TYPE\");\n}\n```\n\n\n### Operators\nList of operators related to shapefiles:\n  * **shape\\_file(string path)**: load a file (with an authorized extension) as a shapefile with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).\n  * **shape\\_file(string path, string code)**: load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)\n  * **shape\\_file(string path, int EPSG\\_ID)**: load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/)\n```\nfile my_file <- shape_file(\"../includes/data.shp\", \"EPSG:32601\");\n```\n\n  * **shape\\_file(string path, list content)**: load a file (with an authorized extension) as a shapefile and fill it with the given content.\n  * **is\\_shape(op)**: tests whether the operand is a shapefile\n\n\n\n\n\n## OSM File\nOSM (Open Street Map) is a collaborative project to create a free editable map of the world. The data produced in this project (OSM File)  represent physical features on the ground (e.g., roads or buildings) using tags attached to its basic data structures (its nodes, ways, and relations). Each tag describes a geographic attribute of the feature being shown by that specific node, way or relation (source: openstreetmap.org).\n\nMore details about OSM data can be found [here](http://wiki.openstreetmap.org/wiki/Map_Features).\n\n### Extensions\nHere the list of possible extension for shapefile:\n  * \"osm\"\n  * \"pbf\"\n  * \"bz2\"\n  * \"gz\"\n\n### Content\nThe content of a OSM data is a list of geometries corresponding to the objects of the OSM file.\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- osm_file(\"../includes/data.gz\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nPoint\nPoint\nPoint\nPoint\nPoint\nLineString\nLineString\nPolygon\nPolygon\nPolygon\n...\n```\n\nNote that like for shapefiles, the attributes of each object of the osm file is stored in their corresponding GAMA geometry. The operator \"get\" (or \"read\") allows to get the value of a corresponding attributes.\n\n\n### Operators\nList of operators related to osm file:\n  * **osm\\_file(string path)**: load a file (with an authorized extension) as a osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, all the nodes and ways of the OSM file will becomes a geometry.\n  * **osm\\_file(string path, string code)**: load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will becomes a geometry.\n  * **osm\\_file(string path, int EPSG\\_ID)**: load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will becomes a geometry.\n```\nfile my_file <- osm_file(\"../includes/data.gz\", \"EPSG:32601\");\n```\n  * **osm\\_file(string path, map filter)**: load a file (with an authorized extension) as a osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, only the elements with the defined values are loaded from the file.\n```\n//map used to filter the object to build from the OSM file according to attributes. \nmap filtering <- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\",\"residential\", \"unclassified\"], \"building\"::[\"yes\"]]);\n\n//OSM file to load\nfile<geometry> osmfile <-  file<geometry (osm_file(\"../includes/rouen.gz\", filtering))  ;\n```\n  * **osm\\_file(string path, map filter, string code)**: load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.\n  * **osm\\_file(string path, map filter, int EPSG\\_ID)**: load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.\n  * **is\\_osm(op)**: tests whether the operand is a osm file\n\n\n\n\n\n## Grid File\nEsri ASCII Grid files are classic text raster GIS data.\n\nMore details about Esri ASCII grid file can be found [here](http://en.wikipedia.org/wiki/Esri_grid).\n\nNote that grid files can be used to initialize a grid species. The number of rows and columns will be read from the file. Similarly, the values of each cell contained in the grid file will be accessible through the **grid\\_value** attribute.\n\n```\ngrid cell file: grid_file {\n}\n```\n\n### Extensions\nHere the list of possible extension for grid file:\n  * \"asc\"\n\n### Content\nThe content of a grid file is a list of geometries corresponding to the cells of the grid.\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- grid_file(\"../includes/data.asc\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nPolygon\nPolygon\nPolygon\nPolygon\nPolygon\nPolygon\nPolygon\n...\n```\n\nNote that the values of each cell of the grid file is stored in their corresponding GAMA geometry (**grid\\_value** attribute). The operator \"get\" (or \"read\") allows to get the value of this attribute.\n\nFor example:\n```\nfile my_file <- grid_file(\"../includes/data.asc\");\nwrite \"my_file: \" + my_file.contents;\nloop el over: my_file {\n\twrite el get \"grid_value\";\n}\n```\n\n\n### Operators\nList of operators related to shapefiles:\n  * **grid\\_file(string path)**: load a file (with an authorized extension) as a grid file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).\n  * **grid\\_file(string path, string code)**: load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)\n  * **grid\\_file(string path, int EPSG\\_ID)**: load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/)\n```\nfile my_file <- grid_file(\"../includes/data.shp\", \"EPSG:32601\");\n```\n\n  * **is\\_grid(op)**: tests whether the operand is a grid file.\n\n\n\n\n\n\n## Image File\n### Extensions\nHere the list of possible extensions for image file:\n  * \"tif\"\n  * \"tiff\"\n  * \"jpg\"\n  * \"jpeg\"\n  * \"png\"\n  * \"gif\"\n  * \"pict\"\n  * \"bmp\"\n\n### Content\nThe content of an image file is a matrix of int: each pixel is a value in the matrix.\n\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- image_file(\"../includes/DEM.png\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\n-9671572\n-9671572\n-9671572\n-9671572\n-9934744\n-9934744\n-9868951\n-9868951\n-10000537\n-10000537\n...\n```\n\n### Operators\nList of operators related to csv files:\n  * **image\\_file(string path)**: load a file (with an authorized extension) as an image file.\n  * **image\\_file(string path, matrix content)**: load a file (with an authorized extension) as an image file and fill it with the given content.\n  * **is\\_image(op)**: tests whether the operand is an image file\n\n\n\n\n\n## SVG File\n\nScalable Vector Graphics (SVG) is an XML-based vector image format for two-dimensional graphics with support for interactivity and animation. Note that interactivity and animation features are not supported in GAMA.\n\nMore details about SVG file can be found [here](http://en.wikipedia.org/wiki/Scalable_Vector_Graphics).\n\n### Extensions\nHere the list of possible extension for SVG file:\n  * \"svg\"\n\n### Content\nThe content of a SVG file is a list of geometries.\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- svg_file(\"../includes/data.svg\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nPolygon\n```\n\n### Operators\nList of operators related to svg files:\n  * **shape\\_file(string path)**: load a file (with an authorized extension) as a SVG file.\n  * **shape\\_file(string path, point size)**: load a file (with an authorized extension) as a SVG file with the given size:\n\n```\nfile my_file <- svg_file(\"../includes/data.svg\", {5.0,5.0});\n```\n\n  * **is\\_svg(op)**: tests whether the operand is a SVG file\n\n\n\n\n\n## Property File\n### Extensions\nHere the list of possible extensions for property file:\n  * \"properties\"\n\n### Content\nThe content of a property file is a map of string corresponding to the content of the file.\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- property_file(\"../includes/data.properties\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\nwith the given property file:\n```\nsepallength = 5.0\nsepalwidth = 3.0\npetallength = 4.0\npetalwidth = 2.5\ntype = Iris-setosa\n```\n\nwill give:\n```\n3.0\n4.0\n5.0\nIris-setosa\n2.5\n```\n\n### Operators\nList of operators related to text files:\n  * **property\\_file(string path)**: load a file (with an authorized extension) as a property file.\n  * **is\\_property(op)**: tests whether the operand is a property file\n\n\n\n\n\n## R File\nR is a free software environment for statistical computing and graphics. GAMA allows to execute R script (if R is installed on the computer).\n\nMore details about R can be found [here](http://www.r-project.org/).\n\nNote that GAMA also integrates some operators to manage R scripts:\n  * [R\\_compute](Operators#R_compute)\n  * [R\\_compute\\_param](Operators#R_compute_param)\n\n### Extensions\nHere the list of possible extensions for R file:\n  * \"r\"\n\n### Content\nThe content of a R file corresponds to the results of the application of the script contained in the file.\n\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- R_file(\"../includes/data.r\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\n3.0\n```\n\n### Operators\nList of operators related to R files:\n  * **R\\_file(string path)**: load a file (with an authorized extension) as a R file.\n  * **is\\_R(op)**: tests whether the operand is a R file.\n\n\n\n\n## 3DS File\n\n3DS is one of the file formats used by the Autodesk 3ds Max 3D modeling, animation and rendering software. 3DS files can be used in GAMA to load 3D geometries.\n\nMore details about 3DS file can be found [here](http://en.wikipedia.org/wiki/.3ds).\n\n### Extensions\nHere the list of possible extension for 3DS file:\n  * \"3ds\"\n  * \"max\"\n\n### Content\nThe content of a 3DS file is a list of geometries.\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- threeds_file(\"../includes/data.3ds\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nPolygon\n```\n\n### Operators\nList of operators related to 3ds files:\n  * **threeds\\_file(string path)**: load a file (with an authorized extension) as a 3ds file.\n  * **is\\_threeds(op)**: tests whether the operand is a 3DS file\n\n\n\n\n\n## OBJ File\nOBJ file is a geometry definition file format first developed by Wavefront Technologies for its Advanced Visualizer animation package. The file format is open and has been adopted by other 3D graphics application vendors.\n\nMore details about Obj file can be found [here](http://en.wikipedia.org/wiki/Wavefront_.obj_file).\n\n### Extensions\nHere the list of possible extension for OBJ files:\n  * \"obj\"\n\n### Content\nThe content of a OBJ file is a list of geometries.\nFor example:\n```\nglobal {\n\tinit {\n\t\tfile my_file <- obj_file(\"../includes/data.obj\");\n\t\tloop el over: my_file {\n\t\t\twrite el;\n\t\t}\n\t}\n}\n```\n\nwill give:\n```\nPolygon\n```\n\n### Operators\nList of operators related to obj files:\n  * **obj\\_file(string path)**: load a file (with an authorized extension) as a obj file.\n  * **is\\_obj(op)**: tests whether the operand is a OBJ file\n[//]: # (endConcept|load_complex_datas)","url":"wiki/FileTypes.md"},"Literals.md":{"title":" Literals","content":"# Literals\n\n\n\n_(some literal expressions are also described in [data types](DataTypes))_\n\nA literal is a way to specify an unnamed constant value corresponding to a given data type. GAML supports various types of literals for often — or less often — used data types.\n\n## Table of contents \n\n* [Literals](#literals)\n\t* [Simple Types](#simple-types)\n\t* [Literal Constructors](#literal-constructors)\n\t* [Universal Literal](#universal-literal)\n\n\n\n\n## Simple Types\nValues of simple (i.e. not composed) types can all be expressed using literal expressions. Namely:\n\n  * **bool**: `true` and `false`.\n  * **int**: decimal value, such as `100`, or hexadecimal value if preceded by `'#'` (e.g. `#AAAAAA`, which returns the int `11184810`)\n  * **float**: the value in plain digits, using `'.'` for the decimal point (e.g. `123.297`)\n  * **string**: a sequence of characters enclosed between quotes (`'my string'`) or double quotes (`\"my string\"`)\n\n\n\n\n## Literal Constructors\nAlthough they are not strictly literals in the sense given above, some special constructs (called _literal constructors_) allow the modeler to declare constants of other data types. They are actually [operators](Operators) but can be thought of literals when used with constant operands.\n\n  * **pair**: the key and the value separated by `::` (e.g. `12::'abc'`)\n  * **list**: the elements, separated by commas, enclosed inside square brackets (e.g. `[12,15,15]`)\n  * **map**: a list of pairs (e.g. `[12::'abc', 13::'def']`)\n  * **point**: 2 or 3 int or float ordinates enclosed inside curly brackets (e.g. `{10.0,10.0,10.0}`)\n\n\n\n[//]: # (keyword|concept_nil)\n## Universal Literal\nFinally, a special literal, of type `unknown`, is shared between the data types and all the agent types (aka species). Only `bool`, `int` and `float`, which do not derive from `unknown`, do not accept this literal. All the others will accept it (e.g. `string s <- nil;` is ok).\n\n  * **unknown**: `nil`, which represents the non-initialized (or, literally, _unknown_) value.","url":"wiki/Literals.md"},"ModelBuiltIn.md":{"title":" The 'model' built-in species (Under Construction)","content":"# The 'model' built-in species (Under Construction)\n\n\n\nAs described in the [presentation of GAML](Introduction), any model in GAMA is a species (introduced by the keyword [`global`](GlobalSpecies)) which directly inherits from an abstract species called `model`. This abstract species (sub-species of [`agent`](AgentBuiltIn)) defines several attributes and actions that can then be used in any global section of any model.\n\n\n\n## `model` attributes\n`model` defines several attributes, which, in addition to the attributes inherited from [`agent`](AgentBuiltIn), form the minimal set of knowledge a model can manipulate.\n  * \n\n\n## `model` actions","url":"wiki/ModelBuiltIn.md"},"Operators.md":{"title":" Operators ","content":"# Operators \n \t\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Definition\n\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. \n\nMost of them use a classical prefixed functional syntax (i.e. `operator_name(operand1, operand2, operand3)`, see below), with the exception of arithmetic (e.g. `+`, `/`), logical (`and`, `or`), comparison (e.g. `>`, `<`), access (`.`, `[..]`) and pair (`::`) operators, which require an infixed notation (i.e. `operand1 operator_symbol operand1`). \n\nThe ternary functional if-else operator, `? :`, uses a special infixed syntax composed with two symbols (e.g. `operand1 ? operand2 : operand3`). Two unary operators (`-` and `!`) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10`, `! (operand1 or operand2)`). \n\nFinally, special constructor operators (`{...}` for constructing points, `[...]` for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. `{1,2,3}`, `[operand1, operand2, ..., operandn]` or `[key1::value1, key2::value2... keyn::valuen]`).\n\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n* if they only have one operand, the functional prefixed syntax is mandatory (e.g. `operator_name(operand1)`)\n* if they have two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2)`) or the infixed syntax (e.g. `operand1 operator_name operand2`) can be used.\n* if they have more than two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2, ..., operand)`) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. `operand1 operator_name(operand2, ..., operand)`) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\n\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the `shuffle` operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\n----\n\n## Priority between operators\n\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\n\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n* the constructor operators, like `::`, used to compose pairs of operands, have the lowest priority of all operators (e.g. `a > b :: b > c` will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, `[a > 10, b > 5]` will return a list of boolean values.\n* it is followed by the `?:` operator, the functional if-else (e.g. ` a > b ? a + 10 : a - 10` will return the result of the if-else).\n* next are the logical operators, `and` and `or` (e.g. `a > b or b > c` will return the value of the test)\n* next are the comparison operators (i.e. `>`, `<`, `<=`, `>=`, `=`, `!=`)\n* next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\n* next the unary operators `-` and `!`\n* next the access operators `.` and `[]` (e.g. `{1,2,3}.x > 20 + {4,5,6}.y` will return the result of the comparison between the x and y ordinates of the two points)\n* and finally the functional operators, which have the highest priority of all.\n\n----\n\n## Using actions as operators\n\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\n\nFor instance, if the following species is defined:\n\n```\nspecies spec1 {\n        int min(int x, int y) {\n                return x > y ? x : y;\n        }\n}\n```\n\nAny agent instance of spec1 can use `min` as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\n\n```\nglobal {\n        init {\n                create spec1;\n                spec1 my_agent <- spec1[0];\n                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);\n        }\n}\n```\n\nIf the action doesn't have any operands, the syntax to use is `my_agent the_action()`. Finally, if it does not return a value, it might still be used but is considering as returning a value of type `unknown` (e.g. `unknown result <- my_agent the_action(op1, op2);`).\n\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\t\n\n----\n\n## Table of Contents\n\n----\n\n## Operators by categories\n\t\n\n----\n\n### 3D\n[box](#box), [cone3D](#cone3d), [cube](#cube), [cylinder](#cylinder), [dem](#dem), [hexagon](#hexagon), [pyramid](#pyramid), [rgb_to_xyz](#rgb_to_xyz), [set_z](#set_z), [sphere](#sphere), [teapot](#teapot), \n\n----\n\n### Arithmetic operators\n[-](#-), [/](#/), [^](#^), [*](#*), [+](#+), [abs](#abs), [acos](#acos), [asin](#asin), [atan](#atan), [atan2](#atan2), [ceil](#ceil), [cos](#cos), [cos_rad](#cos_rad), [div](#div), [even](#even), [exp](#exp), [fact](#fact), [floor](#floor), [hypot](#hypot), [is_finite](#is_finite), [is_number](#is_number), [ln](#ln), [log](#log), [mod](#mod), [round](#round), [signum](#signum), [sin](#sin), [sin_rad](#sin_rad), [sqrt](#sqrt), [tan](#tan), [tan_rad](#tan_rad), [tanh](#tanh), [with_precision](#with_precision), \n\n----\n\n### BDI\n[and](#and), [eval_when](#eval_when), [get_about](#get_about), [get_agent](#get_agent), [get_agent_cause](#get_agent_cause), [get_decay](#get_decay), [get_dominance](#get_dominance), [get_familiarity](#get_familiarity), [get_intensity](#get_intensity), [get_lifetime](#get_lifetime), [get_liking](#get_liking), [get_praiseworthiness](#get_praiseworthiness), [get_priority](#get_priority), [get_solidarity](#get_solidarity), [get_super_intention](#get_super_intention), [new_emotion](#new_emotion), [new_predicate](#new_predicate), [new_social_link](#new_social_link), [or](#or), [set_about](#set_about), [set_agent](#set_agent), [set_agent_cause](#set_agent_cause), [set_decay](#set_decay), [set_dominance](#set_dominance), [set_familiarity](#set_familiarity), [set_intensity](#set_intensity), [set_liking](#set_liking), [set_solidarity](#set_solidarity), [set_truth](#set_truth), [with_lifetime](#with_lifetime), [with_praiseworthiness](#with_praiseworthiness), [with_priority](#with_priority), [with_values](#with_values), \n\n----\n\n### Casting operators\n[as](#as), [as_int](#as_int), [as_matrix](#as_matrix), [font](#font), [is](#is), [is_skill](#is_skill), [list_with](#list_with), [matrix_with](#matrix_with), [species](#species), [to_gaml](#to_gaml), [topology](#topology), \n\n----\n\n### Color-related operators\n[-](#-), [/](#/), [*](#*), [+](#+), [blend](#blend), [brewer_colors](#brewer_colors), [brewer_palettes](#brewer_palettes), [grayscale](#grayscale), [hsb](#hsb), [mean](#mean), [median](#median), [rgb](#rgb), [rnd_color](#rnd_color), [sum](#sum), \n\n----\n\n### Comparison operators\n[!=](#!=), [<](#<), [<=](#<=), [=](#=), [>](#>), [>=](#>=), [between](#between), \n\n----\n\n### Containers-related operators\n[-](#-), [::](#::), [+](#+), [accumulate](#accumulate), [among](#among), [at](#at), [collect](#collect), [contains](#contains), [contains_all](#contains_all), [contains_any](#contains_any), [count](#count), [distinct](#distinct), [empty](#empty), [every](#every), [first](#first), [first_with](#first_with), [get](#get), [group_by](#group_by), [in](#in), [index_by](#index_by), [inter](#inter), [interleave](#interleave), [internal_at](#internal_at), [internal_integrated_value](#internal_integrated_value), [last](#last), [last_with](#last_with), [length](#length), [max](#max), [max_of](#max_of), [mean](#mean), [mean_of](#mean_of), [median](#median), [min](#min), [min_of](#min_of), [mul](#mul), [one_of](#one_of), [product_of](#product_of), [range](#range), [reverse](#reverse), [shuffle](#shuffle), [sort_by](#sort_by), [sum](#sum), [sum_of](#sum_of), [union](#union), [variance_of](#variance_of), [where](#where), [with_max_of](#with_max_of), [with_min_of](#with_min_of), \n\n----\n\n### Date-related operators\n[-](#-), [!=](#!=), [+](#+), [<](#<), [<=](#<=), [=](#=), [>](#>), [>=](#>=), [after](#after), [before](#before), [between](#between), [every](#every), [milliseconds_between](#milliseconds_between), [minus_days](#minus_days), [minus_hours](#minus_hours), [minus_minutes](#minus_minutes), [minus_months](#minus_months), [minus_ms](#minus_ms), [minus_weeks](#minus_weeks), [minus_years](#minus_years), [months_between](#months_between), [plus_days](#plus_days), [plus_hours](#plus_hours), [plus_minutes](#plus_minutes), [plus_months](#plus_months), [plus_ms](#plus_ms), [plus_weeks](#plus_weeks), [plus_years](#plus_years), [since](#since), [to](#to), [until](#until), [years_between](#years_between), \n\n----\n\n### Dates\n\n\n----\n\n### Driving operators\n[as_driving_graph](#as_driving_graph), \n\n----\n\n### edge\n[edge_between](#edge_between), \n\n----\n\n### EDP-related operators\n[diff](#diff), [diff2](#diff2), [internal_zero_order_equation](#internal_zero_order_equation), \n\n----\n\n### Files-related operators\n[crs](#crs), [file](#file), [file_exists](#file_exists), [folder](#folder), [get](#get), [new_folder](#new_folder), [osm_file](#osm_file), [read](#read), [writable](#writable), \n\n----\n\n### FIPA-related operators\n[conversation](#conversation), [message](#message), \n\n----\n\n### Graphs-related operators\n[add_edge](#add_edge), [add_node](#add_node), [adjacency](#adjacency), [agent_from_geometry](#agent_from_geometry), [all_pairs_shortest_path](#all_pairs_shortest_path), [alpha_index](#alpha_index), [as_distance_graph](#as_distance_graph), [as_edge_graph](#as_edge_graph), [as_intersection_graph](#as_intersection_graph), [as_path](#as_path), [beta_index](#beta_index), [betweenness_centrality](#betweenness_centrality), [biggest_cliques_of](#biggest_cliques_of), [connected_components_of](#connected_components_of), [connectivity_index](#connectivity_index), [contains_edge](#contains_edge), [contains_vertex](#contains_vertex), [degree_of](#degree_of), [directed](#directed), [edge](#edge), [edge_between](#edge_between), [edge_betweenness](#edge_betweenness), [edges](#edges), [gamma_index](#gamma_index), [generate_barabasi_albert](#generate_barabasi_albert), [generate_complete_graph](#generate_complete_graph), [generate_watts_strogatz](#generate_watts_strogatz), [grid_cells_to_graph](#grid_cells_to_graph), [in_degree_of](#in_degree_of), [in_edges_of](#in_edges_of), [layout](#layout), [load_graph_from_file](#load_graph_from_file), [load_shortest_paths](#load_shortest_paths), [maximal_cliques_of](#maximal_cliques_of), [nb_cycles](#nb_cycles), [neighbors_of](#neighbors_of), [node](#node), [nodes](#nodes), [out_degree_of](#out_degree_of), [out_edges_of](#out_edges_of), [path_between](#path_between), [paths_between](#paths_between), [predecessors_of](#predecessors_of), [remove_node_from](#remove_node_from), [rewire_n](#rewire_n), [source_of](#source_of), [spatial_graph](#spatial_graph), [successors_of](#successors_of), [sum](#sum), [target_of](#target_of), [undirected](#undirected), [use_cache](#use_cache), [weight_of](#weight_of), [with_optimizer_type](#with_optimizer_type), [with_weights](#with_weights), \n\n----\n\n### Grid-related operators\n[as_4_grid](#as_4_grid), [as_grid](#as_grid), [as_hexagonal_grid](#as_hexagonal_grid), [grid_at](#grid_at), [path_between](#path_between), \n\n----\n\n### Iterator operators\n[accumulate](#accumulate), [as_map](#as_map), [collect](#collect), [count](#count), [distribution_of](#distribution_of), [distribution_of](#distribution_of), [distribution_of](#distribution_of), [distribution2d_of](#distribution2d_of), [distribution2d_of](#distribution2d_of), [distribution2d_of](#distribution2d_of), [first_with](#first_with), [frequency_of](#frequency_of), [group_by](#group_by), [index_by](#index_by), [last_with](#last_with), [max_of](#max_of), [mean_of](#mean_of), [min_of](#min_of), [product_of](#product_of), [sort_by](#sort_by), [sum_of](#sum_of), [variance_of](#variance_of), [where](#where), [with_max_of](#with_max_of), [with_min_of](#with_min_of), \n\n----\n\n### List-related operators\n[copy_between](#copy_between), [index_of](#index_of), [last_index_of](#last_index_of), \n\n----\n\n### Logical operators\n[:](#:), [!](#!), [?](#?), [and](#and), [or](#or), \n\n----\n\n### Map comparaison operators\n[fuzzy_kappa](#fuzzy_kappa), [fuzzy_kappa_sim](#fuzzy_kappa_sim), [kappa](#kappa), [kappa_sim](#kappa_sim), [percent_absolute_deviation](#percent_absolute_deviation), \n\n----\n\n### Map-related operators\n[as_map](#as_map), [index_of](#index_of), [last_index_of](#last_index_of), \n\n----\n\n### Material\n[material](#material), \n\n----\n\n### Matrix-related operators\n[-](#-), [/](#/), [.](#.), [*](#*), [+](#+), [append_horizontally](#append_horizontally), [append_vertically](#append_vertically), [column_at](#column_at), [columns_list](#columns_list), [determinant](#determinant), [eigenvalues](#eigenvalues), [index_of](#index_of), [inverse](#inverse), [last_index_of](#last_index_of), [row_at](#row_at), [rows_list](#rows_list), [shuffle](#shuffle), [trace](#trace), [transpose](#transpose), \n\n----\n\n### multicriteria operators\n[electre_DM](#electre_dm), [evidence_theory_DM](#evidence_theory_dm), [promethee_DM](#promethee_dm), [weighted_means_DM](#weighted_means_dm), \n\n----\n\n### Path-related operators\n[agent_from_geometry](#agent_from_geometry), [all_pairs_shortest_path](#all_pairs_shortest_path), [as_path](#as_path), [load_shortest_paths](#load_shortest_paths), [path_between](#path_between), [path_to](#path_to), [paths_between](#paths_between), [use_cache](#use_cache), \n\n----\n\n### Points-related operators\n[-](#-), [/](#/), [*](#*), [+](#+), [<](#<), [<=](#<=), [>](#>), [>=](#>=), [add_point](#add_point), [angle_between](#angle_between), [any_location_in](#any_location_in), [centroid](#centroid), [closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), [grid_at](#grid_at), [norm](#norm), [point](#point), [points_along](#points_along), [points_at](#points_at), [points_on](#points_on), \n\n----\n\n### Random operators\n[binomial](#binomial), [flip](#flip), [gauss](#gauss), [poisson](#poisson), [rnd](#rnd), [rnd_choice](#rnd_choice), [sample](#sample), [shuffle](#shuffle), [skew_gauss](#skew_gauss), [truncated_gauss](#truncated_gauss), \n\n----\n\n### ReverseOperators\n\n\n----\n\n### Shape\n[arc](#arc), [box](#box), [circle](#circle), [cone](#cone), [cone3D](#cone3d), [cross](#cross), [cube](#cube), [curve](#curve), [cylinder](#cylinder), [ellipse](#ellipse), [envelope](#envelope), [geometry_collection](#geometry_collection), [hexagon](#hexagon), [line](#line), [link](#link), [plan](#plan), [polygon](#polygon), [polyhedron](#polyhedron), [pyramid](#pyramid), [rectangle](#rectangle), [sphere](#sphere), [square](#square), [squircle](#squircle), [teapot](#teapot), [triangle](#triangle), \n\n----\n\n### Spatial operators\n[-](#-), [*](#*), [+](#+), [add_point](#add_point), [agent_closest_to](#agent_closest_to), [agent_farthest_to](#agent_farthest_to), [agents_at_distance](#agents_at_distance), [agents_inside](#agents_inside), [agents_overlapping](#agents_overlapping), [angle_between](#angle_between), [any_location_in](#any_location_in), [arc](#arc), [around](#around), [as_4_grid](#as_4_grid), [as_grid](#as_grid), [as_hexagonal_grid](#as_hexagonal_grid), [at_distance](#at_distance), [at_location](#at_location), [box](#box), [centroid](#centroid), [circle](#circle), [clean](#clean), [closest_points_with](#closest_points_with), [closest_to](#closest_to), [cone](#cone), [cone3D](#cone3d), [convex_hull](#convex_hull), [covers](#covers), [cross](#cross), [crosses](#crosses), [crs](#crs), [CRS_transform](#crs_transform), [cube](#cube), [curve](#curve), [cylinder](#cylinder), [dem](#dem), [direction_between](#direction_between), [disjoint_from](#disjoint_from), [distance_between](#distance_between), [distance_to](#distance_to), [ellipse](#ellipse), [envelope](#envelope), [farthest_point_to](#farthest_point_to), [farthest_to](#farthest_to), [geometry_collection](#geometry_collection), [gini](#gini), [hexagon](#hexagon), [hierarchical_clustering](#hierarchical_clustering), [IDW](#idw), [inside](#inside), [inter](#inter), [intersects](#intersects), [line](#line), [link](#link), [masked_by](#masked_by), [moran](#moran), [neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [overlapping](#overlapping), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [path_between](#path_between), [path_to](#path_to), [plan](#plan), [points_along](#points_along), [points_at](#points_at), [points_on](#points_on), [polygon](#polygon), [polyhedron](#polyhedron), [pyramid](#pyramid), [rectangle](#rectangle), [rgb_to_xyz](#rgb_to_xyz), [rotated_by](#rotated_by), [round](#round), [scaled_to](#scaled_to), [set_z](#set_z), [simple_clustering_by_distance](#simple_clustering_by_distance), [simplification](#simplification), [skeletonize](#skeletonize), [smooth](#smooth), [sphere](#sphere), [split_at](#split_at), [split_geometry](#split_geometry), [split_lines](#split_lines), [square](#square), [squircle](#squircle), [teapot](#teapot), [to_GAMA_CRS](#to_gama_crs), [to_rectangles](#to_rectangles), [to_squares](#to_squares), [touches](#touches), [towards](#towards), [transformed_by](#transformed_by), [translated_by](#translated_by), [triangle](#triangle), [triangulate](#triangulate), [union](#union), [using](#using), [voronoi](#voronoi), [with_precision](#with_precision), [without_holes](#without_holes), \n\n----\n\n### Spatial properties operators\n[covers](#covers), [crosses](#crosses), [intersects](#intersects), [partially_overlaps](#partially_overlaps), [touches](#touches), \n\n----\n\n### Spatial queries operators\n[agent_closest_to](#agent_closest_to), [agent_farthest_to](#agent_farthest_to), [agents_at_distance](#agents_at_distance), [agents_inside](#agents_inside), [agents_overlapping](#agents_overlapping), [at_distance](#at_distance), [closest_to](#closest_to), [farthest_to](#farthest_to), [inside](#inside), [neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [overlapping](#overlapping), \n\n----\n\n### Spatial relations operators\n[direction_between](#direction_between), [distance_between](#distance_between), [distance_to](#distance_to), [path_between](#path_between), [path_to](#path_to), [towards](#towards), \n\n----\n\n### Spatial statistical operators\n[hierarchical_clustering](#hierarchical_clustering), [simple_clustering_by_distance](#simple_clustering_by_distance), \n\n----\n\n### Spatial transformations operators\n[-](#-), [*](#*), [+](#+), [as_4_grid](#as_4_grid), [as_grid](#as_grid), [as_hexagonal_grid](#as_hexagonal_grid), [at_location](#at_location), [clean](#clean), [convex_hull](#convex_hull), [CRS_transform](#crs_transform), [rotated_by](#rotated_by), [scaled_to](#scaled_to), [simplification](#simplification), [skeletonize](#skeletonize), [smooth](#smooth), [split_geometry](#split_geometry), [split_lines](#split_lines), [to_GAMA_CRS](#to_gama_crs), [to_rectangles](#to_rectangles), [to_squares](#to_squares), [transformed_by](#transformed_by), [translated_by](#translated_by), [triangulate](#triangulate), [voronoi](#voronoi), [without_holes](#without_holes), \n\n----\n\n### Species-related operators\n[index_of](#index_of), [last_index_of](#last_index_of), [of_generic_species](#of_generic_species), [of_species](#of_species), \n\n----\n\n### Statistical operators\n[build](#build), [corR](#corr), [dbscan](#dbscan), [distribution_of](#distribution_of), [distribution2d_of](#distribution2d_of), [frequency_of](#frequency_of), [gamma_rnd](#gamma_rnd), [geometric_mean](#geometric_mean), [gini](#gini), [harmonic_mean](#harmonic_mean), [hierarchical_clustering](#hierarchical_clustering), [kmeans](#kmeans), [kurtosis](#kurtosis), [max](#max), [mean](#mean), [mean_deviation](#mean_deviation), [meanR](#meanr), [median](#median), [min](#min), [moran](#moran), [mul](#mul), [predict](#predict), [simple_clustering_by_distance](#simple_clustering_by_distance), [skewness](#skewness), [standard_deviation](#standard_deviation), [sum](#sum), [variance](#variance), \n\n----\n\n### Strings-related operators\n[+](#+), [<](#<), [<=](#<=), [>](#>), [>=](#>=), [at](#at), [char](#char), [contains](#contains), [contains_all](#contains_all), [contains_any](#contains_any), [copy_between](#copy_between), [date](#date), [empty](#empty), [first](#first), [in](#in), [indented_by](#indented_by), [index_of](#index_of), [is_number](#is_number), [last](#last), [last_index_of](#last_index_of), [length](#length), [lower_case](#lower_case), [replace](#replace), [replace_regex](#replace_regex), [reverse](#reverse), [sample](#sample), [shuffle](#shuffle), [split_with](#split_with), [string](#string), [upper_case](#upper_case), \n\n----\n\n### System\n[.](#.), [command](#command), [copy](#copy), [dead](#dead), [eval_gaml](#eval_gaml), [every](#every), [user_input](#user_input), \n\n----\n\n### Time-related operators\n[date](#date), [string](#string), \n\n----\n\n### Types-related operators\n\n\n----\n\n### User control operators\n[user_input](#user_input), \n\t\n----\n\n## Operators\n\t\n    \t\n----\n\n\n[//]: # (keyword|operator_-)\n### `-`\n\n#### Possible use: \n  *  **`-`** (`int`) --->  `int`\n  *  **`-`** (`point`) --->  `point`\n  *  **`-`** (`float`) --->  `float`\n  * `int` **`-`** `float` --->  `float`\n  *  **`-`** (`int` , `float`) --->  `float`\n  * `int` **`-`** `int` --->  `int`\n  *  **`-`** (`int` , `int`) --->  `int`\n  * `matrix` **`-`** `float` --->  `matrix`\n  *  **`-`** (`matrix` , `float`) --->  `matrix`\n  * `float` **`-`** `matrix` --->  `matrix`\n  *  **`-`** (`float` , `matrix`) --->  `matrix`\n  * `date` **`-`** `float` --->  `date`\n  *  **`-`** (`date` , `float`) --->  `date`\n  * `species` **`-`** `agent` --->  `container`\n  *  **`-`** (`species` , `agent`) --->  `container`\n  * `date` **`-`** `date` --->  `float`\n  *  **`-`** (`date` , `date`) --->  `float`\n  * `matrix` **`-`** `matrix` --->  `matrix`\n  *  **`-`** (`matrix` , `matrix`) --->  `matrix`\n  * `point` **`-`** `int` --->  `point`\n  *  **`-`** (`point` , `int`) --->  `point`\n  * `date` **`-`** `int` --->  `date`\n  *  **`-`** (`date` , `int`) --->  `date`\n  * `point` **`-`** `float` --->  `point`\n  *  **`-`** (`point` , `float`) --->  `point`\n  * `float` **`-`** `float` --->  `float`\n  *  **`-`** (`float` , `float`) --->  `float`\n  * `rgb` **`-`** `rgb` --->  `rgb`\n  *  **`-`** (`rgb` , `rgb`) --->  `rgb`\n  * `int` **`-`** `matrix` --->  `matrix`\n  *  **`-`** (`int` , `matrix`) --->  `matrix`\n  * `container` **`-`** `container` --->  `container`\n  *  **`-`** (`container` , `container`) --->  `container`\n  * `rgb` **`-`** `int` --->  `rgb`\n  *  **`-`** (`rgb` , `int`) --->  `rgb`\n  * `container` **`-`** `unknown` --->  `container`\n  *  **`-`** (`container` , `unknown`) --->  `container`\n  * `point` **`-`** `point` --->  `point`\n  *  **`-`** (`point` , `point`) --->  `point`\n  * `float` **`-`** `int` --->  `float`\n  *  **`-`** (`float` , `int`) --->  `float`\n  * `geometry` **`-`** `geometry` --->  `geometry`\n  *  **`-`** (`geometry` , `geometry`) --->  `geometry`\n  * `matrix` **`-`** `int` --->  `matrix`\n  *  **`-`** (`matrix` , `int`) --->  `matrix`\n  * `geometry` **`-`** `float` --->  `geometry`\n  *  **`-`** (`geometry` , `float`) --->  `geometry`\n  * `map` **`-`** `map` --->  `map`\n  *  **`-`** (`map` , `map`) --->  `map`\n  * `map` **`-`** `pair` --->  `map`\n  *  **`-`** (`map` , `pair`) --->  `map`\n  * `geometry` **`-`** `container<geometry>` --->  `geometry`\n  *  **`-`** (`geometry` , `container<geometry>`) --->  `geometry` \n\n#### Result: \nReturns the difference of the two operands.\nIf it is used as an unary operator, it returns the opposite of the operand.  \n\n#### Comment: \nThe behavior of the operator depends on the type of the operands.\n\n#### Special cases:     \n  * if the left operand is a species and the right operand is an agent of the species, - returns a list containing all the agents of the species minus this agent    \n  * if both operands are containers and the right operand is empty, - returns the left operand    \n  * if both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float. \n  \n```\nint var7 <- 1 - 1; \t// var7 equals 0\nint var8 <- 1.0 - 1; \t// var8 equals 0.0\nint var9 <- 3.7 - 1.2; \t// var9 equals 2.5\nint var10 <- 3 - 1.2; \t// var10 equals 1.8\n\n``` \n\n    \n  * if both operands are dates, returns the duration in seconds between  date2 and date1. To obtain a more precise duration, in milliseconds, use milliseconds_between(date1, date2) \n  \n```\nfloat var11 <- date1 - date2; \t// var11 equals 598\n\n``` \n\n    \n  * if one of the operands is a date and the other a number, returns a date corresponding to the date minus the given number as duration (in seconds) \n  \n```\ndate1 - 200\n\n``` \n\n    \n  * if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number. \n  \n```\npoint var13 <- {1, 2} - 4.5; \t// var13 equals {-3.5, -2.5, -4.5}\npoint var14 <- {1, 2} - 4; \t// var14 equals {-3.0,-2.0,-4.0}\n\n``` \n\n    \n  * if both operands are colors, returns a new color resulting from the subtraction of the two operands, component by component \n  \n```\nrgb var15 <- rgb([255, 128, 32]) - rgb('red'); \t// var15 equals rgb([0,128,32])\n\n``` \n\n    \n  * if one operand is a matrix and the other a number (float or int), performs a normal arithmetic difference of the number with each element of the matrix (results are float if the number is a float. \n  \n```\nmatrix var16 <- 3.5 - matrix([[2,5],[3,4]]); \t// var16 equals matrix([[1.5,-1.5],[0.5,-0.5]])\n\n``` \n\n    \n  * if both operands are containers, returns a new list in which all the elements of the right operand have been removed from the left one \n  \n```\nlist<int> var17 <- [1,2,3,4,5,6] - [2,4,9]; \t// var17 equals [1,3,5,6]\nlist<int> var18 <- [1,2,3,4,5,6] - [0,8]; \t// var18 equals [1,2,3,4,5,6]\n\n``` \n\n    \n  * if one operand is a color and the other an integer, returns a new color resulting from the subtraction of each component of the color with the right operand \n  \n```\nrgb var19 <- rgb([255, 128, 32]) - 3; \t// var19 equals rgb([252,125,29])\n\n``` \n\n    \n  * if the left operand is a list and the right operand is an object of any type (except list), - returns a list containing the elements of the left operand minus all the occurrences of this object \n  \n```\nlist<int> var20 <- [1,2,3,4,5,6] - 2; \t// var20 equals [1,3,4,5,6]\nlist<int> var21 <- [1,2,3,4,5,6] - 0; \t// var21 equals [1,2,3,4,5,6]\n\n``` \n\n    \n  * if both operands are points, returns their difference (coordinates per coordinates). \n  \n```\npoint var22 <- {1, 2} - {4, 5}; \t// var22 equals {-3.0, -3.0}\n\n``` \n\n    \n  * if both operands are a point, a geometry or an agent, returns the geometry resulting from the difference between both geometries \n  \n```\ngeometry var23 <- geom1 - geom2; \t// var23 equals a geometry corresponding to difference between geom1 and geom2\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distance \n  \n```\ngeometry var24 <- shape - 5; \t// var24 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5\n\n``` \n\n    \n  * if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometries \n  \n```\ngeometry var25 <- rectangle(10,10) - [circle(2), square(2)]; \t// var25 equals rectangle(10,10) - (circle(2) + square(2))\n\n``` \n\n\n\n#### Examples: \n```\nint var0 <- - (-56); \t// var0 equals 56\npoint var1 <- -{3.0,5.0}; \t// var1 equals {-3.0,-5.0}\npoint var2 <- -{1.0,6.0,7.0}; \t// var2 equals {-1.0,-6.0,-7.0}\nmap var3 <- ['a'::1,'b'::2] - ['b'::2]; \t// var3 equals ['a'::1]\nmap var4 <- ['a'::1,'b'::2] - ['b'::2,'c'::3]; \t// var4 equals ['a'::1]\nmap var5 <- ['a'::1,'b'::2] - ('b'::2); \t// var5 equals ['a'::1]\nmap var6 <- ['a'::1,'b'::2] - ('c'::3); \t// var6 equals ['a'::1,'b'::2]\n```\n      \n\n#### See also: \n[+](#+), [*](#*), [/](#/), [milliseconds_between](#milliseconds_between), [-](#-), \n    \t\n----\n\n\n[//]: # (keyword|operator_:)\n### `:`\n\n#### Possible use: \n  * `unknown` **`:`** `unknown` --->  `unknown`\n  *  **`:`** (`unknown` , `unknown`) --->  `unknown`    \n\n#### See also: \n[?](#?), \n    \t\n----\n\n\n[//]: # (keyword|operator_::)\n### `::`\n\n#### Possible use: \n  * `any expression` **`::`** `any expression` --->  `pair`\n  *  **`::`** (`any expression` , `any expression`) --->  `pair` \n\n#### Result: \nproduces a new pair combining the left and the right operands\n\n#### Special cases:     \n  * nil is not acceptable as a key (although it is as a value). If such a case happens, :: will throw an appropriate error\n    \t\n----\n\n\n[//]: # (keyword|operator_!)\n### `!`\n\n#### Possible use: \n  *  **`!`** (`bool`) --->  `bool` \n\n#### Result: \nopposite boolean value.\n\n#### Special cases:     \n  * if the parameter is not boolean, it is casted to a boolean value.\n\n#### Examples: \n```\nbool var0 <- ! (true); \t// var0 equals false\n```\n      \n\n#### See also: \n[bool](#bool), [and](#and), [or](#or), \n    \t\n----\n\n\n[//]: # (keyword|operator_!=)\n### `!=`\n\n#### Possible use: \n  * `float` **`!=`** `float` --->  `bool`\n  *  **`!=`** (`float` , `float`) --->  `bool`\n  * `unknown` **`!=`** `unknown` --->  `bool`\n  *  **`!=`** (`unknown` , `unknown`) --->  `bool`\n  * `date` **`!=`** `date` --->  `bool`\n  *  **`!=`** (`date` , `date`) --->  `bool`\n  * `float` **`!=`** `int` --->  `bool`\n  *  **`!=`** (`float` , `int`) --->  `bool`\n  * `int` **`!=`** `float` --->  `bool`\n  *  **`!=`** (`int` , `float`) --->  `bool` \n\n#### Result: \ntrue if both operands are different, false otherwise\n\n#### Examples: \n```\nbool var0 <- 3.0 != 3.0; \t// var0 equals false\nbool var1 <- 4.0 != 4.7; \t// var1 equals true\nbool var2 <- [2,3] != [2,3]; \t// var2 equals false\nbool var3 <- [2,4] != [2,3]; \t// var3 equals true\n#now != #now minus_hours 1 :- true\nbool var5 <- 3.0 != 3; \t// var5 equals false\nbool var6 <- 4.7 != 4; \t// var6 equals true\nbool var7 <- 3 != 3.0; \t// var7 equals false\nbool var8 <- 4 != 4.7; \t// var8 equals true\n```\n      \n\n#### See also: \n[=](#=), [>](#>), [<](#<), [>=](#>=), [<=](#<=), \n    \t\n----\n\n\n[//]: # (keyword|operator_?)\n### `?`\n\n#### Possible use: \n  * `bool` **`?`** `any expression` --->  `unknown`\n  *  **`?`** (`bool` , `any expression`) --->  `unknown` \n\n#### Result: \nIt is used in combination with the : operator: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :  \n\n#### Comment: \nThese functional tests can be combined together.\n\n#### Examples: \n```\nlist<string> var0 <- [10, 19, 43, 12, 7, 22] collect ((each > 20) ? 'above' : 'below'); \t// var0 equals ['below', 'below', 'above', 'below', 'below', 'above']\nrgb color <- (flip(0.3) ? #red : (flip(0.9) ? #blue : #green));\n```\n      \n\n#### See also: \n[:](#:), \n    \t\n----\n\n\n[//]: # (keyword|operator_/)\n### `/`\n\n#### Possible use: \n  * `rgb` **`/`** `float` --->  `rgb`\n  *  **`/`** (`rgb` , `float`) --->  `rgb`\n  * `float` **`/`** `int` --->  `float`\n  *  **`/`** (`float` , `int`) --->  `float`\n  * `point` **`/`** `float` --->  `point`\n  *  **`/`** (`point` , `float`) --->  `point`\n  * `int` **`/`** `int` --->  `float`\n  *  **`/`** (`int` , `int`) --->  `float`\n  * `int` **`/`** `float` --->  `float`\n  *  **`/`** (`int` , `float`) --->  `float`\n  * `matrix` **`/`** `float` --->  `matrix`\n  *  **`/`** (`matrix` , `float`) --->  `matrix`\n  * `point` **`/`** `int` --->  `point`\n  *  **`/`** (`point` , `int`) --->  `point`\n  * `matrix` **`/`** `matrix` --->  `matrix`\n  *  **`/`** (`matrix` , `matrix`) --->  `matrix`\n  * `matrix` **`/`** `int` --->  `matrix`\n  *  **`/`** (`matrix` , `int`) --->  `matrix`\n  * `float` **`/`** `float` --->  `float`\n  *  **`/`** (`float` , `float`) --->  `float`\n  * `rgb` **`/`** `int` --->  `rgb`\n  *  **`/`** (`rgb` , `int`) --->  `rgb` \n\n#### Result: \nReturns the division of the two operands.\n\n#### Special cases:     \n  * if the right-hand operand is equal to zero, raises a \"Division by zero\" exception    \n  * if one operand is a color and the other a double, returns a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated. \n  \n```\nrgb var0 <- rgb([255, 128, 32]) / 2.5; \t// var0 equals rgb([102,51,13])\n\n``` \n\n    \n  * if the left operand is a point, returns a new point with coordinates divided by the right operand \n  \n```\npoint var1 <- {5, 7.5} / 2.5; \t// var1 equals {2, 3}\npoint var2 <- {2,5} / 4; \t// var2 equals {0.5,1.25}\n\n``` \n\n    \n  * if both operands are numbers (float or int), performs a normal arithmetic division and returns a float. \n  \n```\nfloat var3 <- 3 / 5.0; \t// var3 equals 0.6\n\n``` \n\n    \n  * if one operand is a color and the other an integer, returns a new color resulting from the division of each component of the color by the right operand \n  \n```\nrgb var4 <- rgb([255, 128, 32]) / 2; \t// var4 equals rgb([127,64,16])\n\n``` \n\n    \n\n#### See also: \n[*](#*), [+](#+), [-](#-), \n    \t\n----\n\n\n[//]: # (keyword|operator_.)\n### `.`\n\n#### Possible use: \n  * `matrix` **`.`** `matrix` --->  `matrix`\n  *  **`.`** (`matrix` , `matrix`) --->  `matrix`\n  * `agent` **`.`** `any expression` --->  `unknown`\n  *  **`.`** (`agent` , `any expression`) --->  `unknown` \n\n#### Result: \nIt has two different uses: it can be the dot product between 2 matrices or return an evaluation of the expression (right-hand operand) in the scope the given agent.\n\n#### Special cases:     \n  * if the agent is nil or dead, throws an exception    \n  * if both operands are matrix, returns the dot product of them \n  \n```\nmatrix var0 <- matrix([[1,1],[1,2]]) . matrix([[1,1],[1,2]]); \t// var0 equals matrix([[2,3],[3,5]])\n\n``` \n\n    \n  * if the left operand is an agent, it evaluates of the expression (right-hand operand) in the scope the given agent \n  \n```\nunknown var1 <- agent1.location; \t// var1 equals the location of the agent agent1\nmap(nil).keys\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_^)\n### `^`\n\n#### Possible use: \n  * `int` **`^`** `float` --->  `float`\n  *  **`^`** (`int` , `float`) --->  `float`\n  * `float` **`^`** `float` --->  `float`\n  *  **`^`** (`float` , `float`) --->  `float`\n  * `int` **`^`** `int` --->  `float`\n  *  **`^`** (`int` , `int`) --->  `float`\n  * `float` **`^`** `int` --->  `float`\n  *  **`^`** (`float` , `int`) --->  `float` \n\n#### Result: \nReturns the value (always a float) of the left operand raised to the power of the right operand.\n\n#### Special cases:     \n  * if the right-hand operand is equal to 0, returns 1    \n  * if it is equal to 1, returns the left-hand operand.    \n  * Various examples of power \n  \n```\nfloat var1 <- 2 ^ 3; \t// var1 equals 8.0\n\n``` \n\n\n\n#### Examples: \n```\nfloat var0 <- 4.84 ^ 0.5; \t// var0 equals 2.2\n```\n      \n\n#### See also: \n[*](#*), [sqrt](#sqrt), \n    \t\n----\n\n\n[//]: # (keyword|operator_@)\n### `@`\nSame signification as [at](#at)\n    \t\n----\n\n\n[//]: # (keyword|operator_*)\n### `*`\n\n#### Possible use: \n  * `int` **`*`** `int` --->  `int`\n  *  **`*`** (`int` , `int`) --->  `int`\n  * `matrix` **`*`** `int` --->  `matrix`\n  *  **`*`** (`matrix` , `int`) --->  `matrix`\n  * `point` **`*`** `point` --->  `float`\n  *  **`*`** (`point` , `point`) --->  `float`\n  * `int` **`*`** `float` --->  `float`\n  *  **`*`** (`int` , `float`) --->  `float`\n  * `float` **`*`** `float` --->  `float`\n  *  **`*`** (`float` , `float`) --->  `float`\n  * `matrix` **`*`** `matrix` --->  `matrix`\n  *  **`*`** (`matrix` , `matrix`) --->  `matrix`\n  * `point` **`*`** `int` --->  `point`\n  *  **`*`** (`point` , `int`) --->  `point`\n  * `float` **`*`** `matrix` --->  `matrix`\n  *  **`*`** (`float` , `matrix`) --->  `matrix`\n  * `geometry` **`*`** `point` --->  `geometry`\n  *  **`*`** (`geometry` , `point`) --->  `geometry`\n  * `point` **`*`** `float` --->  `point`\n  *  **`*`** (`point` , `float`) --->  `point`\n  * `int` **`*`** `matrix` --->  `matrix`\n  *  **`*`** (`int` , `matrix`) --->  `matrix`\n  * `float` **`*`** `int` --->  `float`\n  *  **`*`** (`float` , `int`) --->  `float`\n  * `rgb` **`*`** `int` --->  `rgb`\n  *  **`*`** (`rgb` , `int`) --->  `rgb`\n  * `matrix` **`*`** `float` --->  `matrix`\n  *  **`*`** (`matrix` , `float`) --->  `matrix`\n  * `geometry` **`*`** `float` --->  `geometry`\n  *  **`*`** (`geometry` , `float`) --->  `geometry` \n\n#### Result: \nReturns the product of the two operands.\n\n#### Special cases:     \n  * if both operands are numbers (float or int), performs a normal arithmetic product and returns a float if one of them is a float. \n  \n```\nint var1 <- 1 * 1; \t// var1 equals 1\n\n``` \n\n    \n  * if both operands are points, returns their scalar product \n  \n```\nfloat var2 <- {2,5} * {4.5, 5}; \t// var2 equals 34.0\n\n``` \n\n    \n  * if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the number \n  \n```\npoint var3 <- {2,5} * 4; \t// var3 equals {8.0, 20.0}\npoint var4 <- {2, 4} * 2.5; \t// var4 equals {5.0, 10.0}\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operand a point, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficients in the 3 dimensions \n  \n```\ngeometry var5 <- shape * {0.5,0.5,2}; \t// var5 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z\n\n``` \n\n    \n  * if one operand is a matrix and the other a number (float or int), performs a normal arithmetic product of the number with each element of the matrix (results are float if the number is a float. \n  \n```\nmatrix<float> m <- (3.5 * matrix([[2,5],[3,4]]));\t//m equals matrix([[7.0,17.5],[10.5,14]])\n\n``` \n\n    \n  * if one operand is a color and the other an integer, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255) \n  \n```\nrgb var7 <- rgb([255, 128, 32]) * 2; \t// var7 equals rgb([255,255,64])\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficient \n  \n```\ngeometry var8 <- circle(10) * 2; \t// var8 equals circle(20)\n\n``` \n\n\n\n#### Examples: \n```\nfloat var0 <- 2.5 * 2; \t// var0 equals 5.0\n```\n      \n\n#### See also: \n[+](#+), [-](#-), [/](#/), \n    \t\n----\n\n\n[//]: # (keyword|operator_+)\n### `+`\n\n#### Possible use: \n  * `string` **`+`** `string` --->  `string`\n  *  **`+`** (`string` , `string`) --->  `string`\n  * `date` **`+`** `float` --->  `date`\n  *  **`+`** (`date` , `float`) --->  `date`\n  * `map` **`+`** `pair` --->  `map`\n  *  **`+`** (`map` , `pair`) --->  `map`\n  * `int` **`+`** `matrix` --->  `matrix`\n  *  **`+`** (`int` , `matrix`) --->  `matrix`\n  * `point` **`+`** `int` --->  `point`\n  *  **`+`** (`point` , `int`) --->  `point`\n  * `rgb` **`+`** `rgb` --->  `rgb`\n  *  **`+`** (`rgb` , `rgb`) --->  `rgb`\n  * `geometry` **`+`** `float` --->  `geometry`\n  *  **`+`** (`geometry` , `float`) --->  `geometry`\n  * `matrix` **`+`** `float` --->  `matrix`\n  *  **`+`** (`matrix` , `float`) --->  `matrix`\n  * `geometry` **`+`** `geometry` --->  `geometry`\n  *  **`+`** (`geometry` , `geometry`) --->  `geometry`\n  * `map` **`+`** `map` --->  `map`\n  *  **`+`** (`map` , `map`) --->  `map`\n  * `float` **`+`** `float` --->  `float`\n  *  **`+`** (`float` , `float`) --->  `float`\n  * `float` **`+`** `int` --->  `float`\n  *  **`+`** (`float` , `int`) --->  `float`\n  * `matrix` **`+`** `matrix` --->  `matrix`\n  *  **`+`** (`matrix` , `matrix`) --->  `matrix`\n  * `date` **`+`** `string` --->  `string`\n  *  **`+`** (`date` , `string`) --->  `string`\n  * `matrix` **`+`** `int` --->  `matrix`\n  *  **`+`** (`matrix` , `int`) --->  `matrix`\n  * `int` **`+`** `int` --->  `int`\n  *  **`+`** (`int` , `int`) --->  `int`\n  * `string` **`+`** `unknown` --->  `string`\n  *  **`+`** (`string` , `unknown`) --->  `string`\n  * `point` **`+`** `point` --->  `point`\n  *  **`+`** (`point` , `point`) --->  `point`\n  * `float` **`+`** `matrix` --->  `matrix`\n  *  **`+`** (`float` , `matrix`) --->  `matrix`\n  * `int` **`+`** `float` --->  `float`\n  *  **`+`** (`int` , `float`) --->  `float`\n  * `point` **`+`** `float` --->  `point`\n  *  **`+`** (`point` , `float`) --->  `point`\n  * `rgb` **`+`** `int` --->  `rgb`\n  *  **`+`** (`rgb` , `int`) --->  `rgb`\n  * `date` **`+`** `int` --->  `date`\n  *  **`+`** (`date` , `int`) --->  `date`\n  * `container` **`+`** `container` --->  `container`\n  *  **`+`** (`container` , `container`) --->  `container`\n  * `container` **`+`** `unknown` --->  `container`\n  *  **`+`** (`container` , `unknown`) --->  `container`\n  *  **`+`** (`geometry`, `float`, `int`) --->  `geometry`\n  *  **`+`** (`geometry`, `float`, `int`, `int`) --->  `geometry` \n\n#### Result: \nReturns the sum, union or concatenation of the two operands.\n\n#### Special cases:     \n  * if one of the operands is nil, + throws an error    \n  * if both operands are species, returns a special type of list called meta-population    \n  * if the left-hand operand is a geometry and the right-hand operands a float and an integer, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand \n  \n```\ngeometry var4 <- circle(5) + (5,32); \t// var4 equals circle(10)\n\n``` \n\n    \n  * if one operand is a matrix and the other a number (float or int), performs a normal arithmetic sum of the number with each element of the matrix (results are float if the number is a float. \n  \n```\nmatrix var5 <- 3.5 + matrix([[2,5],[3,4]]); \t// var5 equals matrix([[5.5,8.5],[6.5,7.5]])\n\n``` \n\n    \n  * if both operands are colors, returns a new color resulting from the sum of the two operands, component by component \n  \n```\nrgb var6 <- rgb([255, 128, 32]) + rgb('red'); \t// var6 equals rgb([255,128,32])\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance. The number of segments used by default is 8 and the end cap style is #round \n  \n```\ngeometry var7 <- circle(5) + 5; \t// var7 equals circle(10)\n\n``` \n\n    \n  * if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometries \n  \n```\ngeometry var8 <- geom1 + geom2; \t// var8 equals a geometry corresponding to union between geom1 and geom2\n\n``` \n\n    \n  * if both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float. \n  \n```\nint var9 <- 1 + 1; \t// var9 equals 2\nint var10 <- 1.0 + 1; \t// var10 equals 2.0\nint var11 <- 1.0 + 2.5; \t// var11 equals 3.5\n\n``` \n\n    \n  * if the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string) \n  \n```\nstring var12 <- \"hello \" + 12; \t// var12 equals \"hello 12\"\n\n``` \n\n    \n  * if both operands are points, returns their sum. \n  \n```\npoint var13 <- {1, 2} + {4, 5}; \t// var13 equals {5.0, 7.0}\n\n``` \n\n    \n  * if the left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number. \n  \n```\npoint var14 <- {1, 2} + 4; \t// var14 equals {5.0, 6.0,4.0}\npoint var15 <- {1, 2} + 4.5; \t// var15 equals {5.5, 6.5,4.5}\n\n``` \n\n    \n  * if one operand is a color and the other an integer, returns a new color resulting from the sum of each component of the color with the right operand \n  \n```\nrgb var16 <- rgb([255, 128, 32]) + 3; \t// var16 equals rgb([255,131,35])\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operands a float, an integer and one of #round, #square or #flat, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap style \n  \n```\ngeometry var17 <- circle(5) + (5,32,#round); \t// var17 equals circle(10)\n\n``` \n\n    \n  * if one of the operands is a date and the other a number, returns a date corresponding to the date plus the given number as duration (in seconds) \n  \n```\ndate1 + 200\n\n``` \n\n    \n  * if both operands are list, +returns the concatenation of both lists. \n  \n```\nlist<int> var19 <- [1,2,3,4,5,6] + [2,4,9]; \t// var19 equals [1,2,3,4,5,6,2,4,9]\nlist<int> var20 <- [1,2,3,4,5,6] + [0,8]; \t// var20 equals [1,2,3,4,5,6,0,8]\n\n``` \n\n    \n  * if the right operand is an object of any type (except a container), + returns a list of the elements of the left operand, to which this object has been added \n  \n```\nlist<int> var21 <- [1,2,3,4,5,6] + 2; \t// var21 equals [1,2,3,4,5,6,2]\nlist<int> var22 <- [1,2,3,4,5,6] + 0; \t// var22 equals [1,2,3,4,5,6,0]\n\n``` \n\n\n\n#### Examples: \n```\nmap var0 <- ['a'::1,'b'::2] + ('c'::3); \t// var0 equals ['a'::1,'b'::2,'c'::3]\nmap var1 <- ['a'::1,'b'::2] + ('c'::3); \t// var1 equals ['a'::1,'b'::2,'c'::3]\nmap var2 <- ['a'::1,'b'::2] + ['c'::3]; \t// var2 equals ['a'::1,'b'::2,'c'::3]\nmap var3 <- ['a'::1,'b'::2] + [5::3.0]; \t// var3 equals ['a'::1.0,'b'::2.0,5::3.0]\n```\n      \n\n#### See also: \n[-](#-), [*](#*), [/](#/), \n    \t\n----\n\n\n[//]: # (keyword|operator_<)\n### `<`\n\n#### Possible use: \n  * `float` **`<`** `int` --->  `bool`\n  *  **`<`** (`float` , `int`) --->  `bool`\n  * `int` **`<`** `int` --->  `bool`\n  *  **`<`** (`int` , `int`) --->  `bool`\n  * `point` **`<`** `point` --->  `bool`\n  *  **`<`** (`point` , `point`) --->  `bool`\n  * `int` **`<`** `float` --->  `bool`\n  *  **`<`** (`int` , `float`) --->  `bool`\n  * `date` **`<`** `date` --->  `bool`\n  *  **`<`** (`date` , `date`) --->  `bool`\n  * `float` **`<`** `float` --->  `bool`\n  *  **`<`** (`float` , `float`) --->  `bool`\n  * `string` **`<`** `string` --->  `bool`\n  *  **`<`** (`string` , `string`) --->  `bool` \n\n#### Result: \ntrue if the left-hand operand is less than the right-hand operand, false otherwise.\n\n#### Special cases:     \n  * if one of the operands is nil, returns false    \n  * if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one. \n  \n```\nbool var5 <- {5,7} < {4,6}; \t// var5 equals false\nbool var6 <- {5,7} < {4,8}; \t// var6 equals false\n\n``` \n\n    \n  * if both operands are String, uses a lexicographic comparison of two strings \n  \n```\nbool var7 <- 'abc' < 'aeb'; \t// var7 equals true\n\n``` \n\n\n\n#### Examples: \n```\nbool var0 <- 3.5 < 7; \t// var0 equals true\nbool var1 <- 3 < 7; \t// var1 equals true\nbool var2 <- 3 < 2.5; \t// var2 equals false\n#now < #now minus_hours 1 :- false\nbool var4 <- 3.5 < 7.6; \t// var4 equals true\n```\n      \n\n#### See also: \n[>](#>), [>=](#>=), [<=](#<=), [=](#=), [!=](#!=), \n    \t\n----\n\n\n[//]: # (keyword|operator_<=)\n### `<=`\n\n#### Possible use: \n  * `string` **`<=`** `string` --->  `bool`\n  *  **`<=`** (`string` , `string`) --->  `bool`\n  * `date` **`<=`** `date` --->  `bool`\n  *  **`<=`** (`date` , `date`) --->  `bool`\n  * `float` **`<=`** `float` --->  `bool`\n  *  **`<=`** (`float` , `float`) --->  `bool`\n  * `int` **`<=`** `int` --->  `bool`\n  *  **`<=`** (`int` , `int`) --->  `bool`\n  * `int` **`<=`** `float` --->  `bool`\n  *  **`<=`** (`int` , `float`) --->  `bool`\n  * `float` **`<=`** `int` --->  `bool`\n  *  **`<=`** (`float` , `int`) --->  `bool`\n  * `point` **`<=`** `point` --->  `bool`\n  *  **`<=`** (`point` , `point`) --->  `bool` \n\n#### Result: \ntrue if the left-hand operand is less or equal than the right-hand operand, false otherwise.\n\n#### Special cases:     \n  * if one of the operands is nil, returns false    \n  * if both operands are String, uses a lexicographic comparison of two strings \n  \n```\nbool var5 <- 'abc' <= 'aeb'; \t// var5 equals true\n\n``` \n\n    \n  * if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one. \n  \n```\nbool var6 <- {5,7} <= {4,6}; \t// var6 equals false\nbool var7 <- {5,7} <= {4,8}; \t// var7 equals false\n\n``` \n\n\n\n#### Examples: \n```\n#now <= #now minus_hours 1 :- false\nbool var1 <- 3.5 <= 3.5; \t// var1 equals true\nbool var2 <- 3 <= 7; \t// var2 equals true\nbool var3 <- 3 <= 2.5; \t// var3 equals false\nbool var4 <- 7.0 <= 7; \t// var4 equals true\n```\n      \n\n#### See also: \n[>](#>), [<](#<), [>=](#>=), [=](#=), [!=](#!=), \n    \t\n----\n\n\n[//]: # (keyword|operator_<>)\n### `<>`\nSame signification as [!=](#!=)\n    \t\n----\n\n\n[//]: # (keyword|operator_=)\n### `=`\n\n#### Possible use: \n  * `date` **`=`** `date` --->  `bool`\n  *  **`=`** (`date` , `date`) --->  `bool`\n  * `int` **`=`** `float` --->  `bool`\n  *  **`=`** (`int` , `float`) --->  `bool`\n  * `unknown` **`=`** `unknown` --->  `bool`\n  *  **`=`** (`unknown` , `unknown`) --->  `bool`\n  * `float` **`=`** `float` --->  `bool`\n  *  **`=`** (`float` , `float`) --->  `bool`\n  * `float` **`=`** `int` --->  `bool`\n  *  **`=`** (`float` , `int`) --->  `bool`\n  * `int` **`=`** `int` --->  `bool`\n  *  **`=`** (`int` , `int`) --->  `bool` \n\n#### Result: \nreturns true if both operands are equal, false otherwise\nreturns true if both operands are equal, false otherwise\n\n#### Special cases:     \n  * if both operands are any kind of objects, returns true if they are identical (i.e., the same object) or equal (comparisons between nil values are permitted) \n  \n```\nbool var0 <- [2,3] = [2,3]; \t// var0 equals true\n\n``` \n\n\n\n#### Examples: \n```\n#now = #now minus_hours 1 :- false\nbool var2 <- 3 = 3.0; \t// var2 equals true\nbool var3 <- 4 = 4.7; \t// var3 equals false\nbool var4 <- 4.5 = 4.7; \t// var4 equals false\nbool var5 <- 4.7 = 4; \t// var5 equals false\nbool var6 <- 4 = 5; \t// var6 equals false\n```\n      \n\n#### See also: \n[!=](#!=), [>](#>), [<](#<), [>=](#>=), [<=](#<=), \n    \t\n----\n\n\n[//]: # (keyword|operator_>)\n### `>`\n\n#### Possible use: \n  * `int` **`>`** `float` --->  `bool`\n  *  **`>`** (`int` , `float`) --->  `bool`\n  * `float` **`>`** `float` --->  `bool`\n  *  **`>`** (`float` , `float`) --->  `bool`\n  * `string` **`>`** `string` --->  `bool`\n  *  **`>`** (`string` , `string`) --->  `bool`\n  * `int` **`>`** `int` --->  `bool`\n  *  **`>`** (`int` , `int`) --->  `bool`\n  * `date` **`>`** `date` --->  `bool`\n  *  **`>`** (`date` , `date`) --->  `bool`\n  * `point` **`>`** `point` --->  `bool`\n  *  **`>`** (`point` , `point`) --->  `bool`\n  * `float` **`>`** `int` --->  `bool`\n  *  **`>`** (`float` , `int`) --->  `bool` \n\n#### Result: \ntrue if the left-hand operand is greater than the right-hand operand, false otherwise.\n\n#### Special cases:     \n  * if one of the operands is nil, returns false    \n  * if both operands are String, uses a lexicographic comparison of two strings \n  \n```\nbool var0 <- 'abc' > 'aeb'; \t// var0 equals false\n\n``` \n\n    \n  * if both operands are points, returns true if and only if the left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one. \n  \n```\nbool var1 <- {5,7} > {4,6}; \t// var1 equals true\nbool var2 <- {5,7} > {4,8}; \t// var2 equals false\n\n``` \n\n\n\n#### Examples: \n```\nbool var3 <- 3 > 2.5; \t// var3 equals true\nbool var4 <- 3.5 > 7.6; \t// var4 equals false\nbool var5 <- 3 > 7; \t// var5 equals false\n#now > #now minus_hours 1 :- true\nbool var7 <- 3.5 > 7; \t// var7 equals false\n```\n      \n\n#### See also: \n[<](#<), [>=](#>=), [<=](#<=), [=](#=), [!=](#!=), \n    \t\n----\n\n\n[//]: # (keyword|operator_>=)\n### `>=`\n\n#### Possible use: \n  * `float` **`>=`** `int` --->  `bool`\n  *  **`>=`** (`float` , `int`) --->  `bool`\n  * `int` **`>=`** `int` --->  `bool`\n  *  **`>=`** (`int` , `int`) --->  `bool`\n  * `int` **`>=`** `float` --->  `bool`\n  *  **`>=`** (`int` , `float`) --->  `bool`\n  * `string` **`>=`** `string` --->  `bool`\n  *  **`>=`** (`string` , `string`) --->  `bool`\n  * `date` **`>=`** `date` --->  `bool`\n  *  **`>=`** (`date` , `date`) --->  `bool`\n  * `float` **`>=`** `float` --->  `bool`\n  *  **`>=`** (`float` , `float`) --->  `bool`\n  * `point` **`>=`** `point` --->  `bool`\n  *  **`>=`** (`point` , `point`) --->  `bool` \n\n#### Result: \ntrue if the left-hand operand is greater or equal than the right-hand operand, false otherwise.\n\n#### Special cases:     \n  * if one of the operands is nil, returns false    \n  * if both operands are string, uses a lexicographic comparison of the two strings \n  \n```\nbool var5 <- 'abc' >= 'aeb'; \t// var5 equals false\nbool var6 <- 'abc' >= 'abc'; \t// var6 equals true\n\n``` \n\n    \n  * if both operands are points, returns true if and only if the left component (x) of the left operand if greater or equal than x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one. \n  \n```\nbool var7 <- {5,7} >= {4,6}; \t// var7 equals true\nbool var8 <- {5,7} >= {4,8}; \t// var8 equals false\n\n``` \n\n\n\n#### Examples: \n```\nbool var0 <- 3.5 >= 7; \t// var0 equals false\nbool var1 <- 3 >= 7; \t// var1 equals false\nbool var2 <- 3 >= 2.5; \t// var2 equals true\n#now >= #now minus_hours 1 :- true\nbool var4 <- 3.5 >= 3.5; \t// var4 equals true\n```\n      \n\n#### See also: \n[>](#>), [<](#<), [<=](#<=), [=](#=), [!=](#!=), \n    \t\n----\n\n\n[//]: # (keyword|operator_abs)\n### `abs`\n\n#### Possible use: \n  *  **`abs`** (`int`) --->  `int`\n  *  **`abs`** (`float`) --->  `float` \n\n#### Result: \nReturns the absolute value of the operand (so a positive int or float depending on the type of the operand).\n\n#### Examples: \n```\nint var0 <- abs (-10); \t// var0 equals 10\nint var1 <- abs (10); \t// var1 equals 10\nfloat var3 <- abs (200 * -1 + 0.5); \t// var3 equals 199.5\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_accumulate)\n### `accumulate`\n\n#### Possible use: \n  * `container` **`accumulate`** `any expression` --->  `container`\n  *  **`accumulate`** (`container` , `any expression`) --->  `container` \n\n#### Result: \nreturns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned  \n\n#### Comment: \naccumulate is dedicated to the application of a same computation on each element of a container (and returns a list). In the right-hand operand, the keyword each can be used to represent, in turn, each of the left-hand operand elements.\n\n#### Examples: \n```\ncontainer var0 <- [a1,a2,a3] accumulate (each neighbors_at 10); \t// var0 equals a flat list of all the neighbors of these three agents\nlist<int> var1 <- [1,2,4] accumulate ([2,4]); \t// var1 equals [2,4,2,4,2,4]\nlist<int> var2 <- [1,2,4] accumulate (each * 2); \t// var2 equals [2,4,8]\n```\n      \n\n#### See also: \n[collect](#collect), \n    \t\n----\n\n\n[//]: # (keyword|operator_acos)\n### `acos`\n\n#### Possible use: \n  *  **`acos`** (`float`) --->  `float`\n  *  **`acos`** (`int`) --->  `float` \n\n#### Result: \nReturns the value (in the interval [0,180], in decimal degrees) of the arccos of the operand (which should be in [-1,1]).\n\n#### Special cases:     \n  * if the right-hand operand is outside of the [-1,1] interval, returns NaN\n\n#### Examples: \n```\nfloat var0 <- acos (0); \t// var0 equals 90.0\n```\n      \n\n#### See also: \n[asin](#asin), [atan](#atan), [cos](#cos), \n    \t\n----\n\n\n[//]: # (keyword|operator_action)\n### `action`\n\n#### Possible use: \n  *  **`action`** (`any`) --->  `action` \n\n#### Result: \nCasts the operand into the type action\n    \t\n----\n\n\n[//]: # (keyword|operator_add_days)\n### `add_days`\nSame signification as [plus_days](#plus_days)\n    \t\n----\n\n\n[//]: # (keyword|operator_add_edge)\n### `add_edge`\n\n#### Possible use: \n  * `graph` **`add_edge`** `pair` --->  `graph`\n  *  **`add_edge`** (`graph` , `pair`) --->  `graph` \n\n#### Result: \nadd an edge between a source vertex and a target vertex (resp. the left and the right element of the pair operand)  \n\n#### Comment: \nif the edge already exists, the graph is unchanged\n\n#### Examples: \n```\ngraph <- graph add_edge (source::target);\n```\n      \n\n#### See also: \n[add_node](#add_node), [graph](#graph), \n    \t\n----\n\n\n[//]: # (keyword|operator_add_hours)\n### `add_hours`\nSame signification as [plus_hours](#plus_hours)\n    \t\n----\n\n\n[//]: # (keyword|operator_add_minutes)\n### `add_minutes`\nSame signification as [plus_minutes](#plus_minutes)\n    \t\n----\n\n\n[//]: # (keyword|operator_add_months)\n### `add_months`\nSame signification as [plus_months](#plus_months)\n    \t\n----\n\n\n[//]: # (keyword|operator_add_ms)\n### `add_ms`\nSame signification as [plus_ms](#plus_ms)\n    \t\n----\n\n\n[//]: # (keyword|operator_add_node)\n### `add_node`\n\n#### Possible use: \n  * `graph` **`add_node`** `geometry` --->  `graph`\n  *  **`add_node`** (`graph` , `geometry`) --->  `graph` \n\n#### Result: \nadds a node in a graph.\n\n#### Examples: \n```\ngraph var0 <- graph add_node node(0) ; \t// var0 equals the graph with node(0)\n```\n      \n\n#### See also: \n[add_edge](#add_edge), [graph](#graph), \n    \t\n----\n\n\n[//]: # (keyword|operator_add_point)\n### `add_point`\n\n#### Possible use: \n  * `geometry` **`add_point`** `point` --->  `geometry`\n  *  **`add_point`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nA new geometry resulting from the addition of the right point (coordinate) to the left-hand geometry. Note that adding a point to a line or polyline will always return a closed contour. Also note that the position at which the added point will appear in the geometry is not necessarily the last one, as points are always ordered in a clockwise fashion in geometries\n\n#### Examples: \n```\ngeometry var0 <- polygon([{10,10},{10,20},{20,20}]) add_point {20,10}; \t// var0 equals polygon([{10,10},{10,20},{20,20},{20,10}])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_add_seconds)\n### `add_seconds`\nSame signification as [+](#+)\n    \t\n----\n\n\n[//]: # (keyword|operator_add_weeks)\n### `add_weeks`\nSame signification as [plus_weeks](#plus_weeks)\n    \t\n----\n\n\n[//]: # (keyword|operator_add_years)\n### `add_years`\nSame signification as [plus_years](#plus_years)\n    \t\n----\n\n\n[//]: # (keyword|operator_adjacency)\n### `adjacency`\n\n#### Possible use: \n  *  **`adjacency`** (`graph`) --->  `matrix<float>` \n\n#### Result: \nadjacency matrix of the given graph.\n    \t\n----\n\n\n[//]: # (keyword|operator_after)\n### `after`\n\n#### Possible use: \n  *  **`after`** (`date`) --->  `bool`\n  * `any expression` **`after`** `date` --->  `bool`\n  *  **`after`** (`any expression` , `date`) --->  `bool` \n\n#### Result: \nReturns true if the current_date of the model is strictly after the date passed in argument. Synonym of 'current_date > argument'. Can be used in its composed form with 2 arguments to express the lower boundary for the computation of a frequency. Note that only dates strictly after this one will be tested against the frequency\n\n#### Examples: \n```\nreflex when: after(starting_date) {} -: will always be run after the first step\nreflex when: false after(starting date + #10days) {} -: will not be run after this date. Better to use 'until' or 'before' in that case\nevery(2#days) after (starting_date + 1#day) // the computation will return true every two days (using the starting_date of the model as the starting point) only for the dates strictly after this starting_date + 1#day\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_agent)\n### `agent`\n\n#### Possible use: \n  *  **`agent`** (`any`) --->  `agent` \n\n#### Result: \nCasts the operand into the type agent\n    \t\n----\n\n\n[//]: # (keyword|operator_agent_closest_to)\n### `agent_closest_to`\n\n#### Possible use: \n  *  **`agent_closest_to`** (`unknown`) --->  `agent` \n\n#### Result: \nAn agent, the closest to the operand (casted as a geometry).  \n\n#### Comment: \nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\n\n#### Examples: \n```\nagent var0 <- agent_closest_to(self); \t// var0 equals the closest agent to the agent applying the operator.\n```\n      \n\n#### See also: \n[neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [agents_inside](#agents_inside), [agents_overlapping](#agents_overlapping), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), \n    \t\n----\n\n\n[//]: # (keyword|operator_agent_farthest_to)\n### `agent_farthest_to`\n\n#### Possible use: \n  *  **`agent_farthest_to`** (`unknown`) --->  `agent` \n\n#### Result: \nAn agent, the farthest to the operand (casted as a geometry).  \n\n#### Comment: \nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\n\n#### Examples: \n```\nagent var0 <- agent_farthest_to(self); \t// var0 equals the farthest agent to the agent applying the operator.\n```\n      \n\n#### See also: \n[neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [agents_inside](#agents_inside), [agents_overlapping](#agents_overlapping), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), [agent_closest_to](#agent_closest_to), [farthest_to](#farthest_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_agent_from_geometry)\n### `agent_from_geometry`\n\n#### Possible use: \n  * `path` **`agent_from_geometry`** `geometry` --->  `agent`\n  *  **`agent_from_geometry`** (`path` , `geometry`) --->  `agent` \n\n#### Result: \nreturns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).\n\n#### Special cases:     \n  * if the left-hand operand is nil, returns nil\n\n#### Examples: \n```\ngeometry line <- one_of(path_followed.segments);\nroad ag <- road(path_followed agent_from_geometry line);\n```\n      \n\n#### See also: \n[path](#path), \n    \t\n----\n\n\n[//]: # (keyword|operator_agents_at_distance)\n### `agents_at_distance`\n\n#### Possible use: \n  *  **`agents_at_distance`** (`float`) --->  `container` \n\n#### Result: \nA list of agents situated at a distance lower than the right argument.\n\n#### Examples: \n```\ncontainer var0 <- agents_at_distance(20); \t// var0 equals all the agents (excluding the caller) which distance to the caller is lower than 20\n```\n      \n\n#### See also: \n[neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [agent_closest_to](#agent_closest_to), [agents_inside](#agents_inside), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), [at_distance](#at_distance), \n    \t\n----\n\n\n[//]: # (keyword|operator_agents_inside)\n### `agents_inside`\n\n#### Possible use: \n  *  **`agents_inside`** (`unknown`) --->  `list<agent>` \n\n#### Result: \nA list of agents covered by the operand (casted as a geometry).\n\n#### Examples: \n```\nlist<agent> var0 <- agents_inside(self); \t// var0 equals the agents that are covered by the shape of the agent applying the operator.\n```\n      \n\n#### See also: \n[agent_closest_to](#agent_closest_to), [agents_overlapping](#agents_overlapping), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), \n    \t\n----\n\n\n[//]: # (keyword|operator_agents_overlapping)\n### `agents_overlapping`\n\n#### Possible use: \n  *  **`agents_overlapping`** (`unknown`) --->  `list<agent>` \n\n#### Result: \nA list of agents overlapping the operand (casted as a geometry).\n\n#### Examples: \n```\nlist<agent> var0 <- agents_overlapping(self); \t// var0 equals the agents that overlap the shape of the agent applying the operator.\n```\n      \n\n#### See also: \n[neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [agent_closest_to](#agent_closest_to), [agents_inside](#agents_inside), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), [at_distance](#at_distance), \n    \t\n----\n\n\n[//]: # (keyword|operator_all_pairs_shortest_path)\n### `all_pairs_shortest_path`\n\n#### Possible use: \n  *  **`all_pairs_shortest_path`** (`graph`) --->  `matrix<int>` \n\n#### Result: \nreturns the successor matrix of shortest paths between all node pairs (rows: source, columns: target): a cell (i,j) will thus contains the next node in the shortest path between i and j.\n\n#### Examples: \n```\nmatrix<int> var0 <- all_pairs_shortest_paths(my_graph); \t// var0 equals shortest_paths_matrix will contain all pairs of shortest paths\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_alpha_index)\n### `alpha_index`\n\n#### Possible use: \n  *  **`alpha_index`** (`graph`) --->  `float` \n\n#### Result: \nreturns the alpha index of the graph (measure of connectivity which evaluates the number of cycles in a graph in comparison with the maximum number of cycles. The higher the alpha index, the more a network is connected: alpha = nb_cycles / (2`*`S-5) - planar graph)\n\n#### Examples: \n```\nfloat var1 <- alpha_index(graphEpidemio); \t// var1 equals the alpha index of the graph\n```\n      \n\n#### See also: \n[beta_index](#beta_index), [gamma_index](#gamma_index), [nb_cycles](#nb_cycles), [connectivity_index](#connectivity_index), \n    \t\n----\n\n\n[//]: # (keyword|operator_among)\n### `among`\n\n#### Possible use: \n  * `int` **`among`** `container` --->  `container`\n  *  **`among`** (`int` , `container`) --->  `container` \n\n#### Result: \nReturns a list of length the value of the left-hand operand, containing random elements from the right-hand operand. As of GAMA 1.6, the order in which the elements are returned can be different than the order in which they appear in the right-hand container\n\n#### Special cases:     \n  * if the right-hand operand is empty, among returns a new empty list. If it is nil, it throws an error.    \n  * if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand (converted as a list). If it is smaller or equal to zero, it returns an empty list\n\n#### Examples: \n```\nlist<int> var0 <- 3 among [1,2,4,3,5,7,6,8]; \t// var0 equals [1,2,8] (for example)\ncontainer var1 <- 3 among g2; \t// var1 equals [node6,node11,node7]\ncontainer var2 <- 3 among list(node); \t// var2 equals [node1,node11,node4]\nlist<int> var3 <- 1 among [1::2,3::4]; \t// var3 equals 2 or 4\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_and)\n### `and`\n\n#### Possible use: \n  * `bool` **`and`** `any expression` --->  `bool`\n  *  **`and`** (`bool` , `any expression`) --->  `bool` \n\n#### Result: \na bool value, equal to the logical and between the left-hand operand and the right-hand operand.  \n\n#### Comment: \nboth operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.    \n\n#### See also: \n[bool](#bool), [or](#or), [!](#!), \n    \t\n----\n\n\n[//]: # (keyword|operator_and)\n### `and`\n\n#### Possible use: \n  * `predicate` **`and`** `predicate` --->  `predicate`\n  *  **`and`** (`predicate` , `predicate`) --->  `predicate` \n\n#### Result: \ncreate a new predicate from two others by including them as subintentions\n\n#### Examples: \n```\npredicate1 and predicate2\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_angle_between)\n### `angle_between`\n\n#### Possible use: \n  *  **`angle_between`** (`point`, `point`, `point`) --->  `int` \n\n#### Result: \nthe angle between vectors P0P1 and P0P2 (P0, P1, P2 being the three point operands)\n\n#### Examples: \n```\nint var0 <- angle_between({5,5},{10,5},{5,10}); \t// var0 equals 90\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_any)\n### `any`\nSame signification as [one_of](#one_of)\n    \t\n----\n\n\n[//]: # (keyword|operator_any_location_in)\n### `any_location_in`\n\n#### Possible use: \n  *  **`any_location_in`** (`geometry`) --->  `point` \n\n#### Result: \nA point inside (or touching) the operand-geometry.\n\n#### Examples: \n```\npoint var0 <- any_location_in(square(5)); \t// var0 equals a point in the square, for example : {3,4.6}.\n```\n      \n\n#### See also: \n[closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), [points_at](#points_at), \n    \t\n----\n\n\n[//]: # (keyword|operator_any_point_in)\n### `any_point_in`\nSame signification as [any_location_in](#any_location_in)\n    \t\n----\n\n\n[//]: # (keyword|operator_append_horizontally)\n### `append_horizontally`\n\n#### Possible use: \n  * `matrix` **`append_horizontally`** `matrix` --->  `matrix`\n  *  **`append_horizontally`** (`matrix` , `matrix`) --->  `matrix`\n  * `matrix` **`append_horizontally`** `matrix` --->  `matrix`\n  *  **`append_horizontally`** (`matrix` , `matrix`) --->  `matrix` \n\n#### Result: \nA matrix resulting from the concatenation of the rows of the two given matrices. If not both numerical or both object matrices, returns the first matrix.\n\n#### Examples: \n```\nmatrix var0 <- matrix([[1.0,2.0],[3.0,4.0]]) append_horizontally matrix([[1,2],[3,4]]); \t// var0 equals matrix([[1.0,2.0],[3.0,4.0],[1.0,2.0],[3.0,4.0]])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_append_vertically)\n### `append_vertically`\n\n#### Possible use: \n  * `matrix` **`append_vertically`** `matrix` --->  `matrix`\n  *  **`append_vertically`** (`matrix` , `matrix`) --->  `matrix`\n  * `matrix` **`append_vertically`** `matrix` --->  `matrix`\n  *  **`append_vertically`** (`matrix` , `matrix`) --->  `matrix` \n\n#### Result: \nA matrix resulting from the concatenation of the columns  of the two given matrices. If not both numerical or both object matrices, returns the first matrix.\n\n#### Examples: \n```\nmatrix var0 <- matrix([[1,2],[3,4]]) append_vertically matrix([[1,2],[3,4]]); \t// var0 equals matrix([[1,2,1,2],[3,4,3,4]])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_arc)\n### `arc`\n\n#### Possible use: \n  *  **`arc`** (`float`, `float`, `float`) --->  `geometry`\n  *  **`arc`** (`float`, `float`, `float`, `bool`) --->  `geometry` \n\n#### Result: \nAn arc, which radius is equal to the first operand, heading to the second and amplitude the third\nAn arc, which radius is equal to the first operand, heading to the second, amplitude to the third and a boolean indicating whether to return a linestring or a polygon to the fourth  \n\n#### Comment: \nthe center of the arc is by default the location of the current agent in which has been called this operator. This operator returns a polygon by default.the center of the arc is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the radius operand is lower or equal to 0.    \n  * returns a point if the radius operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- arc(4,45,90); \t// var0 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°\ngeometry var1 <- arc(4,45,90, false); \t// var1 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°, which only contains the points on the arc\n```\n      \n\n#### See also: \n[around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [super_ellipse](#super_ellipse), [rectangle](#rectangle), [square](#square), [circle](#circle), [ellipse](#ellipse), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_around)\n### `around`\n\n#### Possible use: \n  * `float` **`around`** `unknown` --->  `geometry`\n  *  **`around`** (`float` , `unknown`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.\n\n#### Special cases:     \n  * returns a circle geometry of radius right-operand if the left-operand is nil\n\n#### Examples: \n```\ngeometry var0 <- 10 around circle(5); \t// var0 equals the ring geometry between 5 and 10.\n```\n      \n\n#### See also: \n[circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_as)\n### `as`\n\n#### Possible use: \n  * `unknown` **`as`** `any expression` --->  `unknown`\n  *  **`as`** (`unknown` , `any expression`) --->  `unknown` \n\n#### Result: \ncasting of the first argument into a given type  \n\n#### Comment: \nIt is equivalent to the application of the type operator on the left operand.\n\n#### Examples: \n```\nint var0 <- 3.5 as int; \t// var0 equals int(3.5)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_as_4_grid)\n### `as_4_grid`\n\n#### Possible use: \n  * `geometry` **`as_4_grid`** `point` --->  `matrix`\n  *  **`as_4_grid`** (`geometry` , `point`) --->  `matrix` \n\n#### Result: \nA matrix of square geometries (grid with 4-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)\n\n#### Examples: \n```\nmatrix var0 <- self as_4_grid {10, 5}; \t// var0 equals the matrix of square geometries (grid with 4-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.\n```\n      \n\n#### See also: \n[as_grid](#as_grid), [as_hexagonal_grid](#as_hexagonal_grid), \n    \t\n----\n\n\n[//]: # (keyword|operator_as_distance_graph)\n### `as_distance_graph`\n\n#### Possible use: \n  * `container` **`as_distance_graph`** `map` --->  `graph`\n  *  **`as_distance_graph`** (`container` , `map`) --->  `graph`\n  * `container` **`as_distance_graph`** `float` --->  `graph`\n  *  **`as_distance_graph`** (`container` , `float`) --->  `graph`\n  *  **`as_distance_graph`** (`container`, `float`, `species`) --->  `graph` \n\n#### Result: \ncreates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).  \n\n#### Comment: \nas_distance_graph is more efficient for a list of points than as_intersection_graph.\n\n#### Examples: \n```\nlist(ant) as_distance_graph 3.0\n```\n      \n\n#### See also: \n[as_intersection_graph](#as_intersection_graph), [as_edge_graph](#as_edge_graph), \n    \t\n----\n\n\n[//]: # (keyword|operator_as_driving_graph)\n### `as_driving_graph`\n\n#### Possible use: \n  * `container` **`as_driving_graph`** `container` --->  `graph`\n  *  **`as_driving_graph`** (`container` , `container`) --->  `graph` \n\n#### Result: \ncreates a graph from the list/map of edges given as operand and connect the node to the edge\n\n#### Examples: \n```\nas_driving_graph(road,node)  --:  build a graph while using the road agents as edges and the node agents as nodes\n```\n      \n\n#### See also: \n[as_intersection_graph](#as_intersection_graph), [as_distance_graph](#as_distance_graph), [as_edge_graph](#as_edge_graph), \n    \t\n----\n\n\n[//]: # (keyword|operator_as_edge_graph)\n### `as_edge_graph`\n\n#### Possible use: \n  *  **`as_edge_graph`** (`map`) --->  `graph`\n  *  **`as_edge_graph`** (`container`) --->  `graph`\n  * `container` **`as_edge_graph`** `float` --->  `graph`\n  *  **`as_edge_graph`** (`container` , `float`) --->  `graph` \n\n#### Result: \ncreates a graph from the list/map of edges given as operand\n\n#### Special cases:     \n  * if the operand is a map, the graph will be built by creating edges from pairs of the map \n  \n```\ngraph var0 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); \t// var0 equals a graph with these three vertices and two edges\n\n``` \n\n    \n  * if the operand is a list and a tolerance (max distance in meters to consider that 2 points are the same node) is given, the graph will be built with elements of the list as edges and two edges will be connected by a node if the distance between their extremity (first or last points) are at distance lower or equal to the tolerance \n  \n```\ngraph var1 <- as_edge_graph([line([{1,5},{12,45}]),line([{13,45},{34,56}])],1);; \t// var1 equals a graph with two edges and three vertices\n\n``` \n\n    \n  * if the operand is a list, the graph will be built with elements of the list as edges \n  \n```\ngraph var2 <- as_edge_graph([line([{1,5},{12,45}]),line([{12,45},{34,56}])]); \t// var2 equals a graph with two edges and three vertices\n\n``` \n\n    \n\n#### See also: \n[as_intersection_graph](#as_intersection_graph), [as_distance_graph](#as_distance_graph), \n    \t\n----\n\n\n[//]: # (keyword|operator_as_grid)\n### `as_grid`\n\n#### Possible use: \n  * `geometry` **`as_grid`** `point` --->  `matrix`\n  *  **`as_grid`** (`geometry` , `point`) --->  `matrix` \n\n#### Result: \nA matrix of square geometries (grid with 8-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)\n\n#### Examples: \n```\nmatrix var0 <- self as_grid {10, 5}; \t// var0 equals a matrix of square geometries (grid with 8-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.\n```\n      \n\n#### See also: \n[as_4_grid](#as_4_grid), [as_hexagonal_grid](#as_hexagonal_grid), \n    \t\n----\n\n\n[//]: # (keyword|operator_as_hexagonal_grid)\n### `as_hexagonal_grid`\n\n#### Possible use: \n  * `geometry` **`as_hexagonal_grid`** `point` --->  `list<geometry>`\n  *  **`as_hexagonal_grid`** (`geometry` , `point`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry\n\n#### Examples: \n```\nlist<geometry> var0 <- self as_hexagonal_grid {10, 5}; \t// var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry\n```\n      \n\n#### See also: \n[as_4_grid](#as_4_grid), [as_grid](#as_grid), \n    \t\n----\n\n\n[//]: # (keyword|operator_as_int)\n### `as_int`\n\n#### Possible use: \n  * `string` **`as_int`** `int` --->  `int`\n  *  **`as_int`** (`string` , `int`) --->  `int` \n\n#### Result: \nparses the string argument as a signed integer in the radix specified by the second argument.\n\n#### Special cases:     \n  * if the left operand is nil or empty, as_int returns 0    \n  * if the left operand does not represent an integer in the specified radix, as_int throws an exception \n\n#### Examples: \n```\nint var0 <- '20' as_int 10; \t// var0 equals 20\nint var1 <- '20' as_int 8; \t// var1 equals 16\nint var2 <- '20' as_int 16; \t// var2 equals 32\nint var3 <- '1F' as_int 16; \t// var3 equals 31\nint var4 <- 'hello' as_int 32; \t// var4 equals 18306744\n```\n      \n\n#### See also: \n[int](#int), \n    \t\n----\n\n\n[//]: # (keyword|operator_as_intersection_graph)\n### `as_intersection_graph`\n\n#### Possible use: \n  * `container` **`as_intersection_graph`** `float` --->  `graph`\n  *  **`as_intersection_graph`** (`container` , `float`) --->  `graph` \n\n#### Result: \ncreates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).  \n\n#### Comment: \nas_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.\n\n#### Examples: \n```\nlist(ant) as_intersection_graph 0.5\n```\n      \n\n#### See also: \n[as_distance_graph](#as_distance_graph), [as_edge_graph](#as_edge_graph), \n    \t\n----\n\n\n[//]: # (keyword|operator_as_map)\n### `as_map`\n\n#### Possible use: \n  * `container` **`as_map`** `any expression` --->  `map`\n  *  **`as_map`** (`container` , `any expression`) --->  `map` \n\n#### Result: \nproduces a new map from the evaluation of the right-hand operand for each element of the left-hand operand  \n\n#### Comment: \nthe right-hand operand should be a pair\n\n#### Special cases:     \n  * if the left-hand operand is nil, as_map throws an error.\n\n#### Examples: \n```\nmap<int,int> var0 <- [1,2,3,4,5,6,7,8] as_map (each::(each * 2)); \t// var0 equals [1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16]\nmap<int,int> var1 <- [1::2,3::4,5::6] as_map (each::(each * 2)); \t// var1 equals [2::4, 4::8, 6::12] \n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_as_matrix)\n### `as_matrix`\n\n#### Possible use: \n  * `unknown` **`as_matrix`** `point` --->  `matrix`\n  *  **`as_matrix`** (`unknown` , `point`) --->  `matrix` \n\n#### Result: \ncasts the left operand into a matrix with right operand as preferred size  \n\n#### Comment: \nThis operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.\n\n#### Special cases:     \n  * if the right operand is nil, as_matrix is equivalent to the matrix operator    \n\n#### See also: \n[matrix](#matrix), \n    \t\n----\n\n\n[//]: # (keyword|operator_as_path)\n### `as_path`\n\n#### Possible use: \n  * `list<geometry>` **`as_path`** `graph` --->  `path`\n  *  **`as_path`** (`list<geometry>` , `graph`) --->  `path` \n\n#### Result: \ncreate a graph path from the list of shape\n\n#### Examples: \n```\npath var0 <- [road1,road2,road3] as_path my_graph; \t// var0 equals a path road1->road2->road3 of my_graph\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_asin)\n### `asin`\n\n#### Possible use: \n  *  **`asin`** (`float`) --->  `float`\n  *  **`asin`** (`int`) --->  `float` \n\n#### Result: \nthe arcsin of the operand\n\n#### Special cases:     \n  * if the right-hand operand is outside of the [-1,1] interval, returns NaN\n\n#### Examples: \n```\nfloat var0 <- asin (0); \t// var0 equals 0.0\nfloat var1 <- asin (90); \t// var1 equals #nan\n```\n      \n\n#### See also: \n[acos](#acos), [atan](#atan), [sin](#sin), \n    \t\n----\n\n\n[//]: # (keyword|operator_at)\n### `at`\n\n#### Possible use: \n  * `string` **`at`** `int` --->  `string`\n  *  **`at`** (`string` , `int`) --->  `string`\n  * `container<KeyType,ValueType>` **`at`** `KeyType` --->  `ValueType`\n  *  **`at`** (`container<KeyType,ValueType>` , `KeyType`) --->  `ValueType` \n\n#### Result: \nthe element at the right operand index of the container  \n\n#### Comment: \nThe first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a file, at returns the element of the file content at the index specified by the right operand    \n  * if it is a population, at returns the agent at the index specified by the right operand    \n  * if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node    \n  * if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge    \n  * if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph    \n  * if it is a list or a matrix, at returns the element at the index specified by the right operand \n  \n```\nint var1 <- [1, 2, 3] at 2; \t// var1 equals 3\npoint var2 <- [{1,2}, {3,4}, {5,6}] at 0; \t// var2 equals {1.0,2.0}\n\n``` \n\n\n\n#### Examples: \n```\nstring var0 <- 'abcdef' at 0; \t// var0 equals 'a'\n```\n      \n\n#### See also: \n[contains_all](#contains_all), [contains_any](#contains_any), \n    \t\n----\n\n\n[//]: # (keyword|operator_at_distance)\n### `at_distance`\n\n#### Possible use: \n  * `container<agent>` **`at_distance`** `float` --->  `list<geometry>`\n  *  **`at_distance`** (`container<agent>` , `float`) --->  `list<geometry>` \n\n#### Result: \nA list of agents or geometries among the left-operand list that are located at a distance <= the right operand from the caller agent (in its topology)\n\n#### Examples: \n```\nlist<geometry> var0 <- [ag1, ag2, ag3] at_distance 20; \t// var0 equals the agents of the list located at a distance <= 20 from the caller agent (in the same order).\n```\n      \n\n#### See also: \n[neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [agent_closest_to](#agent_closest_to), [agents_inside](#agents_inside), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), \n    \t\n----\n\n\n[//]: # (keyword|operator_at_location)\n### `at_location`\n\n#### Possible use: \n  * `geometry` **`at_location`** `point` --->  `geometry`\n  *  **`at_location`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)\n\n#### Examples: \n```\ngeometry var0 <- self at_location {10, 20}; \t// var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent).\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_atan)\n### `atan`\n\n#### Possible use: \n  *  **`atan`** (`float`) --->  `float`\n  *  **`atan`** (`int`) --->  `float` \n\n#### Result: \nReturns the value (in the interval [-90,90], in decimal degrees) of the arctan of the operand (which can be any real number).\n\n#### Examples: \n```\nfloat var0 <- atan (1); \t// var0 equals 45.0\n```\n      \n\n#### See also: \n[acos](#acos), [asin](#asin), [tan](#tan), \n    \t\n----\n\n\n[//]: # (keyword|operator_atan2)\n### `atan2`\n\n#### Possible use: \n  * `float` **`atan2`** `float` --->  `float`\n  *  **`atan2`** (`float` , `float`) --->  `float` \n\n#### Result: \nthe atan2 value of the two operands.  \n\n#### Comment: \nThe function atan2 is the arctangent function with two arguments. The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument arctangent function.\n\n#### Examples: \n```\nfloat var0 <- atan2 (0,0); \t// var0 equals 0.0\n```\n      \n\n#### See also: \n[atan](#atan), [acos](#acos), [asin](#asin), \n    \t\n----\n\n\n[//]: # (keyword|operator_attributes)\n### `attributes`\n\n#### Possible use: \n  *  **`attributes`** (`any`) --->  `attributes` \n\n#### Result: \nCasts the operand into the type attributes\n    \t\n----\n\n\n[//]: # (keyword|operator_BDIPlan)\n### `BDIPlan`\n\n#### Possible use: \n  *  **`BDIPlan`** (`any`) --->  `BDIPlan` \n\n#### Result: \nCasts the operand into the type BDIPlan\n    \t\n----\n\n\n[//]: # (keyword|operator_before)\n### `before`\n\n#### Possible use: \n  *  **`before`** (`date`) --->  `bool`\n  * `any expression` **`before`** `date` --->  `bool`\n  *  **`before`** (`any expression` , `date`) --->  `bool` \n\n#### Result: \nReturns true if the current_date of the model is strictly before the date passed in argument. Synonym of 'current_date < argument'\n\n#### Examples: \n```\nreflex when: before(starting_date) {} -: will never be run\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_beta_index)\n### `beta_index`\n\n#### Possible use: \n  *  **`beta_index`** (`graph`) --->  `float` \n\n#### Result: \nreturns the beta index of the graph (Measures the level of connectivity in a graph and is expressed by the relationship between the number of links (e) over the number of nodes (v) : beta = e/v.\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nfloat var1 <- beta_index(graphEpidemio); \t// var1 equals the beta index of the graph\n```\n      \n\n#### See also: \n[alpha_index](#alpha_index), [gamma_index](#gamma_index), [nb_cycles](#nb_cycles), [connectivity_index](#connectivity_index), \n    \t\n----\n\n\n[//]: # (keyword|operator_between)\n### `between`\n\n#### Possible use: \n  * `date` **`between`** `date` --->  `bool`\n  *  **`between`** (`date` , `date`) --->  `bool`\n  *  **`between`** (`int`, `int`, `int`) --->  `bool`\n  *  **`between`** (`any expression`, `date`, `date`) --->  `bool`\n  *  **`between`** (`float`, `float`, `float`) --->  `bool`\n  *  **`between`** (`date`, `date`, `date`) --->  `bool` \n\n#### Result: \nreturns true the first integer operand is bigger than the second integer operand and smaller than the third integer operand\nreturns true if the first float operand is bigger than the second float operand and smaller than the third float operand\n\n#### Special cases:     \n  * returns true if the first operand is between the two dates passed in arguments (both exclusive). Can be combined with 'every' to express a frequency between two dates \n  \n```\n(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: true\nevery #day between(date('2000-01-01'), date('2020-02-02') // will return true every new day between these two dates, taking the first one as the starting point\n\n``` \n\n    \n  * returns true if the first operand is between the two dates passed in arguments (both exclusive). The version with 2 arguments compares the current_date with the 2 others \n  \n```\n(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: true\nbetween(date('2000-01-01'), date('2020-02-02') // will return true if the current_date of the model is in_between the 2\n\n``` \n\n\n\n#### Examples: \n```\nbool var0 <- between(5, 1, 10); \t// var0 equals true\nbool var1 <- between(5.0, 1.0, 10.0); \t// var1 equals true\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_betweenness_centrality)\n### `betweenness_centrality`\n\n#### Possible use: \n  *  **`betweenness_centrality`** (`graph`) --->  `map` \n\n#### Result: \nreturns a map containing for each vertex (key), its betweenness centrality (value): number of shortest paths passing through each vertex\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nmap var1 <- betweenness_centrality(graphEpidemio); \t// var1 equals the betweenness centrality index of the graph\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_biggest_cliques_of)\n### `biggest_cliques_of`\n\n#### Possible use: \n  *  **`biggest_cliques_of`** (`graph`) --->  `list<list>` \n\n#### Result: \nreturns the biggest cliques of a graph using the Bron-Kerbosch clique detection algorithm\n\n#### Examples: \n```\ngraph my_graph <- graph([]);\nlist<list> var1 <- biggest_cliques_of (my_graph); \t// var1 equals the list of the biggest cliques as list\n```\n      \n\n#### See also: \n[maximal_cliques_of](#maximal_cliques_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_binomial)\n### `binomial`\n\n#### Possible use: \n  * `int` **`binomial`** `float` --->  `int`\n  *  **`binomial`** (`int` , `float`) --->  `int` \n\n#### Result: \nA value from a random variable following a binomial distribution. The operands represent the number of experiments n and the success probability p.  \n\n#### Comment: \nThe binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.\n\n#### Examples: \n```\nint var0 <- binomial(15,0.6); \t// var0 equals a random positive integer\n```\n      \n\n#### See also: \n[poisson](#poisson), [gauss](#gauss), \n    \t\n----\n\n\n[//]: # (keyword|operator_blend)\n### `blend`\n\n#### Possible use: \n  * `rgb` **`blend`** `rgb` --->  `rgb`\n  *  **`blend`** (`rgb` , `rgb`) --->  `rgb`\n  *  **`blend`** (`rgb`, `rgb`, `float`) --->  `rgb` \n\n#### Result: \nBlend two colors with an optional ratio (c1 `*` r + c2 `*` (1 - r)) between 0 and 1\n\n#### Special cases:     \n  * If the ratio is omitted, an even blend is done \n  \n```\nrgb var3 <- blend(#red, #blue); \t// var3 equals to a color very close to the purple\n\n``` \n\n\n\n#### Examples: \n```\nrgb var1 <- blend(#red, #blue, 0.3); \t// var1 equals to a color between the purple and the blue\n```\n      \n\n#### See also: \n[rgb](#rgb), [hsb](#hsb), \n    \t\n----\n\n\n[//]: # (keyword|operator_bool)\n### `bool`\n\n#### Possible use: \n  *  **`bool`** (`any`) --->  `bool` \n\n#### Result: \nCasts the operand into the type bool\n    \t\n----\n\n\n[//]: # (keyword|operator_box)\n### `box`\n\n#### Possible use: \n  *  **`box`** (`point`) --->  `geometry`\n  *  **`box`** (`float`, `float`, `float`) --->  `geometry` \n\n#### Result: \nA box geometry which side sizes are given by the operands.  \n\n#### Comment: \nthe center of the box is by default the location of the current agent in which has been called this operator.the center of the box is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- box(10, 5 , 5); \t// var0 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.\ngeometry var1 <- box({10, 5 , 5}); \t// var1 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [sphere](#sphere), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [square](#square), [cube](#cube), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_brewer_colors)\n### `brewer_colors`\n\n#### Possible use: \n  *  **`brewer_colors`** (`string`) --->  `list<rgb>`\n  * `string` **`brewer_colors`** `int` --->  `list<rgb>`\n  *  **`brewer_colors`** (`string` , `int`) --->  `list<rgb>` \n\n#### Result: \nBuild a list of colors of a given type (see website http://colorbrewer2.org/)\nBuild a list of colors of a given type (see website http://colorbrewer2.org/) with a given number of classes\n\n#### Examples: \n```\nlist<rgb> var0 <- list<rgb> colors <- brewer_colors(\"OrRd\");; \t// var0 equals a list of 6 blue colors\nlist<rgb> var1 <- list<rgb> colors <- brewer_colors(\"Pastel1\", 10);; \t// var1 equals a list of 10 sequential colors\n```\n      \n\n#### See also: \n[brewer_palettes](#brewer_palettes), \n    \t\n----\n\n\n[//]: # (keyword|operator_brewer_palettes)\n### `brewer_palettes`\n\n#### Possible use: \n  *  **`brewer_palettes`** (`int`) --->  `list<string>`\n  * `int` **`brewer_palettes`** `int` --->  `list<string>`\n  *  **`brewer_palettes`** (`int` , `int`) --->  `list<string>` \n\n#### Result: \nreturns the list a palette with a given min number of classes and max number of classes)\nreturns the list a palette with a given min number of classes and max number of classes)\n\n#### Examples: \n```\nlist<string> var0 <- list<rgb> colors <- brewer_palettes(5,10);; \t// var0 equals a list of palettes that are composed of a min of 5 colors and a max of 10 colors\nlist<string> var1 <- list<rgb> colors <- brewer_palettes();; \t// var1 equals a list of palettes that are composed of a min of 5 colors\n```\n      \n\n#### See also: \n[brewer_colors](#brewer_colors), \n    \t\n----\n\n\n[//]: # (keyword|operator_buffer)\n### `buffer`\nSame signification as [+](#+)\n    \t\n----\n\n\n[//]: # (keyword|operator_build)\n### `build`\n\n#### Possible use: \n  *  **`build`** (`matrix<float>`) --->  `regression`\n  * `matrix<float>` **`build`** `string` --->  `regression`\n  *  **`build`** (`matrix<float>` , `string`) --->  `regression` \n\n#### Result: \nreturns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given ordinary least squares method. Usage: build(data)\nreturns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given method (\"GLS\" or \"OLS\"). Usage: build(data,method)\n\n#### Examples: \n```\nmatrix([[1,2,3,4],[2,3,4,2]])\nbuild(matrix([[1,2,3,4],[2,3,4,2]]),\"GLS\")\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_ceil)\n### `ceil`\n\n#### Possible use: \n  *  **`ceil`** (`float`) --->  `float` \n\n#### Result: \nMaps the operand to the smallest following integer, i.e. the smallest integer not less than x.\n\n#### Examples: \n```\nfloat var0 <- ceil(3); \t// var0 equals 3.0\nfloat var1 <- ceil(3.5); \t// var1 equals 4.0\nfloat var2 <- ceil(-4.7); \t// var2 equals -4.0\n```\n      \n\n#### See also: \n[floor](#floor), [round](#round), \n    \t\n----\n\n\n[//]: # (keyword|operator_centroid)\n### `centroid`\n\n#### Possible use: \n  *  **`centroid`** (`geometry`) --->  `point` \n\n#### Result: \nCentroid (weighted sum of the centroids of a decomposition of the area into triangles) of the operand-geometry. Can be different to the location of the geometry\n\n#### Examples: \n```\npoint var0 <- centroid(world); \t// var0 equals the centroid of the square, for example : {50.0,50.0}.\n```\n      \n\n#### See also: \n[any_location_in](#any_location_in), [closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), [points_at](#points_at), \n    \t\n----\n\n\n[//]: # (keyword|operator_char)\n### `char`\n\n#### Possible use: \n  *  **`char`** (`int`) --->  `string`\n\n#### Special cases:     \n  * converts ACSII integer value to character \n  \n```\nstring var0 <- char (34); \t// var0 equals '\"'\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_circle)\n### `circle`\n\n#### Possible use: \n  *  **`circle`** (`float`) --->  `geometry`\n  * `float` **`circle`** `point` --->  `geometry`\n  *  **`circle`** (`float` , `point`) --->  `geometry` \n\n#### Result: \nA circle geometry which radius is equal to the first operand, and the center has the location equal to the second operand.\nA circle geometry which radius is equal to the operand.  \n\n#### Comment: \nthe center of the circle is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.    \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- circle(10,{80,30}); \t// var0 equals a geometry as a circle of radius 10, the center will be in the location {80,30}.\ngeometry var1 <- circle(10); \t// var1 equals a geometry as a circle of radius 10.\n```\n      \n\n#### See also: \n[around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_clean)\n### `clean`\n\n#### Possible use: \n  *  **`clean`** (`geometry`) --->  `geometry` \n\n#### Result: \nA geometry corresponding to the cleaning of the operand (geometry, agent, point)  \n\n#### Comment: \nThe cleaning corresponds to a buffer with a distance of 0.0\n\n#### Examples: \n```\ngeometry var0 <- clean(self); \t// var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_closest_points_with)\n### `closest_points_with`\n\n#### Possible use: \n  * `geometry` **`closest_points_with`** `geometry` --->  `list<point>`\n  *  **`closest_points_with`** (`geometry` , `geometry`) --->  `list<point>` \n\n#### Result: \nA list of two closest points between the two geometries.\n\n#### Examples: \n```\nlist<point> var0 <- geom1 closest_points_with(geom2); \t// var0 equals [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1\n```\n      \n\n#### See also: \n[any_location_in](#any_location_in), [any_point_in](#any_point_in), [farthest_point_to](#farthest_point_to), [points_at](#points_at), \n    \t\n----\n\n\n[//]: # (keyword|operator_closest_to)\n### `closest_to`\n\n#### Possible use: \n  * `container<agent>` **`closest_to`** `geometry` --->  `geometry`\n  *  **`closest_to`** (`container<agent>` , `geometry`) --->  `geometry` \n\n#### Result: \nAn agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the closest to the operand (casted as a geometry).  \n\n#### Comment: \nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\n\n#### Examples: \n```\ngeometry var0 <- [ag1, ag2, ag3] closest_to(self); \t// var0 equals return the closest agent among ag1, ag2 and ag3 to the agent applying the operator.\n(species1 + species2) closest_to self\n```\n      \n\n#### See also: \n[neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [inside](#inside), [overlapping](#overlapping), [agents_overlapping](#agents_overlapping), [agents_inside](#agents_inside), [agent_closest_to](#agent_closest_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_collect)\n### `collect`\n\n#### Possible use: \n  * `container` **`collect`** `any expression` --->  `container`\n  *  **`collect`** (`container` , `any expression`) --->  `container` \n\n#### Result: \nreturns a new list, in which each element is the evaluation of the right-hand operand.  \n\n#### Comment: \ncollect is similar to accumulate except that accumulate always produces flat lists if the right-hand operand returns a list.In addition, collect can be applied to any container.\n\n#### Special cases:     \n  * if the left-hand operand is nil, collect throws an error\n\n#### Examples: \n```\ncontainer var0 <- [1,2,4] collect (each *2); \t// var0 equals [2,4,8]\ncontainer var1 <- [1,2,4] collect ([2,4]); \t// var1 equals [[2,4],[2,4],[2,4]]\ncontainer var2 <- [1::2, 3::4, 5::6] collect (each + 2); \t// var2 equals [4,6,8]\ncontainer var3 <- (list(node) collect (node(each).location.x * 2); \t// var3 equals the list of nodes with their x multiplied by 2\n```\n      \n\n#### See also: \n[accumulate](#accumulate), \n    \t\n----\n\n\n[//]: # (keyword|operator_column_at)\n### `column_at`\n\n#### Possible use: \n  * `matrix` **`column_at`** `int` --->  `list`\n  *  **`column_at`** (`matrix` , `int`) --->  `list` \n\n#### Result: \nreturns the column at a num_col (right-hand operand)\n\n#### Examples: \n```\nlist var0 <- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) column_at 2; \t// var0 equals [\"el31\",\"el32\",\"el33\"]\n```\n      \n\n#### See also: \n[row_at](#row_at), [rows_list](#rows_list), \n    \t\n----\n\n\n[//]: # (keyword|operator_columns_list)\n### `columns_list`\n\n#### Possible use: \n  *  **`columns_list`** (`matrix`) --->  `list<list>` \n\n#### Result: \nreturns a list of the columns of the matrix, with each column as a list of elements\n\n#### Examples: \n```\nlist<list> var0 <- columns_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); \t// var0 equals [[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]\n```\n      \n\n#### See also: \n[rows_list](#rows_list), \n    \t\n----\n\n\n[//]: # (keyword|operator_command)\n### `command`\n\n#### Possible use: \n  *  **`command`** (`string`) --->  `string` \n\n#### Result: \ncommand allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence ' &' is used at the end. In this case, the result of the operator is an empty string\n    \t\n----\n\n\n[//]: # (keyword|operator_cone)\n### `cone`\n\n#### Possible use: \n  *  **`cone`** (`point`) --->  `geometry`\n  * `int` **`cone`** `int` --->  `geometry`\n  *  **`cone`** (`int` , `int`) --->  `geometry` \n\n#### Result: \nA cone geometry which min and max angles are given by the operands.\nA cone geometry which min and max angles are given by the operands.  \n\n#### Comment: \nthe center of the cone is by default the location of the current agent in which has been called this operator.the center of the cone is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- cone({0, 45}); \t// var0 equals a geometry as a cone with min angle is 0 and max angle is 45.\ngeometry var1 <- cone(0, 45); \t// var1 equals a geometry as a cone with min angle is 0 and max angle is 45.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_cone3D)\n### `cone3D`\n\n#### Possible use: \n  * `float` **`cone3D`** `float` --->  `geometry`\n  *  **`cone3D`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nA cone geometry which base radius size is equal to the first operand, and which the height is equal to the second operand.  \n\n#### Comment: \nthe center of the cone is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- cone3D(10.0,5.0); \t// var0 equals a geometry as a cone with a base circle of radius 10 and a height of 5.\n```\n      \n\n#### See also: \n[around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_connected_components_of)\n### `connected_components_of`\n\n#### Possible use: \n  *  **`connected_components_of`** (`graph`) --->  `list<list>` \n\n#### Result: \nreturns the connected components of of a graph, i.e. the list of all vertices that are in the maximally connected component together with the specified vertex.\n\n#### Examples: \n```\ngraph my_graph <- graph([]);\nlist<list> var1 <- connected_components_of (my_graph); \t// var1 equals the list of all the components as list\n```\n      \n\n#### See also: \n[alpha_index](#alpha_index), [connectivity_index](#connectivity_index), [nb_cycles](#nb_cycles), \n    \t\n----\n\n\n[//]: # (keyword|operator_connectivity_index)\n### `connectivity_index`\n\n#### Possible use: \n  *  **`connectivity_index`** (`graph`) --->  `float` \n\n#### Result: \nreturns a simple connectivity index. This number is estimated through the number of nodes (v) and of sub-graphs (p) : IC = (v - p) /(v - 1).\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nfloat var1 <- connectivity_index(graphEpidemio); \t// var1 equals the connectivity index of the graph\n```\n      \n\n#### See also: \n[alpha_index](#alpha_index), [beta_index](#beta_index), [gamma_index](#gamma_index), [nb_cycles](#nb_cycles), \n    \t\n----\n\n\n[//]: # (keyword|operator_container)\n### `container`\n\n#### Possible use: \n  *  **`container`** (`any`) --->  `container` \n\n#### Result: \nCasts the operand into the type container\n    \t\n----\n\n\n[//]: # (keyword|operator_contains)\n### `contains`\n\n#### Possible use: \n  * `container<KeyType,ValueType>` **`contains`** `unknown` --->  `bool`\n  *  **`contains`** (`container<KeyType,ValueType>` , `unknown`) --->  `bool`\n  * `string` **`contains`** `string` --->  `bool`\n  *  **`contains`** (`string` , `string`) --->  `bool` \n\n#### Result: \ntrue, if the container contains the right operand, false otherwise  \n\n#### Comment: \nthe contains operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a map, contains returns true if the operand is a key of the map    \n  * if it is a file, contains returns true it the operand is contained in the file content    \n  * if it is a population, contains returns true if the operand is an agent of the population, false otherwise    \n  * if it is a graph, contains returns true if the operand is a node or an edge of the graph, false otherwise    \n  * if both operands are strings, returns true if the right-hand operand contains the right-hand pattern;    \n  * if it is a list or a matrix, contains returns true if the list or matrix contains the right operand \n  \n```\nbool var0 <- [1, 2, 3] contains 2; \t// var0 equals true\nbool var1 <- [{1,2}, {3,4}, {5,6}] contains {3,4}; \t// var1 equals true\n\n``` \n\n\n\n#### Examples: \n```\nbool var2 <- 'abcded' contains 'bc'; \t// var2 equals true\n```\n      \n\n#### See also: \n[contains_all](#contains_all), [contains_any](#contains_any), \n    \t\n----\n\n\n[//]: # (keyword|operator_contains_all)\n### `contains_all`\n\n#### Possible use: \n  * `container` **`contains_all`** `container` --->  `bool`\n  *  **`contains_all`** (`container` , `container`) --->  `bool`\n  * `string` **`contains_all`** `list` --->  `bool`\n  *  **`contains_all`** (`string` , `list`) --->  `bool` \n\n#### Result: \ntrue if the left operand contains all the elements of the right operand, false otherwise  \n\n#### Comment: \nthe definition of contains depends on the container\n\n#### Special cases:     \n  * if the right operand is nil or empty, contains_all returns true    \n  * if the left-operand is a string, test whether the string contains all the element of the list; \n  \n```\nbool var4 <- \"abcabcabc\" contains_all [\"ca\",\"xy\"]; \t// var4 equals false\n\n``` \n\n\n\n#### Examples: \n```\nbool var0 <- [1,2,3,4,5,6] contains_all [2,4]; \t// var0 equals true \nbool var1 <- [1,2,3,4,5,6] contains_all [2,8]; \t// var1 equals false\nbool var2 <- [1::2, 3::4, 5::6] contains_all [1,3]; \t// var2 equals false \nbool var3 <- [1::2, 3::4, 5::6] contains_all [2,4]; \t// var3 equals true\n```\n      \n\n#### See also: \n[contains](#contains), [contains_any](#contains_any), \n    \t\n----\n\n\n[//]: # (keyword|operator_contains_any)\n### `contains_any`\n\n#### Possible use: \n  * `container` **`contains_any`** `container` --->  `bool`\n  *  **`contains_any`** (`container` , `container`) --->  `bool`\n  * `string` **`contains_any`** `list` --->  `bool`\n  *  **`contains_any`** (`string` , `list`) --->  `bool` \n\n#### Result: \ntrue if the left operand contains one of the elements of the right operand, false otherwise  \n\n#### Comment: \nthe definition of contains depends on the container\n\n#### Special cases:     \n  * if the right operand is nil or empty, contains_any returns false\n\n#### Examples: \n```\nbool var0 <- [1,2,3,4,5,6] contains_any [2,4]; \t// var0 equals true \nbool var1 <- [1,2,3,4,5,6] contains_any [2,8]; \t// var1 equals true\nbool var2 <- [1::2, 3::4, 5::6] contains_any [1,3]; \t// var2 equals false\nbool var3 <- [1::2, 3::4, 5::6] contains_any [2,4]; \t// var3 equals true\nbool var4 <- \"abcabcabc\" contains_any [\"ca\",\"xy\"]; \t// var4 equals true\n```\n      \n\n#### See also: \n[contains](#contains), [contains_all](#contains_all), \n    \t\n----\n\n\n[//]: # (keyword|operator_contains_edge)\n### `contains_edge`\n\n#### Possible use: \n  * `graph` **`contains_edge`** `unknown` --->  `bool`\n  *  **`contains_edge`** (`graph` , `unknown`) --->  `bool`\n  * `graph` **`contains_edge`** `pair` --->  `bool`\n  *  **`contains_edge`** (`graph` , `pair`) --->  `bool` \n\n#### Result: \nreturns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwise\n\n#### Special cases:     \n  * if the left-hand operand is nil, returns false    \n  * if the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graph \n  \n```\nbool var2 <- graphEpidemio contains_edge (node(0)::node(3)); \t// var2 equals true\n\n``` \n\n\n\n#### Examples: \n```\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nbool var1 <- graphFromMap contains_edge link({1,5}::{12,45}); \t// var1 equals true\n```\n      \n\n#### See also: \n[contains_vertex](#contains_vertex), \n    \t\n----\n\n\n[//]: # (keyword|operator_contains_vertex)\n### `contains_vertex`\n\n#### Possible use: \n  * `graph` **`contains_vertex`** `unknown` --->  `bool`\n  *  **`contains_vertex`** (`graph` , `unknown`) --->  `bool` \n\n#### Result: \nreturns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwise\n\n#### Special cases:     \n  * if the left-hand operand is nil, returns false\n\n#### Examples: \n```\ngraph graphFromMap<-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nbool var1 <- graphFromMap contains_vertex {1,5}; \t// var1 equals true\n```\n      \n\n#### See also: \n[contains_edge](#contains_edge), \n    \t\n----\n\n\n[//]: # (keyword|operator_conversation)\n### `conversation`\n\n#### Possible use: \n  *  **`conversation`** (`unknown`) --->  `conversation`\n    \t\n----\n\n\n[//]: # (keyword|operator_convex_hull)\n### `convex_hull`\n\n#### Possible use: \n  *  **`convex_hull`** (`geometry`) --->  `geometry` \n\n#### Result: \nA geometry corresponding to the convex hull of the operand.\n\n#### Examples: \n```\ngeometry var0 <- convex_hull(self); \t// var0 equals the convex hull of the geometry of the agent applying the operator\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_copy)\n### `copy`\n\n#### Possible use: \n  *  **`copy`** (`unknown`) --->  `unknown` \n\n#### Result: \nreturns a copy of the operand.\n    \t\n----\n\n\n[//]: # (keyword|operator_copy_between)\n### `copy_between`\n\n#### Possible use: \n  *  **`copy_between`** (`string`, `int`, `int`) --->  `string`\n  *  **`copy_between`** (`container`, `int`, `int`) --->  `container` \n\n#### Result: \nReturns a copy of the first operand between the indexes determined by the second (inclusive) and third operands (exclusive)\n\n#### Special cases:     \n  * If the first operand is empty, returns an empty object of the same type    \n  * If the second operand is greater than or equal to the third operand, return an empty object of the same type    \n  * If the first operand is nil, raises an error\n\n#### Examples: \n```\nstring var0 <- copy_between(\"abcabcabc\", 2,6); \t// var0 equals \"cabc\"\ncontainer var1 <-  copy_between ([4, 1, 6, 9 ,7], 1, 3); \t// var1 equals [1, 6]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_corR)\n### `corR`\n\n#### Possible use: \n  * `container` **`corR`** `container` --->  `unknown`\n  *  **`corR`** (`container` , `container`) --->  `unknown` \n\n#### Result: \nreturns the Pearson correlation coefficient of two given vectors (right-hand operands) in given variable  (left-hand operand).\n\n#### Special cases:     \n  * if the lengths of two vectors in the right-hand aren't equal, returns 0\n\n#### Examples: \n```\nlist X <- [1, 2, 3];\nlist Y <- [1, 2, 4];\nunknown var2 <- corR(X, Y); \t// var2 equals 0.981980506061966\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_cos)\n### `cos`\n\n#### Possible use: \n  *  **`cos`** (`int`) --->  `float`\n  *  **`cos`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized.\n\n#### Examples: \n```\nfloat var0 <- cos (0); \t// var0 equals 1.0\nfloat var1 <- cos(360); \t// var1 equals 1.0\nfloat var2 <- cos(-720); \t// var2 equals 1.0\n```\n      \n\n#### See also: \n[sin](#sin), [tan](#tan), \n    \t\n----\n\n\n[//]: # (keyword|operator_cos_rad)\n### `cos_rad`\n\n#### Possible use: \n  *  **`cos_rad`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized.    \n\n#### See also: \n[sin](#sin), [tan](#tan), \n    \t\n----\n\n\n[//]: # (keyword|operator_count)\n### `count`\n\n#### Possible use: \n  * `container` **`count`** `any expression` --->  `int`\n  *  **`count`** (`container` , `any expression`) --->  `int` \n\n#### Result: \nreturns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, count throws an error\n\n#### Examples: \n```\nint var0 <- [1,2,3,4,5,6,7,8] count (each > 3); \t// var0 equals 5\n// Number of nodes of graph g2 without any out edge\ngraph g2 <- graph([]);\nint var3 <- g2 count (length(g2 out_edges_of each) = 0  ) ; \t// var3 equals the total number of out edges\n// Number of agents node with x > 32\nint n <- (list(node) count (round(node(each).location.x) > 32);\nint var6 <- [1::2, 3::4, 5::6] count (each > 4); \t// var6 equals 1\n```\n      \n\n#### See also: \n[group_by](#group_by), \n    \t\n----\n\n\n[//]: # (keyword|operator_covers)\n### `covers`\n\n#### Possible use: \n  * `geometry` **`covers`** `geometry` --->  `bool`\n  *  **`covers`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) covers the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.\n\n#### Examples: \n```\nbool var0 <- square(5) covers square(2); \t// var0 equals true\n```\n      \n\n#### See also: \n[disjoint_from](#disjoint_from), [crosses](#crosses), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [touches](#touches), \n    \t\n----\n\n\n[//]: # (keyword|operator_cross)\n### `cross`\n\n#### Possible use: \n  *  **`cross`** (`float`) --->  `geometry`\n  * `float` **`cross`** `float` --->  `geometry`\n  *  **`cross`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nA cross, which radius is equal to the first operand\nA cross, which radius is equal to the first operand and the width of the lines for the second\n\n#### Examples: \n```\ngeometry var0 <- cross(10); \t// var0 equals a geometry as a cross of radius 10\ngeometry var1 <- cross(10,2); \t// var1 equals a geometry as a cross of radius 10, and with a width of 2 for the lines \n```\n      \n\n#### See also: \n[around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [super_ellipse](#super_ellipse), [rectangle](#rectangle), [square](#square), [circle](#circle), [ellipse](#ellipse), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_crosses)\n### `crosses`\n\n#### Possible use: \n  * `geometry` **`crosses`** `geometry` --->  `bool`\n  *  **`crosses`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.    \n  * if one operand is a point, returns false.\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]); \t// var0 equals true\nbool var1 <- polyline([{10,10},{20,20}]) crosses {15,15}; \t// var1 equals true\nbool var2 <- polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]); \t// var2 equals true\n```\n      \n\n#### See also: \n[disjoint_from](#disjoint_from), [intersects](#intersects), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [touches](#touches), \n    \t\n----\n\n\n[//]: # (keyword|operator_crs)\n### `crs`\n\n#### Possible use: \n  *  **`crs`** (`file`) --->  `string` \n\n#### Result: \nthe Coordinate Reference System (CRS) of the GIS file\n\n#### Examples: \n```\nstring var0 <- crs(my_shapefile); \t// var0 equals the crs of the shapefile\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_CRS_transform)\n### `CRS_transform`\n\n#### Possible use: \n  *  **`CRS_transform`** (`geometry`) --->  `geometry`\n  * `geometry` **`CRS_transform`** `string` --->  `geometry`\n  *  **`CRS_transform`** (`geometry` , `string`) --->  `geometry`\n\n#### Special cases:     \n  * returns the geometry corresponding to the transformation of the given geometry by the left operand CRS (Coordinate Reference System) \n  \n```\ngeometry var0 <- shape CRS_transform(\"EPSG:4326\"); \t// var0 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS\n\n``` \n\n    \n  * returns the geometry corresponding to the transformation of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world's agent one \n  \n```\ngeometry var1 <- CRS_transform(shape); \t// var1 equals a geometry corresponding to the agent geometry transformed into the current CRS\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_csv_file)\n### `csv_file`\n\n#### Possible use: \n  *  **`csv_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type csv. Allowed extensions are limited to csv, tsv\n    \t\n----\n\n\n[//]: # (keyword|operator_cube)\n### `cube`\n\n#### Possible use: \n  *  **`cube`** (`float`) --->  `geometry` \n\n#### Result: \nA cube geometry which side size is equal to the operand.  \n\n#### Comment: \nthe center of the cube is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- cube(10); \t// var0 equals a geometry as a square of side size 10.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_curve)\n### `curve`\n\n#### Possible use: \n  *  **`curve`** (`point`, `point`, `point`) --->  `geometry`\n  *  **`curve`** (`point`, `point`, `point`, `int`) --->  `geometry`\n  *  **`curve`** (`point`, `point`, `point`, `point`) --->  `geometry`\n  *  **`curve`** (`point`, `point`, `point`, `point`, `int`) --->  `geometry` \n\n#### Result: \nA quadratic Bezier curve geometry built from the three given points composed of a given numnber of points.\nA quadratic Bezier curve geometry built from the three given points composed of 10 points.\nA cubic Bezier curve geometry built from the four given points composed of a given number of points.\nA cubic Bezier curve geometry built from the four given points composed of 10 points.\n\n#### Special cases:     \n  * if the operand is nil, returns nil    \n  * if the last operand (number of points) is inferior to 2, returns nil    \n  * if the operand is nil, returns nil    \n  * if the operand is nil, returns nil    \n  * if the last operand (number of points) is inferior to 2, returns nil    \n  * if the operand is nil, returns nil\n\n#### Examples: \n```\ngeometry var0 <- curve({0,0}, {0,10}, {10,10}, 20); \t// var0 equals a quadratic Bezier curve geometry composed of 20 points from p0 to p2.\ngeometry var1 <- curve({0,0}, {0,10}, {10,10}); \t// var1 equals a quadratic Bezier curve geometry composed of 10 points from p0 to p2.\ngeometry var2 <- curve({0,0}, {0,10}, {10,10}); \t// var2 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.\ngeometry var3 <- curve({0,0}, {0,10}, {10,10}); \t// var3 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [link](#link), [norm](#norm), [point](#point), [polygone](#polygone), [rectangle](#rectangle), [square](#square), [triangle](#triangle), [line](#line), \n    \t\n----\n\n\n[//]: # (keyword|operator_cylinder)\n### `cylinder`\n\n#### Possible use: \n  * `float` **`cylinder`** `float` --->  `geometry`\n  *  **`cylinder`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nA cylinder geometry which radius is equal to the operand.  \n\n#### Comment: \nthe center of the cylinder is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- cylinder(10,10); \t// var0 equals a geometry as a circle of radius 10.\n```\n      \n\n#### See also: \n[around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_date)\n### `date`\n\n#### Possible use: \n  * `string` **`date`** `string` --->  `date`\n  *  **`date`** (`string` , `string`) --->  `date` \n\n#### Result: \nconverts a string to a date following a custom pattern. The pattern can use \"%Y %M %N %D %E %h %m %s %z\" for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will parse the date using one of the ISO date & time formats (similar to date('...') in that case). The pattern can also follow the pattern definition found here, which gives much more control over what will be parsed: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constant: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences\n\n#### Examples: \n```\ndate(\"1999-12-30\", 'yyyy-MM-dd')\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_dbscan)\n### `dbscan`\n\n#### Possible use: \n  *  **`dbscan`** (`list`, `float`, `int`) --->  `list<list>` \n\n#### Result: \nreturns the list of clusters (list of instance indices) computed with the dbscan (density-based spatial clustering of applications with noise) algorithm from the first operand data according to the maximum radius of the neighborhood to be considered (eps) and the minimum number of points needed for a cluster (minPts). Usage: dbscan(data,eps,minPoints)\n\n#### Special cases:     \n  * if the lengths of two vectors in the right-hand aren't equal, returns 0\n\n#### Examples: \n```\ndbscan ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],10,2)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_dead)\n### `dead`\n\n#### Possible use: \n  *  **`dead`** (`agent`) --->  `bool` \n\n#### Result: \ntrue if the agent is dead (or null), false otherwise.\n\n#### Examples: \n```\nbool var0 <- dead(agent_A); \t// var0 equals true or false\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_degree_of)\n### `degree_of`\n\n#### Possible use: \n  * `graph` **`degree_of`** `unknown` --->  `int`\n  *  **`degree_of`** (`graph` , `unknown`) --->  `int` \n\n#### Result: \nreturns the degree (in+out) of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\nint var1 <- graphFromMap degree_of (node(3)); \t// var1 equals 3\n```\n      \n\n#### See also: \n[in_degree_of](#in_degree_of), [out_degree_of](#out_degree_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_dem)\n### `dem`\n\n#### Possible use: \n  *  **`dem`** (`file`) --->  `geometry`\n  * `file` **`dem`** `file` --->  `geometry`\n  *  **`dem`** (`file` , `file`) --->  `geometry`\n  * `file` **`dem`** `float` --->  `geometry`\n  *  **`dem`** (`file` , `float`) --->  `geometry`\n  *  **`dem`** (`file`, `file`, `float`) --->  `geometry` \n\n#### Result: \nA polygon that is equivalent to the surface of the texture\n\n#### Examples: \n```\ngeometry var0 <- dem(dem,texture,z_factor); \t// var0 equals a geometry as a rectangle of width and height equal to the texture.\ngeometry var1 <- dem(dem,texture); \t// var1 equals a geometry as a rectangle of weight and height equal to the texture.\ngeometry var2 <- dem(dem,z_factor); \t// var2 equals a geometry as a rectangle of weight and height equal to the texture.\ngeometry var3 <- dem(dem); \t// var3 equals returns a geometry as a rectangle of width and height equal to the texture.\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_det)\n### `det`\nSame signification as [determinant](#determinant)\n    \t\n----\n\n\n[//]: # (keyword|operator_determinant)\n### `determinant`\n\n#### Possible use: \n  *  **`determinant`** (`matrix`) --->  `float` \n\n#### Result: \nThe determinant of the given matrix\n\n#### Examples: \n```\nfloat var0 <- determinant(matrix([[1,2],[3,4]])); \t// var0 equals -2\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_diff)\n### `diff`\n\n#### Possible use: \n  * `float` **`diff`** `float` --->  `float`\n  *  **`diff`** (`float` , `float`) --->  `float`\n    \t\n----\n\n\n[//]: # (keyword|operator_diff2)\n### `diff2`\n\n#### Possible use: \n  * `float` **`diff2`** `float` --->  `float`\n  *  **`diff2`** (`float` , `float`) --->  `float`\n    \t\n----\n\n\n[//]: # (keyword|operator_directed)\n### `directed`\n\n#### Possible use: \n  *  **`directed`** (`graph`) --->  `graph` \n\n#### Result: \nthe operand graph becomes a directed graph.  \n\n#### Comment: \nthe operator alters the operand graph, it does not create a new one.    \n\n#### See also: \n[undirected](#undirected), \n    \t\n----\n\n\n[//]: # (keyword|operator_direction_between)\n### `direction_between`\n\n#### Possible use: \n  * `topology` **`direction_between`** `container<geometry>` --->  `int`\n  *  **`direction_between`** (`topology` , `container<geometry>`) --->  `int` \n\n#### Result: \nA direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.\n\n#### Examples: \n```\nint var0 <- my_topology direction_between [ag1, ag2]; \t// var0 equals the direction between ag1 and ag2 considering the topology my_topology\n```\n      \n\n#### See also: \n[towards](#towards), [direction_to](#direction_to), [distance_to](#distance_to), [distance_between](#distance_between), [path_between](#path_between), [path_to](#path_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_direction_to)\n### `direction_to`\nSame signification as [towards](#towards)\n    \t\n----\n\n\n[//]: # (keyword|operator_disjoint_from)\n### `disjoint_from`\n\n#### Possible use: \n  * `geometry` **`disjoint_from`** `geometry` --->  `bool`\n  *  **`disjoint_from`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns true.    \n  * if one operand is a point, returns false if the point is included in the geometry.\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]); \t// var0 equals false\nbool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals false\nbool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {15,15}; \t// var2 equals false\nbool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {25,25}; \t// var3 equals true\nbool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var4 equals true\n```\n      \n\n#### See also: \n[intersects](#intersects), [crosses](#crosses), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [touches](#touches), \n    \t\n----\n\n\n[//]: # (keyword|operator_distance_between)\n### `distance_between`\n\n#### Possible use: \n  * `topology` **`distance_between`** `container<geometry>` --->  `float`\n  *  **`distance_between`** (`topology` , `container<geometry>`) --->  `float` \n\n#### Result: \nA distance between a list of geometries (geometries, agents, points) considering a topology.\n\n#### Examples: \n```\nfloat var0 <- my_topology distance_between [ag1, ag2, ag3]; \t// var0 equals the distance between ag1, ag2 and ag3 considering the topology my_topology\n```\n      \n\n#### See also: \n[towards](#towards), [direction_to](#direction_to), [distance_to](#distance_to), [direction_between](#direction_between), [path_between](#path_between), [path_to](#path_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_distance_to)\n### `distance_to`\n\n#### Possible use: \n  * `geometry` **`distance_to`** `geometry` --->  `float`\n  *  **`distance_to`** (`geometry` , `geometry`) --->  `float`\n  * `point` **`distance_to`** `point` --->  `float`\n  *  **`distance_to`** (`point` , `point`) --->  `float` \n\n#### Result: \nA distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.\n\n#### Examples: \n```\nfloat var0 <- ag1 distance_to ag2; \t// var0 equals the distance between ag1 and ag2 considering the topology of the agent applying the operator\n```\n      \n\n#### See also: \n[towards](#towards), [direction_to](#direction_to), [distance_between](#distance_between), [direction_between](#direction_between), [path_between](#path_between), [path_to](#path_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_distinct)\n### `distinct`\n\n#### Possible use: \n  *  **`distinct`** (`container`) --->  `container` \n\n#### Result: \nproduces a set from the elements of the operand (i.e. a list without duplicated elements)\n\n#### Special cases:     \n  * if the operand is nil, remove_duplicates returns nil    \n  * if the operand is a graph, remove_duplicates returns the set of nodes    \n  * if the operand is a matrix, remove_duplicates returns a matrix without duplicated row    \n  * if the operand is a map, remove_duplicates returns the set of values without duplicate \n  \n```\ncontainer var1 <- remove_duplicates([1::3,2::4,3::3,5::7]); \t// var1 equals [3,4,7]\n\n``` \n\n\n\n#### Examples: \n```\ncontainer var0 <- remove_duplicates([3,2,5,1,2,3,5,5,5]); \t// var0 equals [3,2,5,1]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_distribution_of)\n### `distribution_of`\n\n#### Possible use: \n  *  **`distribution_of`** (`container`) --->  `map`\n  * `container` **`distribution_of`** `int` --->  `map`\n  *  **`distribution_of`** (`container` , `int`) --->  `map`\n  *  **`distribution_of`** (`container`, `int`, `float`, `float`) --->  `map` \n\n#### Result: \nDiscretize a list of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)\n\n#### Examples: \n```\nmap var0 <- distribution_of([1,1,2,12.5]); \t// var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nmap var1 <- distribution_of([1,1,2,12.5],10); \t// var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nmap var2 <- distribution_of([1,1,2,12.5]); \t// var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\n```\n      \n\n#### See also: \n[as_map](#as_map), \n    \t\n----\n\n\n[//]: # (keyword|operator_distribution2d_of)\n### `distribution2d_of`\n\n#### Possible use: \n  * `container` **`distribution2d_of`** `container` --->  `map`\n  *  **`distribution2d_of`** (`container` , `container`) --->  `map`\n  *  **`distribution2d_of`** (`container`, `container`, `int`, `int`) --->  `map`\n  *  **`distribution2d_of`** (`container`, `container`, `int`, `float`, `float`, `int`, `float`, `float`) --->  `map` \n\n#### Result: \nDiscretize two lists of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)\n\n#### Examples: \n```\nmap var0 <- distribution_of([1,1,2,12.5],10); \t// var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nmap var1 <- distribution2d_of([1,1,2,12.5]); \t// var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nmap var2 <- distribution_of([1,1,2,12.5],10); \t// var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\n```\n      \n\n#### See also: \n[as_map](#as_map), \n    \t\n----\n\n\n[//]: # (keyword|operator_div)\n### `div`\n\n#### Possible use: \n  * `float` **`div`** `float` --->  `int`\n  *  **`div`** (`float` , `float`) --->  `int`\n  * `int` **`div`** `int` --->  `int`\n  *  **`div`** (`int` , `int`) --->  `int`\n  * `float` **`div`** `int` --->  `int`\n  *  **`div`** (`float` , `int`) --->  `int`\n  * `int` **`div`** `float` --->  `int`\n  *  **`div`** (`int` , `float`) --->  `int` \n\n#### Result: \nReturns the truncation of the division of the left-hand operand by the right-hand operand.\n\n#### Special cases:     \n  * if the right-hand operand is equal to zero, raises an exception.    \n  * if the right-hand operand is equal to zero, raises an exception.    \n  * if the right-hand operand is equal to zero, raises an exception.\n\n#### Examples: \n```\nint var0 <- 40.1 div 4.5; \t// var0 equals 8\nint var1 <- 40 div 3; \t// var1 equals 13\nint var2 <- 40.5 div 3; \t// var2 equals 13\nint var3 <- 40 div 4.1; \t// var3 equals 9\n```\n      \n\n#### See also: \n[mod](#mod), \n    \t\n----\n\n\n[//]: # (keyword|operator_dxf_file)\n### `dxf_file`\n\n#### Possible use: \n  *  **`dxf_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type dxf. Allowed extensions are limited to dxf\n    \t\n----\n\n\n[//]: # (keyword|operator_edge)\n### `edge`\n\n#### Possible use: \n  *  **`edge`** (`pair`) --->  `unknown`\n  *  **`edge`** (`unknown`) --->  `unknown`\n  * `unknown` **`edge`** `unknown` --->  `unknown`\n  *  **`edge`** (`unknown` , `unknown`) --->  `unknown`\n  * `pair` **`edge`** `float` --->  `unknown`\n  *  **`edge`** (`pair` , `float`) --->  `unknown`\n  * `unknown` **`edge`** `float` --->  `unknown`\n  *  **`edge`** (`unknown` , `float`) --->  `unknown`\n  *  **`edge`** (`unknown`, `unknown`, `unknown`) --->  `unknown`\n  *  **`edge`** (`unknown`, `unknown`, `float`) --->  `unknown`\n  *  **`edge`** (`pair`, `unknown`, `float`) --->  `unknown`\n  *  **`edge`** (`unknown`, `unknown`, `unknown`, `float`) --->  `unknown`\n    \t\n----\n\n\n[//]: # (keyword|operator_edge_between)\n### `edge_between`\n\n#### Possible use: \n  * `graph` **`edge_between`** `pair` --->  `unknown`\n  *  **`edge_between`** (`graph` , `pair`) --->  `unknown` \n\n#### Result: \nreturns the edge linking two nodes\n\n#### Examples: \n```\nunknown var0 <- graphFromMap edge_between node1::node2; \t// var0 equals edge1\n```\n      \n\n#### See also: \n[out_edges_of](#out_edges_of), [in_edges_of](#in_edges_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_edge_betweenness)\n### `edge_betweenness`\n\n#### Possible use: \n  *  **`edge_betweenness`** (`graph`) --->  `map` \n\n#### Result: \nreturns a map containing for each edge (key), its betweenness centrality (value): number of shortest paths passing through each edge\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nmap var1 <- edge_betweenness(graphEpidemio); \t// var1 equals the edge betweenness index of the graph\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_edges)\n### `edges`\n\n#### Possible use: \n  *  **`edges`** (`container`) --->  `container`\n    \t\n----\n\n\n[//]: # (keyword|operator_eigenvalues)\n### `eigenvalues`\n\n#### Possible use: \n  *  **`eigenvalues`** (`matrix`) --->  `list<float>` \n\n#### Result: \nThe eigen values (matrix) of the given matrix\n\n#### Examples: \n```\nlist<float> var0 <- eigenvalues(matrix([[5,-3],[6,-4]])); \t// var0 equals [2.0000000000000004,-0.9999999999999998]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_electre_DM)\n### `electre_DM`\n\n#### Possible use: \n  *  **`electre_DM`** (`list<list>`, `list<map<string,object>>`, `float`) --->  `int` \n\n#### Result: \nThe index of the best candidate according to a method based on the ELECTRE methods. The principle of the ELECTRE methods is to compare the possible candidates by pair. These methods analyses the possible outranking relation existing between two candidates. An candidate outranks another if this one is at least as good as the other one. The ELECTRE methods are based on two concepts: the concordance and the discordance. The concordance characterizes the fact that, for an outranking relation to be validated, a sufficient majority of criteria should be in favor of this assertion. The discordance characterizes the fact that, for an outranking relation to be validated, none of the criteria in the minority should oppose too strongly this assertion. These two conditions must be true for validating the outranking assertion. More information about the ELECTRE methods can be found in [http://www.springerlink.com/content/g367r44322876223/\tFigueira,  J., Mousseau, V., Roy, B.: ELECTRE Methods. In: Figueira, J., Greco, S., and Ehrgott, M., (Eds.), Multiple Criteria Decision Analysis: State of the Art Surveys, Springer, New York, 133--162 (2005)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fives elements: a name, a weight, a preference value (p), an indifference value (q) and a veto value (v). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant. The veto value represents the threshold from which the difference between two criterion values disqualifies the candidate that obtained the smaller value; the last operand is the fuzzy cut.\n\n#### Special cases:     \n  * returns -1 is the list of candidates is nil or empty\n\n#### Examples: \n```\nint var0 <- electre_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]]); \t// var0 equals 0\n```\n      \n\n#### See also: \n[weighted_means_DM](#weighted_means_dm), [promethee_DM](#promethee_dm), [evidence_theory_DM](#evidence_theory_dm), \n    \t\n----\n\n\n[//]: # (keyword|operator_ellipse)\n### `ellipse`\n\n#### Possible use: \n  * `float` **`ellipse`** `float` --->  `geometry`\n  *  **`ellipse`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nAn ellipse geometry which x-radius is equal to the first operand and y-radius is equal to the second operand  \n\n#### Comment: \nthe center of the ellipse is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if both operands are lower or equal to 0, a line if only one is.\n\n#### Examples: \n```\ngeometry var0 <- ellipse(10, 10); \t// var0 equals a geometry as an ellipse of width 10 and height 10.\n```\n      \n\n#### See also: \n[around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [circle](#circle), [squircle](#squircle), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_emotion)\n### `emotion`\n\n#### Possible use: \n  *  **`emotion`** (`any`) --->  `emotion` \n\n#### Result: \nCasts the operand into the type emotion\n    \t\n----\n\n\n[//]: # (keyword|operator_empty)\n### `empty`\n\n#### Possible use: \n  *  **`empty`** (`container<KeyType,ValueType>`) --->  `bool`\n  *  **`empty`** (`string`) --->  `bool` \n\n#### Result: \ntrue if the operand is empty, false otherwise.  \n\n#### Comment: \nthe empty operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a map, empty returns true if the map contains no key-value mappings, and false otherwise    \n  * if it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise    \n  * if it is a population, empty returns true if there is no agent in the population, and false otherwise    \n  * if it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise    \n  * if it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise    \n  * if it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise    \n  * if it is a list, empty returns true if there is no element in the list, and false otherwise \n  \n```\nbool var0 <- empty([]); \t// var0 equals true\n\n``` \n\n    \n  * if it is a string, empty returns true if the string does not contain any character, and false otherwise \n  \n```\nbool var1 <- empty ('abced'); \t// var1 equals false\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_enlarged_by)\n### `enlarged_by`\nSame signification as [+](#+)\n    \t\n----\n\n\n[//]: # (keyword|operator_envelope)\n### `envelope`\n\n#### Possible use: \n  *  **`envelope`** (`unknown`) --->  `geometry` \n\n#### Result: \nA 3D geometry that represents the box that surrounds the geometries or the surface described by the arguments. More general than geometry(arguments).envelope, as it allows to pass int, double, point, image files, shape files, asc files, or any list combining these arguments, in which case the envelope will be correctly expanded. If an envelope cannot be determined from the arguments, a default one of dimensions (0,100, 0, 100, 0, 100) is returned\n    \t\n----\n\n\n[//]: # (keyword|operator_eval_gaml)\n### `eval_gaml`\n\n#### Possible use: \n  *  **`eval_gaml`** (`string`) --->  `unknown` \n\n#### Result: \nevaluates the given GAML string.\n\n#### Examples: \n```\nunknown var0 <- eval_gaml(\"2+3\"); \t// var0 equals 5\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_eval_when)\n### `eval_when`\n\n#### Possible use: \n  *  **`eval_when`** (`BDIPlan`) --->  `bool` \n\n#### Result: \nevaluate the facet when of a given plan\n\n#### Examples: \n```\neval_when(plan1)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_even)\n### `even`\n\n#### Possible use: \n  *  **`even`** (`int`) --->  `bool` \n\n#### Result: \nReturns true if the operand is even and false if it is odd.\n\n#### Special cases:     \n  * if the operand is equal to 0, it returns true.    \n  * if the operand is a float, it is truncated before\n\n#### Examples: \n```\nbool var0 <- even (3); \t// var0 equals false\nbool var1 <- even(-12); \t// var1 equals true\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_every)\n### `every`\n\n#### Possible use: \n  *  **`every`** (`int`) --->  `bool`\n  *  **`every`** (`any expression`) --->  `bool`\n  * `msi.gama.util.GamaDateInterval` **`every`** `any expression` --->  `msi.gama.util.IList<msi.gama.util.GamaDate>`\n  *  **`every`** (`msi.gama.util.GamaDateInterval` , `any expression`) --->  `msi.gama.util.IList<msi.gama.util.GamaDate>`\n  * `container` **`every`** `int` --->  `container`\n  *  **`every`** (`container` , `int`) --->  `container` \n\n#### Result: \ntrue every operand * cycle, false otherwise\napplies a step to an interval of dates defined by 'date1 to date2'\nexpects a frequency (expressed in seconds of simulated time) as argument. Will return true every time the current_date matches with this frequency\nRetrieves elements from the first argument every `step` (second argument) elements. Raises an error if the step is negative or equal to zero  \n\n#### Comment: \nthe value of the every operator depends on the cycle. It can be used to do something every x cycle.Used to do something at regular intervals of time. Can be used in conjunction with 'since', 'after', 'before', 'until' or 'between', so that this computation only takes place in the temporal segment defined by these operators. In all cases, the starting_date of the model is used as a reference starting point\n\n#### Examples: \n```\nif every(2) {write \"the cycle number is even\";}\n\t     else {write \"the cycle number is odd\";}\n(date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval\nreflex when: every(2#days) since date('2000-01-01') { .. }\nstate a { transition to: b when: every(2#mn);} state b { transition to: a when: every(30#s);} // This oscillatory behavior will use the starting_date of the model as its starting point in time\n```\n      \n\n#### See also: \n[to](#to), [since](#since), [after](#after), \n    \t\n----\n\n\n[//]: # (keyword|operator_every_cycle)\n### `every_cycle`\nSame signification as [every](#every)\n    \t\n----\n\n\n[//]: # (keyword|operator_evidence_theory_DM)\n### `evidence_theory_DM`\n\n#### Possible use: \n  * `list<list>` **`evidence_theory_DM`** `list<map<string,object>>` --->  `int`\n  *  **`evidence_theory_DM`** (`list<list>` , `list<map<string,object>>`) --->  `int`\n  *  **`evidence_theory_DM`** (`list<list>`, `list<map<string,object>>`, `bool`) --->  `int` \n\n#### Result: \nThe index of the best candidate according to a method based on the Evidence theory. This theory, which was proposed by Shafer ([http://www.glennshafer.com/books/amte.html Shafer G (1976) A mathematical theory of evidence, Princeton University Press]), is based on the work of Dempster ([http://projecteuclid.org/DPubS?service=UI&version=1.0&verb=Display&handle=euclid.aoms/1177698950 Dempster A (1967) Upper and lower probabilities induced by multivalued mapping. Annals of Mathematical Statistics, vol.  38, pp. 325--339]) on lower and upper probability distributions. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains seven elements: a name, a first threshold s1, a second threshold s2, a value for the assertion \"this candidate is the best\" at threshold s1 (v1p), a value for the assertion \"this candidate is the best\" at threshold s2 (v2p), a value for the assertion \"this candidate is not the best\" at threshold s1 (v1c), a value for the assertion \"this candidate is not the best\" at threshold s2 (v2c). v1p, v2p, v1c and v2c have to been defined in order that: v1p + v1c <= 1.0; v2p + v2c <= 1.0.; the last operand allows to use a simple version of this multi-criteria decision making method (simple if true)\n\n#### Special cases:     \n  * if the operator is used with only 2 operands (the candidates and the criteria), the last parameter (use simple method) is set to true    \n  * returns -1 is the list of candidates is nil or empty\n\n#### Examples: \n```\nint var0 <- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true],[\"name\"::\"price\",  \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true]], true); \t// var0 equals 0\n```\n      \n\n#### See also: \n[weighted_means_DM](#weighted_means_dm), [electre_DM](#electre_dm), \n    \t\n----\n\n\n[//]: # (keyword|operator_exp)\n### `exp`\n\n#### Possible use: \n  *  **`exp`** (`float`) --->  `float`\n  *  **`exp`** (`int`) --->  `float` \n\n#### Result: \nReturns Euler's number e raised to the power of the operand.\n\n#### Special cases:     \n  * the operand is casted to a float before being evaluated.    \n  * the operand is casted to a float before being evaluated.\n\n#### Examples: \n```\nfloat var0 <- exp (0); \t// var0 equals 1.0\n```\n      \n\n#### See also: \n[ln](#ln), \n    \t\n----\n\n\n[//]: # (keyword|operator_fact)\n### `fact`\n\n#### Possible use: \n  *  **`fact`** (`int`) --->  `float` \n\n#### Result: \nReturns the factorial of the operand.\n\n#### Special cases:     \n  * if the operand is less than 0, fact returns 0.\n\n#### Examples: \n```\nfloat var0 <- fact(4); \t// var0 equals 24\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_farthest_point_to)\n### `farthest_point_to`\n\n#### Possible use: \n  * `geometry` **`farthest_point_to`** `point` --->  `point`\n  *  **`farthest_point_to`** (`geometry` , `point`) --->  `point` \n\n#### Result: \nthe farthest point of the left-operand to the left-point.\n\n#### Examples: \n```\npoint var0 <- geom farthest_point_to(pt); \t// var0 equals the farthest point of geom to pt\n```\n      \n\n#### See also: \n[any_location_in](#any_location_in), [any_point_in](#any_point_in), [closest_points_with](#closest_points_with), [points_at](#points_at), \n    \t\n----\n\n\n[//]: # (keyword|operator_farthest_to)\n### `farthest_to`\n\n#### Possible use: \n  * `container<agent>` **`farthest_to`** `geometry` --->  `geometry`\n  *  **`farthest_to`** (`container<agent>` , `geometry`) --->  `geometry` \n\n#### Result: \nAn agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the farthest to the operand (casted as a geometry).  \n\n#### Comment: \nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\n\n#### Examples: \n```\ngeometry var0 <- [ag1, ag2, ag3] closest_to(self); \t// var0 equals return the farthest agent among ag1, ag2 and ag3 to the agent applying the operator.\n(species1 + species2) closest_to self\n```\n      \n\n#### See also: \n[neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [inside](#inside), [overlapping](#overlapping), [agents_overlapping](#agents_overlapping), [agents_inside](#agents_inside), [agent_closest_to](#agent_closest_to), [closest_to](#closest_to), [agent_farthest_to](#agent_farthest_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_file)\n### `file`\n\n#### Possible use: \n  *  **`file`** (`string`) --->  `file`\n  * `string` **`file`** `container` --->  `file`\n  *  **`file`** (`string` , `container`) --->  `file` \n\n#### Result: \nopens a file in read only mode, creates a GAML file object, and tries to determine and store the file content in the contents attribute.\nCreates a file in read/write mode, setting its contents to the container passed in parameter  \n\n#### Comment: \nThe file should have a supported extension, see file type definition for supported file extensions.The type of container to pass will depend on the type of file (see the management of files in the documentation). Can be used to copy files since files are considered as containers. For example: save file('image_copy.png', file('image.png')); will copy image.png to image_copy.png\n\n#### Special cases:     \n  * If the specified string does not refer to an existing file, an exception is risen when the variable is used.\n\n#### Examples: \n```\nlet fileT type: file value: file(\"../includes/Stupid_Cell.Data\"); \n\t\t\t// fileT represents the file \"../includes/Stupid_Cell.Data\"\n\t\t\t// fileT.contents here contains a matrix storing all the data of the text file\n```\n      \n\n#### See also: \n[folder](#folder), [new_folder](#new_folder), \n    \t\n----\n\n\n[//]: # (keyword|operator_file_exists)\n### `file_exists`\n\n#### Possible use: \n  *  **`file_exists`** (`string`) --->  `bool` \n\n#### Result: \nTest whether the parameter is the path to an existing file.\n    \t\n----\n\n\n[//]: # (keyword|operator_first)\n### `first`\n\n#### Possible use: \n  *  **`first`** (`string`) --->  `string`\n  *  **`first`** (`container<KeyType,ValueType>`) --->  `ValueType`\n  * `int` **`first`** `container` --->  `container`\n  *  **`first`** (`int` , `container`) --->  `container` \n\n#### Result: \nthe first value of the operand  \n\n#### Comment: \nthe first operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a map, first returns the first value of the first pair (in insertion order)    \n  * if it is a file, first returns the first element of the content of the file (that is also a container)    \n  * if it is a population, first returns the first agent of the population    \n  * if it is a graph, first returns the first edge (in creation order)    \n  * if it is a matrix, first returns the element at {0,0} in the matrix    \n  * for a matrix of int or float, it will return 0 if the matrix is empty    \n  * for a matrix of object or geometry, it will return nil if the matrix is empty    \n  * if it is a string, first returns a string composed of its first character \n  \n```\nstring var0 <- first ('abce'); \t// var0 equals 'a'\n\n``` \n\n    \n  * if it is a list, first returns the first element of the list, or nil if the list is empty \n  \n```\nint var1 <- first ([1, 2, 3]); \t// var1 equals 1\n\n``` \n\n    \n\n#### See also: \n[last](#last), \n    \t\n----\n\n\n[//]: # (keyword|operator_first_of)\n### `first_of`\nSame signification as [first](#first)\n    \t\n----\n\n\n[//]: # (keyword|operator_first_with)\n### `first_with`\n\n#### Possible use: \n  * `container` **`first_with`** `any expression` --->  `unknown`\n  *  **`first_with`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe first element of the left-hand operand that makes the right-hand operand evaluate to true.  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, first_with throws an error. If there is no element that satisfies the condition, it returns nil    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var4 <- [1::2, 3::4, 5::6] first_with (each >= 4); \t// var4 equals 4\nunknown var5 <- [1::2, 3::4, 5::6].pairs first_with (each.value >= 4); \t// var5 equals 3::4\n\n``` \n\n\n\n#### Examples: \n```\nunknown var0 <- [1,2,3,4,5,6,7,8] first_with (each > 3); \t// var0 equals 4\nunknown var2 <- g2 first_with (length(g2 out_edges_of each) = 0); \t// var2 equals node9\nunknown var3 <- (list(node) first_with (round(node(each).location.x) > 32); \t// var3 equals node2\n```\n      \n\n#### See also: \n[group_by](#group_by), [last_with](#last_with), [where](#where), \n    \t\n----\n\n\n[//]: # (keyword|operator_flip)\n### `flip`\n\n#### Possible use: \n  *  **`flip`** (`float`) --->  `bool` \n\n#### Result: \ntrue or false given the probability represented by the operand\n\n#### Special cases:     \n  * flip 0 always returns false, flip 1 true\n\n#### Examples: \n```\nbool var0 <- flip (0.66666); \t// var0 equals 2/3 chances to return true.\n```\n      \n\n#### See also: \n[rnd](#rnd), \n    \t\n----\n\n\n[//]: # (keyword|operator_float)\n### `float`\n\n#### Possible use: \n  *  **`float`** (`any`) --->  `float` \n\n#### Result: \nCasts the operand into the type float\n    \t\n----\n\n\n[//]: # (keyword|operator_floor)\n### `floor`\n\n#### Possible use: \n  *  **`floor`** (`float`) --->  `float` \n\n#### Result: \nMaps the operand to the largest previous following integer, i.e. the largest integer not greater than x.\n\n#### Examples: \n```\nfloat var0 <- floor(3); \t// var0 equals 3.0\nfloat var1 <- floor(3.5); \t// var1 equals 3.0\nfloat var2 <- floor(-4.7); \t// var2 equals -5.0\n```\n      \n\n#### See also: \n[ceil](#ceil), [round](#round), \n    \t\n----\n\n\n[//]: # (keyword|operator_folder)\n### `folder`\n\n#### Possible use: \n  *  **`folder`** (`string`) --->  `file` \n\n#### Result: \nopens an existing repository\n\n#### Special cases:     \n  * If the specified string does not refer to an existing repository, an exception is risen.\n\n#### Examples: \n```\nfolder(\"../includes/\")\nfile dirT <- folder(\"../includes/\");\n\t\t\t\t// dirT represents the repository \"../includes/\"\n\t\t\t\t// dirT.contents here contains the list of the names of included files\n```\n      \n\n#### See also: \n[file](#file), [new_folder](#new_folder), \n    \t\n----\n\n\n[//]: # (keyword|operator_font)\n### `font`\n\n#### Possible use: \n  *  **`font`** (`string`, `int`, `int`) --->  `font` \n\n#### Result: \nCreates a new font, by specifying its name (either a font face name like 'Lucida Grande Bold' or 'Helvetica', or a logical name like 'Dialog', 'SansSerif', 'Serif', etc.), a size in points and a style, either #bold, #italic or #plain or a combination (addition) of them.\n\n#### Examples: \n```\nfont var0 <- font ('Helvetica Neue',12, #bold + #italic); \t// var0 equals a bold and italic face of the Helvetica Neue family\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_frequency_of)\n### `frequency_of`\n\n#### Possible use: \n  * `container` **`frequency_of`** `any expression` --->  `map`\n  *  **`frequency_of`** (`container` , `any expression`) --->  `map` \n\n#### Result: \nReturns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)\n\n#### Examples: \n```\nmap var0 <- [ag1, ag2, ag3, ag4] frequency_of each.size; \t// var0 equals the different sizes as keys and the number of agents of this size as values\n```\n      \n\n#### See also: \n[as_map](#as_map), \n    \t\n----\n\n\n[//]: # (keyword|operator_from)\n### `from`\nSame signification as [since](#since)\n    \t\n----\n\n\n[//]: # (keyword|operator_fuzzy_kappa)\n### `fuzzy_kappa`\n\n#### Possible use: \n  *  **`fuzzy_kappa`** (`list<agent>`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`) --->  `float`\n  *  **`fuzzy_kappa`** (`list<agent>`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`, `list`) --->  `float` \n\n#### Result: \nfuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21\nfuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21\n\n#### Examples: \n```\nfuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])\nfuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_fuzzy_kappa_sim)\n### `fuzzy_kappa_sim`\n\n#### Possible use: \n  *  **`fuzzy_kappa_sim`** (`list<agent>`, `list`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`) --->  `float`\n  *  **`fuzzy_kappa_sim`** (`list<agent>`, `list`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`, `list`) --->  `float` \n\n#### Result: \nfuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, \nfuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,\n\n#### Examples: \n```\nfuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2)\nfuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_gaml_file)\n### `gaml_file`\n\n#### Possible use: \n  *  **`gaml_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type gaml. Allowed extensions are limited to gaml, experiment\n    \t\n----\n\n\n[//]: # (keyword|operator_gamma_index)\n### `gamma_index`\n\n#### Possible use: \n  *  **`gamma_index`** (`graph`) --->  `float` \n\n#### Result: \nreturns the gamma index of the graph (A measure of connectivity that considers the relationship between the number of observed links and the number of possible links: gamma = e/(3 `*` (v - 2)) - for planar graph.\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nfloat var1 <- gamma_index(graphEpidemio); \t// var1 equals the gamma index of the graph\n```\n      \n\n#### See also: \n[alpha_index](#alpha_index), [beta_index](#beta_index), [nb_cycles](#nb_cycles), [connectivity_index](#connectivity_index), \n    \t\n----\n\n\n[//]: # (keyword|operator_gamma_rnd)\n### `gamma_rnd`\n\n#### Possible use: \n  * `float` **`gamma_rnd`** `float` --->  `float`\n  *  **`gamma_rnd`** (`float` , `float`) --->  `float` \n\n#### Result: \nreturns a random value from a gamma distribution with specified values of the shape and scale parameters\n\n#### Examples: \n```\ngamma_rnd(10.0,5.0)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_gauss)\n### `gauss`\n\n#### Possible use: \n  *  **`gauss`** (`point`) --->  `float`\n  * `float` **`gauss`** `float` --->  `float`\n  *  **`gauss`** (`float` , `float`) --->  `float` \n\n#### Result: \nA value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.\nA value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.\n\n#### Special cases:     \n  * when the operand is a point, it is read as {mean, standardDeviation}    \n  * when standardDeviation value is 0.0, it always returns the mean value    \n  * when the operand is a point, it is read as {mean, standardDeviation}    \n  * when standardDeviation value is 0.0, it always returns the mean value\n\n#### Examples: \n```\nfloat var0 <- gauss(0,0.3); \t// var0 equals 0.22354\nfloat var1 <- gauss(0,0.3); \t// var1 equals -0.1357\nfloat var2 <- gauss({0,0.3}); \t// var2 equals 0.22354\nfloat var3 <- gauss({0,0.3}); \t// var3 equals -0.1357\n```\n      \n\n#### See also: \n[skew_gauss](#skew_gauss), [truncated_gauss](#truncated_gauss), [poisson](#poisson), \n    \t\n----\n\n\n[//]: # (keyword|operator_generate_barabasi_albert)\n### `generate_barabasi_albert`\n\n#### Possible use: \n  *  **`generate_barabasi_albert`** (`container<agent>`, `species`, `int`, `bool`) --->  `graph`\n  *  **`generate_barabasi_albert`** (`species`, `species`, `int`, `int`, `bool`) --->  `graph` \n\n#### Result: \nreturns a random scale-free network (following Barabasi-Albert (BA) model).\nreturns a random scale-free network (following Barabasi-Albert (BA) model).  \n\n#### Comment: \nThe Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:\n\n#### Special cases:     \n  * \"vertices_specy\": the species of vertices    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain (size + 1) nodes    \n  * \"m\": the number of edges added per novel node    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"agents\": list of existing node agents    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain (size + 1) nodes    \n  * \"m\": the number of edges added per novel node    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?\n\n#### Examples: \n```\ngraph<yourNodeSpecy,yourEdgeSpecy> graphEpidemio <- generate_barabasi_albert(\n\t\tyourNodeSpecy,\n\t\tyourEdgeSpecy,\n\t\t3,\n\t\t5,\n\t\ttrue);\ngraph<yourNodeSpecy,yourEdgeSpecy> graphEpidemio <- generate_barabasi_albert(\n\t\tyourListOfNodes,\n\t\tyourEdgeSpecy,\n\t\t3,\n\t\t5,\n\t\ttrue);\n```\n      \n\n#### See also: \n[generate_watts_strogatz](#generate_watts_strogatz), \n    \t\n----\n\n\n[//]: # (keyword|operator_generate_complete_graph)\n### `generate_complete_graph`\n\n#### Possible use: \n  *  **`generate_complete_graph`** (`container<agent>`, `species`, `bool`) --->  `graph`\n  *  **`generate_complete_graph`** (`container<agent>`, `species`, `float`, `bool`) --->  `graph`\n  *  **`generate_complete_graph`** (`species`, `species`, `int`, `bool`) --->  `graph`\n  *  **`generate_complete_graph`** (`species`, `species`, `int`, `float`, `bool`) --->  `graph` \n\n#### Result: \nreturns a fully connected graph.\nreturns a fully connected graph.\nreturns a fully connected graph.\nreturns a fully connected graph.  \n\n#### Comment: \nArguments should include following elements:Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:\n\n#### Special cases:     \n  * \"agents\": list of existing node agents    \n  * \"edges_species\": the species of edges    \n  * \"layoutRadius\": nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"vertices_specy\": the species of vertices    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain size nodes.    \n  * \"layoutRadius\": nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"vertices_specy\": the species of vertices    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain size nodes.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"agents\": list of existing node agents    \n  * \"edges_species\": the species of edges    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?\n\n#### Examples: \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(\n\t\t\tmyListOfNodes,\n\t\t\tmyEdgeSpecy,\n\t\t\t25,\n\t\ttrue);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy,\n\t\t\t10, 25,\n\t\ttrue);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy,\n\t\t\t10,\n\t\ttrue);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(\n\t\t\tmyListOfNodes,\n\t\t\tmyEdgeSpecy,\n\t\ttrue);\n```\n      \n\n#### See also: \n[generate_barabasi_albert](#generate_barabasi_albert), [generate_watts_strogatz](#generate_watts_strogatz), \n    \t\n----\n\n\n[//]: # (keyword|operator_generate_watts_strogatz)\n### `generate_watts_strogatz`\n\n#### Possible use: \n  *  **`generate_watts_strogatz`** (`container<agent>`, `species`, `float`, `int`, `bool`) --->  `graph`\n  *  **`generate_watts_strogatz`** (`species`, `species`, `int`, `float`, `int`, `bool`) --->  `graph` \n\n#### Result: \nreturns a random small-world network (following Watts-Strogatz model).\nreturns a random small-world network (following Watts-Strogatz model).  \n\n#### Comment: \nThe Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:\n\n#### Special cases:     \n  * \"vertices_specy\": the species of vertices    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain (size + 1) nodes. Size must be greater than k.    \n  * \"p\": probability to \"rewire\" an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.    \n  * \"k\": the base degree of each node. k must be greater than 2 and even.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"agents\": list of existing node agents    \n  * \"edges_species\": the species of edges    \n  * \"p\": probability to \"rewire\" an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.    \n  * \"k\": the base degree of each node. k must be greater than 2 and even.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?\n\n#### Examples: \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz(\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy,\n\t\t\t2,\n\t\t\t0.3,\n\t\t\t2,\n\t\ttrue);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz(\n\t\t\tmyListOfNodes,\n\t\t\tmyEdgeSpecy,\n\t\t\t0.3,\n\t\t\t2,\n\t\ttrue);\n```\n      \n\n#### See also: \n[generate_barabasi_albert](#generate_barabasi_albert), \n    \t\n----\n\n\n[//]: # (keyword|operator_geojson_file)\n### `geojson_file`\n\n#### Possible use: \n  *  **`geojson_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type geojson. Allowed extensions are limited to json, geojson, geo.json\n    \t\n----\n\n\n[//]: # (keyword|operator_geometric_mean)\n### `geometric_mean`\n\n#### Possible use: \n  *  **`geometric_mean`** (`container`) --->  `float` \n\n#### Result: \nthe geometric mean of the elements of the operand. See <A href=\"http://en.wikipedia.org/wiki/Geometric_mean\">Geometric_mean</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- geometric_mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 4.962326343467649\n```\n      \n\n#### See also: \n[mean](#mean), [median](#median), [harmonic_mean](#harmonic_mean), \n    \t\n----\n\n\n[//]: # (keyword|operator_geometry)\n### `geometry`\n\n#### Possible use: \n  *  **`geometry`** (`any`) --->  `geometry` \n\n#### Result: \nCasts the operand into the type geometry\n    \t\n----\n\n\n[//]: # (keyword|operator_geometry_collection)\n### `geometry_collection`\n\n#### Possible use: \n  *  **`geometry_collection`** (`container<geometry>`) --->  `geometry` \n\n#### Result: \nA geometry collection (multi-geometry) composed of the given list of geometries.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single geometry, returns a copy of the geometry.\n\n#### Examples: \n```\ngeometry var0 <- geometry_collection([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var0 equals a geometry composed of the 4 points (multi-point).\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [link](#link), [norm](#norm), [point](#point), [polygone](#polygone), [rectangle](#rectangle), [square](#square), [triangle](#triangle), [line](#line), \n    \t\n----\n\n\n[//]: # (keyword|operator_get)\n### `get`\n\n#### Possible use: \n  * `geometry` **`get`** `string` --->  `unknown`\n  *  **`get`** (`geometry` , `string`) --->  `unknown`\n  * `agent` **`get`** `string` --->  `unknown`\n  *  **`get`** (`agent` , `string`) --->  `unknown` \n\n#### Result: \nReads an attribute of the specified geometry (left operand). The attribute name is specified by the right operand.\nReads an attribute of the specified agent (left operand). The attribute name is specified by the right operand.\n\n#### Special cases:     \n  * Reading the attribute of a geometry \n  \n```\nstring geom_area <- a_geometry get('area');     // reads then 'area' attribute of 'a_geometry' variable then assigns the returned value to the geom_area variable\n\n``` \n\n    \n  * Reading the attribute of another agent \n  \n```\nstring agent_name <- an_agent get('name');     // reads then 'name' attribute of an_agent then assigns the returned value to the agent_name variable\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_get_about)\n### `get_about`\n\n#### Possible use: \n  *  **`get_about`** (`emotion`) --->  `predicate` \n\n#### Result: \nget the about value of the given emotion\n\n#### Examples: \n```\nget_about(emotion)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_get_agent)\n### `get_agent`\n\n#### Possible use: \n  *  **`get_agent`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `agent` \n\n#### Result: \nget the agent value of the given social link\n\n#### Examples: \n```\nget_agent(social_link1)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_get_agent_cause)\n### `get_agent_cause`\n\n#### Possible use: \n  *  **`get_agent_cause`** (`emotion`) --->  `agent`\n  *  **`get_agent_cause`** (`predicate`) --->  `agent` \n\n#### Result: \nget the agent cause value of the given emotion\n\n#### Examples: \n```\nget_agent_cause(emotion)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_get_decay)\n### `get_decay`\n\n#### Possible use: \n  *  **`get_decay`** (`emotion`) --->  `float` \n\n#### Result: \nget the decay value of the given emotion\n\n#### Examples: \n```\nget_decay(emotion)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_get_dominance)\n### `get_dominance`\n\n#### Possible use: \n  *  **`get_dominance`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `float` \n\n#### Result: \nget the dominance value of the given social link\n\n#### Examples: \n```\nget_dominance(social_link1)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_get_familiarity)\n### `get_familiarity`\n\n#### Possible use: \n  *  **`get_familiarity`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `float` \n\n#### Result: \nget the familiarity value of the given social link\n\n#### Examples: \n```\nget_familiarity(social_link1)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_get_intensity)\n### `get_intensity`\n\n#### Possible use: \n  *  **`get_intensity`** (`emotion`) --->  `float` \n\n#### Result: \nget the intensity value of the given emotion\n\n#### Examples: \n```\nemotion set_intensity 12\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_get_lifetime)\n### `get_lifetime`\n\n#### Possible use: \n  *  **`get_lifetime`** (`predicate`) --->  `int`\n    \t\n----\n\n\n[//]: # (keyword|operator_get_liking)\n### `get_liking`\n\n#### Possible use: \n  *  **`get_liking`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `float` \n\n#### Result: \nget the liking value of the given social link\n\n#### Examples: \n```\nget_liking(social_link1)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_get_praiseworthiness)\n### `get_praiseworthiness`\n\n#### Possible use: \n  *  **`get_praiseworthiness`** (`predicate`) --->  `float`\n    \t\n----\n\n\n[//]: # (keyword|operator_get_priority)\n### `get_priority`\n\n#### Possible use: \n  *  **`get_priority`** (`predicate`) --->  `float`\n    \t\n----\n\n\n[//]: # (keyword|operator_get_solidarity)\n### `get_solidarity`\n\n#### Possible use: \n  *  **`get_solidarity`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `float` \n\n#### Result: \nget the solidarity value of the given social link\n\n#### Examples: \n```\nget_solidarity(social_link1)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_get_super_intention)\n### `get_super_intention`\n\n#### Possible use: \n  *  **`get_super_intention`** (`predicate`) --->  `predicate`\n    \t\n----\n\n\n[//]: # (keyword|operator_gif_file)\n### `gif_file`\n\n#### Possible use: \n  *  **`gif_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type gif. Allowed extensions are limited to gif\n    \t\n----\n\n\n[//]: # (keyword|operator_gini)\n### `gini`\n\n#### Possible use: \n  *  **`gini`** (`list<float>`) --->  `float`\n\n#### Special cases:     \n  * return the Gini Index of the given list of values (list of floats) \n  \n```\nfloat var0 <- gini([1.0, 0.5, 2.0]); \t// var0 equals the gini index computed\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_graph)\n### `graph`\n\n#### Possible use: \n  *  **`graph`** (`any`) --->  `graph` \n\n#### Result: \nCasts the operand into the type graph\n    \t\n----\n\n\n[//]: # (keyword|operator_grayscale)\n### `grayscale`\n\n#### Possible use: \n  *  **`grayscale`** (`rgb`) --->  `rgb` \n\n#### Result: \nConverts rgb color to grayscale value  \n\n#### Comment: \nr=red, g=green, b=blue. Between 0 and 255 and gray = 0.299 `*` red + 0.587 `*` green + 0.114 `*` blue (Photoshop value)\n\n#### Examples: \n```\nrgb var0 <- grayscale (rgb(255,0,0)); \t// var0 equals to a dark grey\n```\n      \n\n#### See also: \n[rgb](#rgb), [hsb](#hsb), \n    \t\n----\n\n\n[//]: # (keyword|operator_grid_at)\n### `grid_at`\n\n#### Possible use: \n  * `species` **`grid_at`** `point` --->  `agent`\n  *  **`grid_at`** (`species` , `point`) --->  `agent` \n\n#### Result: \nreturns the cell of the grid (right-hand operand) at the position given by the right-hand operand  \n\n#### Comment: \nIf the left-hand operand is a point of floats, it is used as a point of ints.\n\n#### Special cases:     \n  * if the left-hand operand is not a grid cell species, returns nil\n\n#### Examples: \n```\nagent var0 <- grid_cell grid_at {1,2}; \t// var0 equals the agent grid_cell with grid_x=1 and grid_y = 2\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_grid_cells_to_graph)\n### `grid_cells_to_graph`\n\n#### Possible use: \n  *  **`grid_cells_to_graph`** (`container`) --->  `graph` \n\n#### Result: \ncreates a graph from a list of cells (operand). An edge is created between neighbors.\n\n#### Examples: \n```\nmy_cell_graph<-grid_cells_to_graph(cells_list)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_grid_file)\n### `grid_file`\n\n#### Possible use: \n  *  **`grid_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type grid. Allowed extensions are limited to asc, tif\n    \t\n----\n\n\n[//]: # (keyword|operator_group_by)\n### `group_by`\n\n#### Possible use: \n  * `container` **`group_by`** `any expression` --->  `map`\n  *  **`group_by`** (`container` , `any expression`) --->  `map` \n\n#### Result: \nReturns a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key value  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, group_by throws an error\n\n#### Examples: \n```\nmap var0 <- [1,2,3,4,5,6,7,8] group_by (each > 3); \t// var0 equals [false::[1, 2, 3], true::[4, 5, 6, 7, 8]]\nmap var1 <- g2 group_by (length(g2 out_edges_of each) ); \t// var1 equals [ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]]\nmap var2 <- (list(node) group_by (round(node(each).location.x)); \t// var2 equals [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]]\nmap var3 <- [1::2, 3::4, 5::6] group_by (each > 4); \t// var3 equals [false::[2, 4], true::[6]]\n```\n      \n\n#### See also: \n[first_with](#first_with), [last_with](#last_with), [where](#where), \n    \t\n----\n\n\n[//]: # (keyword|operator_harmonic_mean)\n### `harmonic_mean`\n\n#### Possible use: \n  *  **`harmonic_mean`** (`container`) --->  `float` \n\n#### Result: \nthe harmonic mean of the elements of the operand. See <A href=\"http://en.wikipedia.org/wiki/Harmonic_mean\">Harmonic_mean</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- harmonic_mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 4.804159445407279\n```\n      \n\n#### See also: \n[mean](#mean), [median](#median), [geometric_mean](#geometric_mean), \n    \t\n----\n\n\n[//]: # (keyword|operator_hexagon)\n### `hexagon`\n\n#### Possible use: \n  *  **`hexagon`** (`point`) --->  `geometry`\n  *  **`hexagon`** (`float`) --->  `geometry` \n\n#### Result: \nA hexagon geometry which the given with and height  \n\n#### Comment: \nthe center of the hexagon is by default the location of the current agent in which has been called this operator.the center of the hexagon is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- hexagon({10,5}); \t// var0 equals a geometry as a hexagon of width of 10 and height of 5.\ngeometry var1 <- hexagon(10); \t// var1 equals a geometry as a hexagon of width of 10 and height of 10.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_hierarchical_clustering)\n### `hierarchical_clustering`\n\n#### Possible use: \n  * `container<agent>` **`hierarchical_clustering`** `float` --->  `container`\n  *  **`hierarchical_clustering`** (`container<agent>` , `float`) --->  `container` \n\n#### Result: \nA tree (list of list) contained groups of agents clustered by distance considering a distance min between two groups.  \n\n#### Comment: \nuse of hierarchical clustering with Minimum for linkage criterion between two groups of agents.\n\n#### Examples: \n```\ncontainer var0 <- [ag1, ag2, ag3, ag4, ag5] hierarchical_clustering 20.0; \t// var0 equals for example, can return [[[ag1],[ag3]], [ag2], [[[ag4],[ag5]],[ag6]]\n```\n      \n\n#### See also: \n[simple_clustering_by_distance](#simple_clustering_by_distance), \n    \t\n----\n\n\n[//]: # (keyword|operator_hsb)\n### `hsb`\n\n#### Possible use: \n  *  **`hsb`** (`float`, `float`, `float`) --->  `rgb`\n  *  **`hsb`** (`float`, `float`, `float`, `int`) --->  `rgb`\n  *  **`hsb`** (`float`, `float`, `float`, `float`) --->  `rgb` \n\n#### Result: \nConverts hsb (h=hue, s=saturation, b=brightness) value to Gama color  \n\n#### Comment: \nh,s and b components should be floating-point values between 0.0 and 1.0 and when used alpha should be an integer (between 0 and 255) or a float (between 0 and 1) . Examples: Red=(0.0,1.0,1.0), Yellow=(0.16,1.0,1.0), Green=(0.33,1.0,1.0), Cyan=(0.5,1.0,1.0), Blue=(0.66,1.0,1.0), Magenta=(0.83,1.0,1.0)\n\n#### Examples: \n```\nrgb var0 <- hsb (0.5,1.0,1.0,0.0); \t// var0 equals rgb(\"cyan\",0)\nrgb var1 <- hsb (0.0,1.0,1.0); \t// var1 equals rgb(\"red\")\n```\n      \n\n#### See also: \n[rgb](#rgb), \n    \t\n----\n\n\n[//]: # (keyword|operator_hypot)\n### `hypot`\n\n#### Possible use: \n  *  **`hypot`** (`float`, `float`, `float`, `float`) --->  `float` \n\n#### Result: \nReturns sqrt(x2 +y2) without intermediate overflow or underflow.\n\n#### Special cases:     \n  * If either argument is infinite, then the result is positive infinity. If either argument is NaN and neither argument is infinite, then the result is NaN.\n\n#### Examples: \n```\nfloat var0 <- hypot(0,1,0,1); \t// var0 equals sqrt(2)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_IDW)\n### `IDW`\n\n#### Possible use: \n  *  **`IDW`** (`container<agent>`, `map<point,float>`, `int`) --->  `map<agent,float>` \n\n#### Result: \nInverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter)\n\n#### Examples: \n```\nmap<agent,float> var0 <- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2); \t// var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_image_file)\n### `image_file`\n\n#### Possible use: \n  *  **`image_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type image. Allowed extensions are limited to tiff, jpg, jpeg, png, pict, bmp\n    \t\n----\n\n\n[//]: # (keyword|operator_in)\n### `in`\n\n#### Possible use: \n  * `unknown` **`in`** `container` --->  `bool`\n  *  **`in`** (`unknown` , `container`) --->  `bool`\n  * `string` **`in`** `string` --->  `bool`\n  *  **`in`** (`string` , `string`) --->  `bool` \n\n#### Result: \ntrue if the right operand contains the left operand, false otherwise  \n\n#### Comment: \nthe definition of in depends on the container\n\n#### Special cases:     \n  * if the right operand is nil or empty, in returns false    \n  * if both operands are strings, returns true if the left-hand operand patterns is included in to the right-hand string;\n\n#### Examples: \n```\nbool var0 <- 2 in [1,2,3,4,5,6]; \t// var0 equals true\nbool var1 <- 7 in [1,2,3,4,5,6]; \t// var1 equals false\nbool var2 <- 3 in [1::2, 3::4, 5::6]; \t// var2 equals false\nbool var3 <- 6 in [1::2, 3::4, 5::6]; \t// var3 equals true\nbool var4 <-  'bc' in 'abcded'; \t// var4 equals true\n```\n      \n\n#### See also: \n[contains](#contains), \n    \t\n----\n\n\n[//]: # (keyword|operator_in_degree_of)\n### `in_degree_of`\n\n#### Possible use: \n  * `graph` **`in_degree_of`** `unknown` --->  `int`\n  *  **`in_degree_of`** (`graph` , `unknown`) --->  `int` \n\n#### Result: \nreturns the in degree of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\nint var1 <- graphFromMap in_degree_of (node(3)); \t// var1 equals 2\n```\n      \n\n#### See also: \n[out_degree_of](#out_degree_of), [degree_of](#degree_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_in_edges_of)\n### `in_edges_of`\n\n#### Possible use: \n  * `graph` **`in_edges_of`** `unknown` --->  `container`\n  *  **`in_edges_of`** (`graph` , `unknown`) --->  `container` \n\n#### Result: \nreturns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\ncontainer var1 <- graphFromMap in_edges_of node({12,45}); \t// var1 equals [LineString]\n```\n      \n\n#### See also: \n[out_edges_of](#out_edges_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_indented_by)\n### `indented_by`\n\n#### Possible use: \n  * `string` **`indented_by`** `int` --->  `string`\n  *  **`indented_by`** (`string` , `int`) --->  `string` \n\n#### Result: \nConverts a (possibly multiline) string by indenting it by a number -- specified by the second operand -- of tabulations to the right\n    \t\n----\n\n\n[//]: # (keyword|operator_index_by)\n### `index_by`\n\n#### Possible use: \n  * `container` **`index_by`** `any expression` --->  `map`\n  *  **`index_by`** (`container` , `any expression`) --->  `map` \n\n#### Result: \nproduces a new map from the evaluation of the right-hand operand for each element of the left-hand operand\n\n#### Special cases:     \n  * if the left-hand operand is nil, index_by throws an error. If the operation results in duplicate keys, only the first value corresponding to the key is kept\n\n#### Examples: \n```\nmap var0 <- [1,2,3,4,5,6,7,8] index_by (each - 1); \t// var0 equals [0::1, 1::2, 2::3, 3::4, 4::5, 5::6, 6::7, 7::8]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_index_of)\n### `index_of`\n\n#### Possible use: \n  * `container` **`index_of`** `unknown` --->  `int`\n  *  **`index_of`** (`container` , `unknown`) --->  `int`\n  * `map` **`index_of`** `unknown` --->  `unknown`\n  *  **`index_of`** (`map` , `unknown`) --->  `unknown`\n  * `matrix` **`index_of`** `unknown` --->  `point`\n  *  **`index_of`** (`matrix` , `unknown`) --->  `point`\n  * `string` **`index_of`** `string` --->  `int`\n  *  **`index_of`** (`string` , `string`) --->  `int`\n  * `species` **`index_of`** `unknown` --->  `int`\n  *  **`index_of`** (`species` , `unknown`) --->  `int` \n\n#### Result: \nthe index of the first occurence of the right operand in the left operand container\nthe index of the first occurence of the right operand in the left operand container  \n\n#### Comment: \nThe definition of index_of and the type of the index depend on the container\n\n#### Special cases:     \n  * if the left operand is a map, index_of returns the index of a value or nil if the value is not mapped    \n  * if the left operator is a species, returns the index of an agent in a species. If the argument is not an agent of this species, returns -1. Use int(agent) instead    \n  * if the left operand is a list, index_of returns the index as an integer \n  \n```\nint var1 <- [1,2,3,4,5,6] index_of 4; \t// var1 equals 3\nint var2 <- [4,2,3,4,5,4] index_of 4; \t// var2 equals 0\n\n``` \n\n    \n  * if the left operand is a matrix, index_of returns the index as a point \n  \n```\npoint var3 <- matrix([[1,2,3],[4,5,6]]) index_of 4; \t// var3 equals {1.0,0.0}\n\n``` \n\n    \n  * if both operands are strings, returns the index within the left-hand string of the first occurrence of the given right-hand string \n  \n```\nint var4 <-  \"abcabcabc\" index_of \"ca\"; \t// var4 equals 2\n\n``` \n\n\n\n#### Examples: \n```\nunknown var0 <- [1::2, 3::4, 5::6] index_of 4; \t// var0 equals 3\n```\n      \n\n#### See also: \n[at](#at), [last_index_of](#last_index_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_inside)\n### `inside`\n\n#### Possible use: \n  * `container<agent>` **`inside`** `geometry` --->  `list<geometry>`\n  *  **`inside`** (`container<agent>` , `geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), covered by the operand (casted as a geometry).\n\n#### Examples: \n```\nlist<geometry> var0 <- [ag1, ag2, ag3] inside(self); \t// var0 equals the agents among ag1, ag2 and ag3 that are covered by the shape of the right-hand argument.\nlist<geometry> var1 <- (species1 + species2) inside (self); \t// var1 equals the agents among species species1 and species2 that are covered by the shape of the right-hand argument.\n```\n      \n\n#### See also: \n[neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [closest_to](#closest_to), [overlapping](#overlapping), [agents_overlapping](#agents_overlapping), [agents_inside](#agents_inside), [agent_closest_to](#agent_closest_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_int)\n### `int`\n\n#### Possible use: \n  *  **`int`** (`any`) --->  `int` \n\n#### Result: \nCasts the operand into the type int\n    \t\n----\n\n\n[//]: # (keyword|operator_inter)\n### `inter`\n\n#### Possible use: \n  * `container` **`inter`** `container` --->  `container`\n  *  **`inter`** (`container` , `container`) --->  `container`\n  * `geometry` **`inter`** `geometry` --->  `geometry`\n  *  **`inter`** (`geometry` , `geometry`) --->  `geometry` \n\n#### Result: \nthe intersection of the two operands\nA geometry resulting from the intersection between the two geometries  \n\n#### Comment: \nboth containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.\n\n#### Special cases:     \n  * if an operand is a graph, it will be transformed into the set of its nodes    \n  * returns nil if one of the operands is nil    \n  * if an operand is a map, it will be transformed into the set of its values \n  \n```\ncontainer var0 <- [1::2, 3::4, 5::6] inter [2,4]; \t// var0 equals [2,4]\ncontainer var1 <- [1::2, 3::4, 5::6] inter [1,3]; \t// var1 equals []\n\n``` \n\n    \n  * if an operand is a matrix, it will be transformed into the set of the lines \n  \n```\ncontainer var2 <- matrix([[1,2,3],[4,5,4]]) inter [3,4]; \t// var2 equals [3,4]\n\n``` \n\n\n\n#### Examples: \n```\ncontainer var3 <- [1,2,3,4,5,6] inter [2,4]; \t// var3 equals [2,4]\ncontainer var4 <- [1,2,3,4,5,6] inter [0,8]; \t// var4 equals []\ngeometry var5 <- square(10) inter circle(5); \t// var5 equals circle(5)\n```\n      \n\n#### See also: \n[remove_duplicates](#remove_duplicates), [union](#union), [+](#+), [-](#-), \n    \t\n----\n\n\n[//]: # (keyword|operator_interleave)\n### `interleave`\n\n#### Possible use: \n  *  **`interleave`** (`container`) --->  `container` \n\n#### Result: \na new list containing the interleaved elements of the containers contained in the operand  \n\n#### Comment: \nthe operand should be a list of lists of elements. The result is a list of elements.\n\n#### Examples: \n```\ncontainer var0 <- interleave([1,2,4,3,5,7,6,8]); \t// var0 equals [1,2,4,3,5,7,6,8]\ncontainer var1 <- interleave([['e11','e12','e13'],['e21','e22','e23'],['e31','e32','e33']]); \t// var1 equals ['e11','e21','e31','e12','e22','e32','e13','e23','e33']\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_internal_at)\n### `internal_at`\n\n#### Possible use: \n  * `agent` **`internal_at`** `container` --->  `unknown`\n  *  **`internal_at`** (`agent` , `container`) --->  `unknown`\n  * `geometry` **`internal_at`** `container` --->  `unknown`\n  *  **`internal_at`** (`geometry` , `container`) --->  `unknown`\n  * `container<KeyType,ValueType>` **`internal_at`** `list<KeyType>` --->  `ValueType`\n  *  **`internal_at`** (`container<KeyType,ValueType>` , `list<KeyType>`) --->  `ValueType` \n\n#### Result: \nFor internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]\nFor internal use only. Corresponds to the implementation, for geometries, of the access to containers with [index]\nFor internal use only. Corresponds to the implementation of the access to containers with [index]    \n\n#### See also: \n[at](#at), \n    \t\n----\n\n\n[//]: # (keyword|operator_internal_integrated_value)\n### `internal_integrated_value`\n\n#### Possible use: \n  * `any expression` **`internal_integrated_value`** `any expression` --->  `container`\n  *  **`internal_integrated_value`** (`any expression` , `any expression`) --->  `container` \n\n#### Result: \nFor internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]\n    \t\n----\n\n\n[//]: # (keyword|operator_internal_zero_order_equation)\n### `internal_zero_order_equation`\n\n#### Possible use: \n  *  **`internal_zero_order_equation`** (`any expression`) --->  `float`\n    \t\n----\n\n\n[//]: # (keyword|operator_intersection)\n### `intersection`\nSame signification as [inter](#inter)\n    \t\n----\n\n\n[//]: # (keyword|operator_intersects)\n### `intersects`\n\n#### Possible use: \n  * `geometry` **`intersects`** `geometry` --->  `bool`\n  *  **`intersects`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.\n\n#### Examples: \n```\nbool var0 <- square(5) intersects {10,10}; \t// var0 equals false\n```\n      \n\n#### See also: \n[disjoint_from](#disjoint_from), [crosses](#crosses), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [touches](#touches), \n    \t\n----\n\n\n[//]: # (keyword|operator_inverse)\n### `inverse`\n\n#### Possible use: \n  *  **`inverse`** (`matrix`) --->  `matrix<float>` \n\n#### Result: \nThe inverse matrix of the given matrix. If no inverse exists, returns a matrix that has properties that resemble that of an inverse.\n\n#### Examples: \n```\nmatrix<float> var0 <- inverse(matrix([[5,-3],[6,-4]])); \t// var0 equals [2.0000000000000004,-0.9999999999999998]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_inverse_distance_weighting)\n### `inverse_distance_weighting`\nSame signification as [IDW](#idw)\n    \t\n----\n\n\n[//]: # (keyword|operator_is)\n### `is`\n\n#### Possible use: \n  * `unknown` **`is`** `any expression` --->  `bool`\n  *  **`is`** (`unknown` , `any expression`) --->  `bool` \n\n#### Result: \nreturns true if the left operand is of the right operand type, false otherwise\n\n#### Examples: \n```\nbool var0 <- 0 is int; \t// var0 equals true\nbool var1 <- an_agent is node; \t// var1 equals true\nbool var2 <- 1 is float; \t// var2 equals false\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_is_csv)\n### `is_csv`\n\n#### Possible use: \n  *  **`is_csv`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a csv file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_dxf)\n### `is_dxf`\n\n#### Possible use: \n  *  **`is_dxf`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a dxf file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_finite)\n### `is_finite`\n\n#### Possible use: \n  *  **`is_finite`** (`float`) --->  `bool` \n\n#### Result: \nReturns whether the argument is a finite number or not\n\n#### Examples: \n```\nbool var0 <- is_finite(4.66); \t// var0 equals true\nbool var1 <- is_finite(#infinity); \t// var1 equals false\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_is_gaml)\n### `is_gaml`\n\n#### Possible use: \n  *  **`is_gaml`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a gaml file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_geojson)\n### `is_geojson`\n\n#### Possible use: \n  *  **`is_geojson`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a geojson file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_gif)\n### `is_gif`\n\n#### Possible use: \n  *  **`is_gif`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a gif file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_grid)\n### `is_grid`\n\n#### Possible use: \n  *  **`is_grid`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a grid file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_image)\n### `is_image`\n\n#### Possible use: \n  *  **`is_image`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a image file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_json)\n### `is_json`\n\n#### Possible use: \n  *  **`is_json`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a json file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_number)\n### `is_number`\n\n#### Possible use: \n  *  **`is_number`** (`string`) --->  `bool`\n  *  **`is_number`** (`float`) --->  `bool` \n\n#### Result: \ntests whether the operand represents a numerical value\nReturns whether the argument is a real number or not  \n\n#### Comment: \nNote that the symbol . should be used for a float value (a string with , will not be considered as a numeric value). Symbols e and E are also accepted. A hexadecimal value should begin with #.\n\n#### Examples: \n```\nbool var0 <- is_number(\"test\"); \t// var0 equals false\nbool var1 <- is_number(\"123.56\"); \t// var1 equals true\nbool var2 <- is_number(\"-1.2e5\"); \t// var2 equals true\nbool var3 <- is_number(\"1,2\"); \t// var3 equals false\nbool var4 <- is_number(\"#12FA\"); \t// var4 equals true\nbool var5 <- is_number(4.66); \t// var5 equals true\nbool var6 <- is_number(#infinity); \t// var6 equals true\nbool var7 <- is_number(#nan); \t// var7 equals false\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_is_obj)\n### `is_obj`\n\n#### Possible use: \n  *  **`is_obj`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a obj file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_osm)\n### `is_osm`\n\n#### Possible use: \n  *  **`is_osm`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a osm file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_pgm)\n### `is_pgm`\n\n#### Possible use: \n  *  **`is_pgm`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a pgm file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_property)\n### `is_property`\n\n#### Possible use: \n  *  **`is_property`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a property file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_R)\n### `is_R`\n\n#### Possible use: \n  *  **`is_R`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a R file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_shape)\n### `is_shape`\n\n#### Possible use: \n  *  **`is_shape`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a shape file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_skill)\n### `is_skill`\n\n#### Possible use: \n  * `unknown` **`is_skill`** `string` --->  `bool`\n  *  **`is_skill`** (`unknown` , `string`) --->  `bool` \n\n#### Result: \nreturns true if the left operand is an agent whose species implements the right-hand skill name\n\n#### Examples: \n```\nbool var0 <- agentA is_skill 'moving'; \t// var0 equals true\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_is_svg)\n### `is_svg`\n\n#### Possible use: \n  *  **`is_svg`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a svg file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_text)\n### `is_text`\n\n#### Possible use: \n  *  **`is_text`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a text file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_threeds)\n### `is_threeds`\n\n#### Possible use: \n  *  **`is_threeds`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a threeds file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_URL)\n### `is_URL`\n\n#### Possible use: \n  *  **`is_URL`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a URL file.\n    \t\n----\n\n\n[//]: # (keyword|operator_is_xml)\n### `is_xml`\n\n#### Possible use: \n  *  **`is_xml`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a xml file.\n    \t\n----\n\n\n[//]: # (keyword|operator_json_file)\n### `json_file`\n\n#### Possible use: \n  *  **`json_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type json. Allowed extensions are limited to json\n    \t\n----\n\n\n[//]: # (keyword|operator_kappa)\n### `kappa`\n\n#### Possible use: \n  *  **`kappa`** (`list`, `list`, `list`) --->  `float`\n  *  **`kappa`** (`list`, `list`, `list`, `list`) --->  `float` \n\n#### Result: \nkappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.\nkappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.\n\n#### Examples: \n```\nkappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3])\nfloat var1 <- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]); \t// var1 equals the similarity between 0 and 1\nfloat var2 <- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]); \t// var2 equals 1.0\nkappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_kappa_sim)\n### `kappa_sim`\n\n#### Possible use: \n  *  **`kappa_sim`** (`list`, `list`, `list`, `list`) --->  `float`\n  *  **`kappa_sim`** (`list`, `list`, `list`, `list`, `list`) --->  `float` \n\n#### Result: \nkappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8).\nkappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8)\n\n#### Examples: \n```\nkappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3])\nkappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_kmeans)\n### `kmeans`\n\n#### Possible use: \n  * `list` **`kmeans`** `int` --->  `list<list>`\n  *  **`kmeans`** (`list` , `int`) --->  `list<list>`\n  *  **`kmeans`** (`list`, `int`, `int`) --->  `list<list>` \n\n#### Result: \nreturns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k) and the maximum number of iterations to run the algorithm for (If negative, no maximum will be used) (maxIt). Usage: kmeans(data,k,maxit)\nreturns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k). Usage: kmeans(data,k)\n\n#### Special cases:     \n  * if the lengths of two vectors in the right-hand aren't equal, returns 0    \n  * if the lengths of two vectors in the right-hand aren't equal, returns 0\n\n#### Examples: \n```\nkmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2,10)\nkmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_kurtosis)\n### `kurtosis`\n\n#### Possible use: \n  *  **`kurtosis`** (`list`) --->  `float` \n\n#### Result: \nreturns kurtosis value computed from the operand list of values\n\n#### Special cases:     \n  * if the length of the list is lower than 3, returns NaN\n\n#### Examples: \n```\nkurtosis ([1,2,3,4,5])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_last)\n### `last`\n\n#### Possible use: \n  *  **`last`** (`string`) --->  `string`\n  *  **`last`** (`container<KeyType,ValueType>`) --->  `ValueType`\n  * `int` **`last`** `container` --->  `container`\n  *  **`last`** (`int` , `container`) --->  `container` \n\n#### Result: \nthe last element of the operand  \n\n#### Comment: \nthe last operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a map, last returns the value of the last pair (in insertion order)    \n  * if it is a file, last returns the last element of the content of the file (that is also a container)    \n  * if it is a population, last returns the last agent of the population    \n  * if it is a graph, last returns a list containing the last edge created    \n  * if it is a matrix, last returns the element at {length-1,length-1} in the matrix    \n  * for a matrix of int or float, it will return 0 if the matrix is empty    \n  * for a matrix of object or geometry, it will return nil if the matrix is empty    \n  * if it is a string, last returns a string composed of its last character, or an empty string if the operand is empty \n  \n```\nstring var0 <- last ('abce'); \t// var0 equals 'e'\n\n``` \n\n    \n  * if it is a list, last returns the last element of the list, or nil if the list is empty \n  \n```\nint var1 <- last ([1, 2, 3]); \t// var1 equals 3\n\n``` \n\n    \n\n#### See also: \n[first](#first), \n    \t\n----\n\n\n[//]: # (keyword|operator_last_index_of)\n### `last_index_of`\n\n#### Possible use: \n  * `map` **`last_index_of`** `unknown` --->  `unknown`\n  *  **`last_index_of`** (`map` , `unknown`) --->  `unknown`\n  * `string` **`last_index_of`** `string` --->  `int`\n  *  **`last_index_of`** (`string` , `string`) --->  `int`\n  * `species` **`last_index_of`** `unknown` --->  `int`\n  *  **`last_index_of`** (`species` , `unknown`) --->  `int`\n  * `container` **`last_index_of`** `unknown` --->  `int`\n  *  **`last_index_of`** (`container` , `unknown`) --->  `int`\n  * `matrix` **`last_index_of`** `unknown` --->  `point`\n  *  **`last_index_of`** (`matrix` , `unknown`) --->  `point` \n\n#### Result: \nthe index of the last occurence of the right operand in the left operand container  \n\n#### Comment: \nThe definition of last_index_of and the type of the index depend on the container\n\n#### Special cases:     \n  * if the left operand is a species, the last index of an agent is the same as its index    \n  * if the left operand is a map, last_index_of returns the index as an int (the key of the pair) \n  \n```\nunknown var0 <- [1::2, 3::4, 5::4] last_index_of 4; \t// var0 equals 5\n\n``` \n\n    \n  * if both operands are strings, returns the index within the left-hand string of the rightmost occurrence of the given right-hand string \n  \n```\nint var1 <- \"abcabcabc\" last_index_of \"ca\"; \t// var1 equals 5\n\n``` \n\n    \n  * if the left operand is a list, last_index_of returns the index as an integer \n  \n```\nint var2 <- [1,2,3,4,5,6] last_index_of 4; \t// var2 equals 3\nint var3 <- [4,2,3,4,5,4] last_index_of 4; \t// var3 equals 5\n\n``` \n\n    \n  * if the left operand is a matrix, last_index_of returns the index as a point \n  \n```\npoint var4 <- matrix([[1,2,3],[4,5,4]]) last_index_of 4; \t// var4 equals {1.0,2.0}\n\n``` \n\n    \n\n#### See also: \n[at](#at), [index_of](#index_of), [last_index_of](#last_index_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_last_of)\n### `last_of`\nSame signification as [last](#last)\n    \t\n----\n\n\n[//]: # (keyword|operator_last_with)\n### `last_with`\n\n#### Possible use: \n  * `container` **`last_with`** `any expression` --->  `unknown`\n  *  **`last_with`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe last element of the left-hand operand that makes the right-hand operand evaluate to true.  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, last_with throws an error.    \n  * If there is no element that satisfies the condition, it returns nil    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var4 <- [1::2, 3::4, 5::6] last_with (each >= 4); \t// var4 equals 6\nunknown var5 <- [1::2, 3::4, 5::6].pairs last_with (each.value >= 4); \t// var5 equals 5::6\n\n``` \n\n\n\n#### Examples: \n```\nunknown var0 <- [1,2,3,4,5,6,7,8] last_with (each > 3); \t// var0 equals 8\nunknown var2 <- g2 last_with (length(g2 out_edges_of each) = 0 ); \t// var2 equals node11\nunknown var3 <- (list(node) last_with (round(node(each).location.x) > 32); \t// var3 equals node3\n```\n      \n\n#### See also: \n[group_by](#group_by), [first_with](#first_with), [where](#where), \n    \t\n----\n\n\n[//]: # (keyword|operator_layout)\n### `layout`\n\n#### Possible use: \n  * `graph` **`layout`** `string` --->  `graph`\n  *  **`layout`** (`graph` , `string`) --->  `graph`\n  *  **`layout`** (`graph`, `string`, `int`) --->  `graph`\n  *  **`layout`** (`graph`, `string`, `int`, `map<string,unknown>`) --->  `graph` \n\n#### Result: \nlayouts a GAMA graph.\n    \t\n----\n\n\n[//]: # (keyword|operator_length)\n### `length`\n\n#### Possible use: \n  *  **`length`** (`string`) --->  `int`\n  *  **`length`** (`container<KeyType,ValueType>`) --->  `int` \n\n#### Result: \nthe number of elements contained in the operand  \n\n#### Comment: \nthe length operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a population, length returns number of agents of the population    \n  * if it is a graph, length returns the number of vertexes or of edges (depending on the way it was created)    \n  * if it is a string, length returns the number of characters \n  \n```\nint var0 <- length ('I am an agent'); \t// var0 equals 13\n\n``` \n\n    \n  * if it is a list or a map, length returns the number of elements in the list or map \n  \n```\nint var1 <- length([12,13]); \t// var1 equals 2\nint var2 <- length([]); \t// var2 equals 0\n\n``` \n\n    \n  * if it is a matrix, length returns the number of cells \n  \n```\nint var3 <- length(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var3 equals 6\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_line)\n### `line`\n\n#### Possible use: \n  *  **`line`** (`container<geometry>`) --->  `geometry`\n  * `container<geometry>` **`line`** `float` --->  `geometry`\n  *  **`line`** (`container<geometry>` , `float`) --->  `geometry` \n\n#### Result: \nA polyline geometry from the given list of points represented as a cylinder of radius r.\nA polyline geometry from the given list of points.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry.    \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry.    \n  * if a radius is added, the given list of points represented as a cylinder of radius r \n  \n```\ngeometry var0 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}],0.2); \t// var0 equals a polyline geometry composed of the 4 points.\n\n``` \n\n\n\n#### Examples: \n```\ngeometry var1 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var1 equals a polyline geometry composed of the 4 points.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [link](#link), [norm](#norm), [point](#point), [polygone](#polygone), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_link)\n### `link`\n\n#### Possible use: \n  * `geometry` **`link`** `geometry` --->  `geometry`\n  *  **`link`** (`geometry` , `geometry`) --->  `geometry` \n\n#### Result: \nA dynamic line geometry between the location of the two operands  \n\n#### Comment: \nThe geometry of the link is a line between the locations of the two operands, which is built and maintained dynamically\n\n#### Special cases:     \n  * if one of the operands is nil, link returns a point geometry at the location of the other. If both are null, it returns a point geometry at {0,0}\n\n#### Examples: \n```\ngeometry var0 <- link (geom1,geom2); \t// var0 equals a link geometry between geom1 and geom2.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [line](#line), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_list)\n### `list`\n\n#### Possible use: \n  *  **`list`** (`any`) --->  `list` \n\n#### Result: \nCasts the operand into the type list\n    \t\n----\n\n\n[//]: # (keyword|operator_list_with)\n### `list_with`\n\n#### Possible use: \n  * `int` **`list_with`** `any expression` --->  `container`\n  *  **`list_with`** (`int` , `any expression`) --->  `container` \n\n#### Result: \ncreates a list with a size provided by the first operand, and filled with the second operand  \n\n#### Comment: \nNote that the right operand  should be positive, and that the second one is evaluated for each position  in the list.    \n\n#### See also: \n[list](#list), \n    \t\n----\n\n\n[//]: # (keyword|operator_ln)\n### `ln`\n\n#### Possible use: \n  *  **`ln`** (`int`) --->  `float`\n  *  **`ln`** (`float`) --->  `float` \n\n#### Result: \nReturns the natural logarithm (base e) of the operand.\n\n#### Special cases:     \n  * an exception is raised if the operand is less than zero.\n\n#### Examples: \n```\nfloat var0 <- ln(1); \t// var0 equals 0.0\nfloat var1 <- ln(exp(1)); \t// var1 equals 1.0\n```\n      \n\n#### See also: \n[exp](#exp), \n    \t\n----\n\n\n[//]: # (keyword|operator_load_graph_from_file)\n### `load_graph_from_file`\n\n#### Possible use: \n  *  **`load_graph_from_file`** (`string`) --->  `graph`\n  * `string` **`load_graph_from_file`** `file` --->  `graph`\n  *  **`load_graph_from_file`** (`string` , `file`) --->  `graph`\n  * `string` **`load_graph_from_file`** `string` --->  `graph`\n  *  **`load_graph_from_file`** (`string` , `string`) --->  `graph`\n  *  **`load_graph_from_file`** (`string`, `species`, `species`) --->  `graph`\n  *  **`load_graph_from_file`** (`string`, `file`, `species`, `species`) --->  `graph`\n  *  **`load_graph_from_file`** (`string`, `string`, `species`, `species`) --->  `graph`\n  *  **`load_graph_from_file`** (`string`, `string`, `species`, `species`, `bool`) --->  `graph` \n\n#### Result: \nloads a graph from a file\nreturns a graph loaded from a given file encoded into a given format. The last boolean parameter indicates whether the resulting graph will be considered as spatial or not by GAMA  \n\n#### Comment: \nAvailable formats: \"pajek\": Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.\"lgl\": LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.\"dot\": DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.\"edge\": This format is a simple text file with numeric vertex ids defining the edges.\"gexf\": GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.\"graphml\": GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details.\"tlp\" or \"tulip\": TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details. \"ncol\": This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:Available formats: \"pajek\": Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.\"lgl\": LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.\"dot\": DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.\"edge\": This format is a simple text file with numeric vertex ids defining the edges.\"gexf\": GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.\"graphml\": GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details.\"tlp\" or \"tulip\": TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details. \"ncol\": This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:\n\n#### Special cases:     \n  * \"format\": the format of the file    \n  * \"filename\": the filename of the file containing the network    \n  * \"edges_species\": the species of edges    \n  * \"vertices_specy\": the species of vertices    \n  * \"format\": the format of the file    \n  * \"filename\": the filename of the file containing the network    \n  * \"edges_species\": the species of edges    \n  * \"vertices_specy\": the species of vertices    \n  * \"format\": the format of the file, \"file\": the file containing the network, \"edges_species\": the species of edges, \"vertices_specy\": the species of vertices \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"example_of_Pajek_file\",\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy );\n\n``` \n\n    \n  * \"filename\": the filename of the file containing the network, \"edges_species\": the species of edges, \"vertices_specy\": the species of vertices \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"./example_of_Pajek_file\",\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy );\n\n``` \n\n    \n  * \"file\": the file containing the network \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"example_of_Pajek_file\");\n\n``` \n\n    \n  * \"format\": the format of the file, \"file\": the file containing the network \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"example_of_Pajek_file\");\n\n``` \n\n    \n  * \"format\": the format of the file, \"filename\": the filename of the file containing the network \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"example_of_Pajek_file\");\n\n``` \n\n\n\n#### Examples: \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"./example_of_Pajek_file\",\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"./example_of_Pajek_file\",\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy , true);\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_load_shortest_paths)\n### `load_shortest_paths`\n\n#### Possible use: \n  * `graph` **`load_shortest_paths`** `matrix` --->  `graph`\n  *  **`load_shortest_paths`** (`graph` , `matrix`) --->  `graph` \n\n#### Result: \nput in the graph cache the computed shortest paths contained in the matrix (rows: source, columns: target)\n\n#### Examples: \n```\ngraph var0 <- load_shortest_paths(shortest_paths_matrix); \t// var0 equals return my_graph with all the shortest paths computed\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_log)\n### `log`\n\n#### Possible use: \n  *  **`log`** (`float`) --->  `float`\n  *  **`log`** (`int`) --->  `float` \n\n#### Result: \nReturns the logarithm (base 10) of the operand.\n\n#### Special cases:     \n  * an exception is raised if the operand is equals or less than zero.\n\n#### Examples: \n```\nfloat var0 <- log(10); \t// var0 equals 1.0\nfloat var1 <- log(1); \t// var1 equals 0.0\n```\n      \n\n#### See also: \n[ln](#ln), \n    \t\n----\n\n\n[//]: # (keyword|operator_lower_case)\n### `lower_case`\n\n#### Possible use: \n  *  **`lower_case`** (`string`) --->  `string` \n\n#### Result: \nConverts all of the characters in the string operand to lower case\n\n#### Examples: \n```\nstring var0 <- lower_case(\"Abc\"); \t// var0 equals 'abc'\n```\n      \n\n#### See also: \n[upper_case](#upper_case), \n    \t\n----\n\n\n[//]: # (keyword|operator_map)\n### `map`\n\n#### Possible use: \n  *  **`map`** (`any`) --->  `map` \n\n#### Result: \nCasts the operand into the type map\n    \t\n----\n\n\n[//]: # (keyword|operator_masked_by)\n### `masked_by`\n\n#### Possible use: \n  * `geometry` **`masked_by`** `container<geometry>` --->  `geometry`\n  *  **`masked_by`** (`geometry` , `container<geometry>`) --->  `geometry`\n  *  **`masked_by`** (`geometry`, `container<geometry>`, `int`) --->  `geometry`\n\n#### Examples: \n```\ngeometry var0 <- perception_geom masked_by obstacle_list; \t// var0 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.\ngeometry var1 <- perception_geom masked_by obstacle_list; \t// var1 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_material)\n### `material`\n\n#### Possible use: \n  * `float` **`material`** `float` --->  `msi.gama.util.GamaMaterial`\n  *  **`material`** (`float` , `float`) --->  `msi.gama.util.GamaMaterial` \n\n#### Result: \nReturns\n\n#### Examples: \n```\n\n```\n      \n\n#### See also: \n[](#), \n    \t\n----\n\n\n[//]: # (keyword|operator_matrix)\n### `matrix`\n\n#### Possible use: \n  *  **`matrix`** (`any`) --->  `matrix` \n\n#### Result: \nCasts the operand into the type matrix\n    \t\n----\n\n\n[//]: # (keyword|operator_matrix_with)\n### `matrix_with`\n\n#### Possible use: \n  * `point` **`matrix_with`** `any expression` --->  `matrix`\n  *  **`matrix_with`** (`point` , `any expression`) --->  `matrix` \n\n#### Result: \ncreates a matrix with a size provided by the first operand, and filled with the second operand  \n\n#### Comment: \nNote that both components of the right operand point should be positive, otherwise an exception is raised.    \n\n#### See also: \n[matrix](#matrix), [as_matrix](#as_matrix), \n    \t\n----\n\n\n[//]: # (keyword|operator_max)\n### `max`\n\n#### Possible use: \n  *  **`max`** (`container`) --->  `unknown` \n\n#### Result: \nthe maximum element found in the operand  \n\n#### Comment: \nthe max operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them    \n  * if it is a map, max returns the maximum among the list of all elements value    \n  * if it is a file, max returns the maximum of the content of the file (that is also a container)    \n  * if it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)    \n  * if it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices)    \n  * if it is a matrix of geometry, max returns the maximum of the list of the geometries    \n  * if it is a matrix of another type, max returns the maximum of the elements transformed into float    \n  * if it is a list of int of float, max returns the maximum of all the elements \n  \n```\nunknown var0 <- max ([100, 23.2, 34.5]); \t// var0 equals 100.0\n\n``` \n\n    \n  * if it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. ) \n  \n```\nunknown var1 <- max([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); \t// var1 equals {9.0,1.0}\n\n``` \n\n    \n\n#### See also: \n[min](#min), \n    \t\n----\n\n\n[//]: # (keyword|operator_max_of)\n### `max_of`\n\n#### Possible use: \n  * `container` **`max_of`** `any expression` --->  `unknown`\n  *  **`max_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe maximum value of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * As of GAMA 1.6, if the left-hand operand is nil or empty, max_of throws an error    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var5 <- [1::2, 3::4, 5::6] max_of (each + 3); \t// var5 equals 6\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2,4,3,5,7,6,8] max_of (each * 100 ); \t// var1 equals 800\ngraph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nunknown var3 <- g2.vertices max_of (g2 degree_of( each )); \t// var3 equals 2\nunknown var4 <- (list(node) max_of (round(node(each).location.x)); \t// var4 equals 96\n```\n      \n\n#### See also: \n[min_of](#min_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_maximal_cliques_of)\n### `maximal_cliques_of`\n\n#### Possible use: \n  *  **`maximal_cliques_of`** (`graph`) --->  `list<list>` \n\n#### Result: \nreturns the maximal cliques of a graph using the Bron-Kerbosch clique detection algorithm: A clique is maximal if it is impossible to enlarge it by adding another vertex from the graph. Note that a maximal clique is not necessarily the biggest clique in the graph.\n\n#### Examples: \n```\ngraph my_graph <- graph([]);\nlist<list> var1 <- maximal_cliques_of (my_graph); \t// var1 equals the list of all the maximal cliques as list\n```\n      \n\n#### See also: \n[biggest_cliques_of](#biggest_cliques_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_mean)\n### `mean`\n\n#### Possible use: \n  *  **`mean`** (`container`) --->  `unknown` \n\n#### Result: \nthe mean of all the elements of the operand  \n\n#### Comment: \nthe elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.\n\n#### Special cases:     \n  * if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color\n\n#### Examples: \n```\nunknown var0 <- mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 5.125 \n```\n      \n\n#### See also: \n[sum](#sum), \n    \t\n----\n\n\n[//]: # (keyword|operator_mean_deviation)\n### `mean_deviation`\n\n#### Possible use: \n  *  **`mean_deviation`** (`container`) --->  `float` \n\n#### Result: \nthe deviation from the mean of all the elements of the operand. See <A href= \"http://en.wikipedia.org/wiki/Absolute_deviation\" >Mean_deviation</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- mean_deviation ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.125\n```\n      \n\n#### See also: \n[mean](#mean), [standard_deviation](#standard_deviation), \n    \t\n----\n\n\n[//]: # (keyword|operator_mean_of)\n### `mean_of`\n\n#### Possible use: \n  * `container` **`mean_of`** `any expression` --->  `unknown`\n  *  **`mean_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe mean of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var2 <- [1::2, 3::4, 5::6] mean_of (each); \t// var2 equals 4\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2] mean_of (each * 10 ); \t// var1 equals 15\n```\n      \n\n#### See also: \n[min_of](#min_of), [max_of](#max_of), [sum_of](#sum_of), [product_of](#product_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_meanR)\n### `meanR`\n\n#### Possible use: \n  *  **`meanR`** (`container`) --->  `unknown` \n\n#### Result: \nreturns the mean value of given vector (right-hand operand) in given variable  (left-hand operand).\n\n#### Examples: \n```\nlist<int> X <- [2, 3, 1];\nint var1 <- meanR(X); \t// var1 equals 2\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_median)\n### `median`\n\n#### Possible use: \n  *  **`median`** (`container`) --->  `unknown` \n\n#### Result: \nthe median of all the elements of the operand.\n\n#### Special cases:     \n  * if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color\n\n#### Examples: \n```\nunknown var0 <- median ([4.5, 3.5, 5.5, 3.4, 7.0]); \t// var0 equals 5.0\n```\n      \n\n#### See also: \n[mean](#mean), \n    \t\n----\n\n\n[//]: # (keyword|operator_message)\n### `message`\n\n#### Possible use: \n  *  **`message`** (`unknown`) --->  `msi.gama.extensions.messaging.GamaMessage` \n\n#### Result: \nto be added\n    \t\n----\n\n\n[//]: # (keyword|operator_milliseconds_between)\n### `milliseconds_between`\n\n#### Possible use: \n  * `date` **`milliseconds_between`** `date` --->  `float`\n  *  **`milliseconds_between`** (`date` , `date`) --->  `float` \n\n#### Result: \nProvide the exact number of milliseconds between two dates. This number can be positive or negative (if the second operand is smaller than the first one)\n\n#### Examples: \n```\nmilliseconds_between(d1, d2) -: 10 \n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_min)\n### `min`\n\n#### Possible use: \n  *  **`min`** (`container`) --->  `unknown` \n\n#### Result: \nthe minimum element found in the operand.  \n\n#### Comment: \nthe min operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )    \n  * if it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them    \n  * if it is a map, min returns the minimum among the list of all elements value    \n  * if it is a file, min returns the minimum of the content of the file (that is also a container)    \n  * if it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)    \n  * if it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices)    \n  * if it is a matrix of geometry, min returns the minimum of the list of the geometries    \n  * if it is a matrix of another type, min returns the minimum of the elements transformed into float    \n  * if it is a list of int or float: min returns the minimum of all the elements \n  \n```\nunknown var0 <- min ([100, 23.2, 34.5]); \t// var0 equals 23.2\n\n``` \n\n    \n\n#### See also: \n[max](#max), \n    \t\n----\n\n\n[//]: # (keyword|operator_min_of)\n### `min_of`\n\n#### Possible use: \n  * `container` **`min_of`** `any expression` --->  `unknown`\n  *  **`min_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe minimum value of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil or empty, min_of throws an error    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var5 <- [1::2, 3::4, 5::6] min_of (each + 3); \t// var5 equals 5\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2,4,3,5,7,6,8] min_of (each * 100 ); \t// var1 equals 100\ngraph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nunknown var3 <- g2 min_of (length(g2 out_edges_of each) ); \t// var3 equals 0\nunknown var4 <- (list(node) min_of (round(node(each).location.x)); \t// var4 equals 4\n```\n      \n\n#### See also: \n[max_of](#max_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_minus_days)\n### `minus_days`\n\n#### Possible use: \n  * `date` **`minus_days`** `int` --->  `date`\n  *  **`minus_days`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of days from a date\n\n#### Examples: \n```\ndate1 minus_days 20\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_minus_hours)\n### `minus_hours`\n\n#### Possible use: \n  * `date` **`minus_hours`** `int` --->  `date`\n  *  **`minus_hours`** (`date` , `int`) --->  `date` \n\n#### Result: \nRemove a given number of hours from a date\n\n#### Examples: \n```\ndate1 minus_hours 15 // equivalent to date1 - 15 #h\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_minus_minutes)\n### `minus_minutes`\n\n#### Possible use: \n  * `date` **`minus_minutes`** `int` --->  `date`\n  *  **`minus_minutes`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of minutes from a date\n\n#### Examples: \n```\ndate1 minus_minutes 5 // equivalent to date1 - 5#mn\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_minus_months)\n### `minus_months`\n\n#### Possible use: \n  * `date` **`minus_months`** `int` --->  `date`\n  *  **`minus_months`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of months from a date\n\n#### Examples: \n```\ndate1 minus_months 5\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_minus_ms)\n### `minus_ms`\n\n#### Possible use: \n  * `date` **`minus_ms`** `int` --->  `date`\n  *  **`minus_ms`** (`date` , `int`) --->  `date` \n\n#### Result: \nRemove a given number of milliseconds from a date\n\n#### Examples: \n```\ndate1 minus_ms 15 // equivalent to date1 - 15 #ms\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_minus_seconds)\n### `minus_seconds`\nSame signification as [-](#-)\n    \t\n----\n\n\n[//]: # (keyword|operator_minus_weeks)\n### `minus_weeks`\n\n#### Possible use: \n  * `date` **`minus_weeks`** `int` --->  `date`\n  *  **`minus_weeks`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of weeks from a date\n\n#### Examples: \n```\ndate1 minus_weeks 15\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_minus_years)\n### `minus_years`\n\n#### Possible use: \n  * `date` **`minus_years`** `int` --->  `date`\n  *  **`minus_years`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of year from a date\n\n#### Examples: \n```\ndate1 minus_years 3\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_mod)\n### `mod`\n\n#### Possible use: \n  * `int` **`mod`** `int` --->  `int`\n  *  **`mod`** (`int` , `int`) --->  `int` \n\n#### Result: \nReturns the remainder of the integer division of the left-hand operand by the right-hand operand.\n\n#### Special cases:     \n  * if operands are float, they are truncated    \n  * if the right-hand operand is equal to zero, raises an exception.\n\n#### Examples: \n```\nint var0 <- 40 mod 3; \t// var0 equals 1\n```\n      \n\n#### See also: \n[div](#div), \n    \t\n----\n\n\n[//]: # (keyword|operator_months_between)\n### `months_between`\n\n#### Possible use: \n  * `date` **`months_between`** `date` --->  `int`\n  *  **`months_between`** (`date` , `date`) --->  `int` \n\n#### Result: \nProvide the exact number of months between two dates. This number can be positive or negative (if the second operand is smaller than the first one)\n\n#### Examples: \n```\nmonths_between(d1, d2) -: 10 \n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_moran)\n### `moran`\n\n#### Possible use: \n  * `list<float>` **`moran`** `matrix<float>` --->  `float`\n  *  **`moran`** (`list<float>` , `matrix<float>`) --->  `float`\n\n#### Special cases:     \n  * return the Moran Index of the given list of interest points (list of floats) and the weight matrix (matrix of float) \n  \n```\nfloat var0 <- moran([1.0, 0.5, 2.0], weight_matrix); \t// var0 equals the Moran index computed\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_mul)\n### `mul`\n\n#### Possible use: \n  *  **`mul`** (`container`) --->  `unknown` \n\n#### Result: \nthe product of all the elements of the operand  \n\n#### Comment: \nthe mul operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element)    \n  * if it is a list of other types: mul transforms all elements into integer and multiplies them    \n  * if it is a map, mul returns the product of the value of all elements    \n  * if it is a file, mul returns the product of the content of the file (that is also a container)    \n  * if it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)    \n  * if it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices)    \n  * if it is a matrix of geometry, mul returns the product of the list of the geometries    \n  * if it is a matrix of other types: mul transforms all elements into float and multiplies them    \n  * if it is a list of int or float: mul returns the product of all the elements \n  \n```\nunknown var0 <- mul ([100, 23.2, 34.5]); \t// var0 equals 80040.0\n\n``` \n\n    \n\n#### See also: \n[sum](#sum), \n    \t\n----\n\n\n[//]: # (keyword|operator_nb_cycles)\n### `nb_cycles`\n\n#### Possible use: \n  *  **`nb_cycles`** (`graph`) --->  `int` \n\n#### Result: \nreturns the maximum number of independent cycles in a graph. This number (u) is estimated through the number of nodes (v), links (e) and of sub-graphs (p): u = e - v + p.\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nint var1 <- nb_cycles(graphEpidemio); \t// var1 equals the number of cycles in the graph\n```\n      \n\n#### See also: \n[alpha_index](#alpha_index), [beta_index](#beta_index), [gamma_index](#gamma_index), [connectivity_index](#connectivity_index), \n    \t\n----\n\n\n[//]: # (keyword|operator_neighbors_at)\n### `neighbors_at`\n\n#### Possible use: \n  * `geometry` **`neighbors_at`** `float` --->  `container`\n  *  **`neighbors_at`** (`geometry` , `float`) --->  `container` \n\n#### Result: \na list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).  \n\n#### Comment: \nThe topology used to compute the neighborhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.\n\n#### Examples: \n```\ncontainer var0 <- (self neighbors_at (10)); \t// var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator.\n```\n      \n\n#### See also: \n[neighbors_of](#neighbors_of), [closest_to](#closest_to), [overlapping](#overlapping), [agents_overlapping](#agents_overlapping), [agents_inside](#agents_inside), [agent_closest_to](#agent_closest_to), [at_distance](#at_distance), \n    \t\n----\n\n\n[//]: # (keyword|operator_neighbors_of)\n### `neighbors_of`\n\n#### Possible use: \n  * `graph` **`neighbors_of`** `unknown` --->  `container`\n  *  **`neighbors_of`** (`graph` , `unknown`) --->  `container`\n  * `topology` **`neighbors_of`** `agent` --->  `container`\n  *  **`neighbors_of`** (`topology` , `agent`) --->  `container`\n  *  **`neighbors_of`** (`topology`, `geometry`, `float`) --->  `container` \n\n#### Result: \na list, containing all the agents of the same species than the argument (if it is an agent) located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.\n\n#### Special cases:     \n  * a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the third argument to the second argument (agent, geometry or point) considering the first operand topology. \n  \n```\ncontainer var3 <- neighbors_of (topology(self), self,10); \t// var3 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.\n\n``` \n\n\n\n#### Examples: \n```\ncontainer var0 <- graphEpidemio neighbors_of (node(3)); \t// var0 equals [node0,node2]\ncontainer var1 <- graphFromMap neighbors_of node({12,45}); \t// var1 equals [{1.0,5.0},{34.0,56.0}]\ncontainer var2 <- topology(self) neighbors_of self; \t// var2 equals returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology.\n```\n      \n\n#### See also: \n[predecessors_of](#predecessors_of), [successors_of](#successors_of), [neighbors_at](#neighbors_at), [closest_to](#closest_to), [overlapping](#overlapping), [agents_overlapping](#agents_overlapping), [agents_inside](#agents_inside), [agent_closest_to](#agent_closest_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_new_emotion)\n### `new_emotion`\n\n#### Possible use: \n  *  **`new_emotion`** (`string`) --->  `emotion`\n  * `string` **`new_emotion`** `agent` --->  `emotion`\n  *  **`new_emotion`** (`string` , `agent`) --->  `emotion`\n  * `string` **`new_emotion`** `float` --->  `emotion`\n  *  **`new_emotion`** (`string` , `float`) --->  `emotion`\n  * `string` **`new_emotion`** `predicate` --->  `emotion`\n  *  **`new_emotion`** (`string` , `predicate`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `predicate`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `float`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `predicate`, `agent`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `agent`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `float`, `agent`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `predicate`, `float`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `predicate`, `agent`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `predicate`, `float`, `agent`) --->  `emotion` \n\n#### Result: \na new emotion with the given properties (name)\na new emotion with the given properties (name)\na new emotion with the given properties (name,intensity,about)\na new emotion with the given properties (name,intensity,decay)\na new emotion with the given properties (name)\na new emotion with the given properties (name, intensity)\na new emotion with the given properties (name,about)\na new emotion with the given properties (name)\na new emotion with the given properties (name)\na new emotion with the given properties (name)\na new emotion with the given properties (name)\na new emotion with the given properties (name)\n\n#### Examples: \n```\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood)\nemotion(\"joy\",12.3,4)\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3)\nemotion(\"joy\",eatFood)\nemotion(\"joy\")\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood,4)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_new_folder)\n### `new_folder`\n\n#### Possible use: \n  *  **`new_folder`** (`string`) --->  `file` \n\n#### Result: \nopens an existing repository or create a new folder if it does not exist.\n\n#### Special cases:     \n  * If the specified string does not refer to an existing repository, the repository is created.    \n  * If the string refers to an existing file, an exception is risen.\n\n#### Examples: \n```\nfile dirNewT <- new_folder(\"incl/\");   \t// dirNewT represents the repository \"../incl/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// eventually creates the directory ../incl\n```\n      \n\n#### See also: \n[folder](#folder), [file](#file), \n    \t\n----\n\n\n[//]: # (keyword|operator_new_predicate)\n### `new_predicate`\n\n#### Possible use: \n  *  **`new_predicate`** (`string`) --->  `predicate`\n  * `string` **`new_predicate`** `agent` --->  `predicate`\n  *  **`new_predicate`** (`string` , `agent`) --->  `predicate`\n  * `string` **`new_predicate`** `float` --->  `predicate`\n  *  **`new_predicate`** (`string` , `float`) --->  `predicate`\n  * `string` **`new_predicate`** `int` --->  `predicate`\n  *  **`new_predicate`** (`string` , `int`) --->  `predicate`\n  * `string` **`new_predicate`** `map` --->  `predicate`\n  *  **`new_predicate`** (`string` , `map`) --->  `predicate`\n  * `string` **`new_predicate`** `bool` --->  `predicate`\n  *  **`new_predicate`** (`string` , `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `int`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `int`, `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `bool`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `int`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `int`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `int`, `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `int`, `bool`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `bool`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `int`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `int`, `bool`, `agent`) --->  `predicate` \n\n#### Result: \na new predicate with the given properties (name, values, lifetime, is_true)\na new predicate with the given properties (name, values, priority)\na new predicate with the given properties (name, values, priority, lifetime, is_true, agentCause)\na new predicate with the given properties (name, values, is_true, agentCause)\na new predicate with the given properties (name, values, lifetime)\na new predicate with the given properties (name, values, priority, lifetime, is_true)\na new predicate with the given properties (name, values, lifetime, is_true, agentCause)\na new predicate with the given is_true (name, priority)\na new predicate with the given is_true (name, lifetime)\na new predicate with the given properties (name, values)\na new predicate with the given properties (name, values, lifetime)\na new predicate with the given is_true (name, is_true)\na new predicate with the given properties (name, values, priority,lifetime)\na new predicate with the given properties (name, values, priority, is_true, agentCause)\na new predicate with the given properties (name, values, \tagentCause)\na new predicate with the given properties (name, values, lifetime, agentCause)\na new predicate with the given properties (name)\na new predicate with the given properties (name, values, priority, agentCause)\na new predicate with the given properties (name, values, priority, is_true)\na new predicate with the given properties (name, values, priority, lifetime, agentCause)\na new predicate with the given properties (name, values, is_true)\n\n#### Examples: \n```\npredicate(\"people to meet\", [\"time\"::10], 10,true)\npredicate(\"people to meet\", people1, [\"time\"::10])\npredicate(\"people to meet\", [\"time\"::10],2.0,10, true, agentA)\npredicate(\"people to meet\", [\"time\"::10], true, agentA)\npredicate(\"people to meet\", [\"time\"::10], true)\npredicate(\"people to meet\", [\"time\"::10],2.0,10, true)\npredicate(\"people to meet\", [\"time\"::10], 10, true, agentA)\npredicate(\"hasWater\", 2.0 )\npredicate(\"hasWater\", 10 \npredicate(\"people to meet\", people1 )\npredicate(\"people to meet\", [\"time\"::10], true)\npredicate(\"hasWater\", true)\npredicate(\"people to meet\", [\"time\"::10], 2.0,10)\npredicate(\"people to meet\", [\"time\"::10], 2.0, true, agentA)\npredicate(\"people to meet\", [\"time\"::10], agentA)\npredicate(\"people to meet\", [\"time\"::10], 10, agentA)\npredicate(\"people to meet\")\npredicate(\"people to meet\", [\"time\"::10], 2.0,agentA)\npredicate(\"people to meet\", [\"time\"::10],2.0, true)\npredicate(\"people to meet\", [\"time\"::10], 2.0,10,agentA)\npredicate(\"people to meet\", [\"time\"::10], true)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_new_social_link)\n### `new_social_link`\n\n#### Possible use: \n  *  **`new_social_link`** (`agent`) --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`new_social_link`** (`agent`, `float`, `float`, `float`, `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \na new social link\na new social link\n\n#### Examples: \n```\nnew_social_link(agentA)\nnew_social_link(agentA,0.0,-0.1,0.2,0.1)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_node)\n### `node`\n\n#### Possible use: \n  *  **`node`** (`unknown`) --->  `unknown`\n  * `unknown` **`node`** `float` --->  `unknown`\n  *  **`node`** (`unknown` , `float`) --->  `unknown`\n    \t\n----\n\n\n[//]: # (keyword|operator_nodes)\n### `nodes`\n\n#### Possible use: \n  *  **`nodes`** (`container`) --->  `container`\n    \t\n----\n\n\n[//]: # (keyword|operator_norm)\n### `norm`\n\n#### Possible use: \n  *  **`norm`** (`point`) --->  `float` \n\n#### Result: \nthe norm of the vector with the coordinates of the point operand.\n\n#### Examples: \n```\nfloat var0 <- norm({3,4}); \t// var0 equals 5.0\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_not)\n### `not`\nSame signification as [!](#!)\n    \t\n----\n\n\n[//]: # (keyword|operator_obj_file)\n### `obj_file`\n\n#### Possible use: \n  *  **`obj_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type obj. Allowed extensions are limited to obj, OBJ\n    \t\n----\n\n\n[//]: # (keyword|operator_of)\n### `of`\nSame signification as [.](#.)\n    \t\n----\n\n\n[//]: # (keyword|operator_of_generic_species)\n### `of_generic_species`\n\n#### Possible use: \n  * `container` **`of_generic_species`** `species` --->  `container`\n  *  **`of_generic_species`** (`container` , `species`) --->  `container` \n\n#### Result: \na list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand species\n\n#### Examples: \n```\n// species test {}\n// species sous_test parent: test {}\ncontainer var2 <- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species test; \t// var2 equals [sous_test0,sous_test1,test2,test3]\ncontainer var3 <- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species sous_test; \t// var3 equals [sous_test0,sous_test1]\ncontainer var4 <- [sous_test(0),sous_test(1),test(2),test(3)] of_species test; \t// var4 equals [test2,test3]\ncontainer var5 <- [sous_test(0),sous_test(1),test(2),test(3)] of_species sous_test; \t// var5 equals [sous_test0,sous_test1]\n```\n      \n\n#### See also: \n[of_species](#of_species), \n    \t\n----\n\n\n[//]: # (keyword|operator_of_species)\n### `of_species`\n\n#### Possible use: \n  * `container` **`of_species`** `species` --->  `container`\n  *  **`of_species`** (`container` , `species`) --->  `container` \n\n#### Result: \na list, containing the agents of the left-hand operand whose species is the one denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitly if it is to be used in an ask statement, for instance).\n\n#### Special cases:     \n  * if the right operand is nil, of_species returns the right operand\n\n#### Examples: \n```\ncontainer var0 <- (self neighbors_at 10) of_species (species (self)); \t// var0 equals all the neighboring agents of the same species.\ncontainer var1 <- [test(0),test(1),node(1),node(2)] of_species test; \t// var1 equals [test0,test1]\n```\n      \n\n#### See also: \n[of_generic_species](#of_generic_species), \n    \t\n----\n\n\n[//]: # (keyword|operator_one_of)\n### `one_of`\n\n#### Possible use: \n  *  **`one_of`** (`container<KeyType,ValueType>`) --->  `ValueType` \n\n#### Result: \none of the values stored in this container  at a random key  \n\n#### Comment: \nthe one_of operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a graph, one_of returns one of the lists of edges    \n  * if it is a file, one_of returns one of the elements of the content of the file (that is also a container)    \n  * if the operand is empty, one_of returns nil \n  \n```\n\n``` \n\n    \n  * if it is a list or a matrix, one_of returns one of the values of the list or of the matrix \n  \n```\nint i <- any ([1,2,3]); \t// i equals 1, 2 or 3\nstring sMat <- one_of(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// sMat equals \"c11\",\"c12\",\"c13\", \"c21\",\"c22\" or \"c23\"\n\n``` \n\n    \n  * if it is a map, one_of returns one the value of a random pair of the map \n  \n```\nint im <- one_of ([2::3, 4::5, 6::7]);\t// im equals 3, 5 or 7\nbool var6 <- [2::3, 4::5, 6::7].values contains im; \t// var6 equals true\n\n``` \n\n    \n  * if it is a population, one_of returns one of the agents of the population \n  \n```\nbug b <- one_of(bug);  \t// Given a previously defined species bug, b is one of the created bugs, e.g. bug3\n\n``` \n\n    \n\n#### See also: \n[contains](#contains), \n    \t\n----\n\n\n[//]: # (keyword|operator_or)\n### `or`\n\n#### Possible use: \n  * `bool` **`or`** `any expression` --->  `bool`\n  *  **`or`** (`bool` , `any expression`) --->  `bool` \n\n#### Result: \na bool value, equal to the logical or between the left-hand operand and the right-hand operand.  \n\n#### Comment: \nboth operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.    \n\n#### See also: \n[bool](#bool), [and](#and), [!](#!), \n    \t\n----\n\n\n[//]: # (keyword|operator_or)\n### `or`\n\n#### Possible use: \n  * `predicate` **`or`** `predicate` --->  `predicate`\n  *  **`or`** (`predicate` , `predicate`) --->  `predicate` \n\n#### Result: \ncreate a new predicate from two others by including them as subintentions. It's an exclusive \"or\"\n\n#### Examples: \n```\npredicate1 or predicate2\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_osm_file)\n### `osm_file`\n\n#### Possible use: \n  * `string` **`osm_file`** `map<string,list>` --->  `file`\n  *  **`osm_file`** (`string` , `map<string,list>`) --->  `file`\n  *  **`osm_file`** (`string`, `map<string,list>`, `int`) --->  `file` \n\n#### Result: \nopens a file that a is a kind of OSM file with some filtering.\nopens a file that a is a kind of OSM file with some filtering, forcing the initial CRS to be the one indicated by the second int parameter (see http://spatialreference.org/ref/epsg/). If this int parameter is equal to 0, the data is considered as already projected.  \n\n#### Comment: \nThe file should have a OSM file extension, cf. file type definition for supported file extensions.The file should have a OSM file extension, cf. file type definition for supported file extensions.\n\n#### Special cases:     \n  * If the specified string does not refer to an existing OSM file, an exception is risen.    \n  * If the specified string does not refer to an existing OSM file, an exception is risen.\n\n#### Examples: \n```\nfile myOSMfile <- osm_file(\"../includes/rouen.osm\", [\"highway\"::[\"primary\",\"motorway\"]]);\nfile myOSMfile2 <- osm_file(\"../includes/rouen.osm\",[\"highway\"::[\"primary\",\"motorway\"]], 0);\n```\n      \n\n#### See also: \n[file](#file), \n    \t\n----\n\n\n[//]: # (keyword|operator_out_degree_of)\n### `out_degree_of`\n\n#### Possible use: \n  * `graph` **`out_degree_of`** `unknown` --->  `int`\n  *  **`out_degree_of`** (`graph` , `unknown`) --->  `int` \n\n#### Result: \nreturns the out degree of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\nint var1 <- graphFromMap out_degree_of (node(3)); \t// var1 equals 4\n```\n      \n\n#### See also: \n[in_degree_of](#in_degree_of), [degree_of](#degree_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_out_edges_of)\n### `out_edges_of`\n\n#### Possible use: \n  * `graph` **`out_edges_of`** `unknown` --->  `container`\n  *  **`out_edges_of`** (`graph` , `unknown`) --->  `container` \n\n#### Result: \nreturns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\ncontainer var1 <- graphFromMap out_edges_of (node(3)); \t// var1 equals 3\n```\n      \n\n#### See also: \n[in_edges_of](#in_edges_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_overlapping)\n### `overlapping`\n\n#### Possible use: \n  * `container<agent>` **`overlapping`** `geometry` --->  `list<geometry>`\n  *  **`overlapping`** (`container<agent>` , `geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), overlapping the operand (casted as a geometry).\n\n#### Examples: \n```\nlist<geometry> var0 <- [ag1, ag2, ag3] overlapping(self); \t// var0 equals return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator.\n(species1 + species2) overlapping self\n```\n      \n\n#### See also: \n[neighbors_at](#neighbors_at), [neighbors_of](#neighbors_of), [agent_closest_to](#agent_closest_to), [agents_inside](#agents_inside), [closest_to](#closest_to), [inside](#inside), [agents_overlapping](#agents_overlapping), \n    \t\n----\n\n\n[//]: # (keyword|operator_overlaps)\n### `overlaps`\n\n#### Possible use: \n  * `geometry` **`overlaps`** `geometry` --->  `bool`\n  *  **`overlaps`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.    \n  * if one operand is a point, returns true if the point is included in the geometry\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]); \t// var0 equals true\nbool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals true\nbool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {25,25}; \t// var2 equals false\nbool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var3 equals false\nbool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]); \t// var4 equals true\nbool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {15,15}; \t// var5 equals true\nbool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); \t// var6 equals true\nbool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var7 equals true\nbool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var8 equals true\n```\n      \n\n#### See also: \n[disjoint_from](#disjoint_from), [crosses](#crosses), [intersects](#intersects), [partially_overlaps](#partially_overlaps), [touches](#touches), \n    \t\n----\n\n\n[//]: # (keyword|operator_pair)\n### `pair`\n\n#### Possible use: \n  *  **`pair`** (`any`) --->  `pair` \n\n#### Result: \nCasts the operand into the type pair\n    \t\n----\n\n\n[//]: # (keyword|operator_partially_overlaps)\n### `partially_overlaps`\n\n#### Possible use: \n  * `geometry` **`partially_overlaps`** `geometry` --->  `bool`\n  *  **`partially_overlaps`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).  \n\n#### Comment: \nif one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]); \t// var0 equals true\nbool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals true\nbool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {25,25}; \t// var2 equals false\nbool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var3 equals false\nbool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]); \t// var4 equals false\nbool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {15,15}; \t// var5 equals false\nbool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); \t// var6 equals false\nbool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var7 equals true\nbool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var8 equals false\n```\n      \n\n#### See also: \n[disjoint_from](#disjoint_from), [crosses](#crosses), [overlaps](#overlaps), [intersects](#intersects), [touches](#touches), \n    \t\n----\n\n\n[//]: # (keyword|operator_path)\n### `path`\n\n#### Possible use: \n  *  **`path`** (`any`) --->  `path` \n\n#### Result: \nCasts the operand into the type path\n    \t\n----\n\n\n[//]: # (keyword|operator_path_between)\n### `path_between`\n\n#### Possible use: \n  * `topology` **`path_between`** `container<geometry>` --->  `path`\n  *  **`path_between`** (`topology` , `container<geometry>`) --->  `path`\n  * `list<agent>` **`path_between`** `container<geometry>` --->  `path`\n  *  **`path_between`** (`list<agent>` , `container<geometry>`) --->  `path`\n  *  **`path_between`** (`graph`, `geometry`, `geometry`) --->  `path`\n  *  **`path_between`** (`list<agent>`, `geometry`, `geometry`) --->  `path`\n  *  **`path_between`** (`topology`, `geometry`, `geometry`) --->  `path` \n\n#### Result: \nThe shortest path between a list of two objects in a graph\nThe shortest path between two objects according to set of cells\nThe shortest path between several objects according to set of cells\n\n#### Examples: \n```\npath var0 <- path_between (my_graph, ag1, ag2); \t// var0 equals A path between ag1 and ag2\npath var1 <- my_topology path_between [ag1, ag2]; \t// var1 equals A path between ag1 and ag2\npath var2 <- path_between (cell_grid where each.is_free, ag1, ag2); \t// var2 equals A path between ag1 and ag2 passing through the given cell_grid agents\npath var3 <- my_topology path_between (ag1, ag2); \t// var3 equals A path between ag1 and ag2\npath var4 <- path_between (cell_grid where each.is_free, [ag1, ag2, ag3]); \t// var4 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agents\n```\n      \n\n#### See also: \n[towards](#towards), [direction_to](#direction_to), [distance_between](#distance_between), [direction_between](#direction_between), [path_to](#path_to), [distance_to](#distance_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_path_to)\n### `path_to`\n\n#### Possible use: \n  * `geometry` **`path_to`** `geometry` --->  `path`\n  *  **`path_to`** (`geometry` , `geometry`) --->  `path`\n  * `point` **`path_to`** `point` --->  `path`\n  *  **`path_to`** (`point` , `point`) --->  `path` \n\n#### Result: \nA path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.\n\n#### Examples: \n```\npath var0 <- ag1 path_to ag2; \t// var0 equals the path between ag1 and ag2 considering the topology of the agent applying the operator\n```\n      \n\n#### See also: \n[towards](#towards), [direction_to](#direction_to), [distance_between](#distance_between), [direction_between](#direction_between), [path_between](#path_between), [distance_to](#distance_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_paths_between)\n### `paths_between`\n\n#### Possible use: \n  *  **`paths_between`** (`graph`, `pair`, `int`) --->  `list<path>` \n\n#### Result: \nThe K shortest paths between a list of two objects in a graph\n\n#### Examples: \n```\nlist<path> var0 <- paths_between(my_graph, ag1:: ag2, 2); \t// var0 equals the 2 shortest paths (ordered by length) between ag1 and ag2\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_percent_absolute_deviation)\n### `percent_absolute_deviation`\n\n#### Possible use: \n  * `list<float>` **`percent_absolute_deviation`** `list<float>` --->  `float`\n  *  **`percent_absolute_deviation`** (`list<float>` , `list<float>`) --->  `float` \n\n#### Result: \npercent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)\n\n#### Examples: \n```\npercent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_pgm_file)\n### `pgm_file`\n\n#### Possible use: \n  *  **`pgm_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type pgm. Allowed extensions are limited to pgm\n    \t\n----\n\n\n[//]: # (keyword|operator_plan)\n### `plan`\n\n#### Possible use: \n  * `container<geometry>` **`plan`** `float` --->  `geometry`\n  *  **`plan`** (`container<geometry>` , `float`) --->  `geometry` \n\n#### Result: \nA polyline geometry from the given list of points.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry.\n\n#### Examples: \n```\ngeometry var0 <- polyplan([{0,0}, {0,10}, {10,10}, {10,0}],10); \t// var0 equals a polyline geometry composed of the 4 points with a depth of 10.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [link](#link), [norm](#norm), [point](#point), [polygone](#polygone), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_plus_days)\n### `plus_days`\n\n#### Possible use: \n  * `date` **`plus_days`** `int` --->  `date`\n  *  **`plus_days`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of days to a date\n\n#### Examples: \n```\ndate1 plus_days 20\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_plus_hours)\n### `plus_hours`\n\n#### Possible use: \n  * `date` **`plus_hours`** `int` --->  `date`\n  *  **`plus_hours`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of hours to a date\n\n#### Examples: \n```\ndate1 plus_hours 15 // equivalent to date1 + 15 #h\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_plus_minutes)\n### `plus_minutes`\n\n#### Possible use: \n  * `date` **`plus_minutes`** `int` --->  `date`\n  *  **`plus_minutes`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of minutes to a date\n\n#### Examples: \n```\ndate1 plus_minutes 5 // equivalent to date1 + 5 #mn\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_plus_months)\n### `plus_months`\n\n#### Possible use: \n  * `date` **`plus_months`** `int` --->  `date`\n  *  **`plus_months`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of months to a date\n\n#### Examples: \n```\ndate1 plus_months 5\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_plus_ms)\n### `plus_ms`\n\n#### Possible use: \n  * `date` **`plus_ms`** `int` --->  `date`\n  *  **`plus_ms`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of milliseconds to a date\n\n#### Examples: \n```\ndate1 plus_ms 15 // equivalent to date1 + 15 #ms\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_plus_seconds)\n### `plus_seconds`\nSame signification as [+](#+)\n    \t\n----\n\n\n[//]: # (keyword|operator_plus_weeks)\n### `plus_weeks`\n\n#### Possible use: \n  * `date` **`plus_weeks`** `int` --->  `date`\n  *  **`plus_weeks`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of weeks to a date\n\n#### Examples: \n```\ndate1 plus_weeks 15\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_plus_years)\n### `plus_years`\n\n#### Possible use: \n  * `date` **`plus_years`** `int` --->  `date`\n  *  **`plus_years`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of years to a date\n\n#### Examples: \n```\ndate1 plus_years 3\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_point)\n### `point`\n\n#### Possible use: \n  * `float` **`point`** `int` --->  `point`\n  *  **`point`** (`float` , `int`) --->  `point`\n  * `int` **`point`** `float` --->  `point`\n  *  **`point`** (`int` , `float`) --->  `point`\n  * `int` **`point`** `int` --->  `point`\n  *  **`point`** (`int` , `int`) --->  `point`\n  * `float` **`point`** `float` --->  `point`\n  *  **`point`** (`float` , `float`) --->  `point`\n  *  **`point`** (`float`, `int`, `int`) --->  `point`\n  *  **`point`** (`int`, `int`, `int`) --->  `point`\n  *  **`point`** (`float`, `int`, `float`) --->  `point`\n  *  **`point`** (`int`, `int`, `float`) --->  `point`\n  *  **`point`** (`int`, `float`, `float`) --->  `point`\n  *  **`point`** (`float`, `float`, `float`) --->  `point`\n  *  **`point`** (`float`, `float`, `int`) --->  `point` \n\n#### Result: \ninternal use only. Use the standard construction {x,y} instead.\ninternal use only. Use the standard construction {x,y} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y} instead.\ninternal use only. Use the standard construction {x,y} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\n    \t\n----\n\n\n[//]: # (keyword|operator_points_along)\n### `points_along`\n\n#### Possible use: \n  * `geometry` **`points_along`** `list<float>` --->  `container`\n  *  **`points_along`** (`geometry` , `list<float>`) --->  `container` \n\n#### Result: \nA list of points along the operand-geometry given its location in terms of rate of distance from the starting points of the geometry.\n\n#### Examples: \n```\ncontainer var0 <-  line([{10,10},{80,80}]) points_along ([0.3, 0.5, 0.9]); \t// var0 equals the list of following points: [{31.0,31.0,0.0},{45.0,45.0,0.0},{73.0,73.0,0.0}]\n```\n      \n\n#### See also: \n[closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), [points_at](#points_at), [points_on](#points_on), \n    \t\n----\n\n\n[//]: # (keyword|operator_points_at)\n### `points_at`\n\n#### Possible use: \n  * `int` **`points_at`** `float` --->  `list<point>`\n  *  **`points_at`** (`int` , `float`) --->  `list<point>` \n\n#### Result: \nA list of left-operand number of points located at a the right-operand distance to the agent location.\n\n#### Examples: \n```\nlist<point> var0 <- 3 points_at(20.0); \t// var0 equals returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent location\n```\n      \n\n#### See also: \n[any_location_in](#any_location_in), [any_point_in](#any_point_in), [closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_points_on)\n### `points_on`\n\n#### Possible use: \n  * `geometry` **`points_on`** `float` --->  `container`\n  *  **`points_on`** (`geometry` , `float`) --->  `container` \n\n#### Result: \nA list of points of the operand-geometry distant from each other to the float right-operand .\n\n#### Examples: \n```\ncontainer var0 <-  square(5) points_on(2); \t// var0 equals a list of points belonging to the exterior ring of the square distant from each other of 2.\n```\n      \n\n#### See also: \n[closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), [points_at](#points_at), \n    \t\n----\n\n\n[//]: # (keyword|operator_poisson)\n### `poisson`\n\n#### Possible use: \n  *  **`poisson`** (`float`) --->  `int` \n\n#### Result: \nA value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).  \n\n#### Comment: \nThe Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.\n\n#### Examples: \n```\nint var0 <- poisson(3.5); \t// var0 equals a random positive integer\n```\n      \n\n#### See also: \n[binomial](#binomial), [gauss](#gauss), \n    \t\n----\n\n\n[//]: # (keyword|operator_polygon)\n### `polygon`\n\n#### Possible use: \n  *  **`polygon`** (`container<agent>`) --->  `geometry` \n\n#### Result: \nA polygon geometry from the given list of points.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry    \n  * if the operand is composed of 2 points, returns a polyline geometry.\n\n#### Examples: \n```\ngeometry var0 <- polygon([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var0 equals a polygon geometry composed of the 4 points.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_polyhedron)\n### `polyhedron`\n\n#### Possible use: \n  * `container<geometry>` **`polyhedron`** `float` --->  `geometry`\n  *  **`polyhedron`** (`container<geometry>` , `float`) --->  `geometry` \n\n#### Result: \nA polyhedron geometry from the given list of points.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry    \n  * if the operand is composed of 2 points, returns a polyline geometry.\n\n#### Examples: \n```\ngeometry var0 <- polyhedron([{0,0}, {0,10}, {10,10}, {10,0}],10); \t// var0 equals a polygon geometry composed of the 4 points and of depth 10.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_polyline)\n### `polyline`\nSame signification as [line](#line)\n    \t\n----\n\n\n[//]: # (keyword|operator_polyplan)\n### `polyplan`\nSame signification as [plan](#plan)\n    \t\n----\n\n\n[//]: # (keyword|operator_predecessors_of)\n### `predecessors_of`\n\n#### Possible use: \n  * `graph` **`predecessors_of`** `unknown` --->  `container`\n  *  **`predecessors_of`** (`graph` , `unknown`) --->  `container` \n\n#### Result: \nreturns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)\n\n#### Examples: \n```\ncontainer var1 <- graphEpidemio predecessors_of ({1,5}); \t// var1 equals []\ncontainer var2 <- graphEpidemio predecessors_of node({34,56}); \t// var2 equals [{12;45}]\n```\n      \n\n#### See also: \n[neighbors_of](#neighbors_of), [successors_of](#successors_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_predicate)\n### `predicate`\n\n#### Possible use: \n  *  **`predicate`** (`any`) --->  `predicate` \n\n#### Result: \nCasts the operand into the type predicate\n    \t\n----\n\n\n[//]: # (keyword|operator_predict)\n### `predict`\n\n#### Possible use: \n  * `regression` **`predict`** `list<float>` --->  `float`\n  *  **`predict`** (`regression` , `list<float>`) --->  `float` \n\n#### Result: \nreturns the value predict by the regression parameters for a given instance. Usage: predict(regression, instance)\n\n#### Examples: \n```\npredict(my_regression, [1,2,3]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_product)\n### `product`\nSame signification as [mul](#mul)\n    \t\n----\n\n\n[//]: # (keyword|operator_product_of)\n### `product_of`\n\n#### Possible use: \n  * `container` **`product_of`** `any expression` --->  `unknown`\n  *  **`product_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe product of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var2 <- [1::2, 3::4, 5::6] product_of (each); \t// var2 equals 48\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2] product_of (each * 10 ); \t// var1 equals 200\n```\n      \n\n#### See also: \n[min_of](#min_of), [max_of](#max_of), [sum_of](#sum_of), [mean_of](#mean_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_promethee_DM)\n### `promethee_DM`\n\n#### Possible use: \n  * `list<list>` **`promethee_DM`** `list<map<string,object>>` --->  `int`\n  *  **`promethee_DM`** (`list<list>` , `list<map<string,object>>`) --->  `int` \n\n#### Result: \nThe index of the best candidate according to the Promethee II method. This method is based on a comparison per pair of possible candidates along each criterion: all candidates are compared to each other by pair and ranked. More information about this method can be found in [http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6VCT-4VF56TV-1&_user=10&_coverDate=01%2F01%2F2010&_rdoc=1&_fmt=high&_orig=search&_sort=d&_docanchor=&view=c&_searchStrId=1389284642&_rerunOrigin=google&_acct=C000050221&_version=1&_urlVersion=0&_userid=10&md5=d334de2a4e0d6281199a39857648cd36 Behzadian, M., Kazemzadeh, R., Albadvi, A., M., A.: PROMETHEE: A comprehensive literature review on methodologies and applications. European Journal of Operational Research(2009)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fours elements: a name, a weight, a preference value (p) and an indifference value (q). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant.\n\n#### Special cases:     \n  * returns -1 is the list of candidates is nil or empty\n\n#### Examples: \n```\nint var0 <- promethee_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]]); \t// var0 equals 1\n```\n      \n\n#### See also: \n[weighted_means_DM](#weighted_means_dm), [electre_DM](#electre_dm), [evidence_theory_DM](#evidence_theory_dm), \n    \t\n----\n\n\n[//]: # (keyword|operator_property_file)\n### `property_file`\n\n#### Possible use: \n  *  **`property_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type property. Allowed extensions are limited to properties\n    \t\n----\n\n\n[//]: # (keyword|operator_pyramid)\n### `pyramid`\n\n#### Possible use: \n  *  **`pyramid`** (`float`) --->  `geometry` \n\n#### Result: \nA square geometry which side size is given by the operand.  \n\n#### Comment: \nthe center of the pyramid is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- pyramid(5); \t// var0 equals a geometry as a square with side_size = 5.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), \n    \t\n----\n\n\n[//]: # (keyword|operator_R_correlation)\n### `R_correlation`\nSame signification as [corR](#corr)\n    \t\n----\n\n\n[//]: # (keyword|operator_R_file)\n### `R_file`\n\n#### Possible use: \n  *  **`R_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type R. Allowed extensions are limited to r\n    \t\n----\n\n\n[//]: # (keyword|operator_R_mean)\n### `R_mean`\nSame signification as [meanR](#meanr)\n    \t\n----\n\n\n[//]: # (keyword|operator_range)\n### `range`\n\n#### Possible use: \n  *  **`range`** (`int`) --->  `container`\n  * `int` **`range`** `int` --->  `container`\n  *  **`range`** (`int` , `int`) --->  `container`\n  *  **`range`** (`int`, `int`, `int`) --->  `container` \n\n#### Result: \nAllows to build a list of int representing all contiguous values from zero to the argument. The range can be increasing or decreasing. Passing 0 will return a singleton list with 0\nAllows to build a list of int representing all contiguous values from the first to the second argument, using the step represented by the third argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value. Passing a step of 0 will result in an exception. Attempting to build infinite ranges (e.g. end > start with a negative step) will similarly not be accepted and yield an exception\nAllows to build a list of int representing all contiguous values from the first to the second argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value\n    \t\n----\n\n\n[//]: # (keyword|operator_read)\n### `read`\n\n#### Possible use: \n  *  **`read`** (`string`) --->  `unknown` \n\n#### Result: \nReads an attribute of the agent. The attribute's name is specified by the operand.\n\n#### Examples: \n```\nunknown agent_name <- read ('name'); \t// agent_name equals reads the 'name' variable of agent then assigns the returned value to the 'agent_name' variable. \n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_rectangle)\n### `rectangle`\n\n#### Possible use: \n  *  **`rectangle`** (`point`) --->  `geometry`\n  * `float` **`rectangle`** `float` --->  `geometry`\n  *  **`rectangle`** (`float` , `float`) --->  `geometry`\n  * `point` **`rectangle`** `point` --->  `geometry`\n  *  **`rectangle`** (`point` , `point`) --->  `geometry` \n\n#### Result: \nA rectangle geometry which side sizes are given by the operands.  \n\n#### Comment: \nthe center of the rectangle is by default the location of the current agent in which has been called this operator.the center of the rectangle is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- rectangle(10, 5); \t// var0 equals a geometry as a rectangle with width = 10 and height = 5.\ngeometry var1 <- rectangle({2.0,6.0}, {6.0,20.0}); \t// var1 equals a geometry as a rectangle with {2.0,6.0} as the upper-left corner, {6.0,20.0} as the lower-right corner.\ngeometry var2 <- rectangle({10, 5}); \t// var2 equals a geometry as a rectangle with width = 10 and height = 5.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_reduced_by)\n### `reduced_by`\nSame signification as [-](#-)\n    \t\n----\n\n\n[//]: # (keyword|operator_regression)\n### `regression`\n\n#### Possible use: \n  *  **`regression`** (`any`) --->  `regression` \n\n#### Result: \nCasts the operand into the type regression\n    \t\n----\n\n\n[//]: # (keyword|operator_remove_duplicates)\n### `remove_duplicates`\nSame signification as [distinct](#distinct)\n    \t\n----\n\n\n[//]: # (keyword|operator_remove_node_from)\n### `remove_node_from`\n\n#### Possible use: \n  * `geometry` **`remove_node_from`** `graph` --->  `graph`\n  *  **`remove_node_from`** (`geometry` , `graph`) --->  `graph` \n\n#### Result: \nremoves a node from a graph.  \n\n#### Comment: \nall the edges containing this node are also removed.\n\n#### Examples: \n```\ngraph var0 <- node(0) remove_node_from graphEpidemio; \t// var0 equals the graph without node(0)\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_replace)\n### `replace`\n\n#### Possible use: \n  *  **`replace`** (`string`, `string`, `string`) --->  `string` \n\n#### Result: \nReturns the String resulting by replacing for the first operand all the sub-strings corresponding the second operand by the third operand\n\n#### Examples: \n```\nstring var0 <- replace('to be or not to be,that is the question','to', 'do'); \t// var0 equals 'do be or not do be,that is the question'\n```\n      \n\n#### See also: \n[replace_regex](#replace_regex), \n    \t\n----\n\n\n[//]: # (keyword|operator_replace_regex)\n### `replace_regex`\n\n#### Possible use: \n  *  **`replace_regex`** (`string`, `string`, `string`) --->  `string` \n\n#### Result: \nReturns the String resulting by replacing for the first operand all the sub-strings corresponding to the regular expression given in the second operand by the third operand\n\n#### Examples: \n```\nstring var0 <- replace_regex(\"colour, color\", \"colou?r\", \"col\"); \t// var0 equals 'col, col'\n```\n      \n\n#### See also: \n[replace](#replace), \n    \t\n----\n\n\n[//]: # (keyword|operator_reverse)\n### `reverse`\n\n#### Possible use: \n  *  **`reverse`** (`string`) --->  `string`\n  *  **`reverse`** (`container<KeyType,ValueType>`) --->  `msi.gama.util.IContainer<?,?>` \n\n#### Result: \nthe operand elements in the reversed order in a copy of the operand.  \n\n#### Comment: \nthe reverse operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a file, reverse returns a copy of the file with a reversed content    \n  * if it is a population, reverse returns a copy of the population with elements in the reversed order    \n  * if it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed    \n  * if it is a string, reverse returns a new string with characters in the reversed order \n  \n```\nstring var0 <- reverse ('abcd'); \t// var0 equals 'dcba'\n\n``` \n\n    \n  * if it is a list, reverse returns a copy of the operand list with elements in the reversed order \n  \n```\nmsi.gama.util.IContainer<?,?> var1 <- reverse ([10,12,14]); \t// var1 equals [14, 12, 10]\n\n``` \n\n    \n  * if it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys) \n  \n```\nmsi.gama.util.IContainer<?,?> var2 <- reverse (['k1'::44, 'k2'::32, 'k3'::12]); \t// var2 equals [12::'k3',  32::'k2', 44::'k1']\n\n``` \n\n    \n  * if it is a matrix, reverse returns a new matrix containing the transpose of the operand. \n  \n```\nmsi.gama.util.IContainer<?,?> var3 <- reverse(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var3 equals matrix([[\"c11\",\"c21\"],[\"c12\",\"c22\"],[\"c13\",\"c23\"]])\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_rewire_n)\n### `rewire_n`\n\n#### Possible use: \n  * `graph` **`rewire_n`** `int` --->  `graph`\n  *  **`rewire_n`** (`graph` , `int`) --->  `graph` \n\n#### Result: \nrewires the given count of edges.  \n\n#### Comment: \nIf there are too many edges, all the edges will be rewired.\n\n#### Examples: \n```\ngraph var1 <- graphEpidemio rewire_n 10; \t// var1 equals the graph with 3 edges rewired\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_rgb)\n### `rgb`\n\n#### Possible use: \n  * `rgb` **`rgb`** `float` --->  `rgb`\n  *  **`rgb`** (`rgb` , `float`) --->  `rgb`\n  * `rgb` **`rgb`** `int` --->  `rgb`\n  *  **`rgb`** (`rgb` , `int`) --->  `rgb`\n  * `string` **`rgb`** `int` --->  `rgb`\n  *  **`rgb`** (`string` , `int`) --->  `rgb`\n  *  **`rgb`** (`int`, `int`, `int`) --->  `rgb`\n  *  **`rgb`** (`int`, `int`, `int`, `float`) --->  `rgb`\n  *  **`rgb`** (`int`, `int`, `int`, `int`) --->  `rgb` \n\n#### Result: \nReturns a color defined by red, green, blue components and an alpha blending value.\n\n#### Special cases:     \n  * It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0.0 and 1.0)    \n  * It can be used with a color and an alpha between 0 and 1    \n  * It can be used with a color and an alpha between 0 and 255    \n  * It can be used with r=red, g=green, b=blue, each between 0 and 255    \n  * It can be used with a name of color and alpha (between 0 and 255)    \n  * It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0 and 255)\n\n#### Examples: \n```\nrgb var0 <- rgb (255,0,0,0.5); \t// var0 equals a light red color\nrgb var1 <- rgb(rgb(255,0,0),0.5); \t// var1 equals a light red color\nrgb var2 <- rgb(rgb(255,0,0),125); \t// var2 equals a light red color\nrgb var3 <- rgb (255,0,0); \t// var3 equals #red\nrgb var4 <- rgb (\"red\"); \t// var4 equals rgb(255,0,0)\nrgb var5 <- rgb (255,0,0,125); \t// var5 equals a light red color\n```\n      \n\n#### See also: \n[hsb](#hsb), \n    \t\n----\n\n\n[//]: # (keyword|operator_rgb_to_xyz)\n### `rgb_to_xyz`\n\n#### Possible use: \n  *  **`rgb_to_xyz`** (`file`) --->  `list<point>` \n\n#### Result: \nA list of point corresponding to RGB value of an image (r:x , g:y, b:z)\n\n#### Examples: \n```\nlist<point> var0 <- rgb_to_xyz(texture); \t// var0 equals a list of points\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_rnd)\n### `rnd`\n\n#### Possible use: \n  *  **`rnd`** (`float`) --->  `float`\n  *  **`rnd`** (`int`) --->  `int`\n  *  **`rnd`** (`point`) --->  `point`\n  * `point` **`rnd`** `point` --->  `point`\n  *  **`rnd`** (`point` , `point`) --->  `point`\n  * `int` **`rnd`** `int` --->  `int`\n  *  **`rnd`** (`int` , `int`) --->  `int`\n  * `float` **`rnd`** `float` --->  `float`\n  *  **`rnd`** (`float` , `float`) --->  `float`\n  *  **`rnd`** (`point`, `point`, `float`) --->  `point`\n  *  **`rnd`** (`float`, `float`, `float`) --->  `float`\n  *  **`rnd`** (`int`, `int`, `int`) --->  `int` \n\n#### Result: \na random integer in the interval [0, operand]  \n\n#### Comment: \nto obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precision\n\n#### Special cases:     \n  * if the operand is a float, returns an uniformly distributed float random number in [0.0, to]    \n  * if the operand is a point, returns a point with three random float ordinates, each in the interval [0, ordinate of argument]\n\n#### Examples: \n```\nfloat var0 <- rnd(3.4); \t// var0 equals a random float between 0.0 and 3.4\npoint var1 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1); \t// var1 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0\npoint var2 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}); \t// var2 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0\nint var3 <- rnd (2, 4); \t// var3 equals 2, 3 or 4\nfloat var4 <- rnd (2.0, 4.0); \t// var4 equals a float number between 2.0 and 4.0\nfloat var5 <- rnd (2.0, 4.0, 0.5); \t// var5 equals a float number between 2.0 and 4.0 every 0.5\nint var6 <- rnd (2); \t// var6 equals 0, 1 or 2\nfloat var7 <- rnd (1000) / 1000; \t// var7 equals a float between 0 and 1 with a precision of 0.001\npoint var8 <- rnd ({2.5,3, 0.0}); \t// var8 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0\nint var9 <- rnd (2, 12, 4); \t// var9 equals 2, 6 or 10\n```\n      \n\n#### See also: \n[flip](#flip), \n    \t\n----\n\n\n[//]: # (keyword|operator_rnd_choice)\n### `rnd_choice`\n\n#### Possible use: \n  *  **`rnd_choice`** (`container`) --->  `int` \n\n#### Result: \nreturns an index of the given list with a probability following the (normalized) distribution described in the list (a form of lottery)\n\n#### Examples: \n```\nint var0 <- rnd_choice([0.2,0.5,0.3]); \t// var0 equals 2/10 chances to return 0, 5/10 chances to return 1, 3/10 chances to return 2\n```\n      \n\n#### See also: \n[rnd](#rnd), \n    \t\n----\n\n\n[//]: # (keyword|operator_rnd_color)\n### `rnd_color`\n\n#### Possible use: \n  *  **`rnd_color`** (`int`) --->  `rgb` \n\n#### Result: \nrgb color  \n\n#### Comment: \nReturn a random color equivalent to rgb(rnd(operand),rnd(operand),rnd(operand))\n\n#### Examples: \n```\nrgb var0 <- rnd_color(255); \t// var0 equals a random color, equivalent to rgb(rnd(255),rnd(255),rnd(255))\n```\n      \n\n#### See also: \n[rgb](#rgb), [hsb](#hsb), \n    \t\n----\n\n\n[//]: # (keyword|operator_rotated_by)\n### `rotated_by`\n\n#### Possible use: \n  * `geometry` **`rotated_by`** `float` --->  `geometry`\n  *  **`rotated_by`** (`geometry` , `float`) --->  `geometry`\n  * `geometry` **`rotated_by`** `int` --->  `geometry`\n  *  **`rotated_by`** (`geometry` , `int`) --->  `geometry`\n  *  **`rotated_by`** (`geometry`, `float`, `point`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point)\nA geometry resulting from the application of a rotation by the right-hand operand angles (degree) along the three axis (x,y,z) to the left-hand operand (geometry, agent, point)  \n\n#### Comment: \nthe right-hand operand can be a float or a int\n\n#### Examples: \n```\ngeometry var0 <- self rotated_by 45; \t// var0 equals the geometry resulting from a 45 degrees rotation to the geometry of the agent applying the operator.\ngeometry var1 <- rotated_by(pyramid(10),45, {1,0,0}); \t// var1 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator.\n```\n      \n\n#### See also: \n[transformed_by](#transformed_by), [translated_by](#translated_by), \n    \t\n----\n\n\n[//]: # (keyword|operator_round)\n### `round`\n\n#### Possible use: \n  *  **`round`** (`int`) --->  `int`\n  *  **`round`** (`point`) --->  `point`\n  *  **`round`** (`float`) --->  `int` \n\n#### Result: \nReturns the rounded value of the operand.\n\n#### Special cases:     \n  * if the operand is an int, round returns it\n\n#### Examples: \n```\npoint var0 <- {12345.78943,  12345.78943, 12345.78943} with_precision 2; \t// var0 equals {12345.79,12345.79,12345.79}\nint var1 <- round (0.51); \t// var1 equals 1\nint var2 <- round (100.2); \t// var2 equals 100\nint var3 <- round(-0.51); \t// var3 equals -1\n```\n      \n\n#### See also: \n[round](#round), [int](#int), [with_precision](#with_precision), \n    \t\n----\n\n\n[//]: # (keyword|operator_row_at)\n### `row_at`\n\n#### Possible use: \n  * `matrix` **`row_at`** `int` --->  `list`\n  *  **`row_at`** (`matrix` , `int`) --->  `list` \n\n#### Result: \nreturns the row at a num_line (right-hand operand)\n\n#### Examples: \n```\nlist var0 <- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) row_at 2; \t// var0 equals [\"el13\",\"el23\",\"el33\"]\n```\n      \n\n#### See also: \n[column_at](#column_at), [columns_list](#columns_list), \n    \t\n----\n\n\n[//]: # (keyword|operator_rows_list)\n### `rows_list`\n\n#### Possible use: \n  *  **`rows_list`** (`matrix`) --->  `list<list>` \n\n#### Result: \nreturns a list of the rows of the matrix, with each row as a list of elements\n\n#### Examples: \n```\nlist<list> var0 <- rows_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); \t// var0 equals [[\"el11\",\"el21\",\"el31\"],[\"el12\",\"el22\",\"el32\"],[\"el13\",\"el23\",\"el33\"]]\n```\n      \n\n#### See also: \n[columns_list](#columns_list), \n    \t\n----\n\n\n[//]: # (keyword|operator_sample)\n### `sample`\n\n#### Possible use: \n  *  **`sample`** (`any expression`) --->  `string`\n  * `string` **`sample`** `any expression` --->  `string`\n  *  **`sample`** (`string` , `any expression`) --->  `string`\n  *  **`sample`** (`container`, `int`, `bool`) --->  `container`\n  *  **`sample`** (`container`, `int`, `bool`, `container`) --->  `container` \n\n#### Result: \ntakes a sample of the specified size from the elements of x using either with or without replacement\ntakes a sample of the specified size from the elements of x using either with or without replacement with given weights\n\n#### Examples: \n```\ncontainer var0 <- sample([2,10,1],2,false); \t// var0 equals [1,2]\ncontainer var1 <- sample([2,10,1],2,false,[0.1,0.7,0.2]); \t// var1 equals [10,2]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_scaled_by)\n### `scaled_by`\nSame signification as [*](#*)\n    \t\n----\n\n\n[//]: # (keyword|operator_scaled_to)\n### `scaled_to`\n\n#### Possible use: \n  * `geometry` **`scaled_to`** `point` --->  `geometry`\n  *  **`scaled_to`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nallows to restrict the size of a geometry so that it fits in the envelope {width, height, depth} defined by the second operand\n\n#### Examples: \n```\ngeometry var0 <- shape scaled_to {10,10}; \t// var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_select)\n### `select`\nSame signification as [where](#where)\n    \t\n----\n\n\n[//]: # (keyword|operator_set_about)\n### `set_about`\n\n#### Possible use: \n  * `emotion` **`set_about`** `predicate` --->  `emotion`\n  *  **`set_about`** (`emotion` , `predicate`) --->  `emotion` \n\n#### Result: \nchange the about value of the given emotion\n\n#### Examples: \n```\nemotion set_about predicate1\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_agent)\n### `set_agent`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_agent`** `agent` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_agent`** (`msi.gaml.architecture.simplebdi.SocialLink` , `agent`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the agent value of the given social link\n\n#### Examples: \n```\nsocial_link set_agent agentA\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_agent_cause)\n### `set_agent_cause`\n\n#### Possible use: \n  * `emotion` **`set_agent_cause`** `agent` --->  `emotion`\n  *  **`set_agent_cause`** (`emotion` , `agent`) --->  `emotion`\n  * `predicate` **`set_agent_cause`** `agent` --->  `predicate`\n  *  **`set_agent_cause`** (`predicate` , `agent`) --->  `predicate` \n\n#### Result: \nchange the agentCause value of the given emotion\nchange the agentCause value of the given predicate\n\n#### Examples: \n```\nemotion set_agent_cause agentA\npredicate set_agent_cause agentA\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_decay)\n### `set_decay`\n\n#### Possible use: \n  * `emotion` **`set_decay`** `float` --->  `emotion`\n  *  **`set_decay`** (`emotion` , `float`) --->  `emotion` \n\n#### Result: \nchange the decay value of the given emotion\n\n#### Examples: \n```\nemotion set_decay 12\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_dominance)\n### `set_dominance`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_dominance`** `float` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_dominance`** (`msi.gaml.architecture.simplebdi.SocialLink` , `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the dominance value of the given social link\n\n#### Examples: \n```\nsocial_link set_dominance 0.4\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_familiarity)\n### `set_familiarity`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_familiarity`** `float` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_familiarity`** (`msi.gaml.architecture.simplebdi.SocialLink` , `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the familiarity value of the given social link\n\n#### Examples: \n```\nsocial_link set_familiarity 0.4\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_intensity)\n### `set_intensity`\n\n#### Possible use: \n  * `emotion` **`set_intensity`** `float` --->  `emotion`\n  *  **`set_intensity`** (`emotion` , `float`) --->  `emotion` \n\n#### Result: \nchange the intensity value of the given emotion\n\n#### Examples: \n```\nemotion set_intensity 12\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_liking)\n### `set_liking`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_liking`** `float` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_liking`** (`msi.gaml.architecture.simplebdi.SocialLink` , `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the liking value of the given social link\n\n#### Examples: \n```\nsocial_link set_liking 0.4\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_solidarity)\n### `set_solidarity`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_solidarity`** `float` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_solidarity`** (`msi.gaml.architecture.simplebdi.SocialLink` , `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the solidarity value of the given social link\n\n#### Examples: \n```\nsocial_link set_solidarity 0.4\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_truth)\n### `set_truth`\n\n#### Possible use: \n  * `predicate` **`set_truth`** `bool` --->  `predicate`\n  *  **`set_truth`** (`predicate` , `bool`) --->  `predicate` \n\n#### Result: \nchange the is_true value of the given predicate\n\n#### Examples: \n```\npredicate set_truth false\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_set_z)\n### `set_z`\n\n#### Possible use: \n  * `geometry` **`set_z`** `container<float>` --->  `geometry`\n  *  **`set_z`** (`geometry` , `container<float>`) --->  `geometry`\n  *  **`set_z`** (`geometry`, `int`, `float`) --->  `geometry` \n\n#### Result: \nSets the z ordinate of the n-th point of a geometry to the value provided by the third argument\n\n#### Examples: \n```\nloop i from: 0 to: length(shape.points) - 1{set shape <-  set_z (shape, i, 3.0);}\nshape <- triangle(3) set_z [5,10,14];\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_shape_file)\n### `shape_file`\n\n#### Possible use: \n  *  **`shape_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type shape. Allowed extensions are limited to shp\n    \t\n----\n\n\n[//]: # (keyword|operator_shuffle)\n### `shuffle`\n\n#### Possible use: \n  *  **`shuffle`** (`matrix`) --->  `matrix`\n  *  **`shuffle`** (`string`) --->  `string`\n  *  **`shuffle`** (`container`) --->  `container` \n\n#### Result: \nThe elements of the operand in random order.\n\n#### Special cases:     \n  * if the operand is empty, returns an empty list (or string, matrix)\n\n#### Examples: \n```\nmatrix var0 <- shuffle (matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var0 equals matrix([[\"c12\",\"c21\",\"c11\"],[\"c13\",\"c22\",\"c23\"]]) (for example)\nstring var1 <- shuffle ('abc'); \t// var1 equals 'bac' (for example)\ncontainer var2 <- shuffle ([12, 13, 14]); \t// var2 equals [14,12,13] (for example)\n```\n      \n\n#### See also: \n[reverse](#reverse), \n    \t\n----\n\n\n[//]: # (keyword|operator_signum)\n### `signum`\n\n#### Possible use: \n  *  **`signum`** (`float`) --->  `int` \n\n#### Result: \nReturns -1 if the argument is negative, +1 if it is positive, 0 if it is equal to zero or not a number\n\n#### Examples: \n```\nint var0 <- signum(-12); \t// var0 equals -1\nint var1 <- signum(14); \t// var1 equals 1\nint var2 <- signum(0); \t// var2 equals 0\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_simple_clustering_by_distance)\n### `simple_clustering_by_distance`\n\n#### Possible use: \n  * `container<agent>` **`simple_clustering_by_distance`** `float` --->  `list<list<agent>>`\n  *  **`simple_clustering_by_distance`** (`container<agent>` , `float`) --->  `list<list<agent>>` \n\n#### Result: \nA list of agent groups clustered by distance considering a distance min between two groups.\n\n#### Examples: \n```\nlist<list<agent>> var0 <- [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0; \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]\n```\n      \n\n#### See also: \n[hierarchical_clustering](#hierarchical_clustering), \n    \t\n----\n\n\n[//]: # (keyword|operator_simple_clustering_by_envelope_distance)\n### `simple_clustering_by_envelope_distance`\nSame signification as [simple_clustering_by_distance](#simple_clustering_by_distance)\n    \t\n----\n\n\n[//]: # (keyword|operator_simplification)\n### `simplification`\n\n#### Possible use: \n  * `geometry` **`simplification`** `float` --->  `geometry`\n  *  **`simplification`** (`geometry` , `float`) --->  `geometry` \n\n#### Result: \nA geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.  \n\n#### Comment: \nThe algorithm used for the simplification is Douglas-Peucker\n\n#### Examples: \n```\ngeometry var0 <- self simplification 0.1; \t// var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_sin)\n### `sin`\n\n#### Possible use: \n  *  **`sin`** (`float`) --->  `float`\n  *  **`sin`** (`int`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized.\n\n#### Examples: \n```\nfloat var0 <- sin(360); \t// var0 equals 0.0\nfloat var1 <- sin (0); \t// var1 equals 0.0\n```\n      \n\n#### See also: \n[cos](#cos), [tan](#tan), \n    \t\n----\n\n\n[//]: # (keyword|operator_sin_rad)\n### `sin_rad`\n\n#### Possible use: \n  *  **`sin_rad`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized.\n\n#### Examples: \n```\nfloat var0 <- sin(360); \t// var0 equals 0.0\n```\n      \n\n#### See also: \n[cos](#cos), [tan](#tan), \n    \t\n----\n\n\n[//]: # (keyword|operator_since)\n### `since`\n\n#### Possible use: \n  *  **`since`** (`date`) --->  `bool`\n  * `any expression` **`since`** `date` --->  `bool`\n  *  **`since`** (`any expression` , `date`) --->  `bool` \n\n#### Result: \nReturns true if the current_date of the model is after (or equal to) the date passed in argument. Synonym of 'current_date >= argument'. Can be used, like 'after', in its composed form with 2 arguments to express the lowest boundary of the computation of a frequency. However, contrary to 'after', there is a subtle difference: the lowest boundary will be tested against the frequency as well\n\n#### Examples: \n```\nreflex when: since(starting_date) {} -: will always be run\nevery(2#days) since (starting_date + 1#day) // the computation will return true 1 day after the starting date and every two days after this reference date\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_skeletonize)\n### `skeletonize`\n\n#### Possible use: \n  *  **`skeletonize`** (`geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)\n\n#### Examples: \n```\nlist<geometry> var0 <- skeletonize(self); \t// var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_skew_gauss)\n### `skew_gauss`\n\n#### Possible use: \n  *  **`skew_gauss`** (`float`, `float`, `float`, `float`) --->  `float` \n\n#### Result: \nA value from a skew normally distributed random variable with min value (the minimum skewed value possible), max value (the maximum skewed value possible), skew (the degree to which the values cluster around the mode of the distribution; higher values mean tighter clustering) and bias (the tendency of the mode to approach the min, max or midpoint value; positive values bias toward max, negative values toward min).The algorithm was taken from http://stackoverflow.com/questions/5853187/skewing-java-random-number-generation-toward-a-certain-number\n\n#### Examples: \n```\nfloat var0 <- skew_gauss(0.0, 1.0, 0.7,0.1); \t// var0 equals 0.1729218460343077\n```\n      \n\n#### See also: \n[gauss](#gauss), [truncated_gauss](#truncated_gauss), [poisson](#poisson), \n    \t\n----\n\n\n[//]: # (keyword|operator_skewness)\n### `skewness`\n\n#### Possible use: \n  *  **`skewness`** (`list`) --->  `float` \n\n#### Result: \nreturns skewness value computed from the operand list of values\n\n#### Special cases:     \n  * if the length of the list is lower than 3, returns NaN\n\n#### Examples: \n```\nskewness ([1,2,3,4,5])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_skill)\n### `skill`\n\n#### Possible use: \n  *  **`skill`** (`any`) --->  `skill` \n\n#### Result: \nCasts the operand into the type skill\n    \t\n----\n\n\n[//]: # (keyword|operator_smooth)\n### `smooth`\n\n#### Possible use: \n  * `geometry` **`smooth`** `float` --->  `geometry`\n  *  **`smooth`** (`geometry` , `float`) --->  `geometry` \n\n#### Result: \nReturns a 'smoothed' geometry, where straight lines are replaces by polynomial (bicubic) curves. The first parameter is the original geometry, the second is the 'fit' parameter which can be in the range 0 (loose fit) to 1 (tightest fit).\n\n#### Examples: \n```\ngeometry var0 <- smooth(square(10), 0.0); \t// var0 equals a 'rounded' square\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_social_link)\n### `social_link`\n\n#### Possible use: \n  *  **`social_link`** (`any`) --->  `social_link` \n\n#### Result: \nCasts the operand into the type social_link\n    \t\n----\n\n\n[//]: # (keyword|operator_solid)\n### `solid`\nSame signification as [without_holes](#without_holes)\n    \t\n----\n\n\n[//]: # (keyword|operator_sort)\n### `sort`\nSame signification as [sort_by](#sort_by)\n    \t\n----\n\n\n[//]: # (keyword|operator_sort_by)\n### `sort_by`\n\n#### Possible use: \n  * `container` **`sort_by`** `any expression` --->  `container`\n  *  **`sort_by`** (`container` , `any expression`) --->  `container` \n\n#### Result: \nReturns a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them.  \n\n#### Comment: \nthe left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, sort_by throws an error\n\n#### Examples: \n```\ncontainer var0 <- [1,2,4,3,5,7,6,8] sort_by (each); \t// var0 equals [1,2,3,4,5,6,7,8]\ncontainer var2 <- g2 sort_by (length(g2 out_edges_of each) ); \t// var2 equals [node9, node7, node10, node8, node11, node6, node5, node4]\ncontainer var3 <- (list(node) sort_by (round(node(each).location.x)); \t// var3 equals [node5, node1, node0, node2, node3]\ncontainer var4 <- [1::2, 5::6, 3::4] sort_by (each); \t// var4 equals [2, 4, 6]\n```\n      \n\n#### See also: \n[group_by](#group_by), \n    \t\n----\n\n\n[//]: # (keyword|operator_source_of)\n### `source_of`\n\n#### Possible use: \n  * `graph` **`source_of`** `unknown` --->  `unknown`\n  *  **`source_of`** (`graph` , `unknown`) --->  `unknown` \n\n#### Result: \nreturns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.\n\n#### Special cases:     \n  * if the lef-hand operand (the graph) is nil, throws an Exception\n\n#### Examples: \n```\ngraph graphEpidemio <- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] );\nunknown var1 <- graphEpidemio source_of(edge(3)); \t// var1 equals node1\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\npoint var3 <- graphFromMap source_of(link({1,5}::{12,45})); \t// var3 equals {1,5}\n```\n      \n\n#### See also: \n[target_of](#target_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_spatial_graph)\n### `spatial_graph`\n\n#### Possible use: \n  *  **`spatial_graph`** (`container`) --->  `graph` \n\n#### Result: \nallows to create a spatial graph from a container of vertices, without trying to wire them. The container can be empty. Emits an error if the contents of the container are not geometries, points or agents    \n\n#### See also: \n[graph](#graph), \n    \t\n----\n\n\n[//]: # (keyword|operator_species)\n### `species`\n\n#### Possible use: \n  *  **`species`** (`unknown`) --->  `species` \n\n#### Result: \ncasting of the operand to a species.\n\n#### Special cases:     \n  * if the operand is nil, returns nil;    \n  * if the operand is an agent, returns its species;    \n  * if the operand is a string, returns the species with this name (nil if not found);    \n  * otherwise, returns nil\n\n#### Examples: \n```\nspecies var0 <- species(self); \t// var0 equals the species of the current agent\nspecies var1 <- species('node'); \t// var1 equals node\nspecies var2 <- species([1,5,9,3]); \t// var2 equals nil\nspecies var3 <- species(node1); \t// var3 equals node\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_species_of)\n### `species_of`\nSame signification as [species](#species)\n    \t\n----\n\n\n[//]: # (keyword|operator_sphere)\n### `sphere`\n\n#### Possible use: \n  *  **`sphere`** (`float`) --->  `geometry` \n\n#### Result: \nA sphere geometry which radius is equal to the operand.  \n\n#### Comment: \nthe centre of the sphere is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- sphere(10); \t// var0 equals a geometry as a circle of radius 10 but displays a sphere.\n```\n      \n\n#### See also: \n[around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_split_at)\n### `split_at`\n\n#### Possible use: \n  * `geometry` **`split_at`** `point` --->  `list<geometry>`\n  *  **`split_at`** (`geometry` , `point`) --->  `list<geometry>` \n\n#### Result: \nThe two part of the left-operand lines split at the given right-operand point\n\n#### Special cases:     \n  * if the left-operand is a point or a polygon, returns an empty list\n\n#### Examples: \n```\nlist<geometry> var0 <- polyline([{1,2},{4,6}]) split_at {7,6}; \t// var0 equals [polyline([{1.0,2.0},{7.0,6.0}]), polyline([{7.0,6.0},{4.0,6.0}])]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_split_geometry)\n### `split_geometry`\n\n#### Possible use: \n  * `geometry` **`split_geometry`** `float` --->  `list<geometry>`\n  *  **`split_geometry`** (`geometry` , `float`) --->  `list<geometry>`\n  * `geometry` **`split_geometry`** `point` --->  `list<geometry>`\n  *  **`split_geometry`** (`geometry` , `point`) --->  `list<geometry>`\n  *  **`split_geometry`** (`geometry`, `int`, `int`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries that result from the decomposition of the geometry by square cells of the given side size (geometry, size)\nA list of geometries that result from the decomposition of the geometry by rectangle cells of the given dimension (geometry, {size_x, size_y})\nA list of geometries that result from the decomposition of the geometry according to a grid with the given number of rows and columns (geometry, nb_cols, nb_rows)\n\n#### Examples: \n```\nlist<geometry> var0 <- to_squares(self, 10.0); \t// var0 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0\nlist<geometry> var1 <- to_rectangles(self, {10.0, 15.0}); \t// var1 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0\nlist<geometry> var2 <- to_rectangles(self, 10,20); \t// var2 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operator\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_split_lines)\n### `split_lines`\n\n#### Possible use: \n  *  **`split_lines`** (`container<geometry>`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries resulting after cutting the lines at their intersections.\n\n#### Examples: \n```\nlist<geometry> var0 <- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); \t// var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_split_with)\n### `split_with`\n\n#### Possible use: \n  * `string` **`split_with`** `string` --->  `container`\n  *  **`split_with`** (`string` , `string`) --->  `container` \n\n#### Result: \nReturns a list containing the sub-strings (tokens) of the left-hand operand delimited by each of the characters of the right-hand operand.  \n\n#### Comment: \nDelimiters themselves are excluded from the resulting list.\n\n#### Examples: \n```\ncontainer var0 <- 'to be or not to be,that is the question' split_with ' ,'; \t// var0 equals ['to','be','or','not','to','be','that','is','the','question']\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_sqrt)\n### `sqrt`\n\n#### Possible use: \n  *  **`sqrt`** (`int`) --->  `float`\n  *  **`sqrt`** (`float`) --->  `float` \n\n#### Result: \nReturns the square root of the operand.\n\n#### Special cases:     \n  * if the operand is negative, an exception is raised\n\n#### Examples: \n```\nfloat var0 <- sqrt(4); \t// var0 equals 2.0\nfloat var1 <- sqrt(4); \t// var1 equals 2.0\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_square)\n### `square`\n\n#### Possible use: \n  *  **`square`** (`float`) --->  `geometry` \n\n#### Result: \nA square geometry which side size is equal to the operand.  \n\n#### Comment: \nthe centre of the square is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- square(10); \t// var0 equals a geometry as a square of side size 10.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_squircle)\n### `squircle`\n\n#### Possible use: \n  * `float` **`squircle`** `float` --->  `geometry`\n  *  **`squircle`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nA mix of square and circle geometry (see : http://en.wikipedia.org/wiki/Squircle), which side size is equal to the first operand and power is equal to the second operand  \n\n#### Comment: \nthe center of the ellipse is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the side operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- squircle(4,4); \t// var0 equals a geometry as a squircle of side 4 with a power of 4.\n```\n      \n\n#### See also: \n[around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [super_ellipse](#super_ellipse), [rectangle](#rectangle), [square](#square), [circle](#circle), [ellipse](#ellipse), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_standard_deviation)\n### `standard_deviation`\n\n#### Possible use: \n  *  **`standard_deviation`** (`container`) --->  `float` \n\n#### Result: \nthe standard deviation on the elements of the operand. See <A href=\"http://en.wikipedia.org/wiki/Standard_deviation\">Standard_deviation</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- standard_deviation ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.2930100540985752\n```\n      \n\n#### See also: \n[mean](#mean), [mean_deviation](#mean_deviation), \n    \t\n----\n\n\n[//]: # (keyword|operator_string)\n### `string`\n\n#### Possible use: \n  * `date` **`string`** `string` --->  `string`\n  *  **`string`** (`date` , `string`) --->  `string` \n\n#### Result: \nconverts a date to astring following a custom pattern. The pattern can use \"%Y %M %N %D %E %h %m %s %z\" for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will return the complete date as defined by the ISO date & time format. The pattern can also follow the pattern definition found here, which gives much more control over the format of the date: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constants: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences\n\n#### Examples: \n```\nformat(#now, 'yyyy-MM-dd')\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_subtract_days)\n### `subtract_days`\nSame signification as [minus_days](#minus_days)\n    \t\n----\n\n\n[//]: # (keyword|operator_subtract_hours)\n### `subtract_hours`\nSame signification as [minus_hours](#minus_hours)\n    \t\n----\n\n\n[//]: # (keyword|operator_subtract_minutes)\n### `subtract_minutes`\nSame signification as [minus_minutes](#minus_minutes)\n    \t\n----\n\n\n[//]: # (keyword|operator_subtract_months)\n### `subtract_months`\nSame signification as [minus_months](#minus_months)\n    \t\n----\n\n\n[//]: # (keyword|operator_subtract_ms)\n### `subtract_ms`\nSame signification as [minus_ms](#minus_ms)\n    \t\n----\n\n\n[//]: # (keyword|operator_subtract_seconds)\n### `subtract_seconds`\nSame signification as [-](#-)\n    \t\n----\n\n\n[//]: # (keyword|operator_subtract_weeks)\n### `subtract_weeks`\nSame signification as [minus_weeks](#minus_weeks)\n    \t\n----\n\n\n[//]: # (keyword|operator_subtract_years)\n### `subtract_years`\nSame signification as [minus_years](#minus_years)\n    \t\n----\n\n\n[//]: # (keyword|operator_successors_of)\n### `successors_of`\n\n#### Possible use: \n  * `graph` **`successors_of`** `unknown` --->  `container`\n  *  **`successors_of`** (`graph` , `unknown`) --->  `container` \n\n#### Result: \nreturns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)\n\n#### Examples: \n```\ncontainer var1 <- graphEpidemio successors_of ({1,5}); \t// var1 equals [{12,45}]\ncontainer var2 <- graphEpidemio successors_of node({34,56}); \t// var2 equals []\n```\n      \n\n#### See also: \n[predecessors_of](#predecessors_of), [neighbors_of](#neighbors_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_sum)\n### `sum`\n\n#### Possible use: \n  *  **`sum`** (`graph`) --->  `float`\n  *  **`sum`** (`container`) --->  `unknown` \n\n#### Result: \nthe sum of all the elements of the operand  \n\n#### Comment: \nthe behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a population or a list of other types: sum transforms all elements into float and sums them    \n  * if it is a map, sum returns the sum of the value of all elements    \n  * if it is a file, sum returns the sum of the content of the file (that is also a container)    \n  * if it is a graph, sum returns the total weight of the graph    \n  * if it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices)    \n  * if it is a matrix of other types: sum transforms all elements into float and sums them    \n  * if it is a list of colors: sum will sum them and return the blended resulting color    \n  * if it is a list of int or float: sum returns the sum of all the elements \n  \n```\nint var0 <- sum ([12,10,3]); \t// var0 equals 25\n\n``` \n\n    \n  * if it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element) \n  \n```\nunknown var1 <- sum([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); \t// var1 equals {20.0,17.0}\n\n``` \n\n    \n\n#### See also: \n[mul](#mul), \n    \t\n----\n\n\n[//]: # (keyword|operator_sum_of)\n### `sum_of`\n\n#### Possible use: \n  * `container` **`sum_of`** `any expression` --->  `unknown`\n  *  **`sum_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe sum of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var2 <- [1::2, 3::4, 5::6] sum_of (each + 3); \t// var2 equals 21\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2] sum_of (each * 100 ); \t// var1 equals 300\n```\n      \n\n#### See also: \n[min_of](#min_of), [max_of](#max_of), [product_of](#product_of), [mean_of](#mean_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_svg_file)\n### `svg_file`\n\n#### Possible use: \n  *  **`svg_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type svg. Allowed extensions are limited to svg\n    \t\n----\n\n\n[//]: # (keyword|operator_tan)\n### `tan`\n\n#### Possible use: \n  *  **`tan`** (`int`) --->  `float`\n  *  **`tan`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16    \n  * The tangent is only defined for any real number except 90 + k `*` 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).\n\n#### Examples: \n```\nfloat var0 <- tan (0); \t// var0 equals 0.0\nfloat var1 <- tan(90); \t// var1 equals 1.633123935319537E16\n```\n      \n\n#### See also: \n[cos](#cos), [sin](#sin), \n    \t\n----\n\n\n[//]: # (keyword|operator_tan_rad)\n### `tan_rad`\n\n#### Possible use: \n  *  **`tan_rad`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16    \n  * The tangent is only defined for any real number except 90 + k `*` 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).    \n\n#### See also: \n[cos](#cos), [sin](#sin), \n    \t\n----\n\n\n[//]: # (keyword|operator_tanh)\n### `tanh`\n\n#### Possible use: \n  *  **`tanh`** (`float`) --->  `float`\n  *  **`tanh`** (`int`) --->  `float` \n\n#### Result: \nReturns the value (in the interval [-1,1]) of the hyperbolic tangent of the operand (which can be any real number, expressed in decimal degrees).\n\n#### Examples: \n```\nfloat var0 <- tanh(0); \t// var0 equals 0.0\nfloat var1 <- tanh(100); \t// var1 equals 1.0\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_target_of)\n### `target_of`\n\n#### Possible use: \n  * `graph` **`target_of`** `unknown` --->  `unknown`\n  *  **`target_of`** (`graph` , `unknown`) --->  `unknown` \n\n#### Result: \nreturns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.\n\n#### Special cases:     \n  * if the lef-hand operand (the graph) is nil, returns nil\n\n#### Examples: \n```\ngraph graphEpidemio <- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] );\nunknown var1 <- graphEpidemio source_of(edge(3)); \t// var1 equals node1\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nunknown var3 <- graphFromMap target_of(link({1,5}::{12,45})); \t// var3 equals {12,45}\n```\n      \n\n#### See also: \n[source_of](#source_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_teapot)\n### `teapot`\n\n#### Possible use: \n  *  **`teapot`** (`float`) --->  `geometry` \n\n#### Result: \nA teapot geometry which radius is equal to the operand.  \n\n#### Comment: \nthe centre of the teapot is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- teapot(10); \t// var0 equals a geometry as a circle of radius 10 but displays a teapot.\n```\n      \n\n#### See also: \n[around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), \n    \t\n----\n\n\n[//]: # (keyword|operator_text_file)\n### `text_file`\n\n#### Possible use: \n  *  **`text_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type text. Allowed extensions are limited to txt, data, text\n    \t\n----\n\n\n[//]: # (keyword|operator_TGauss)\n### `TGauss`\nSame signification as [truncated_gauss](#truncated_gauss)\n    \t\n----\n\n\n[//]: # (keyword|operator_threeds_file)\n### `threeds_file`\n\n#### Possible use: \n  *  **`threeds_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type threeds. Allowed extensions are limited to 3ds, max\n    \t\n----\n\n\n[//]: # (keyword|operator_to)\n### `to`\n\n#### Possible use: \n  * `date` **`to`** `date` --->  `msi.gama.util.IList<msi.gama.util.GamaDate>`\n  *  **`to`** (`date` , `date`) --->  `msi.gama.util.IList<msi.gama.util.GamaDate>` \n\n#### Result: \nbuilds an interval between two dates (the first inclusive and the second exclusive, which behaves like a read-only list of dates. The default step between two dates is the step of the model  \n\n#### Comment: \nThe default step can be overruled by using the every operator applied to this interval\n\n#### Examples: \n```\ndate('2000-01-01') to date('2010-01-01') // builds an interval between these two dates\n(date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval\n```\n      \n\n#### See also: \n[every](#every), \n    \t\n----\n\n\n[//]: # (keyword|operator_to_GAMA_CRS)\n### `to_GAMA_CRS`\n\n#### Possible use: \n  *  **`to_GAMA_CRS`** (`geometry`) --->  `geometry`\n  * `geometry` **`to_GAMA_CRS`** `string` --->  `geometry`\n  *  **`to_GAMA_CRS`** (`geometry` , `string`) --->  `geometry`\n\n#### Special cases:     \n  * returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRS \n  \n```\ngeometry var0 <- to_GAMA_CRS({121,14}, \"EPSG:4326\"); \t// var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS\n\n``` \n\n    \n  * returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world's agent one \n  \n```\ngeometry var1 <- to_GAMA_CRS({121,14}); \t// var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_to_gaml)\n### `to_gaml`\n\n#### Possible use: \n  *  **`to_gaml`** (`unknown`) --->  `string` \n\n#### Result: \nreturns the literal description of an expression or description -- action, behavior, species, aspect, even model -- in gaml\n\n#### Examples: \n```\nstring var0 <- to_gaml(0); \t// var0 equals '0'\nstring var1 <- to_gaml(3.78); \t// var1 equals '3.78'\nstring var2 <- to_gaml(true); \t// var2 equals 'true'\nstring var3 <- to_gaml({23, 4.0}); \t// var3 equals '{23.0,4.0,0.0}'\nstring var4 <- to_gaml(5::34); \t// var4 equals '5::34'\nstring var5 <- to_gaml(rgb(255,0,125)); \t// var5 equals 'rgb (255, 0, 125,255)'\nstring var6 <- to_gaml('hello'); \t// var6 equals \"'hello'\"\nstring var7 <- to_gaml([1,5,9,3]); \t// var7 equals '[1,5,9,3]'\nstring var8 <- to_gaml(['a'::345, 'b'::13, 'c'::12]); \t// var8 equals \"(['a'::345,'b'::13,'c'::12] as map )\"\nstring var9 <- to_gaml([[3,5,7,9],[2,4,6,8]]); \t// var9 equals '[[3,5,7,9],[2,4,6,8]]'\nstring var10 <- to_gaml(a_graph); \t// var10 equals ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graph\nstring var11 <- to_gaml(node1); \t// var11 equals  1 as node\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_to_rectangles)\n### `to_rectangles`\n\n#### Possible use: \n  *  **`to_rectangles`** (`geometry`, `point`, `bool`) --->  `list<geometry>`\n  *  **`to_rectangles`** (`geometry`, `int`, `int`, `bool`) --->  `list<geometry>` \n\n#### Result: \nA list of rectangles of the size corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, dimension, overlaps), if overlaps = true, add the rectangles that overlap the border of the geometry\nA list of rectangles corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, nb_cols, nb_rows, overlaps) by a grid composed of the given number of columns and rows, if overlaps = true, add the rectangles that overlap the border of the geometry\n\n#### Examples: \n```\nlist<geometry> var0 <- to_rectangles(self, {10.0, 15.0}, true); \t// var0 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretization into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept\nlist<geometry> var1 <- to_rectangles(self, 5, 20, true); \t// var1 equals the list of rectangles corresponding to the discretization by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_to_squares)\n### `to_squares`\nSame signification as [split_geometry](#split_geometry)\n\n#### Possible use: \n  *  **`to_squares`** (`geometry`, `int`, `bool`) --->  `list<geometry>`\n  *  **`to_squares`** (`geometry`, `float`, `bool`) --->  `list<geometry>`\n  *  **`to_squares`** (`geometry`, `int`, `bool`, `float`) --->  `list<geometry>` \n\n#### Result: \nA list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps), if overlaps = true, add the squares that overlap the border of the geometry\nA list of squares of the size corresponding to the given size that result from the decomposition of the geometry into squares (geometry, size, overlaps), if overlaps = true, add the squares that overlap the border of the geometry\nA list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps, precision_coefficient), if overlaps = true, add the squares that overlap the border of the geometry, coefficient_precision should be close to 1.0\n\n#### Examples: \n```\nlist<geometry> var0 <- to_squares(self, 10, true); \t// var0 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept\nlist<geometry> var1 <- to_squares(self, 10.0, true); \t// var1 equals the list of squares of side size 10.0 corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept\nlist<geometry> var2 <- to_squares(self, 10, true, 0.99); \t// var2 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_to_triangles)\n### `to_triangles`\nSame signification as [triangulate](#triangulate)\n    \t\n----\n\n\n[//]: # (keyword|operator_tokenize)\n### `tokenize`\nSame signification as [split_with](#split_with)\n    \t\n----\n\n\n[//]: # (keyword|operator_topology)\n### `topology`\n\n#### Possible use: \n  *  **`topology`** (`unknown`) --->  `topology` \n\n#### Result: \ncasting of the operand to a topology.\n\n#### Special cases:     \n  * if the operand is a topology, returns the topology itself;    \n  * if the operand is a spatial graph, returns the graph topology associated;    \n  * if the operand is a population, returns the topology of the population;    \n  * if the operand is a shape or a geometry, returns the continuous topology bounded by the geometry;    \n  * if the operand is a matrix, returns the grid topology associated    \n  * if the operand is another kind of container, returns the multiple topology associated to the container    \n  * otherwise, casts the operand to a geometry and build a topology from it.\n\n#### Examples: \n```\ntopology var0 <- topology(0); \t// var0 equals nil\ntopology(a_graph)\t--: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046  7.867357373616512)) at location[53.556743711446195;34.57529210646354]\n```\n      \n\n#### See also: \n[geometry](#geometry), \n    \t\n----\n\n\n[//]: # (keyword|operator_touches)\n### `touches`\n\n#### Possible use: \n  * `geometry` **`touches`** `geometry` --->  `bool`\n  *  **`touches`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).  \n\n#### Comment: \nreturns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.\n\n#### Special cases:     \n  * if one of the operand is null, returns false.\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) touches {15,15}; \t// var0 equals false\nbool var1 <- polyline([{10,10},{20,20}]) touches {10,10}; \t// var1 equals true\nbool var2 <- {15,15} touches {15,15}; \t// var2 equals false\nbool var3 <- polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]); \t// var3 equals true\nbool var4 <- polyline([{10,10},{20,20}]) touches polyline([{5,5},{15,15}]); \t// var4 equals false\nbool var5 <- polyline([{10,10},{20,20}]) touches polyline([{15,15},{25,25}]); \t// var5 equals false\nbool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var6 equals false\nbool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var7 equals true\nbool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,10},{0,10},{0,0},{10,0}]); \t// var8 equals true\nbool var9 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {15,15}; \t// var9 equals false\nbool var10 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {10,15}; \t// var10 equals true\n```\n      \n\n#### See also: \n[disjoint_from](#disjoint_from), [crosses](#crosses), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [intersects](#intersects), \n    \t\n----\n\n\n[//]: # (keyword|operator_towards)\n### `towards`\n\n#### Possible use: \n  * `geometry` **`towards`** `geometry` --->  `int`\n  *  **`towards`** (`geometry` , `geometry`) --->  `int` \n\n#### Result: \nThe direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.\n\n#### Examples: \n```\nint var0 <- ag1 towards ag2; \t// var0 equals the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operator\n```\n      \n\n#### See also: \n[distance_between](#distance_between), [distance_to](#distance_to), [direction_between](#direction_between), [path_between](#path_between), [path_to](#path_to), \n    \t\n----\n\n\n[//]: # (keyword|operator_trace)\n### `trace`\n\n#### Possible use: \n  *  **`trace`** (`matrix`) --->  `float` \n\n#### Result: \nThe trace of the given matrix (the sum of the elements on the main diagonal).\n\n#### Examples: \n```\nfloat var0 <- trace(matrix([[1,2],[3,4]])); \t// var0 equals 5\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_transformed_by)\n### `transformed_by`\n\n#### Possible use: \n  * `geometry` **`transformed_by`** `point` --->  `geometry`\n  *  **`transformed_by`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the application of a rotation and a scaling (right-operand : point {angle(degree), scale factor} of the left-hand operand (geometry, agent, point)\n\n#### Examples: \n```\ngeometry var0 <- self transformed_by {45, 0.5}; \t// var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.\n```\n      \n\n#### See also: \n[rotated_by](#rotated_by), [translated_by](#translated_by), \n    \t\n----\n\n\n[//]: # (keyword|operator_translated_by)\n### `translated_by`\n\n#### Possible use: \n  * `geometry` **`translated_by`** `point` --->  `geometry`\n  *  **`translated_by`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)\n\n#### Examples: \n```\ngeometry var0 <- self translated_by {10,10,10}; \t// var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).\n```\n      \n\n#### See also: \n[rotated_by](#rotated_by), [transformed_by](#transformed_by), \n    \t\n----\n\n\n[//]: # (keyword|operator_translated_to)\n### `translated_to`\nSame signification as [at_location](#at_location)\n    \t\n----\n\n\n[//]: # (keyword|operator_transpose)\n### `transpose`\n\n#### Possible use: \n  *  **`transpose`** (`matrix`) --->  `matrix` \n\n#### Result: \nThe transposition of the given matrix\n\n#### Examples: \n```\nmatrix var0 <- transpose(matrix([[5,-3],[6,-4]])); \t// var0 equals [[5,6],[-3,-4]]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_triangle)\n### `triangle`\n\n#### Possible use: \n  *  **`triangle`** (`float`) --->  `geometry` \n\n#### Result: \nA triangle geometry which side size is given by the operand.  \n\n#### Comment: \nthe center of the triangle is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- triangle(5); \t// var0 equals a geometry as a triangle with side_size = 5.\n```\n      \n\n#### See also: \n[around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), \n    \t\n----\n\n\n[//]: # (keyword|operator_triangulate)\n### `triangulate`\n\n#### Possible use: \n  *  **`triangulate`** (`list<geometry>`) --->  `list<geometry>`\n  *  **`triangulate`** (`geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)\n\n#### Examples: \n```\nlist<geometry> var0 <- triangulate(self); \t// var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.\nlist<geometry> var1 <- triangulate(self); \t// var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_truncated_gauss)\n### `truncated_gauss`\n\n#### Possible use: \n  *  **`truncated_gauss`** (`container`) --->  `float`\n  *  **`truncated_gauss`** (`point`) --->  `float` \n\n#### Result: \nA random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.\n\n#### Special cases:     \n  * if the operand is a list, only the two first elements are taken into account as [mean, standardDeviation]    \n  * when truncated_gauss is called with a list of only one element mean, it will always return 0.0    \n  * when the operand is a point, it is read as {mean, standardDeviation}\n\n#### Examples: \n```\nfloat var0 <- truncated_gauss ([0.5, 0.0]); \t// var0 equals 0.5\nfloat var1 <- truncated_gauss ({0, 0.3}); \t// var1 equals a float between -0.3 and 0.3\n```\n      \n\n#### See also: \n[gauss](#gauss), \n    \t\n----\n\n\n[//]: # (keyword|operator_undirected)\n### `undirected`\n\n#### Possible use: \n  *  **`undirected`** (`graph`) --->  `graph` \n\n#### Result: \nthe operand graph becomes an undirected graph.  \n\n#### Comment: \nthe operator alters the operand graph, it does not create a new one.    \n\n#### See also: \n[directed](#directed), \n    \t\n----\n\n\n[//]: # (keyword|operator_union)\n### `union`\n\n#### Possible use: \n  *  **`union`** (`container<geometry>`) --->  `geometry`\n  * `container` **`union`** `container` --->  `container`\n  *  **`union`** (`container` , `container`) --->  `container` \n\n#### Result: \nreturns a new list containing all the elements of both containers without duplicated elements.\n\n#### Special cases:     \n  * if the left or right operand is nil, union throws an error    \n  * if the right-operand is a container of points, geometries or agents, returns the geometry resulting from the union all the geometries\n\n#### Examples: \n```\ncontainer var0 <- [1,2,3,4,5,6] union [2,4,9]; \t// var0 equals [1,2,3,4,5,6,9]\ncontainer var1 <- [1,2,3,4,5,6] union [0,8]; \t// var1 equals [1,2,3,4,5,6,0,8]\ncontainer var2 <- [1,3,2,4,5,6,8,5,6] union [0,8]; \t// var2 equals [1,3,2,4,5,6,8,0]\ngeometry var3 <- union([geom1, geom2, geom3]); \t// var3 equals a geometry corresponding to union between geom1, geom2 and geom3\n```\n      \n\n#### See also: \n[inter](#inter), [+](#+), \n    \t\n----\n\n\n[//]: # (keyword|operator_unknown)\n### `unknown`\n\n#### Possible use: \n  *  **`unknown`** (`any`) --->  `unknown` \n\n#### Result: \nCasts the operand into the type unknown\n    \t\n----\n\n\n[//]: # (keyword|operator_until)\n### `until`\n\n#### Possible use: \n  *  **`until`** (`date`) --->  `bool`\n  * `any expression` **`until`** `date` --->  `bool`\n  *  **`until`** (`any expression` , `date`) --->  `bool` \n\n#### Result: \nReturns true if the current_date of the model is before (or equel to) the date passed in argument. Synonym of 'current_date <= argument'\n\n#### Examples: \n```\nreflex when: until(starting_date) {} -: will be run only once at the beginning of the simulation\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_upper_case)\n### `upper_case`\n\n#### Possible use: \n  *  **`upper_case`** (`string`) --->  `string` \n\n#### Result: \nConverts all of the characters in the string operand to upper case\n\n#### Examples: \n```\nstring var0 <- upper_case(\"Abc\"); \t// var0 equals 'ABC'\n```\n      \n\n#### See also: \n[lower_case](#lower_case), \n    \t\n----\n\n\n[//]: # (keyword|operator_URL_file)\n### `URL_file`\n\n#### Possible use: \n  *  **`URL_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type URL. Allowed extensions are limited to url\n    \t\n----\n\n\n[//]: # (keyword|operator_use_cache)\n### `use_cache`\n\n#### Possible use: \n  * `graph` **`use_cache`** `bool` --->  `graph`\n  *  **`use_cache`** (`graph` , `bool`) --->  `graph` \n\n#### Result: \nif the second operand is true, the operand graph will store in a cache all the previously computed shortest path (the cache be cleared if the graph is modified).  \n\n#### Comment: \nthe operator alters the operand graph, it does not create a new one.    \n\n#### See also: \n[path_between](#path_between), \n    \t\n----\n\n\n[//]: # (keyword|operator_user_input)\n### `user_input`\n\n#### Possible use: \n  *  **`user_input`** (`any expression`) --->  `map<string,unknown>`\n  * `string` **`user_input`** `any expression` --->  `map<string,unknown>`\n  *  **`user_input`** (`string` , `any expression`) --->  `map<string,unknown>` \n\n#### Result: \nasks the user for some values (not defined as parameters). Takes a string (optional) and a map as arguments. The string is used to specify the message of the dialog box. The map is to specify the parameters you want the user to change before the simulation starts, with the name of the parameter in string key, and the default value as value.  \n\n#### Comment: \nThis operator takes a map [string::value] as argument, displays a dialog asking the user for these values, and returns the same map with the modified values (if any). The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section to force the user to input new values instead of relying on the initial values of parameters :\n\n#### Examples: \n```\nmap<string,unknown> values2 <- user_input(\"Enter numer of agents and locations\",[\"Number\" :: 100, \"Location\" :: {10, 10}]);\ncreate bug number: int(values2 at \"Number\") with: [location:: (point(values2 at \"Location\"))];\nmap<string,unknown> values <- user_input([\"Number\" :: 100, \"Location\" :: {10, 10}]);\ncreate bug number: int(values at \"Number\") with: [location:: (point(values at \"Location\"))];\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_using)\n### `using`\n\n#### Possible use: \n  * `any expression` **`using`** `topology` --->  `unknown`\n  *  **`using`** (`any expression` , `topology`) --->  `unknown` \n\n#### Result: \nAllows to specify in which topology a spatial computation should take place.\n\n#### Special cases:     \n  * has no effect if the topology passed as a parameter is nil\n\n#### Examples: \n```\nunknown var0 <- (agents closest_to self) using topology(world); \t// var0 equals the closest agent to self (the caller) in the continuous topology of the world\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_variance)\n### `variance`\n\n#### Possible use: \n  *  **`variance`** (`container`) --->  `float` \n\n#### Result: \nthe variance of the elements of the operand. See <A href=\"http://en.wikipedia.org/wiki/Variance\">Variance</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- variance ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.671875\n```\n      \n\n#### See also: \n[mean](#mean), [median](#median), \n    \t\n----\n\n\n[//]: # (keyword|operator_variance_of)\n### `variance_of`\n\n#### Possible use: \n  * `container` **`variance_of`** `any expression` --->  `unknown`\n  *  **`variance_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe variance of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.    \n\n#### See also: \n[min_of](#min_of), [max_of](#max_of), [sum_of](#sum_of), [product_of](#product_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_voronoi)\n### `voronoi`\n\n#### Possible use: \n  *  **`voronoi`** (`list<point>`) --->  `list<geometry>`\n  * `list<point>` **`voronoi`** `geometry` --->  `list<geometry>`\n  *  **`voronoi`** (`list<point>` , `geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries corresponding to the Voronoi diagram built from the list of points according to the given clip\nA list of geometries corresponding to the Voronoi diagram built from the list of points\n\n#### Examples: \n```\nlist<geometry> var0 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}], square(300)); \t// var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points with a square of 300m side size as clip.\nlist<geometry> var1 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]); \t// var1 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points.\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_weight_of)\n### `weight_of`\n\n#### Possible use: \n  * `graph` **`weight_of`** `unknown` --->  `float`\n  *  **`weight_of`** (`graph` , `unknown`) --->  `float` \n\n#### Result: \nreturns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.  \n\n#### Comment: \nIn a localized graph, an edge has a weight by default (the distance between both vertices).\n\n#### Special cases:     \n  * if the left-operand (the graph) is nil, returns nil    \n  * if the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight    \n  * if the right-hand operand is neither a node, nor an edge, returns 1.\n\n#### Examples: \n```\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nfloat var1 <- graphFromMap weight_of(link({1,5}::{12,45})); \t// var1 equals 1.0\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_weighted_means_DM)\n### `weighted_means_DM`\n\n#### Possible use: \n  * `list<list>` **`weighted_means_DM`** `list<map<string,object>>` --->  `int`\n  *  **`weighted_means_DM`** (`list<list>` , `list<map<string,object>>`) --->  `int` \n\n#### Result: \nThe index of the candidate that maximizes the weighted mean of its criterion values. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of map)\n\n#### Special cases:     \n  * returns -1 is the list of candidates is nil or empty\n\n#### Examples: \n```\nint var0 <- weighted_means_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0],[\"name\"::\"price\", \"weight\" :: 1.0]]); \t// var0 equals 1\n```\n      \n\n#### See also: \n[promethee_DM](#promethee_dm), [electre_DM](#electre_dm), [evidence_theory_DM](#evidence_theory_dm), \n    \t\n----\n\n\n[//]: # (keyword|operator_where)\n### `where`\n\n#### Possible use: \n  * `container` **`where`** `any expression` --->  `container`\n  *  **`where`** (`container` , `any expression`) --->  `container` \n\n#### Result: \na list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true.  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is a list nil, where returns a new empty list    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\ncontainer var4 <- [1::2, 3::4, 5::6] where (each >= 4); \t// var4 equals [4, 6]\n\n``` \n\n\n\n#### Examples: \n```\ncontainer var0 <- [1,2,3,4,5,6,7,8] where (each > 3); \t// var0 equals [4, 5, 6, 7, 8] \ncontainer var2 <- g2 where (length(g2 out_edges_of each) = 0 ); \t// var2 equals [node9, node7, node10, node8, node11]\ncontainer var3 <- (list(node) where (round(node(each).location.x) > 32); \t// var3 equals [node2, node3]\n```\n      \n\n#### See also: \n[first_with](#first_with), [last_with](#last_with), [where](#where), \n    \t\n----\n\n\n[//]: # (keyword|operator_with_lifetime)\n### `with_lifetime`\n\n#### Possible use: \n  * `predicate` **`with_lifetime`** `int` --->  `predicate`\n  *  **`with_lifetime`** (`predicate` , `int`) --->  `predicate` \n\n#### Result: \nchange the parameters of the given predicate\n\n#### Examples: \n```\npredicate with_lifetime 10\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_with_max_of)\n### `with_max_of`\n\n#### Possible use: \n  * `container` **`with_max_of`** `any expression` --->  `unknown`\n  *  **`with_max_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \none of elements of the left-hand operand that maximizes the value of the right-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand\n\n#### Examples: \n```\nunknown var0 <- [1,2,3,4,5,6,7,8] with_max_of (each ); \t// var0 equals 8\nunknown var2 <- g2 with_max_of (length(g2 out_edges_of each)  ) ; \t// var2 equals node4\nunknown var3 <- (list(node) with_max_of (round(node(each).location.x)); \t// var3 equals node3\nunknown var4 <- [1::2, 3::4, 5::6] with_max_of (each); \t// var4 equals 6\n```\n      \n\n#### See also: \n[where](#where), [with_min_of](#with_min_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_with_min_of)\n### `with_min_of`\n\n#### Possible use: \n  * `container` **`with_min_of`** `any expression` --->  `unknown`\n  *  **`with_min_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \none of elements of the left-hand operand that minimizes the value of the right-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand\n\n#### Examples: \n```\nunknown var0 <- [1,2,3,4,5,6,7,8] with_min_of (each ); \t// var0 equals 1\nunknown var2 <- g2 with_min_of (length(g2 out_edges_of each)  ); \t// var2 equals node11\nunknown var3 <- (list(node) with_min_of (round(node(each).location.x)); \t// var3 equals node0\nunknown var4 <- [1::2, 3::4, 5::6] with_min_of (each); \t// var4 equals 2\n```\n      \n\n#### See also: \n[where](#where), [with_max_of](#with_max_of), \n    \t\n----\n\n\n[//]: # (keyword|operator_with_optimizer_type)\n### `with_optimizer_type`\n\n#### Possible use: \n  * `graph` **`with_optimizer_type`** `string` --->  `graph`\n  *  **`with_optimizer_type`** (`graph` , `string`) --->  `graph` \n\n#### Result: \nchanges the shortest path computation method of the given graph  \n\n#### Comment: \nthe right-hand operand can be \"Djikstra\", \"Bellmann\", \"Astar\" to use the associated algorithm. Note that these methods are dynamic: the path is computed when needed. In contrarily, if the operand is another string, a static method will be used, i.e. all the shortest are previously computed.\n\n#### Examples: \n```\ngraphEpidemio <- graphEpidemio with_optimizer_type \"static\";\n```\n      \n\n#### See also: \n[set_verbose](#set_verbose), \n    \t\n----\n\n\n[//]: # (keyword|operator_with_praiseworthiness)\n### `with_praiseworthiness`\n\n#### Possible use: \n  * `predicate` **`with_praiseworthiness`** `float` --->  `predicate`\n  *  **`with_praiseworthiness`** (`predicate` , `float`) --->  `predicate` \n\n#### Result: \nchange the praiseworthiness value of the given predicate\n\n#### Examples: \n```\npredicate set_truth false\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_with_precision)\n### `with_precision`\n\n#### Possible use: \n  * `float` **`with_precision`** `int` --->  `float`\n  *  **`with_precision`** (`float` , `int`) --->  `float`\n  * `point` **`with_precision`** `int` --->  `point`\n  *  **`with_precision`** (`point` , `int`) --->  `point` \n\n#### Result: \nRounds off the value of left-hand operand to the precision given by the value of right-hand operand\nRounds off the ordinates of the left-hand point to the precision given by the value of right-hand operand\n\n#### Examples: \n```\nfloat var0 <- 12345.78943 with_precision 2; \t// var0 equals 12345.79\nfloat var1 <- 123 with_precision 2; \t// var1 equals 123.00\npoint var2 <- {12345.78943, 12345.78943, 12345.78943} with_precision 2 ; \t// var2 equals {12345.79, 12345.79, 12345.79}\n```\n      \n\n#### See also: \n[round](#round), \n    \t\n----\n\n\n[//]: # (keyword|operator_with_priority)\n### `with_priority`\n\n#### Possible use: \n  * `predicate` **`with_priority`** `float` --->  `predicate`\n  *  **`with_priority`** (`predicate` , `float`) --->  `predicate` \n\n#### Result: \nchange the priority of the given predicate\n\n#### Examples: \n```\npredicate with_priority 2\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_with_values)\n### `with_values`\n\n#### Possible use: \n  * `predicate` **`with_values`** `map` --->  `predicate`\n  *  **`with_values`** (`predicate` , `map`) --->  `predicate` \n\n#### Result: \nchange the parameters of the given predicate\n\n#### Examples: \n```\npredicate with_values [\"time\"::10]\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_with_weights)\n### `with_weights`\n\n#### Possible use: \n  * `graph` **`with_weights`** `map` --->  `graph`\n  *  **`with_weights`** (`graph` , `map`) --->  `graph`\n  * `graph` **`with_weights`** `container` --->  `graph`\n  *  **`with_weights`** (`graph` , `container`) --->  `graph` \n\n#### Result: \nreturns the graph (left-hand operand) with weight given in the map (right-hand operand).  \n\n#### Comment: \nthis operand re-initializes the path finder\n\n#### Special cases:     \n  * if the right-hand operand is a list, affects the n elements of the list to the n first edges. Note that the ordering of edges may change overtime, which can create some problems...    \n  * if the left-hand operand is a map, the map should contains pairs such as: vertex/edge::double \n  \n```\ngraph_from_edges (list(ant) as_map each::one_of (list(ant))) with_weights (list(ant) as_map each::each.food)\n\n``` \n\n\n    \t\n----\n\n\n[//]: # (keyword|operator_without_holes)\n### `without_holes`\n\n#### Possible use: \n  *  **`without_holes`** (`geometry`) --->  `geometry` \n\n#### Result: \nA geometry corresponding to the operand geometry (geometry, agent, point) without its holes\n\n#### Examples: \n```\ngeometry var0 <- solid(self); \t// var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes.\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_writable)\n### `writable`\n\n#### Possible use: \n  * `file` **`writable`** `bool` --->  `file`\n  *  **`writable`** (`file` , `bool`) --->  `file` \n\n#### Result: \nMarks the file as read-only or not, depending on the second boolean argument, and returns the first argument  \n\n#### Comment: \nA file is created using its native flags. This operator can change them. Beware that this change is system-wide (and not only restrained to GAMA): changing a file to read-only mode (e.g. \"writable(f, false)\")\n\n#### Examples: \n```\nfile var0 <- shape_file(\"../images/point_eau.shp\") writable false; \t// var0 equals returns a file in read-only mode\n```\n      \n\n#### See also: \n[file](#file), \n    \t\n----\n\n\n[//]: # (keyword|operator_xml_file)\n### `xml_file`\n\n#### Possible use: \n  *  **`xml_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type xml. Allowed extensions are limited to xml\n    \t\n----\n\n\n[//]: # (keyword|operator_years_between)\n### `years_between`\n\n#### Possible use: \n  * `date` **`years_between`** `date` --->  `int`\n  *  **`years_between`** (`date` , `date`) --->  `int` \n\n#### Result: \nProvide the exact number of years between two dates. This number can be positive or negative (if the second operand is smaller than the first one)\n\n#### Examples: \n```\nyears_between(d1, d2) -: 10 \n```\n  ","url":"wiki/Operators.md"},"OtherBuiltInSpecies.md":{"title":" Other Built-in Species (Under Construction)","content":"# Other Built-in Species (Under Construction)\n\nTODO","url":"wiki/OtherBuiltInSpecies.md"},"PseudoVariables.md":{"title":" Pseudo-variables","content":"[//]: # (keyword|concept_pseudo_variable)\n# Pseudo-variables\n\n\n\nThe expressions known as **pseudo-variables** are special read-only variables that are not declared anywhere (at least not in a species), and which represent a value that changes depending on the context of execution.\n\n\n## Table of contents \n\n* [Pseudo-variables](#pseudo-variables)\n\t* [self](#self)\n\t* [myself](#myself)\n\t* [each](#each)\n\n\n\n## self\nThe pseudo-variable `self` always holds a reference to the agent executing the current statement.\n\n  * Example (sets the `friend` attribute of another random agent of the same species to `self` and conversely):\n\n```\nfriend potential_friend <- one_of (species(self) - self);\nif potential_friend != nil {\n    potential_friend.friend <- self;\n    friend <- potential_friend;\n}\n```\n\n\n\n\n## myself\n`myself` plays the same role as `self` but in remotely-executed code (`ask`, `create`, `capture` and `release` statements), where it represents the _calling_ agent when the code is executed by the _remote_ agent.\n\n  * Example (asks the first agent of my species to set its color to my color):\n\n```\nask first (species (self)){\n    color <- myself.color;\n}\n```\n\n  * Example (create 10 new agents of the species of my species, share the energy between them, turn them towards me, and make them move 4 times to get closer to me):\n\n```\ncreate species (self) number: 10 {\n   energy <- myself.energy / 10.0;\n   loop times: 4 {\n       heading <- towards (myself);\n       do move;\n   }\n}\n```\n\n\n\n\n## each\n`each` is available only in the right-hand argument of [iterators](Operators#Iterator-operators).  It is a pseudo-variable that represents, in turn, each of the elements of the left-hand container. It can then take any type depending on the context.\n\n  * Example:\n\n```\n    list<string> names <- my_species collect each.name;  // each is of type my_species\n    int max <- max(['aa', 'bbb', 'cccc'] collect length(each)); // each is of type string\n```","url":"wiki/PseudoVariables.md"},"SpeciesBuiltIn.md":{"title":" Built-in Species","content":"# Built-in Species\n\n\n\n<font color='red'> This file is automatically generated from java files. Do Not Edit It. </font>\n\n\n\n\n\nIt is possible to use in the models a set of built-in agents. These agents allow to directly use some advance features like clustering, multi-criteria analysis, etc. The creation of these agents are similar as for other kinds of agents:\n\n```\ncreate species: my_built_in_agent returns: the_agent;\n```\n\nSo, for instance, to be able to use clustering techniques in the model:\n```\ncreate cluster_builder returns: clusterer;\n```\n\nThe list of available built-in agents in GAMA is:\n\n  * cluster\\_builder: allows to use clustering techniques on a set of agents.\n  * multicriteria\\_analyzer: allows to use multi-criteria analysis methods.\n\n[Top of the page](#Table_of_Contents)\n\n# Table of Contents\n\n\n\n\n\n\n## agent\n\n### Actions\n\n\n#### **_init_**\n\n  * returns: unknown\n\n#### **_step_**\n\n  * returns: unknown\n\n[Top of the page](#Table_of_Contents)\n\n\n\n\n\n## AgentDB\n\n### Actions\n\n\n#### **close**\n\n  * returns: unknown\n\n#### **connect**\n\n  * returns: unknown\n  * → **params** (map): Connection parameters\n\n#### **executeUpdate**\n\n  * returns: int\n  * → **updateComm** (string): SQL commands such as Create, Update, Delete, Drop with question mark\n  * → **values** (list): List of values that are used to replace question mark\n\n#### **getParameter**\n\n  * returns: unknown\n\n#### **helloWorld**\n\n  * returns: unknown\n\n#### **insert**\n\n  * returns: int\n  * → **into** (string): Table name\n  * → **columns** (list): List of column name of table\n  * → **values** (list): List of values that are used to insert into table. Columns and values must have same size\n\n#### **isConnected**\n\n  * returns: bool\n\n#### **select**\n\n  * returns: list\n  * → **select** (string): select string\n  * → **values** (list): List of values that are used to replace question marks\n\n#### **setParameter**\n\n  * returns: unknown\n  * → **params** (map): Connection parameters\n\n#### **testConnection**\n\n  * returns: bool\n  * → **params** (map): Connection parameters\n\n#### **timeStamp**\n\n  * returns: float\n\n[Top of the page](#Table_of_Contents)\n\n\n\n\n\n## base\\_edge\n\n### Actions\n\n\n[Top of the page](#Table_of_Contents)\n\n\n\n\n\n## experiment\n\n### Actions\n\n\n[Top of the page](#Table_of_Contents)\n\n\n\n\n\n## graph\\_edge\n\n### Actions\n\n\n[Top of the page](#Table_of_Contents)\n\n\n\n\n\n## graph\\_node\n\n### Actions\n\n\n#### **related\\_to**\n\n  * returns: bool\n  * → **other** (agent):\n\n[Top of the page](#Table_of_Contents)\n\n\n\n\n\n## model\n\n### Actions\n\n\n#### **halt**\nAllows to stop the current simulation so that cannot be continued after. All the behaviors and updates are stopped.\n  * returns: unknown\n\n#### **pause**\nAllows to pause the current simulation ACTUALLY EXPERIMENT FOR THE MOMENT. It can be set to continue with the manual intervention of the user.\n  * returns: unknown\n\n[Top of the page](#Table_of_Contents)\n\n\n\n\n\n## multicriteria\\_analyzer\n\n### Actions\n\n\n#### **electre\\_DM**\n\n  * returns: int\n\n#### **evidence\\_theory\\_DM**\n\n  * returns: int\n\n#### **promethee\\_DM**\n\n  * returns: int\n\n#### **weighted\\_means\\_DM**\n\n  * returns: int\n\n[Top of the page](#Table_of_Contents)\n\n\n\n\n\n## Physical3DWorld\n\n### Actions\n\n\n#### **computeForces**\n\n  * returns: unknown\n\n[Top of the page](#Table_of_Contents)","url":"wiki/SpeciesBuiltIn.md"},"Statements.md":{"title":" Statements","content":"# Statements\n\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Table of Contents\n<wiki:toc max_depth=\"2\" />\n[=](#=), [action](#action), [add](#add), [agents](#agents), [annealing](#annealing), [ask](#ask), [aspect](#aspect), [assert](#assert), [benchmark](#benchmark), [break](#break), [camera](#camera), [capture](#capture), [chart](#chart), [conscious_contagion](#conscious_contagion), [create](#create), [data](#data), [datalist](#datalist), [default](#default), [diffuse](#diffuse), [display](#display), [display_grid](#display_grid), [display_population](#display_population), [do](#do), [draw](#draw), [else](#else), [emotional_contagion](#emotional_contagion), [enter](#enter), [equation](#equation), [error](#error), [event](#event), [exhaustive](#exhaustive), [exit](#exit), [experiment](#experiment), [export](#export), [focus](#focus), [focus_on](#focus_on), [genetic](#genetic), [graphics](#graphics), [highlight](#highlight), [hill_climbing](#hill_climbing), [if](#if), [image](#image), [inspect](#inspect), [let](#let), [light](#light), [loop](#loop), [match](#match), [migrate](#migrate), [monitor](#monitor), [output](#output), [output_file](#output_file), [overlay](#overlay), [parameter](#parameter), [perceive](#perceive), [permanent](#permanent), [plan](#plan), [put](#put), [reactive_tabu](#reactive_tabu), [reflex](#reflex), [release](#release), [remove](#remove), [return](#return), [rule](#rule), [run](#run), [save](#save), [save_batch](#save_batch), [set](#set), [setup](#setup), [simulate](#simulate), [socialize](#socialize), [solve](#solve), [species](#species), [state](#state), [status](#status), [switch](#switch), [tabu](#tabu), [task](#task), [test](#test), [trace](#trace), [transition](#transition), [unconscious_contagion](#unconscious_contagion), [user_command](#user_command), [user_init](#user_init), [user_input](#user_input), [user_panel](#user_panel), [using](#using), [Variable_container](#variable_container), [Variable_number](#variable_number), [Variable_regular](#variable_regular), [warn](#warn), [write](#write), \n\n\n## Statements by kinds\n\n  * **Batch method**\n    * [annealing](#annealing),  [exhaustive](#exhaustive),  [genetic](#genetic),  [hill_climbing](#hill_climbing),  [reactive_tabu](#reactive_tabu),  [save_batch](#save_batch),  [tabu](#tabu),  \n  * **Behavior**\n    * [aspect](#aspect),  [plan](#plan),  [reflex](#reflex),  [state](#state),  [task](#task),  [test](#test),  [user_init](#user_init),  [user_panel](#user_panel),  \n  * **Experiment**\n    * [experiment](#experiment),  \n  * **Layer**\n    * [agents](#agents),  [camera](#camera),  [chart](#chart),  [display_grid](#display_grid),  [display_population](#display_population),  [event](#event),  [graphics](#graphics),  [image](#image),  [light](#light),  [overlay](#overlay),  \n  * **Output**\n    * [display](#display),  [inspect](#inspect),  [monitor](#monitor),  [output](#output),  [output_file](#output_file),  [permanent](#permanent),  \n  * **Parameter**\n    * [parameter](#parameter),  \n  * **Sequence of statements or action**\n    * [action](#action),  [ask](#ask),  [benchmark](#benchmark),  [capture](#capture),  [create](#create),  [default](#default),  [else](#else),  [enter](#enter),  [equation](#equation),  [exit](#exit),  [if](#if),  [loop](#loop),  [match](#match),  [migrate](#migrate),  [perceive](#perceive),  [release](#release),  [run](#run),  [setup](#setup),  [switch](#switch),  [trace](#trace),  [transition](#transition),  [user_command](#user_command),  [using](#using),  \n  * **Single statement**\n    * [=](#=),  [add](#add),  [assert](#assert),  [break](#break),  [conscious_contagion](#conscious_contagion),  [data](#data),  [datalist](#datalist),  [diffuse](#diffuse),  [do](#do),  [draw](#draw),  [emotional_contagion](#emotional_contagion),  [error](#error),  [export](#export),  [focus](#focus),  [focus_on](#focus_on),  [highlight](#highlight),  [let](#let),  [put](#put),  [remove](#remove),  [return](#return),  [rule](#rule),  [save](#save),  [set](#set),  [simulate](#simulate),  [socialize](#socialize),  [solve](#solve),  [status](#status),  [unconscious_contagion](#unconscious_contagion),  [user_input](#user_input),  [warn](#warn),  [write](#write),  \n  * **Species**\n    * [species](#species),  \n  * **Variable (container)**\n    * [Variable_container](#variable_container),  \n  * **Variable (number)**\n    * [Variable_number](#variable_number),  \n  * **Variable (regular)**\n    * [Variable_regular](#variable_regular),  \n\n\n## Statements by embedment\n\n  * **Behavior**\n    * [add](#add), [ask](#ask), [benchmark](#benchmark), [capture](#capture), [conscious_contagion](#conscious_contagion), [create](#create), [diffuse](#diffuse), [do](#do), [emotional_contagion](#emotional_contagion), [error](#error), [focus](#focus), [focus_on](#focus_on), [highlight](#highlight), [if](#if), [inspect](#inspect), [let](#let), [loop](#loop), [migrate](#migrate), [put](#put), [release](#release), [remove](#remove), [return](#return), [run](#run), [save](#save), [set](#set), [simulate](#simulate), [socialize](#socialize), [solve](#solve), [status](#status), [switch](#switch), [trace](#trace), [transition](#transition), [unconscious_contagion](#unconscious_contagion), [using](#using), [warn](#warn), [write](#write), \n  * **Environment**\n    * [species](#species), \n  * **Experiment**\n    * [action](#action), [annealing](#annealing), [exhaustive](#exhaustive), [export](#export), [genetic](#genetic), [hill_climbing](#hill_climbing), [output](#output), [parameter](#parameter), [permanent](#permanent), [reactive_tabu](#reactive_tabu), [reflex](#reflex), [save_batch](#save_batch), [setup](#setup), [simulate](#simulate), [state](#state), [tabu](#tabu), [task](#task), [test](#test), [user_command](#user_command), [user_init](#user_init), [user_panel](#user_panel), [Variable_container](#variable_container), [Variable_number](#variable_number), [Variable_regular](#variable_regular), \n  * **Layer**\n    * [add](#add), [benchmark](#benchmark), [draw](#draw), [error](#error), [focus_on](#focus_on), [highlight](#highlight), [if](#if), [let](#let), [loop](#loop), [put](#put), [remove](#remove), [set](#set), [status](#status), [switch](#switch), [trace](#trace), [using](#using), [warn](#warn), [write](#write), \n  * **Model**\n    * [action](#action), [aspect](#aspect), [equation](#equation), [experiment](#experiment), [output](#output), [perceive](#perceive), [plan](#plan), [reflex](#reflex), [rule](#rule), [run](#run), [setup](#setup), [species](#species), [state](#state), [task](#task), [test](#test), [user_command](#user_command), [user_init](#user_init), [user_panel](#user_panel), [Variable_container](#variable_container), [Variable_number](#variable_number), [Variable_regular](#variable_regular), \n  * **Sequence of statements or action**\n    * [add](#add), [ask](#ask), [benchmark](#benchmark), [break](#break), [capture](#capture), [conscious_contagion](#conscious_contagion), [create](#create), [data](#data), [datalist](#datalist), [diffuse](#diffuse), [do](#do), [draw](#draw), [emotional_contagion](#emotional_contagion), [error](#error), [focus](#focus), [focus_on](#focus_on), [highlight](#highlight), [if](#if), [inspect](#inspect), [let](#let), [loop](#loop), [migrate](#migrate), [put](#put), [release](#release), [remove](#remove), [return](#return), [save](#save), [set](#set), [simulate](#simulate), [socialize](#socialize), [solve](#solve), [status](#status), [switch](#switch), [trace](#trace), [transition](#transition), [unconscious_contagion](#unconscious_contagion), [using](#using), [warn](#warn), [write](#write), \n  * **Single statement**\n    * [run](#run), \n  * **Species**\n    * [action](#action), [aspect](#aspect), [equation](#equation), [perceive](#perceive), [plan](#plan), [reflex](#reflex), [rule](#rule), [run](#run), [setup](#setup), [simulate](#simulate), [species](#species), [state](#state), [task](#task), [test](#test), [user_command](#user_command), [user_init](#user_init), [user_panel](#user_panel), [Variable_container](#variable_container), [Variable_number](#variable_number), [Variable_regular](#variable_regular), \n  * **action**\n    * [return](#return), \n  * **aspect**\n    * [draw](#draw), \n  * **chart**\n    * [add](#add), [ask](#ask), [data](#data), [datalist](#datalist), [do](#do), [put](#put), [remove](#remove), [set](#set), [simulate](#simulate), [using](#using), \n  * **display**\n    * [agents](#agents), [camera](#camera), [chart](#chart), [display_grid](#display_grid), [display_population](#display_population), [event](#event), [graphics](#graphics), [image](#image), [light](#light), [overlay](#overlay), \n  * **display_population**\n    * [display_population](#display_population), \n  * **equation**\n    * [=](#=), \n  * **fsm**\n    * [state](#state), [user_panel](#user_panel), \n  * **if**\n    * [else](#else), \n  * **output**\n    * [display](#display), [inspect](#inspect), [monitor](#monitor), [output_file](#output_file), \n  * **permanent**\n    * [display](#display), [inspect](#inspect), [monitor](#monitor), [output_file](#output_file), \n  * **probabilistic_tasks**\n    * [task](#task), \n  * **sorted_tasks**\n    * [task](#task), \n  * **state**\n    * [enter](#enter), [exit](#exit), \n  * **switch**\n    * [default](#default), [match](#match), \n  * **test**\n    * [assert](#assert), \n  * **user_command**\n    * [user_input](#user_input), \n  * **user_first**\n    * [user_panel](#user_panel), \n  * **user_init**\n    * [user_panel](#user_panel), \n  * **user_last**\n    * [user_panel](#user_panel), \n  * **user_only**\n    * [user_panel](#user_panel), \n  * **user_panel**\n    * [user_command](#user_command), \n  * **weighted_tasks**\n    * [task](#task), \n\n\n## General syntax\n\nA statement represents either a declaration or an imperative command. It consists in a keyword, followed by specific facets, some of them mandatory (in bold), some of them optional. One of the facet names can be omitted (the one denoted as omissible). It has to be the first one.\n\n```\nstatement_keyword expression1 facet2: expression2 ... ;\nor\nstatement_keyword facet1: expression1 facet2: expression2 ...;\n```\n\nIf the statement encloses other statements, it is called a **sequence statement**, and its sub-statements (either sequence statements or single statements) are declared between curly brackets, as in:\n\n```\nstatement_keyword1 expression1 facet2: expression2... { // a sequence statement\n     statement_keyword2 expression1 facet2: expression2...;  // a single statement\n     statement_keyword3 expression1 facet2: expression2...;\n}\n```\n\t\n\n----\n\n[//]: # (keyword|statement_=)\n### = \n#### Facets \n  \n  * **`right`** (float), (omissible) : the right part of the equation (it is mandatory that it can be evaluated as a float  \n  * **`left`** (any type): the left part of the equation (it should be a variable or a call to the diff() or diff2() operators) \n \t\n#### Definition\n\nAllows to implement an equation in the form function(n, t) = expression. The left function is only here as a placeholder for enabling a simpler syntax and grabbing the variable as its left member.\n\n#### Usages\n\n* The syntax of the = statement is a bit different from the other statements. It has to be used as follows (in an equation):\n\n```\nfloat t;\nfloat S;\nfloat I;\nequation SI { \n   diff(S,t) = (- 0.3 * S * I / 100);\n   diff(I,t) = (0.3 * S * I / 100);\n} \n```\n\n    \n* See also: [equation](#equation), [solve](#solve), \n\n#### Embedments\n* The `=` statement is of type: **Single statement**\n* The `=` statement can be embedded into: equation, \n* The `=` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_action)\n### action \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : identifier of the action\n  * `index` (a datatype identifier): if the action returns a map, the type of its keys\n  * `of` (a datatype identifier): if the action returns a container, the type of its elements\n  * `type` (a datatype identifier): the action returned type\n  * `virtual` (boolean): whether the action is virtual (defined without a set of instructions) (false by default) \n \t\n#### Definition\n\nAllows to define in a species, model or experiment a new action that can be called elsewhere.\n\n#### Usages\n\n* The simplest syntax to define an action that does not take any parameter and does not return anything is:\n\n```\naction simple_action {\n   // [set of statements]\n}\n```\n\n\n* If the action needs some parameters, they can be specified betwee, braquets after the identifier of the action:\n\n```\naction action_parameters(int i, string s){\n   // [set of statements using i and s]\n}\n```\n\n\n* If the action returns any value, the returned type should be used instead of the \"action\" keyword. A return statement inside the body of the action statement is mandatory.\n\n```\nint action_return_val(int i, string s){\n   // [set of statements using i and s]\n   return i + i;\n}\n```\n\n\n* If virtual: is true, then the action is abstract, which means that the action is defined without body. A species containing at least one abstract action is abstract. Agents of this species cannot be created. The common use of an abstract action is to define an action that can be used by all its sub-species, which should redefine all abstract actions and implements its body.\n\n```\nspecies parent_species {\n   int virtual_action(int i, string s);\n}\n\nspecies children parent: parent_species {\n   int virtual_action(int i, string s) {\n      return i + i;\n   }\n}\n```\n\n    \n* See also: [do](#do), \n\n#### Embedments\n* The `action` statement is of type: **Sequence of statements or action**\n* The `action` statement can be embedded into: Species, Experiment, Model, \n* The `action` statement embeds statements: [return](#return),  \n\n----\n\n[//]: # (keyword|statement_add)\n### add \n#### Facets \n  \n  * **`to`** (any type in [container, species, agent, geometry]): an expression that evaluates to a container\n  * `item` (any type), (omissible) : any expression to add in the container\n  * `all` (any type): Allows to either pass a container so as to add all its element, or 'true', if the item to add is already a container.\n  * `at` (any type): position in the container of added element\n  * `edge` (any type): a pair that will be added to a graph as an edge (if nodes do not exist, they are also added)\n  * `node` (any type): an expression that will be added to a graph as a node.\n  * `vertex` (any type): \n  * `weight` (float):  \n \t\n#### Definition\n\nAllows to add, i.e. to insert, a new element in a container (a list, matrix, map, ...).Incorrect use: The addition of a new element at a position out of the bounds of the container will produce a warning and let the container unmodified. If all: is specified, it has no effect if its argument is not a container, or if its argument is 'true' and the item to add is not a container. In that latter case\n\n#### Usages\n\n* The new element can be added either at the end of the container or at a particular position.\n\n```\nadd expr to: expr_container;    // Add at the end\nadd expr at: expr to: expr_container;   // Add at position expr\n```\n\n\n* Case of a list, the expression in the facet at: should be an integer.\n\n```\nlist<int> workingList <- [];\nadd 0 at: 0 to: workingList ; \t// workingList equals [0]\nadd 10 at: 0 to: workingList ; \t// workingList equals [10,0]\nadd 20 at: 2 to: workingList ; \t// workingList equals [10,0,20]\nadd 50 to: workingList; \t// workingList equals [10,0,20,50]\nadd [60,70] all: true to: workingList; \t// workingList equals [10,0,20,50,60,70]\n```\n\n\n* Case of a map: As a map is basically a list of pairs key::value, we can also use the add statement on it. It is important to note that the behavior of the statement is slightly different, in particular in the use of the at facet, which denotes the key of the pair.\n\n```\nmap<string,string> workingMap <- [];\nadd \"val1\" at: \"x\" to: workingMap; \t// workingMap equals [\"x\"::\"val1\"]\n```\n\n\n* If the at facet is omitted, a pair expr_item::expr_item will be added to the map. An important exception is the case where the expr_item is a pair: in this case the pair is added.\n\n```\nadd \"val2\" to: workingMap; \t// workingMap equals [\"x\"::\"val1\", \"val2\"::\"val2\"]\nadd \"5\"::\"val4\" to: workingMap;  \t// workingMap equals [\"x\"::\"val1\", \"val2\"::\"val2\", \"5\"::\"val4\"]\n```\n\n\n* Notice that, as the key should be unique, the addition of an item at an existing position (i.e. existing key) will only modify the value associated with the given key.\n\n```\nadd \"val3\" at: \"x\" to: workingMap; \t// workingMap equals [\"x\"::\"val3\", \"val2\"::\"val2\", \"5\"::\"val4\"]\n```\n\n\n* On a map, the all facet will add all value of a container  in the map (so as pair val_cont::val_cont)\n\n```\nadd [\"val4\",\"val5\"] all: true at: \"x\" to: workingMap; \t// workingMap equals [\"x\"::\"val3\", \"val2\"::\"val2\", \"5\"::\"val4\",\"val4\"::\"val4\",\"val5\"::\"val5\"]\n```\n\n\n* In case of a graph, we can use the facets `node`, `edge` and `weight` to add a node, an edge or weights to the graph. However, these facets are now considered as deprecated, and it is advised to use the various edge(), node(), edges(), nodes() operators, which can build the correct objects to add to the graph \n\n```\ngraph g <- as_edge_graph([{1,5}::{12,45}]);\nadd edge: {1,5}::{2,3} to: g;\nlist var <- g.vertices; \t// var equals [{1,5},{12,45},{2,3}]\nlist var <- g.edges; \t// var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})]\nadd node: {5,5} to: g;\nlist var <- g.vertices; \t// var equals [{1.0,5.0},{12.0,45.0},{2.0,3.0},{5.0,5.0}]\nlist var <- g.edges; \t// var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})]\n```\n\n\n* Case of a matrix: this statement can not be used on matrix. Please refer to the statement put.    \n* See also: [put](#put), [remove](#remove), \n\n#### Embedments\n* The `add` statement is of type: **Single statement**\n* The `add` statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, \n* The `add` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_agents)\n### agents \n#### Facets \n  \n  * **`value`** (container): the set of agents to display\n  * `name` (a label), (omissible) : Human readable title of the layer\n  * `aspect` (an identifier): the name of the aspect that should be used to display the species\n  * `fading` (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false\n  * `focus` (agent): the agent on which the camera will be focused (it is dynamically computed)\n  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.\n  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, useful in case of agents that do not move)\n  * `selectable` (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true\n  * `size` (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\n  * `trace` (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.\n  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency) \n \t\n#### Definition\n\n`agents` allows the modeler to display only the agents that fulfill a given condition.\n\n#### Usages\n\n* The general syntax is:\n\n```\ndisplay my_display {\n   agents layer_name value: expression [additional options];\n}\n```\n\n\n* For instance, in a segregation model, `agents` will only display unhappy agents:\n\n```\ndisplay Segregation {\n   agents agentDisappear value: people as list where (each.is_happy = false) aspect: with_group_color;\n}\n```\n\n    \n* See also: [display](#display), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [display_population](#display_population), \n\n#### Embedments\n* The `agents` statement is of type: **Layer**\n* The `agents` statement can be embedded into: display, \n* The `agents` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_annealing)\n### annealing \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : \n  * `aggregation` (a label), takes values in: {min, max}: the agregation method\n  * `maximize` (float): the value the algorithm tries to maximize\n  * `minimize` (float): the value the algorithm tries to minimize\n  * `nb_iter_cst_temp` (int): number of iterations per level of temperature\n  * `temp_decrease` (float): temperature decrease coefficient\n  * `temp_end` (float): final temperature\n  * `temp_init` (float): initial temperature \n \t\n#### Definition\n\nThis algorithm is an implementation of the Simulated Annealing algorithm. See the wikipedia article and [batch161 the batch dedicated page].\n\n#### Usages\n\n* As other batch methods, the basic syntax of the annealing statement uses `method annealing` instead of the expected `annealing name: id` : \n\n```\nmethod annealing [facet: value];\n```\n\n\n* For example: \n\n```\nmethod annealing temp_init: 100  temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered;\n```\n\n\n\n#### Embedments\n* The `annealing` statement is of type: **Batch method**\n* The `annealing` statement can be embedded into: Experiment, \n* The `annealing` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_ask)\n### ask \n#### Facets \n  \n  * **`target`** (any type in [container, agent]), (omissible) : an expression that evaluates to an agent or a list of agents\n  * `as` (species): an expression that evaluates to a species\n  * `parallel` (any type in [boolean, int]): (experimental) setting this facet to 'true' will allow 'ask' to use concurrency when traversing the targets; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is false by default. \n \t\n#### Definition\n\nAllows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. If the value of the target facet is nil or empty, the statement is ignored.\n\n#### Usages\n\n* Ask  a set of receiver agents, stored in a container, to perform a block of statements. The block is evaluated in the context of the agents' species\n\n```\nask ${receiver_agents} {\n     ${cursor}\n}\n```\n\n\n* Ask  one agent to perform a block of statements. The block is evaluated in the context of the agent's species\n\n```\nask ${one_agent} {\n     ${cursor}\n}\n```\n\n\n* If the species of the receiver agent(s) cannot be determined, it is possible to force it using the `as` facet. An error is thrown if an agent is not a direct or undirect instance of this species\n\n```\nask${receiver_agent(s)} as: ${a_species_expression} {\n     ${cursor}\n}\n```\n\n\n* To ask a set of agents to do something only if they belong to a given species, the `of_species` operator can be used. If none of the agents belong to the species, nothing happens\n\n```\nask ${receiver_agents} of_species ${species_name} {\n     ${cursor}\n}\n```\n\n\n* Any statement can be declared in the block statements. All the statements will be evaluated in the context of the receiver agent(s), as if they were defined in their species, which means that an expression like `self` will represent the receiver agent and not the sender. If the sender needs to refer to itself, some of its own attributes (or temporary variables) within the block statements, it has to use the keyword `myself`.\n\n```\nspecies animal {\n    float energy <- rnd (1000) min: 0.0 {\n    reflex when: energy > 500 { // executed when the energy is above the given threshold\n         list<animal> others <- (animal at_distance 5); // find all the neighboring animals in a radius of 5 meters\n         float shared_energy  <- (energy - 500) / length (others); // compute the amount of energy to share with each of them\n         ask others { // no need to cast, since others has already been filtered to only include animals\n              if (energy < 500) { // refers to the energy of each animal in others\n                   energy <- energy + myself.shared_energy; // increases the energy of each animal\n                   myself.energy <- myself.energy - myself.shared_energy; // decreases the energy of the sender\n              }\n         }\n    }\n}\n```\n\n\n* If the species of the receiver agent cannot be determined, it is possible to force it by casting the agent. Nothing happens if the agent cannot be casted to this species\n\n#### Embedments\n* The `ask` statement is of type: **Sequence of statements or action**\n* The `ask` statement can be embedded into: chart, Behavior, Sequence of statements or action, \n* The `ask` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_aspect)\n### aspect \n#### Facets \n\n  * `name` (an identifier), (omissible) : identifier of the aspect (it can be used in a display to identify which aspect should be used for the given species). Two special names can also be used: 'default' will allow this aspect to be used as a replacement for the default aspect defined in preferences; 'highlighted' will allow the aspect to be used when the agent is highlighted as a replacement for the default (application of a color) \n \t\n#### Definition\n\nAspect statement is used to define a way to draw the current agent. Several aspects can be defined in one species. It can use attributes to customize each agent's aspect. The aspect is evaluate for each agent each time it has to be displayed.\n\n#### Usages\n\n* An example of use of the aspect statement:\n\n```\nspecies one_species {\n\tint a <- rnd(10);\n\taspect aspect1 {\n\t\tif(a mod 2 = 0) { draw circle(a);}\n\t\telse {draw square(a);}\n\t\tdraw text: \"a= \" + a color: #black size: 5;\n\t}\n}\n```\n\n\n\n#### Embedments\n* The `aspect` statement is of type: **Behavior**\n* The `aspect` statement can be embedded into: Species, Model, \n* The `aspect` statement embeds statements: [draw](#draw),  \n\n----\n\n[//]: # (keyword|statement_assert)\n### assert \n#### Facets \n  \n  * **`value`** (any type), (omissible) : the value that is evaluated and compared to other facets\n  * `equals` (any type): an expression, assert tests whether the value is equals to this expression\n  * `is_not` (any type): an expression, assert tests whether the value is not equals to this expression\n  * `raises` (an identifier): \"error\" or \"warning\", used in testing what raises the evaluation of the value: expression \n \t\n#### Definition\n\nAllows to check whether the evaluation of a given expression fulfills a given condition. If it is not fulfilled, an exception is raised.\n\n#### Usages\n\n* if the equals: facet is used, the equality between the evaluation of expressions in the value: and in the equals: facets is tested\n\n```\nassert (2+2) equals: 4;\n```\n\n\n* if the is_not: facet is used, the inequality between the evaluation of expressions in the value: and in the equals: facets is tested\n\n```\nassert self is_not: nil;\n```\n\n\n* if the raises: facet is used with either \"warning\" or \"error\", the statement tests whether the evaluation of the value: expression raises an error (resp. a warning)\n\n```\nint z <- 0;\nassert (3/z) raises: \"error\";\n```\n\n    \n* See also: [test](#test), [setup](#setup), \n\n#### Embedments\n* The `assert` statement is of type: **Single statement**\n* The `assert` statement can be embedded into: test, \n* The `assert` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_benchmark)\n### benchmark \n#### Facets \n\n  * `message` (any type), (omissible) : A message to display alongside the results. Should concisely describe the contents of the benchmark\n  * `repeat` (int): An int expression describing how many executions of the block must be handled. The output in this case will return the min, max and average durations \n \t\n#### Definition\n\nDisplays in the console the duration in ms of the execution of the statements included in the block. It is possible to indicate, with the 'repeat' facet, how many times the sequence should be run\n\n#### Usages\n\n\n#### Embedments\n* The `benchmark` statement is of type: **Sequence of statements or action**\n* The `benchmark` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `benchmark` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_break)\n### break \n#### Facets \n \n \t\n#### Definition\n\n`break` allows to interrupt the current sequence of statements.\n\n#### Usages\n\n\n#### Embedments\n* The `break` statement is of type: **Single statement**\n* The `break` statement can be embedded into: Sequence of statements or action, \n* The `break` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_camera)\n### camera \n#### Facets \n  \n  * **`name`** (string), (omissible) : The name of the camera\n  * `location` (point): The location of the camera in the world\n  * `look_at` (point): The location that the camera is looking\n  * `up_vector` (point): The up-vector of the camera. \n \t\n#### Definition\n\n`camera` allows the modeler to define a camera. The display will then be able to choose among the camera defined (either within this statement or globally in GAMA) in a dynamic way.\n\n#### Usages\n    \n* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [display_population](#display_population), \n\n#### Embedments\n* The `camera` statement is of type: **Layer**\n* The `camera` statement can be embedded into: display, \n* The `camera` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_capture)\n### capture \n#### Facets \n  \n  * **`target`** (any type in [agent, container]), (omissible) : an expression that is evaluated as an agent or a list of the agent to be captured\n  * `as` (species): the species that the captured agent(s) will become, this is a micro-species of the calling agent's species\n  * `returns` (a new identifier): a list of the newly captured agent(s) \n \t\n#### Definition\n\nAllows an agent to capture other agent(s) as its micro-agent(s).\n\n#### Usages\n\n* The preliminary for an agent A to capture an agent B as its micro-agent is that the A's species must defined a micro-species which is a sub-species of B's species (cf. [Species161#Nesting_species Nesting species]).\n\n```\nspecies A {\n...\n}\nspecies B {\n...\n   species C parent: A {\n   ...\n   }\n...\n}\n```\n\n\n* To capture all \"A\" agents as \"C\" agents, we can ask an \"B\" agent to execute the following statement:\n\n```\ncapture list(B) as: C;\n```\n\n\n* Deprecated writing:\n\n```\ncapture target: list (B) as: C;\n```\n\n    \n* See also: [release](#release), \n\n#### Embedments\n* The `capture` statement is of type: **Sequence of statements or action**\n* The `capture` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `capture` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_chart)\n### chart \n#### Facets \n  \n  * **`name`** (a label), (omissible) : the identifier of the chart layer\n  * `axes` (rgb): the axis color\n  * `background` (rgb): the background color\n  * `color` (rgb): Text color\n  * `gap` (float): minimum gap between bars (in proportion)\n  * `label_font` (string): Label font face\n  * `label_font_size` (int): Label font size\n  * `label_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display labels\n  * `legend_font` (string): Legend font face\n  * `legend_font_size` (int): Legend font size\n  * `legend_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display legend\n  * `memorize` (boolean): Whether or not to keep the values in memory (in order to produce a csv file, for instance). The default value, true, can also be changed in the preferences\n  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.\n  * `reverse_axes` (boolean): reverse X and Y axis (for example to get horizental bar charts\n  * `series_label_position` (an identifier), takes values in: {default, none, legend, onchart, yaxis, xaxis}: Position of the Series names: default (best guess), none, legend, onchart, xaxis (for category plots) or yaxis (uses the first serie name).\n  * `size` (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)\n  * `style` (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded, default}: The sub-style style, also default style for the series.\n  * `tick_font` (string): Tick font face\n  * `tick_font_size` (int): Tick font size\n  * `tick_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display ticks\n  * `title_font` (string): Title font face\n  * `title_font_size` (int): Title font size\n  * `title_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display titles\n  * `type` (an identifier), takes values in: {xy, scatter, histogram, series, pie, radar, heatmap, box_whisker}: the type of chart. It could be histogram, series, xy, pie, radar, heatmap or box whisker. The difference between series and xy is that the former adds an implicit x-axis that refers to the numbers of cycles, while the latter considers the first declaration of data to be its x-axis.\n  * `x_label` (string): the title for the X axis\n  * `x_range` (any type in [float, int, point, list]): range of the x-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).\n  * `x_serie` (any type in [list, float, int]): for series charts, change the default common x serie (simulation cycle) for an other value (list or numerical).\n  * `x_serie_labels` (any type in [list, float, int, a label]): change the default common x series labels (replace x value or categories) for an other value (string or numerical).\n  * `x_tick_unit` (float): the tick unit for the y-axis (distance between horyzontal lines and values on the left of the axis).\n  * `y_label` (string): the title for the Y axis\n  * `y_range` (any type in [float, int, point, list]): range of the y-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).\n  * `y_serie_labels` (any type in [list, float, int, a label]): for heatmaps/3d charts, change the default y serie for an other value (string or numerical in a list or cumulative).\n  * `y_tick_unit` (float): the tick unit for the x-axis (distance between vertical lines and values bellow the axis). \n \t\n#### Definition\n\n`chart` allows modeler to display a chart: this enables to display specific values of the model at each iteration. GAMA can display various chart types: time series (series), pie charts (pie) and histograms (histogram).\n\n#### Usages\n\n* The general syntax is:\n\n```\ndisplay chart_display {\n   chart \"chart name\" type: series [additional options] {\n      [Set of data, datalists statements]\n   }\n}\n```\n\n    \n* See also: [display](#display), [agents](#agents), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), [text](#text), \n\n#### Embedments\n* The `chart` statement is of type: **Layer**\n* The `chart` statement can be embedded into: display, \n* The `chart` statement embeds statements: [add](#add),  [ask](#ask),  [data](#data),  [datalist](#datalist),  [do](#do),  [put](#put),  [remove](#remove),  [set](#set),  [simulate](#simulate),  [using](#using),  \n\n----\n\n[//]: # (keyword|statement_conscious_contagion)\n### conscious_contagion \n#### Facets \n  \n  * **`emotion_created`** (546706): the emotion that will be created with the contagion  \n  * **`emotion_detected`** (546706): the emotion that will start the contagion\n  * `name` (an identifier), (omissible) : the identifier of the unconscious contagion\n  * `charisma` (float): The charisma value of the perceived agent (between 0 and 1)\n  * `receptivity` (float): The receptivity value of the current agent (between 0 and 1)\n  * `threshold` (float): The threshold value to make the contagion\n  * `when` (boolean): A boolean value to get the emotion only with a certain condition \n \t\n#### Definition\n\nenables to directly add an emotion of a perceived specie if the perceived agent ges a patricular emotion.\n\n#### Usages\n\n* Other examples of use: \n```\nconscious_contagion emotion_detected:fear emotion_created:fearConfirmed;\nconscious_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;\n``` \n  \n\n#### Embedments\n* The `conscious_contagion` statement is of type: **Single statement**\n* The `conscious_contagion` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `conscious_contagion` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_create)\n### create \n#### Facets \n\n  * `species` (any type in [species, agent]), (omissible) : an expression that evaluates to a species, the species of the agents to be created. In the case of simulations, the name 'simulation', which represents the current instance of simulation, can also be used as a proxy to their species\n  * `as` (species): \n  * `from` (any type): an expression that evaluates to a localized entity, a list of localized entities, a string (the path of a file), a file (shapefile, a .csv, a .asc or a OSM file) or a container returned by a request to a database\n  * `header` (boolean): an expression that evaluates to a boolean, when creating agents from csv file, specify whether the file header is loaded\n  * `number` (int): an expression that evaluates to an int, the number of created agents\n  * `returns` (a new identifier): a new temporary variable name containing the list of created agents (a list, even if only one agent has been created)\n  * `with` (map): an expression that evaluates to a map, for each pair the key is a species attribute and the value the assigned value \n \t\n#### Definition\n\nAllows an agent to create `number` agents of species `species`, to create agents of species `species` from a shapefile or to create agents of species `species` from one or several localized entities (discretization of the localized entity geometries).\n\n#### Usages\n\n* Its simple syntax to create `an_int` agents of species `a_species` is:\n\n```\ncreate a_species number: an_int;\ncreate species_of(self) number: 5 returns: list5Agents;\n5\n```\n\n\n* In GAML modelers can create agents of species `a_species  (with two attributes `type` and `nature` with types corresponding to the types of the shapefile attributes) from a shapefile `the_shapefile` while reading attributes 'TYPE_OCC' and 'NATURE' of the shapefile. One agent will be created by object contained in the shapefile:\n\n```\ncreate a_species from: the_shapefile with: [type:: read('TYPE_OCC'), nature::read('NATURE')];\n```\n\n\n* In order to create agents from a .csv file, facet `header` can be used to specified whether we can use columns header:\n\n```\ncreate toto from: \"toto.csv\" header: true with:[att1::read(\"NAME\"), att2::read(\"TYPE\")];\nor\ncreate toto from: \"toto.csv\" with:[att1::read(0), att2::read(1)]; //with read(int), the index of the column\n```\n\n\n* Similarly to the creation from shapefile, modelers can create agents from a set of geometries. In this case, one agent per geometry will be created (with the geometry as shape)\n\n```\ncreate species_of(self) from: [square(4),circle(4)]; \t// 2 agents have been created, with shapes respectively square(4) and circle(4)\n```\n\n\n* Created agents are initialized following the rules of their species. If one wants to refer to them after the statement is executed, the returns keyword has to be defined: the agents created will then be referred to by the temporary variable it declares. For instance, the following statement creates 0 to 4 agents of the same species as the sender, and puts them in the temporary variable children for later use.\n\n```\ncreate species (self) number: rnd (4) returns: children;\nask children {\n        // ...\n}\n```\n\n\n* If one wants to specify a special initialization sequence for the agents created, create provides the same possibilities as ask. This extended syntax is:\n\n```\ncreate a_species number: an_int {\n     [statements]\n}\n```\n\n\n* The same rules as in ask apply. The only difference is that, for the agents created, the assignments of variables will bypass the initialization defined in species. For instance:\n\n```\ncreate species(self) number: rnd (4) returns: children {\n     set location <- myself.location + {rnd (2), rnd (2)}; // tells the children to be initially located close to me\n     set parent <- myself; // tells the children that their parent is me (provided the variable parent is declared in this species) \n}\n```\n\n\n* Desprecated uses: \n\n```\n// Simple syntax\ncreate species: a_species number: an_int;\n\n```\n\n\n* If `number` equals 0 or species is not a species, the statement is ignored.\n\n#### Embedments\n* The `create` statement is of type: **Sequence of statements or action**\n* The `create` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `create` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_data)\n### data \n#### Facets \n  \n  * **`legend`** (string), (omissible) :   \n  * **`value`** (any type in [float, point, list]): \n  * `accumulate_values` (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)\n  * `color` (any type in [rgb, list]): color of the serie, for heatmap can be a list to specify [minColor,maxColor] or [minColor,medColor,maxColor]\n  * `fill` (boolean): Marker filled (true) or not (false)\n  * `line_visible` (boolean): Line visible or not\n  * `marker` (boolean): marker visible or not\n  * `marker_shape` (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the marker\n  * `marker_size` (float): Size in pixels of the marker\n  * `style` (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)\n  * `thickness` (float): The thickness of the lines to draw\n  * `x_err_values` (any type in [float, list]): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)\n  * `y_err_values` (any type in [float, list]): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)\n  * `y_minmax_values` (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)\n\n#### Embedments\n* The `data` statement is of type: **Single statement**\n* The `data` statement can be embedded into: chart, Sequence of statements or action, \n* The `data` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_datalist)\n### datalist \n#### Facets \n  \n  * **`value`** (list): the values to display. Has to be a matrix, a list or a List of List. Each element can be a number (series/histogram) or a list with two values (XY chart)\n  * `legend` (list), (omissible) : the name of the series: a list of strings (can be a variable with dynamic names)\n  * `accumulate_values` (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)\n  * `color` (list): list of colors, for heatmaps can be a list of [minColor,maxColor] or [minColor,medColor,maxColor]\n  * `fill` (boolean): Marker filled (true) or not (false), same for all series.\n  * `line_visible` (boolean): Line visible or not (same for all series)\n  * `marker` (boolean): marker visible or not\n  * `marker_shape` (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the marker. Same one for all series.\n  * `marker_size` (list): the marker sizes to display. Can be a list of numbers (same size for each marker of the series) or a list of list (different sizes by point)\n  * `style` (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)\n  * `x_err_values` (list): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)\n  * `y_err_values` (list): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)\n  * `y_minmax_values` (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)\n\n#### Embedments\n* The `datalist` statement is of type: **Single statement**\n* The `datalist` statement can be embedded into: chart, Sequence of statements or action, \n* The `datalist` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_default)\n### default \n#### Facets \n\n  * `value` (any type), (omissible) :  \n \t\n#### Definition\n\nUsed in a switch match structure, the block prefixed by default is executed only if no other block has matched (otherwise it is not).\n\n#### Usages\n    \n* See also: [switch](#switch), [match](#match), \n\n#### Embedments\n* The `default` statement is of type: **Sequence of statements or action**\n* The `default` statement can be embedded into: switch, \n* The `default` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_diffuse)\n### diffuse \n#### Facets \n  \n  * **`var`** (an identifier), (omissible) : the variable to be diffused  \n  * **`on`** (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occur\n  * `avoid_mask` (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the proportion value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won't diffuse the value afterward (lost of signal). (default value : false)\n  * `cycle_length` (int): the number of diffusion operation applied in one simulation step\n  * `mask` (matrix): a matrix masking the diffusion (matrix created from a image for example). The cells corresponding to the values smaller than \"-1\" in the mask matrix will not diffuse, and the other will diffuse.\n  * `mat_diffu` (matrix): the diffusion matrix (can have any size)\n  * `matrix` (matrix): the diffusion matrix (\"kernel\" or \"filter\" in image processing). Can have any size, as long as dimensions are odd values.\n  * `method` (an identifier), takes values in: {convolution, dot_product}: the diffusion method\n  * `min_value` (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.\n  * `propagation` (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals 'diffusion', the intensity of a signal is shared between its neighbors with respect to 'proportion', 'variation' and the number of neighbors of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S' = (S / N / proportion) - variation. The intensity of S is then diminished by S `*` proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals 'gradient', the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If 'propagation' is not defined, it is assumed that it is equal to 'diffusion'.\n  * `proportion` (float): a diffusion rate\n  * `radius` (int): a diffusion radius (in number of cells from the center)\n  * `variation` (float): an absolute value to decrease at each neighbors \n \t\n#### Definition\n\nThis statements allows a value to diffuse among a species on agents (generally on a grid) depending on a given diffusion matrix.\n\n#### Usages\n\n* A basic example of diffusion of the variable phero defined in the species cells, given a diffusion matrix math_diff is:\n\n```\nmatrix<float> math_diff <- matrix([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]);\ndiffuse var: phero on: cells mat_diffu: math_diff;\n```\n\n\n* The diffusion can be masked by obstacles, created from a bitmap image:\n\n```\ndiffuse var: phero on: cells mat_diffu: math_diff mask: mymask;\n```\n\n\n* A convenient way to have an uniform diffusion in a given radius is (which is equivalent to the above diffusion):\n\n```\ndiffuse var: phero on: cells proportion: 1/9 radius: 1;\n```\n\n\n\n#### Embedments\n* The `diffuse` statement is of type: **Single statement**\n* The `diffuse` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `diffuse` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_display)\n### display \n#### Facets \n  \n  * **`name`** (a label), (omissible) : the identifier of the display\n  * `ambient_light` (any type in [int, rgb]): Allows to define the value of the ambient light either using an int (ambient_light:(125)) or a rgb color ((ambient_light:rgb(255,255,255)). default is rgb(127,127,127,255)\n  * `autosave` (any type in [boolean, point]): Allows to save this display on disk. A value of true/false will save it at a resolution of 500x500. A point can be passed to personalize these dimensions\n  * `background` (rgb): Allows to fill the background of the display with a specific color\n  * `camera_interaction` (boolean): If false, the user will not be able to modify the position and the orientation of the camera, and neither using the ROI. Default is true.\n  * `camera_lens` (int): Allows to define the lens of the camera\n  * `camera_look_pos` (point): Allows to define the direction of the camera\n  * `camera_pos` (any type in [point, agent]): Allows to define the position of the camera\n  * `camera_up_vector` (point): Allows to define the orientation of the camera\n  * `diffuse_light` (any type in [int, rgb]): Allows to define the value of the diffuse light either using an int (diffuse_light:(125)) or a rgb color ((diffuse_light:rgb(255,255,255)). default is (127,127,127,255)\n  * `diffuse_light_pos` (point): Allows to define the position of the diffuse light either using an point (diffuse_light_pos:{x,y,z}). default is {world.shape.width/2,world.shape.height/2,world.shape.width`*`2}\n  * `draw_diffuse_light` (boolean): Allows to show/hide a representation of the lights. Default is false.\n  * `draw_env` (boolean): Allows to enable/disable the drawing of the world shape and the ordinate axes. Default can be configured in Preferences\n  * `focus` (geometry): the geometry (or agent) on which the display will (dynamically) focus\n  * `fullscreen` (any type in [boolean, int]): Indicates, when using a boolean value, whether or not the display should cover the whole screen (default is false). If an integer is passed, specifies also the screen to use: 0 for the primary monitor, 1 for the secondary one, and so on and so forth. If the monitor is not available, the first one is used\n  * `keystone` (container): Set the position of the 4 corners of your screen ([topLeft,topRight,botLeft,botRight]), in (x,y) coordinate ( the (0,0) position is the top left corner, while the (1,1) position is the bottom right corner). The default value is : [{0,0},{1,0},{0,1},{1,1}]\n  * `light` (boolean): Allows to enable/disable the light. Default is true\n  * `orthographic_projection` (boolean): Allows to enable/disable the orthographic projection. Default can be configured in Preferences\n  * `refresh` (boolean): Indicates the condition under which this output should be refreshed (default is true)\n  * `refresh_every` (int): Allows to refresh the display every n time steps (default is 1)\n  * `rotate` (float): Set the angle for the rotation around the Z axis\n  * `scale` (any type in [boolean, float]): Allows to display a scale bar in the overlay. Accepts true/false or an unit name\n  * `show_fps` (boolean): Allows to enable/disable the drawing of the number of frames per second\n  * `synchronized` (boolean): Indicates whether the display should be directly synchronized with the simulation\n  * `type` (a label): Allows to use either Java2D (for planar models) or OpenGL (for 3D models) as the rendering subsystem\n  * `use_shader` (boolean): Under construction...\n  * `z_fighting` (boolean): Allows to alleviate a problem where agents at the same z would overlap each other in random ways \n \t\n#### Definition\n\nA display refers to a independent and mobile part of the interface that can display species, images, texts or charts.\n\n#### Usages\n\n* The general syntax is:\n\n```\ndisplay my_display [additional options] { ... }\n```\n\n\n* Each display can include different layers (like in a GIS).\n\n```\ndisplay gridWithElevationTriangulated type: opengl ambient_light: 100 {\n\tgrid cell elevation: true triangulation: true;\n\tspecies people aspect: base;\n}\n```\n\n\n\n#### Embedments\n* The `display` statement is of type: **Output**\n* The `display` statement can be embedded into: output, permanent, \n* The `display` statement embeds statements: [agents](#agents),  [camera](#camera),  [chart](#chart),  [display_grid](#display_grid),  [display_population](#display_population),  [event](#event),  [graphics](#graphics),  [image](#image),  [light](#light),  [overlay](#overlay),  \n\n----\n\n[//]: # (keyword|statement_display_grid)\n### display_grid \n#### Facets \n  \n  * **`species`** (species), (omissible) : the species of the agents in the grid\n  * `dem` (matrix): \n  * `draw_as_dem` (boolean): \n  * `elevation` (any type in [matrix, float, int, boolean]): Allows to specify the elevation of each cell, if any. Can be a matrix of float (provided it has the same size than the grid), an int or float variable of the grid species, or simply true (in which case, the variable called 'grid_value' is used to compute the elevation of each cell)\n  * `grayscale` (boolean): if true, givse a grey value to each polygon depending on its elevation (false by default)\n  * `lines` (rgb): the color to draw lines (borders of cells)\n  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.\n  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)\n  * `selectable` (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true\n  * `size` (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\n  * `text` (boolean): specify whether the attribute used to compute the elevation is displayed on each cells (false by default)\n  * `texture` (any type in [boolean, file]): Either file  containing the texture image to be applied on the grid or, if true, the use of the image composed by the colors of the cells. If false, no texture is applied\n  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)\n  * `triangulation` (boolean): specifies whther the cells will be triangulated: if it is false, they will be displayed as horizontal squares at a given elevation, whereas if it is true, cells will be triangulated and linked to neighbors in order to have a continuous surface (false by default) \n \t\n#### Definition\n\n`display_grid` is used using the `grid` keyword. It allows the modeler to display in an optimized way all cell agents of a grid (i.e. all agents of a species having a grid topology).\n\n#### Usages\n\n* The general syntax is:\n\n```\ndisplay my_display {\n   grid ant_grid lines: #black position: { 0.5, 0 } size: {0.5,0.5};\n}\n```\n\n\n* To display a grid as a DEM:\n\n```\ndisplay my_display {\n    grid cell texture: texture_file text: false triangulation: true elevation: true;\n}\n```\n\n    \n* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [image](#image), [overlay](#overlay), [display_population](#display_population), \n\n#### Embedments\n* The `display_grid` statement is of type: **Layer**\n* The `display_grid` statement can be embedded into: display, \n* The `display_grid` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_display_population)\n### display_population \n#### Facets \n  \n  * **`species`** (species), (omissible) : the species to be displayed\n  * `aspect` (an identifier): the name of the aspect that should be used to display the species\n  * `fading` (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false\n  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.\n  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)\n  * `selectable` (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true\n  * `size` (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\n  * `trace` (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.\n  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency) \n \t\n#### Definition\n\nThe `display_population` statement is used using the `species keyword`. It allows modeler to display all the agent of a given species in the current display. In particular, modeler can choose the aspect used to display them.\n\n#### Usages\n\n* The general syntax is:\n\n```\ndisplay my_display {\n   species species_name [additional options];\n}\n```\n\n\n* Species can be superposed on the same plan (be careful with the order, the last one will be above all the others):\n\n```\ndisplay my_display {\n   species agent1 aspect: base;\n   species agent2 aspect: base;\n   species agent3 aspect: base;\n}\n```\n\n\n* Each species layer can be placed at a different z value using the opengl display. position:{0,0,0} means the layer will be placed on the ground and position:{0,0,1} means it will be placed at an height equal to the maximum size of the environment.\n\n```\ndisplay my_display type: opengl{\n   species agent1 aspect: base ;\n   species agent2 aspect: base position:{0,0,0.5};\n   species agent3 aspect: base position:{0,0,1};\n}\n```\n\n    \n* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), \n\n#### Embedments\n* The `display_population` statement is of type: **Layer**\n* The `display_population` statement can be embedded into: display, display_population, \n* The `display_population` statement embeds statements: [display_population](#display_population),  \n\n----\n\n[//]: # (keyword|statement_do)\n### do \n#### Facets \n  \n  * **`action`** (an identifier), (omissible) : the name of an action or a primitive\n  * `internal_function` (any type): \n  * `returns` (a new identifier): create a new variable and assign to it the result of the action\n  * `with` (map): a map expression containing the parameters of the action \n \t\n#### Definition\n\nAllows the agent to execute an action or a primitive.  For a list of primitives available in every species, see this [BuiltIn161 page]; for the list of primitives defined by the different skills, see this [Skills161 page]. Finally, see this [Species161 page] to know how to declare custom actions.\n\n#### Usages\n\n* The simple syntax (when the action does not expect any argument and the result is not to be kept) is:\n\n```\ndo name_of_action_or_primitive;\n```\n\n\n* In case the action expects one or more arguments to be passed, they are defined by using facets (enclosed tags or a map are now deprecated):\n\n```\ndo name_of_action_or_primitive arg1: expression1 arg2: expression2;\n```\n\n\n* In case the result of the action needs to be made available to the agent, the action can be called with the agent calling the action (`self` when the agent itself calls the action) instead of `do`; the result should be assigned to a temporary variable:\n\n```\ntype_returned_by_action result <- self name_of_action_or_primitive [];\n```\n\n\n* In case of an action expecting arguments and returning a value, the following syntax is used:\n\n```\ntype_returned_by_action result <- self name_of_action_or_primitive [arg1::expression1, arg2::expression2];\n```\n\n\n* Deprecated uses: following uses of the `do` statement (still accepted) are now deprecated:\n\n```\n// Simple syntax: \ndo action: name_of_action_or_primitive;\n\n// In case the result of the action needs to be made available to the agent, the `returns` keyword can be defined; the result will then be referred to by the temporary variable declared in this attribute:\ndo name_of_action_or_primitive returns: result;\ndo name_of_action_or_primitive arg1: expression1 arg2: expression2 returns: result;\ntype_returned_by_action result <- name_of_action_or_primitive(self, [arg1::expression1, arg2::expression2]);\n\n// In case the result of the action needs to be made available to the agent\nlet result <- name_of_action_or_primitive(self, []);\n\n// In case the action expects one or more arguments to be passed, they can also be defined by using enclosed `arg` statements, or the `with` facet with a map of parameters:\ndo name_of_action_or_primitive with: [arg1::expression1, arg2::expression2];\n\nor\n\ndo name_of_action_or_primitive {\n     arg arg1 value: expression1;\n     arg arg2 value: expression2;\n     ...\n}\n```\n\n\n\n#### Embedments\n* The `do` statement is of type: **Single statement**\n* The `do` statement can be embedded into: chart, Behavior, Sequence of statements or action, \n* The `do` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_draw)\n### draw \n#### Facets \n\n  * `geometry` (any type), (omissible) : any type of data (it can be geometry, image, text)\n  * `at` (point): location where the shape/text/icon is drawn\n  * `begin_arrow` (any type in [int, float]): the size of the arrow, located at the beginning of the drawn geometry\n  * `bitmap` (boolean): Whether to render the text in 3D or not\n  * `border` (any type in [rgb, boolean]): if used with a color, represents the color of the geometry border. If set to false, expresses that no border should be drawn. If not set, the borders will be drawn using the color of the geometry.\n  * `color` (any type in [rgb, container]): the color to use to display the object. In case of images, will try to colorize it. You can also pass a list of colors : in that case, each color will be matched to its corresponding vertex.\n  * `depth` (float): (only if the display type is opengl) Add an artificial depth to the geometry previously defined (a line becomes a plan, a circle becomes a cylinder, a square becomes a cube, a polygon becomes a polyhedron with height equal to the depth value). Note: This only works if the geometry is not a point\n  * `empty` (boolean): a condition specifying whether the geometry is empty or full\n  * `end_arrow` (any type in [int, float]): the size of the arrow, located at the end of the drawn geometry\n  * `font` (any type in [19, string]): the font used to draw the text, if any. Applying this facet to geometries or images has no effect. You can construct here your font with the operator \"font\". ex : font:font(\"Helvetica\", 20 , #plain)\n  * `material` (25): Set a particular material to the object (only if you are in the \"use_shader\" mode).\n  * `perspective` (boolean): Whether to render the text in perspective or facing the user. Default is true.\n  * `rotate` (any type in [float, int, pair]): orientation of the shape/text/icon; can be either an int/float (angle) or a pair float::point (angle::rotation axis). The rotation axis, when expressed as an angle, is by defaut {0,0,1}\n  * `rounded` (boolean): specify whether the geometry have to be rounded (e.g. for squares)\n  * `size` (any type in [float, point]): size of the object to draw, expressed as a bounding box (width, height, depth). If expressed as a float, represents the size in the three directions.\n  * `texture` (any type in [string, list, file]): the texture(s) that should be applied to the geometry. Either a path to a file or a list of paths\n  * `width` (float): The line width to use for drawing this object \n \t\n#### Definition\n\n`draw` is used in an aspect block to express how agents of the species will be drawn. It is evaluated each time the agent has to be drawn. It can also be used in the graphics block.\n\n#### Usages\n\n* Any kind of geometry as any location can be drawn when displaying an agent (independently of his shape)\n\n```\naspect geometryAspect {\n\tdraw circle(1.0) empty: !hasFood color: #orange ;\n}\n```\n\n\n* Image or text can also be drawn\n\n```\naspect arrowAspect {\n\tdraw \"Current state= \"+state at: location + {-3,1.5} color: #white font: font('Default', 12, #bold) ;\n\tdraw file(ant_shape_full) rotate: heading at: location size: 5\n}\n```\n\n\n* Arrows can be drawn with any kind of geometry, using begin_arrow and end_arrow facets, combined with the empty: facet to specify whether it is plain or empty\n\n```\naspect arrowAspect {\n\tdraw line([{20, 20}, {40, 40}]) color: #black begin_arrow:5;\n\tdraw line([{10, 10},{20, 50}, {40, 70}]) color: #green end_arrow: 2 begin_arrow: 2 empty: true;\n\tdraw square(10) at: {80,20} color: #purple begin_arrow: 2 empty: true;\n}\n```\n\n\n\n#### Embedments\n* The `draw` statement is of type: **Single statement**\n* The `draw` statement can be embedded into: aspect, Sequence of statements or action, Layer, \n* The `draw` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_else)\n### else \n#### Facets \n \n \t\n#### Definition\n\nThis statement cannot be used alone\n\n#### Usages\n    \n* See also: [if](#if), \n\n#### Embedments\n* The `else` statement is of type: **Sequence of statements or action**\n* The `else` statement can be embedded into: if, \n* The `else` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_emotional_contagion)\n### emotional_contagion \n#### Facets \n  \n  * **`emotion_detected`** (546706): the emotion that will start the contagion\n  * `name` (an identifier), (omissible) : the identifier of the emotional contagion\n  * `charisma` (float): The charisma value of the perceived agent (between 0 and 1)\n  * `emotion_created` (546706): the emotion that will be created with the contagion\n  * `receptivity` (float): The receptivity value of the current agent (between 0 and 1)\n  * `threshold` (float): The threshold value to make the contagion\n  * `when` (boolean): A boolean value to get the emotion only with a certain condition \n \t\n#### Definition\n\nenables to make conscious or unconscious emotional contagion\n\n#### Usages\n\n* Other examples of use: \n```\nemotional_contagion emotion_detected:fearConfirmed;\nemotional_contagion emotion_detected:fear emotion_created:fearConfirmed;\nemotional_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;\n``` \n  \n\n#### Embedments\n* The `emotional_contagion` statement is of type: **Single statement**\n* The `emotional_contagion` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `emotional_contagion` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_enter)\n### enter \n#### Facets \n \n \t\n#### Definition\n\nIn an FSM architecture, `enter` introduces a sequence of statements to execute upon entering a state.\n\n#### Usages\n\n* In the following example, at the step it enters into the state s_init, the message 'Enter in s_init' is displayed followed by the display of the state name:\n\n```\n\tstate s_init {\n\t\tenter { write \"Enter in\" + state; }\n\t\t\twrite \"Enter in\" + state;\n\t\t}\n\t\twrite state;\n\t}\n```\n\n    \n* See also: [state](#state), [exit](#exit), [transition](#transition), \n\n#### Embedments\n* The `enter` statement is of type: **Sequence of statements or action**\n* The `enter` statement can be embedded into: state, \n* The `enter` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_equation)\n### equation \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : the equation identifier\n  * `params` (list): the list of parameters used in predefined equation systems\n  * `simultaneously` (list): a list of species containing a system of equations (all systems will be solved simultaneously)\n  * `type` (an identifier), takes values in: {SI, SIS, SIR, SIRS, SEIR, LV}: the choice of one among classical models (SI, SIS, SIR, SIRS, SEIR, LV)\n  * `vars` (list): the list of variables used in predefined equation systems \n \t\n#### Definition\n\nThe equation statement is used to create an equation system from several single equations.\n\n#### Usages\n\n* The basic syntax to define an equation system is:\n\n```\nfloat t;\nfloat S;\nfloat I;\nequation SI { \n   diff(S,t) = (- 0.3 * S * I / 100);\n   diff(I,t) = (0.3 * S * I / 100);\n} \n```\n\n\n* If the type: facet is used, a predefined equation system is defined using variables vars: and parameters params: in the right order. All possible predefined equation systems are the following ones (see [EquationPresentation161 EquationPresentation161] for precise definition of each classical equation system): \n\n```\nequation eqSI type: SI vars: [S,I,t] params: [N,beta];\nequation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma];\nequation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma];\nequation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu];\nequation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu];\nequation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;\n```\n\n\n* If the simultaneously: facet is used, system of all the agents will be solved simultaneously.    \n* See also: [=](#=), [solve](#solve), \n\n#### Embedments\n* The `equation` statement is of type: **Sequence of statements or action**\n* The `equation` statement can be embedded into: Species, Model, \n* The `equation` statement embeds statements: [=](#=),  \n\n----\n\n[//]: # (keyword|statement_error)\n### error \n#### Facets \n  \n  * **`message`** (string), (omissible) : the message to display in the error. \n \t\n#### Definition\n\nThe statement makes the agent output an error dialog (if the simulation contains a user interface). Otherwise displays the error in the console.\n\n#### Usages\n\n* Throwing an error\n\n```\nerror 'This is an error raised by ' + self;\n```\n\n\n\n#### Embedments\n* The `error` statement is of type: **Single statement**\n* The `error` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `error` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_event)\n### event \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : the type of event captured: can be  \"mouse_up\", \"mouse_down\", \"mouse_move\", \"mouse_exit\", \"mouse_enter\" or a character  \n  * **`action`** (26): Either a block of statements to execute in the context of the simulation or the identifier of the action to be executed. This action needs to be defined in 'global' or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_location\n  * `unused` (an identifier), takes values in: {mouse_up, mouse_down, mouse_move, mouse_enter, mouse_exit}: an unused facet that serves only for the purpose of declaring the string values \n \t\n#### Definition\n\n`event` allows to interact with the simulation by capturing mouse or key events and doing an action. This action needs to be defined in 'global' or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_location\n\n#### Usages\n\n* The general syntax is:\n\n```\nevent [event_type] action: myAction;\n```\n\n\n* For instance:\n\n```\nglobal {\n   // ... \n   action myAction () {\n      point loc <- #user_location; // contains the location of the mouse in the world\n      list<agent> selected_agents <- agents inside (10#m around loc); // contains agents clicked by the event\n      \n      // code written by modelers\n   }\n}\n\nexperiment Simple type:gui {\n   display my_display {\n      event mouse_up action: myAction;\n   }\n}\n```\n\n    \n* See also: [display](#display), [agents](#agents), [chart](#chart), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [display_population](#display_population), \n\n#### Embedments\n* The `event` statement is of type: **Layer**\n* The `event` statement can be embedded into: display, \n* The `event` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_exhaustive)\n### exhaustive \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : \n  * `aggregation` (a label), takes values in: {min, max}: the agregation method\n  * `maximize` (float): the value the algorithm tries to maximize\n  * `minimize` (float): the value the algorithm tries to minimize \n \t\n#### Definition\n\nThis is the standard batch method. The exhaustive mode is defined by default when there is no method element present in the batch section. It explores all the combination of parameter values in a sequential way. See [batch161 the batch dedicated page].\n\n#### Usages\n\n* As other batch methods, the basic syntax of the exhaustive statement uses `method exhaustive` instead of the expected `exhaustive name: id` : \n\n```\nmethod exhaustive [facet: value];\n```\n\n\n* For example: \n\n```\nmethod exhaustive maximize: food_gathered;\n```\n\n\n\n#### Embedments\n* The `exhaustive` statement is of type: **Batch method**\n* The `exhaustive` statement can be embedded into: Experiment, \n* The `exhaustive` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_exit)\n### exit \n#### Facets \n \n \t\n#### Definition\n\nIn an FSM architecture, `exit` introduces a sequence of statements to execute right before exiting the state.\n\n#### Usages\n\n* In the following example, at the state it leaves the state s_init, he will display the message 'EXIT from s_init':\n\n```\n\tstate s_init initial: true {\n\t\twrite state;\n\t\ttransition to: s1 when: (cycle > 2) {\n\t\t\twrite \"transition s_init -> s1\";\n\t\t}\n\t\texit {\n\t\t\twrite \"EXIT from \"+state;\n\t\t}\n\t}\n```\n\n    \n* See also: [enter](#enter), [state](#state), [transition](#transition), \n\n#### Embedments\n* The `exit` statement is of type: **Sequence of statements or action**\n* The `exit` statement can be embedded into: state, \n* The `exit` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_experiment)\n### experiment \n#### Facets \n  \n  * **`name`** (a label), (omissible) : identifier of the experiment  \n  * **`title`** (a label):   \n  * **`type`** (a label), takes values in: {batch, memorize, gui, headless}: the type of the experiment (either 'gui' or 'batch'\n  * `control` (an identifier): \n  * `frequency` (int): the execution frequence of the experiment (default value: 1). If frequency: 10, the experiment is executed only each 10 steps.\n  * `keep_seed` (boolean): \n  * `keep_simulations` (boolean): In the case of a batch experiment, specifies whether or not the simulations should be kept in memory for further analysis or immediately discarded with only their fitness kept in memory\n  * `parallel` (any type in [boolean, int]): When set to true, use multiple threads to run its simulations. Setting it to n will set the numbers of threads to use\n  * `parent` (an identifier): the parent experiment (in case of inheritance between experiments)\n  * `repeat` (int): In the case of a batch experiment, expresses hom many times the simulations must be repeated\n  * `schedules` (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. For instance, 'species a schedules: (10 among a)' will result in a population that schedules only 10 of its own agents every cycle. 'species b schedules: []' will prevent the agents of 'b' to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining 'global schedules: [] {...} species b schedules: []; species c schedules: b + world; ' allows to simulate a model where the agents of b are scheduled first, followed by the world, without even having to create an instance of c.\n  * `skills` (list): \n  * `until` (boolean): In the case of a batch experiment, an expression that will be evaluated to know when a simulation should be terminated\n\n#### Embedments\n* The `experiment` statement is of type: **Experiment**\n* The `experiment` statement can be embedded into: Model, \n* The `experiment` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_export)\n### export \n#### Facets \n  \n  * **`var`** (an identifier), (omissible) : \n  * `framerate` (int): \n  * `name` (string): \n\n#### Embedments\n* The `export` statement is of type: **Single statement**\n* The `export` statement can be embedded into: Experiment, \n* The `export` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_focus)\n### focus \n#### Facets \n\n  * `name` (an identifier), (omissible) : the identifier of the focus\n  * `agent_cause` (agent): the agentCause value of the created belief (can be nil\n  * `expression` (any type): an expression that will be the value kept in the belief\n  * `lifetime` (int): the lifetime value of the created belief\n  * `priority` (any type in [float, int]): The priority of the created predicate\n  * `truth` (boolean): the truth value of the created belief\n  * `var` (any type in [any type, list, container]): the variable of the perceived agent you want to add to your beliefs\n  * `when` (boolean): A boolean value to focus only with a certain condition \n \t\n#### Definition\n\nenables to directly add a belief from the variable of a perceived specie.\n\n#### Usages\n\n* Other examples of use: \n```\nfocus var:speed /*where speed is a variable from a species that is being perceived*/\n``` \n  \n\n#### Embedments\n* The `focus` statement is of type: **Single statement**\n* The `focus` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `focus` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_focus_on)\n### focus_on \n#### Facets \n  \n  * **`value`** (any type), (omissible) : The agent, list of agents, geometry to focus on \n \t\n#### Definition\n\nAllows to focus on the passed parameter in all available displays. Passing 'nil' for the parameter will make all screens return to their normal zoom\n\n#### Usages\n\n* Focuses on an agent, a geometry, a set of agents, etc...)\n\n```\nfocus_on my_species(0);\n```\n\n\n\n#### Embedments\n* The `focus_on` statement is of type: **Single statement**\n* The `focus_on` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `focus_on` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_genetic)\n### genetic \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : \n  * `aggregation` (a label), takes values in: {min, max}: the agregation method\n  * `crossover_prob` (float): crossover probability between two individual solutions\n  * `max_gen` (int): number of generations\n  * `maximize` (float): the value the algorithm tries to maximize\n  * `minimize` (float): the value the algorithm tries to minimize\n  * `mutation_prob` (float): mutation probability for an individual solution\n  * `nb_prelim_gen` (int): number of random populations used to build the initial population\n  * `pop_dim` (int): size of the population (number of individual solutions) \n \t\n#### Definition\n\nThis is a simple implementation of Genetic Algorithms (GA). See the wikipedia article and [batch161 the batch dedicated page]. The principle of the GA is to search an optimal solution by applying evolution operators on an initial population of solutions. There are three types of evolution operators: crossover, mutation and selection. Different techniques can be applied for this selection. Most of them are based on the solution quality (fitness).\n\n#### Usages\n\n* As other batch methods, the basic syntax of the `genetic` statement uses `method genetic` instead of the expected `genetic name: id` : \n\n```\nmethod genetic [facet: value];\n```\n\n\n* For example: \n\n```\nmethod genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20; \n```\n\n\n\n#### Embedments\n* The `genetic` statement is of type: **Batch method**\n* The `genetic` statement can be embedded into: Experiment, \n* The `genetic` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_graphics)\n### graphics \n#### Facets \n\n  * `name` (a label), (omissible) : the human readable title of the graphics\n  * `fading` (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false\n  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.\n  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)\n  * `size` (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\n  * `trace` (any type in [boolean, int]): Allows to aggregate the visualization at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.\n  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency) \n \t\n#### Definition\n\n`graphics` allows the modeler to freely draw shapes/geometries/texts without having to define a species. It works exactly like a species [Aspect161 aspect]: the draw statement can be used in the same way.\n\n#### Usages\n\n* The general syntax is:\n\n```\ndisplay my_display {\n   graphics \"my new layer\" {\n      draw circle(5) at: {10,10} color: #red;\n      draw \"test\" at: {10,10} size: 20 color: #black;\n   }\n}\n```\n\n    \n* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [display_population](#display_population), \n\n#### Embedments\n* The `graphics` statement is of type: **Layer**\n* The `graphics` statement can be embedded into: display, \n* The `graphics` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_highlight)\n### highlight \n#### Facets \n  \n  * **`value`** (agent), (omissible) : The agent to hightlight\n  * `color` (rgb): An optional color to highlight the agent. Note that this color will become the default color for further higlight operations \n \t\n#### Definition\n\nAllows to highlight the agent passed in parameter in all available displays, optionaly setting a color. Passing 'nil' for the agent will remove the current highlight\n\n#### Usages\n\n* Highlighting an agent\n\n```\nhighlight my_species(0) color: #blue;\n```\n\n\n\n#### Embedments\n* The `highlight` statement is of type: **Single statement**\n* The `highlight` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `highlight` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_hill_climbing)\n### hill_climbing \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : \n  * `aggregation` (a label), takes values in: {min, max}: the agregation method\n  * `iter_max` (int): number of iterations\n  * `maximize` (float): the value the algorithm tries to maximize\n  * `minimize` (float): the value the algorithm tries to minimize \n \t\n#### Definition\n\nThis algorithm is an implementation of the Hill Climbing algorithm. See the wikipedia article and [batch161 the batch dedicated page].\n\n#### Usages\n\n* As other batch methods, the basic syntax of the `hill_climbing` statement uses `method hill_climbing` instead of the expected `hill_climbing name: id` : \n\n```\nmethod hill_climbing [facet: value];\n```\n\n\n* For example: \n\n```\nmethod hill_climbing iter_max: 50 maximize : food_gathered; \n```\n\n\n\n#### Embedments\n* The `hill_climbing` statement is of type: **Batch method**\n* The `hill_climbing` statement can be embedded into: Experiment, \n* The `hill_climbing` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_if)\n### if \n#### Facets \n  \n  * **`condition`** (boolean), (omissible) : A boolean expression: the condition that is evaluated. \n \t\n#### Definition\n\nAllows the agent to execute a sequence of statements if and only if the condition evaluates to true.\n\n#### Usages\n\n* The generic syntax is:\n\n```\nif bool_expr {\n    [statements]\n}\n```\n\n\n* Optionally, the statements to execute when the condition evaluates to false can be defined in a following statement else. The syntax then becomes:\n\n```\nif bool_expr {\n    [statements]\n}\nelse {\n    [statements]\n}\nstring valTrue <- \"\";\nif true {\n\tvalTrue <- \"true\";\n}\nelse {\n\tvalTrue <- \"false\";\n}\n \t// valTrue equals \"true\"\nstring valFalse <- \"\";\nif false {\n\tvalFalse <- \"true\";\n}\nelse {\n\tvalFalse <- \"false\";\n}\n \t// valFalse equals \"false\"\n```\n\n\n* ifs and elses can be imbricated as needed. For instance:\n\n```\nif bool_expr {\n    [statements]\n}\nelse if bool_expr2 {\n    [statements]\n}\nelse {\n    [statements]\n}\n```\n\n\n\n#### Embedments\n* The `if` statement is of type: **Sequence of statements or action**\n* The `if` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `if` statement embeds statements: [else](#else),  \n\n----\n\n[//]: # (keyword|statement_image)\n### image \n#### Facets \n\n  * `name` (any type in [string, file]), (omissible) : Human readable title of the image layer\n  * `color` (rgb): in the case of a shapefile, this the color used to fill in geometries of the shapefile\n  * `file` (any type in [string, file]): the name/path of the image (in the case of a raster image)\n  * `gis` (any type in [file, string]): the name/path of the shape file (to display a shapefile as background, without creating agents from it)\n  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.\n  * `refresh` (boolean): (openGL only) specify whether the image display is refreshed. (true by default, usefull in case of images that is not modified over the simulation)\n  * `size` (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\n  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency) \n \t\n#### Definition\n\n`image` allows modeler to display an image (e.g. as background of a simulation).\n\n#### Usages\n\n* The general syntax is:\n\n```\ndisplay my_display {\n   image layer_name file: image_file [additional options];\n}\n```\n\n\n* For instance, in the case of a bitmap image\n\n```\ndisplay my_display {\n   image background file:\"../images/my_backgound.jpg\";\n}\n```\n\n\n* Or in the case of a shapefile:\n\n```\ndisplay my_display {\n   image testGIS gis: \"../includes/building.shp\" color: rgb('blue');\n}\n```\n\n\n* It is also possible to superpose images on different layers in the same way as for species using opengl display:\n\n```\ndisplay my_display {\n  image image1 file:\"../images/image1.jpg\";\n  image image2 file:\"../images/image2.jpg\";\n  image image3 file:\"../images/image3.jpg\" position: {0,0,0.5};\n}\n```\n\n    \n* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [overlay](#overlay), [display_population](#display_population), \n\n#### Embedments\n* The `image` statement is of type: **Layer**\n* The `image` statement can be embedded into: display, \n* The `image` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_inspect)\n### inspect \n#### Facets \n  \n  * **`name`** (any type), (omissible) : the identifier of the inspector\n  * `attributes` (list): the list of attributes to inspect\n  * `refresh` (boolean): Indicates the condition under which this output should be refreshed (default is true)\n  * `refresh_every` (int): Allows to refresh the inspector every n time steps (default is 1)\n  * `type` (an identifier), takes values in: {agent, table}: the way to inspect agents: in a table, or a set of inspectors\n  * `value` (any type): the set of agents to inspect, could be a species, a list of agents or an agent \n \t\n#### Definition\n\n`inspect` (and `browse`) statements allows modeler to inspect a set of agents, in a table with agents and all their attributes or an agent inspector per agent, depending on the type: chosen. Modeler can choose which attributes to display. When `browse` is used, type: default value is table, whereas when`inspect` is used, type: default value is agent.\n\n#### Usages\n\n* An example of syntax is:\n\n```\ninspect \"my_inspector\" value: ant attributes: [\"name\", \"location\"];\n```\n\n\n\n#### Embedments\n* The `inspect` statement is of type: **Output**\n* The `inspect` statement can be embedded into: output, permanent, Behavior, Sequence of statements or action, \n* The `inspect` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_let)\n### let \n#### Facets \n  \n  * **`name`** (a new identifier), (omissible) : \n  * `index` (a datatype identifier): \n  * `of` (a datatype identifier): \n  * `type` (a datatype identifier): \n  * `value` (any type): \n\n#### Embedments\n* The `let` statement is of type: **Single statement**\n* The `let` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `let` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_light)\n### light \n#### Facets \n  \n  * **`id`** (int), (omissible) : a number from 1 to 7 to specify which light we are using\n  * `active` (boolean): a boolean expression telling if you want this light to be switch on or not. (default value : true)\n  * `color` (any type in [int, rgb]): an int / rgb / rgba value to specify the color and the intensity of the light. (default value : (127,127,127,255) ).\n  * `direction` (point): the direction of the light (only for direction and spot light). (default value : {0.5,0.5,-1})\n  * `draw_light` (boolean): draw or not the light. (default value : false).\n  * `linear_attenuation` (float): the linear attenuation of the positionnal light. (default value : 0)\n  * `position` (point): the position of the light (only for point and spot light). (default value : {0,0,1})\n  * `quadratic_attenuation` (float): the linear attenuation of the positionnal light. (default value : 0)\n  * `spot_angle` (float): the angle of the spot light in degree (only for spot light). (default value : 45)\n  * `type` (a label): the type of light to create. A value among {point, direction, spot}. (default value : direction)\n  * `update` (boolean): specify if the light has to be updated. (default value : true). \n \t\n#### Definition\n\n`light` allows to define diffusion lights in your 3D display.\n\n#### Usages\n\n* The general syntax is:\n\n```\nlight 1 type:point position:{20,20,20} color:255, linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:false\nlight 2 type:spot position:{20,20,20} direction:{0,0,-1} color:255 spot_angle:25 linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:false\nlight 3 type:point direction:{1,1,-1} color:255 draw_light:true update:false\n```\n\n    \n* See also: [display](#display), \n\n#### Embedments\n* The `light` statement is of type: **Layer**\n* The `light` statement can be embedded into: display, \n* The `light` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_loop)\n### loop \n#### Facets \n\n  * `name` (a new identifier), (omissible) : a temporary variable name\n  * `from` (int): an int expression\n  * `over` (any type in [container, point]): a list, point, matrix or map expression\n  * `step` (int): an int expression\n  * `times` (int): an int expression\n  * `to` (int): an int expression\n  * `while` (boolean): a boolean expression \n \t\n#### Definition\n\nAllows the agent to perform the same set of statements either a fixed number of times, or while a condition is true, or by progressing in a collection of elements or along an interval of integers. Be aware that there are no prevention of infinite loops. As a consequence, open loops should be used with caution, as one agent may block the execution of the whole model.\n\n#### Usages\n\n* The basic syntax for repeating a fixed number of times a set of statements is:\n\n```\nloop times: an_int_expression {\n     // [statements]\n}\n```\n\n\n* The basic syntax for repeating a set of statements while a condition holds is:\n\n```\nloop while: a_bool_expression {\n     // [statements]\n}\n```\n\n\n* The basic syntax for repeating a set of statements by progressing over a container of a point is:\n\n```\nloop a_temp_var over: a_collection_expression {\n     // [statements]\n}\n```\n\n\n* The basic syntax for repeating a set of statements while an index iterates over a range of values with a fixed step of 1 is:\n\n```\nloop a_temp_var from: int_expression_1 to: int_expression_2 {\n     // [statements]\n}\n```\n\n\n* The incrementation step of the index can also be chosen:\n\n```\nloop a_temp_var from: int_expression_1 to: int_expression_2 step: int_expression3 {\n     // [statements]\n}\n```\n\n\n* In these latter three cases, the name facet designates the name of a temporary variable, whose scope is the loop, and that takes, in turn, the value of each of the element of the list (or each value in the interval). For example, in the first instance of the \"loop over\" syntax :\n\n```\nint a <- 0;\nloop i over: [10, 20, 30] {\n     a <- a + i;\n} // a now equals 60\n```\n\n\n* The second (quite common) case of the loop syntax allows one to use an interval of integers. The from and to facets take an integer expression as arguments, with the first (resp. the last) specifying the beginning (resp. end) of the inclusive interval (i.e. [to, from]). If the step is not defined, it is assumed to be equal to 1 or -1, depending on the direction of the range. If it is defined, its sign will be respected, so that a positive step will never allow the loop to enter a loop from i to j where i is greater than j\n\n```\nlist the_list <-list (species_of (self));\nloop i from: 0 to: length (the_list) - 1 {\n     ask the_list at i {\n        // ...\n     }\n} // every  agent of the list is asked to do something\n```\n\n\n\n#### Embedments\n* The `loop` statement is of type: **Sequence of statements or action**\n* The `loop` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `loop` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_match)\n### match \n#### Facets \n\n  * `value` (any type), (omissible) :  \n \t\n#### Definition\n\nIn a switch...match structure, the value of each match block is compared to the value in the switch. If they match, the embedded statement set is executed. Three kinds of match can be used\n\n#### Usages\n\n* match block is executed if the switch value is equals to the value of the match:\n\n```\nswitch 3 {\n   match 1 {write \"Match 1\"; }\n   match 3 {write \"Match 2\"; }\n}\n```\n\n\n* match_between block is executed if the switch value is in the interval given in value of the match_between:\n\n```\nswitch 3 {\n   match_between [1,2] {write \"Match OK between [1,2]\"; }\n   match_between [2,5] {write \"Match OK between [2,5]\"; }\n}\n```\n\n\n* match_one block is executed if the switch value is equals to one of the values of the match_one:\n\n```\nswitch 3 {\n   match_one [0,1,2] {write \"Match OK with one of [0,1,2]\"; }\n   match_between [2,3,4,5] {write \"Match OK with one of [2,3,4,5]\"; }\n}\n```\n\n    \n* See also: [switch](#switch), [default](#default), \n\n#### Embedments\n* The `match` statement is of type: **Sequence of statements or action**\n* The `match` statement can be embedded into: switch, \n* The `match` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_migrate)\n### migrate \n#### Facets \n  \n  * **`source`** (any type in [agent, species, container, an identifier]), (omissible) : can be an agent, a list of agents, a agent's population to be migrated  \n  * **`target`** (species): target species/population that source agent(s) migrate to.\n  * `returns` (a new identifier): the list of returned agents in a new local variable \n \t\n#### Definition\n\nThis command permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Species of source agents and target species respect the following constraints: (i) they are \"peer\" species (sharing the same direct macro-species), (ii) they have sub-species vs. parent-species relationship.\n\n#### Usages\n\n* It can be used in a 3-levels model, in case where individual agents can be captured into group meso agents and groups into clouds macro agents. migrate is used to allows agents captured by groups to migrate into clouds. See the model 'Balls, Groups and Clouds.gaml' in the library.\n\n```\nmigrate ball_in_group target: ball_in_cloud;\n```\n\n    \n* See also: [capture](#capture), [release](#release), \n\n#### Embedments\n* The `migrate` statement is of type: **Sequence of statements or action**\n* The `migrate` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `migrate` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_monitor)\n### monitor \n#### Facets \n  \n  * **`name`** (a label), (omissible) : identifier of the monitor  \n  * **`value`** (any type): expression that will be evaluated to be displayed in the monitor\n  * `color` (rgb): Indicates the (possibly dynamic) color of this output (default is a light gray)\n  * `refresh` (boolean): Indicates the condition under which this output should be refreshed (default is true)\n  * `refresh_every` (int): Allows to refresh the monitor every n time steps (default is 1) \n \t\n#### Definition\n\nA monitor allows to follow the value of an arbitrary expression in GAML.\n\n#### Usages\n\n* An example of use is:\n\n```\nmonitor \"nb preys\" value: length(prey as list) refresh_every: 5;  \n```\n\n\n\n#### Embedments\n* The `monitor` statement is of type: **Output**\n* The `monitor` statement can be embedded into: output, permanent, \n* The `monitor` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_output)\n### output \n#### Facets \n \n \t\n#### Definition\n\n`output` blocks define how to visualize a simulation (with one or more display blocks that define separate windows). It will include a set of displays, monitors and files statements. It will be taken into account only if the experiment type is `gui`.\n\n#### Usages\n\n* Its basic syntax is: \n\n```\nexperiment exp_name type: gui {\n   // [inputs]\n   output {\n      // [display, file, inspect, layout or monitor statements]\n   }\n}\n```\n\n    \n* See also: [display](#display), [monitor](#monitor), [inspect](#inspect), [output_file](#output_file), [layout](#layout), \n\n#### Embedments\n* The `output` statement is of type: **Output**\n* The `output` statement can be embedded into: Model, Experiment, \n* The `output` statement embeds statements: [display](#display),  [inspect](#inspect),  [monitor](#monitor),  [output_file](#output_file),  \n\n----\n\n[//]: # (keyword|statement_output_file)\n### output_file \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : The name of the file where you want to export the data  \n  * **`data`** (string): The data you want to export\n  * `footer` (string): Define a footer for your export file\n  * `header` (string): Define a header for your export file\n  * `refresh` (boolean): Indicates the condition under which this file should be saved (default is true)\n  * `refresh_every` (int): Allows to save the file every n time steps (default is 1)\n  * `rewrite` (boolean): Rewrite or not the existing file\n  * `type` (an identifier), takes values in: {csv, text, xml}: The type of your output data\n\n#### Embedments\n* The `output_file` statement is of type: **Output**\n* The `output_file` statement can be embedded into: output, permanent, \n* The `output_file` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_overlay)\n### overlay \n#### Facets \n\n  * `background` (rgb): the background color of the overlay displayed inside the view (the bottom overlay remains black)\n  * `border` (rgb): Color to apply to the border of the rectangular shape of the overlay. Nil by default\n  * `center` (any type): an expression that will be evaluated and displayed in the center section of the bottom overlay\n  * `color` (any type in [list, rgb]): the color(s) used to display the expressions given in the 'left', 'center' and 'right' facets\n  * `left` (any type): an expression that will be evaluated and displayed in the left section of the bottom overlay\n  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.\n  * `right` (any type): an expression that will be evaluated and displayed in the right section of the bottom overlay\n  * `rounded` (boolean): Whether or not the rectangular shape of the overlay should be rounded. True by default\n  * `size` (point): extent of the layer in the view from its position. Coordinates in [0,1[ are treated as percentages of the total surface of the view, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Unlike  'position', no elevation can be provided with the z coordinate\n  * `transparency` (float): the transparency rate of the overlay (between 0 and 1, 1 means no transparency) when it is displayed inside the view. The bottom overlay will remain at 0.75 \n \t\n#### Definition\n\n`overlay` allows the modeler to display a line to the already existing bottom overlay, where the results of 'left', 'center' and 'right' facets, when they are defined, are displayed with the corresponding color if defined.\n\n#### Usages\n\n* To display information in the bottom overlay, the syntax is:\n\n```\noverlay \"Cycle: \" + (cycle) center: \"Duration: \" + total_duration + \"ms\" right: \"Model time: \" + as_date(time,\"\") color: [#yellow, #orange, #yellow];\n```\n\n    \n* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [display_population](#display_population), \n\n#### Embedments\n* The `overlay` statement is of type: **Layer**\n* The `overlay` statement can be embedded into: display, \n* The `overlay` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_parameter)\n### parameter \n#### Facets \n  \n  * **`var`** (an identifier): the name of the variable (that should be declared in the global)\n  * `name` (a label), (omissible) : The message displayed in the interface\n  * `among` (list): the list of possible values\n  * `category` (a label): a category label, used to group parameters in the interface\n  * `init` (any type): the init value\n  * `max` (any type): the maximum value\n  * `min` (any type): the minimum value\n  * `on_change` (any type): Provides a block of statements that will be executed whenever the value of the parameter changes\n  * `slider` (boolean): Whether or not to display a slider for entering an int or float value. Default is true when max and min values are defined, false otherwise. If no max or min value is defined, setting this facet to true will have no effect\n  * `step` (float): the increment step (mainly used in batch mode to express the variation step between simulation)\n  * `type` (a datatype identifier): the variable type\n  * `unit` (a label): the variable unit \n \t\n#### Definition\n\nThe parameter statement specifies which global attributes (i) will change through the successive simulations (in batch experiments), (ii) can be modified by user via the interface (in gui experiments). In GUI experiments, parameters are displayed depending on their type.\n\n#### Usages\n\n* In gui experiment, the general syntax is the following:\n\n```\nparameter title var: global_var category: cat;\n```\n\n\n* In batch experiment, the two following syntaxes can be used to describe the possible values of a parameter:\n\n```\nparameter 'Value of toto:' var: toto among: [1, 3, 7, 15, 100]; \nparameter 'Value of titi:' var: titi min: 1 max: 100 step: 2; \n```\n\n\n\n#### Embedments\n* The `parameter` statement is of type: **Parameter**\n* The `parameter` statement can be embedded into: Experiment, \n* The `parameter` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_perceive)\n### perceive \n#### Facets \n  \n  * **`target`** (any type in [container, point, agent]): the list of the agent you want to perceive\n  * `name` (an identifier), (omissible) : the name of the perception\n  * `as` (species): an expression that evaluates to a species\n  * `emotion` (546706): The emotion needed to do the perception\n  * `in` (any type in [float, geometry]): a float or a geometry. If it is a float, it's a radius of a detection area. If it is a geometry, it is the area of detection of others species.\n  * `parallel` (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.\n  * `threshold` (float): Threshold linked to the emotion.\n  * `when` (boolean): a boolean to tell when does the perceive is active \n \t\n#### Definition\n\nAllow the agent, with a bdi architecture, to perceive others agents\n\n#### Usages\n\n* the basic syntax to perceive agents inside a circle of perception\n\n```\nperceive name_of-perception target: the_agents_you_want_to_perceive in: a_distance when: a_certain_condition {\nHere you are in the context of the perceived agents. To refer to the agent who does the perception, use myself.\nIf you want to make an action (such as adding a belief for example), use ask myself{ do the_action}\n}\n```\n\n\n\n#### Embedments\n* The `perceive` statement is of type: **Sequence of statements or action**\n* The `perceive` statement can be embedded into: Species, Model, \n* The `perceive` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_permanent)\n### permanent \n#### Facets \n\n  * `layout` (int), (omissible) : Either #none, to indicate that no layout will be imposed, or one of the four possible predefined layouts: #stack, #split, #horizontal or #vertical. This layout will be applied to both experiment and simulation display views \n \t\n#### Definition\n\nRepresents the outputs of the experiment itself. In a batch experiment, the permanent section allows to define an output block that will NOT be re-initialized at the beginning of each simulation but will be filled at the end of each simulation.\n\n#### Usages\n\n* For instance, this permanent section will allow to display for each simulation the end value of the food_gathered variable:\n\n```\npermanent {\n\tdisplay Ants background: rgb('white') refresh_every: 1 {\n\t\tchart \"Food Gathered\" type: series {\n\t\t\tdata \"Food\" value: food_gathered;\n\t\t}\n\t}\n}\n```\n\n\n\n#### Embedments\n* The `permanent` statement is of type: **Output**\n* The `permanent` statement can be embedded into: Experiment, \n* The `permanent` statement embeds statements: [display](#display),  [inspect](#inspect),  [monitor](#monitor),  [output_file](#output_file),  \n\n----\n\n[//]: # (keyword|statement_plan)\n### plan \n#### Facets \n\n  * `name` (an identifier), (omissible) : \n  * `emotion` (546706): \n  * `finished_when` (boolean): \n  * `instantaneous` (boolean): \n  * `intention` (546704): \n  * `priority` (float): \n  * `threshold` (float): \n  * `when` (boolean): \n\n#### Embedments\n* The `plan` statement is of type: **Behavior**\n* The `plan` statement can be embedded into: Species, Model, \n* The `plan` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_put)\n### put \n#### Facets \n  \n  * **`in`** (any type in [container, species, agent, geometry]): an expression that evaluates to a container\n  * `item` (any type), (omissible) : any expression\n  * `all` (any type): any expression\n  * `at` (any type): any expression\n  * `edge` (any type): Indicates that the item to put should be considered as an edge of the receiving graph. Soon to be deprecated, use 'put edge(item)...' instead\n  * `key` (any type): any expression\n  * `weight` (float): an expression that evaluates to a float \n \t\n#### Definition\n\nAllows the agent to replace a value in a container at a given position (in a list or a map) or for a given key (in a map). Note that the behavior and the type of the attributes depends on the specific kind of container.\n\n#### Usages\n\n* The allowed parameters configurations are the following ones:\n\n```\nput expr at: expr in: expr_container;\nput all: expr in: expr_container;\n```\n\n\n* In the case of a list, the position should an integer in the bound of the list. The facet all: is used to replace all the elements of the list by the given value.\n\n```\nlist<int> putList <- [1,2,3,4,5]; \t// putList equals [1,2,3,4,5]\nput -10 at: 1 in: putList; \t// putList equals [1,-10,3,4,5]\nput 10 all: true in: putList; \t// putList equals [10,10,10,10,10]\n```\n\n\n* In the case of a matrix, the position should be a point in the bound of the matrix. The facet all: is used to replace all the elements of the matrix by the given value.\n\n```\nmatrix<int> putMatrix <- matrix([[0,1],[2,3]]); \t// putMatrix equals matrix([[0,1],[2,3]])\nput -10 at: {1,1} in: putMatrix; \t// putMatrix equals matrix([[0,1],[2,-10]])\nput 10 all: true in: putMatrix; \t// putMatrix equals matrix([[10,10],[10,10]])\n```\n\n\n* In the case of a map, the position should be one of the key values of the map. Notice that if the given key value does not exist in the map, the given pair key::value will be added to the map. The facet all is used to replace the value of all the pairs of the map.\n\n```\nmap<string,int> putMap <- [\"x\"::4,\"y\"::7]; \t// putMap equals [\"x\"::4,\"y\"::7]\nput -10 key: \"y\" in: putMap; \t// putMap equals [\"x\"::4,\"y\"::-10]\nput -20 key: \"z\" in: putMap; \t// putMap equals [\"x\"::4,\"y\"::-10, \"z\"::-20]\nput -30 all: true in: putMap; \t// putMap equals [\"x\"::-30,\"y\"::-30, \"z\"::-30]\n```\n\n\n\n#### Embedments\n* The `put` statement is of type: **Single statement**\n* The `put` statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, \n* The `put` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_reactive_tabu)\n### reactive_tabu \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : \n  * `aggregation` (a label), takes values in: {min, max}: the agregation method\n  * `cycle_size_max` (int): minimal size of the considered cycles\n  * `cycle_size_min` (int): maximal size of the considered cycles\n  * `iter_max` (int): number of iterations\n  * `maximize` (float): the value the algorithm tries to maximize\n  * `minimize` (float): the value the algorithm tries to minimize\n  * `nb_tests_wthout_col_max` (int): number of movements without collision before shortening the tabu list\n  * `tabu_list_size_init` (int): initial size of the tabu list\n  * `tabu_list_size_max` (int): maximal size of the tabu list\n  * `tabu_list_size_min` (int): minimal size of the tabu list \n \t\n#### Definition\n\nThis algorithm is a simple implementation of the Reactive Tabu Search algorithm ((Battiti et al., 1993)). This Reactive Tabu Search is an enhance version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle. See [batch161 the batch dedicated page].\n\n#### Usages\n\n* As other batch methods, the basic syntax of the reactive_tabu statement uses `method reactive_tabu` instead of the expected `reactive_tabu name: id` : \n\n```\nmethod reactive_tabu [facet: value];\n```\n\n\n* For example: \n\n```\nmethod reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered;\n```\n\n\n\n#### Embedments\n* The `reactive_tabu` statement is of type: **Batch method**\n* The `reactive_tabu` statement can be embedded into: Experiment, \n* The `reactive_tabu` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_reflex)\n### reflex \n#### Facets \n\n  * `name` (an identifier), (omissible) : the identifier of the reflex\n  * `when` (boolean): an expression that evaluates a boolean, the condition to fulfill in order to execute the statements embedded in the reflex. \n \t\n#### Definition\n\nReflexes are sequences of statements that can be executed by the agent. Reflexes prefixed by the 'reflex' keyword are executed continuously. Reflexes prefixed by 'init' are executed only immediately after the agent has been created. Reflexes prefixed by 'abort' just before the agent is killed. If a facet when: is defined, a reflex is executed only if the boolean expression evaluates to true.\n\n#### Usages\n\n* Example:\n\n```\nreflex my_reflex when: flip (0.5){ \t\t//Only executed when flip returns true\n    write \"Executing the unconditional reflex\";\n}\n```\n\n\n\n#### Embedments\n* The `reflex` statement is of type: **Behavior**\n* The `reflex` statement can be embedded into: Species, Experiment, Model, \n* The `reflex` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_release)\n### release \n#### Facets \n  \n  * **`target`** (any type in [agent, list, 27]), (omissible) : an expression that is evaluated as an agent/a list of the agents to be released or an agent saved as a map\n  * `as` (species): an expression that is evaluated as a species in which the micro-agent will be released\n  * `in` (agent): an expression that is evaluated as an agent that will be the macro-agent in which micro-agent will be released, i.e. their new host\n  * `returns` (a new identifier): a new variable containing a list of the newly released agent(s) \n \t\n#### Definition\n\nAllows an agent to release its micro-agent(s). The preliminary for an agent to release its micro-agents is that species of these micro-agents are sub-species of other species (cf. [Species161#Nesting_species Nesting species]). The released agents won't be micro-agents of the calling agent anymore. Being released from a macro-agent, the micro-agents will change their species and host (macro-agent).\n\n#### Usages\n\n* We consider the following species. Agents of \"C\" species can be released from a \"B\" agent to become agents of \"A\" species. Agents of \"D\" species cannot be released from the \"A\" agent because species \"D\" has no parent species.\n\n```\nspecies A {\n...\n}\nspecies B {\n...\n   species C parent: A {\n   ...\n   }\n   species D {\n   ...\n   }\n...\n}\n```\n\n\n* To release all \"C\" agents from a \"B\" agent, agent \"C\" has to execute the following statement. The \"C\" agent will change to \"A\" agent. The won't consider \"B\" agent as their macro-agent (host) anymore. Their host (macro-agent) will the be the host (macro-agent) of the \"B\" agent.\n\n```\nrelease list(C);\n```\n\n\n* The modeler can specify the new host and the new species of the released agents:\n\n```\nrelease list (C) as: new_species in: new host;\n```\n\n    \n* See also: [capture](#capture), \n\n#### Embedments\n* The `release` statement is of type: **Sequence of statements or action**\n* The `release` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `release` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_remove)\n### remove \n#### Facets \n  \n  * **`from`** (any type in [container, species, agent, geometry]): an expression that evaluates to a container\n  * `item` (any type), (omissible) : any expression to remove from the container\n  * `all` (any type): an expression that evaluates to a container. If it is true and if the value a list, it removes the first instance of each element of the list. If it is true and the value is not a container, it will remove all instances of this value.\n  * `edge` (any type): Indicates that the item to remove should be considered as an edge of the receiving graph\n  * `index` (any type): any expression, the key at which to remove the element from the container\n  * `key` (any type): any expression, the key at which to remove the element from the container\n  * `node` (any type): Indicates that the item to remove should be considered as a node of the receiving graph\n  * `vertex` (any type):  \n \t\n#### Definition\n\nAllows the agent to remove an element from a container (a list, matrix, map...).\n\n#### Usages\n\n* This statement should be used in the following ways, depending on the kind of container used and the expected action on it:\n\n```\nremove expr from: expr_container;\nremove index: expr from: expr_container;\nremove key: expr from: expr_container;\nremove all: expr from: expr_container;\n```\n\n\n* In the case of list, the facet `item:` is used to remove the first occurence of a given expression, whereas `all` is used to remove all the occurrences of the given expression.\n\n```\nlist<int> removeList <- [3,2,1,2,3];\nremove 2 from: removeList; \t// removeList equals [3,1,2,3]\nremove 3 all: true from: removeList; \t// removeList equals [1,2]\nremove index: 1 from: removeList; \t// removeList equals [1]\n```\n\n\n* In the case of map, the facet `key:` is used to remove the pair identified by the given key.\n\n```\nmap<string,int> removeMap <- [\"x\"::5, \"y\"::7, \"z\"::7];\nremove key: \"x\" from: removeMap; \t// removeMap equals [\"y\"::7, \"z\"::7]\nremove 7 all: true from: removeMap; \t// removeMap equals map([])\n```\n\n\n* In addition, a map a be managed as a list with pair key as index. Given that, facets item:, all: and index: can be used in the same way:\n\n```\nmap<string,int> removeMapList <- [\"x\"::5, \"y\"::7, \"z\"::7, \"t\"::5];\nremove 7 from: removeMapList; \t// removeMapList equals [\"x\"::5, \"z\"::7, \"t\"::5]\nremove [5,7] all: true from: removeMapList; \t// removeMapList equals [\"t\"::5]\nremove index: \"t\" from: removeMapList; \t// removeMapList equals map([])\n```\n\n\n* In the case of a graph, both edges and nodes can be removes using node: and edge facets. If a node is removed, all edges to and from this node are also removed.\n\n```\ngraph removeGraph <- as_edge_graph([{1,2}::{3,4},{3,4}::{5,6}]);\nremove node: {1,2} from: removeGraph;\nremove node(1,2) from: removeGraph;\nlist var <- removeGraph.vertices; \t// var equals [{3,4},{5,6}]\nlist var <- removeGraph.edges; \t// var equals [polyline({3,4}::{5,6})]\nremove edge: {3,4}::{5,6} from: removeGraph;\nremove edge({3,4},{5,6}) from: removeGraph;\nlist var <- removeGraph.vertices; \t// var equals [{3,4},{5,6}]\nlist var <- removeGraph.edges; \t// var equals []\n```\n\n\n* In the case of an agent or a shape, `remove` allows to remove an attribute from the attributes map of the receiver. However, for agents, it will only remove attributes that have been added dynamically, not the ones defined in the species or in its built-in parent.\n\n```\nglobal {\n   init {\n      create speciesRemove;\n      speciesRemove sR <- speciesRemove(0); \t// sR.a now equals 100\n      remove key:\"a\" from: sR; \t// sR.a now equals nil\n   }\n}\n\nspecies speciesRemove {\n   int a <- 100; \n}\n```\n\n\n* This statement can not be used on *matrix*.    \n* See also: [add](#add), [put](#put), \n\n#### Embedments\n* The `remove` statement is of type: **Single statement**\n* The `remove` statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, \n* The `remove` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_return)\n### return \n#### Facets \n\n  * `value` (any type), (omissible) : an expression that is returned \n \t\n#### Definition\n\nAllows to immediately stop and tell which value to return from the evaluation of the surrounding action or top-level statement (reflex, init, etc.). Usually used within the declaration of an action. For more details about actions, see the following [Section161 section].\n\n#### Usages\n\n* Example:\n\n```\nstring foo {\n     return \"foo\";\n}\n\nreflex {\n    string foo_result <- foo(); \t// foos_result is now equals to \"foo\"\n}\n```\n\n\n* In the specific case one wants an agent to ask another agent to execute a statement with a return, it can be done similarly to:\n\n```\n// In Species A:\nstring foo_different {\n     return \"foo_not_same\";\n}\n/// ....\n// In Species B:\nreflex writing {\n    string temp <- some_agent_A.foo_different []; \t// temp is now equals to \"foo_not_same\" \n}\n```\n\n\n\n#### Embedments\n* The `return` statement is of type: **Single statement**\n* The `return` statement can be embedded into: action, Behavior, Sequence of statements or action, \n* The `return` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_rule)\n### rule \n#### Facets \n\n  * `name` (an identifier), (omissible) : The name of the rule\n  * `belief` (546704): The mandatory belief\n  * `desire` (546704): The mandatory desire\n  * `emotion` (546706): The mandatory emotion\n  * `new_belief` (546704): The belief that will be added\n  * `new_beliefs` (list): The belief that will be added\n  * `new_desire` (546704): The desire that will be added\n  * `new_desires` (list): The desire that will be added\n  * `new_emotion` (546706): The emotion that will be added\n  * `new_emotions` (list): The emotion that will be added\n  * `new_uncertainties` (list): The uncertainty that will be added\n  * `new_uncertainty` (546704): The uncertainty that will be added\n  * `parallel` (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.\n  * `priority` (any type in [float, int]): The priority of the predicate added as a desire\n  * `remove_belief` (546704): The belief that will be removed\n  * `remove_beliefs` (list): The belief that will be removed\n  * `remove_desire` (546704): The desire that will be removed\n  * `remove_desires` (list): The desire that will be removed\n  * `remove_emotion` (546706): The emotion that will be removed\n  * `remove_emotions` (list): The emotion that will be removed\n  * `remove_intention` (546704): The intention that will be removed\n  * `remove_uncertainties` (list): The uncertainty that will be removed\n  * `remove_uncertainty` (546704): The uncertainty that will be removed\n  * `threshold` (float): Threshold linked to the emotion.\n  * `uncertainty` (546704): The mandatory uncertainty\n  * `when` (boolean):  \n \t\n#### Definition\n\nenables to add a desire or a belief or to remove a belief, a desire or an intention if the agent gets the belief or/and desire or/and condition mentioned.\n\n#### Usages\n\n* Other examples of use: \n```\nrule belief: new_predicate(\"test\") when: flip(0.5) new_desire: new_predicate(\"test\")\n``` \n  \n\n#### Embedments\n* The `rule` statement is of type: **Single statement**\n* The `rule` statement can be embedded into: Species, Model, \n* The `rule` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_run)\n### run \n#### Facets \n  \n  * **`name`** (string), (omissible) :   \n  * **`of`** (string): \n  * `core` (int): \n  * `end_cycle` (int): \n  * `seed` (int): \n  * `with_output` (map): \n  * `with_param` (map): \n\n#### Embedments\n* The `run` statement is of type: **Sequence of statements or action**\n* The `run` statement can be embedded into: Behavior, Single statement, Species, Model, \n* The `run` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_save)\n### save \n#### Facets \n\n  * `data` (any type), (omissible) : any expression, that will be saved in the file\n  * `attributes` (map): Allows to specify the attributes of a shape file (or other files that accept attributes). The keys of the map are the names of the attributes that will be present in the file, the values are whatever expression neeeded to define their value\n  * `crs` (any type): the name of the projection, e.g. crs:\"EPSG:4326\" or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id): http://spatialreference.org\n  * `header` (boolean): an expression that evaluates to a boolean, specifying whether the save will write a header if the file does not exist\n  * `rewrite` (boolean): an expression that evaluates to a boolean, specifying whether the save will ecrase the file or append data at the end of it. Default is true\n  * `to` (string): an expression that evaluates to an string, the path to the file\n  * `type` (an identifier), takes values in: {shp, text, csv, asc, geotiff, image}: an expression that evaluates to an string, the type of the output file (it can be only \"shp\", \"asc\", \"geotiff\", \"image\", \"text\" or \"csv\")\n  * `with` (map): Allows to define the attributes of a shape file. Keys of the map are the attributes of agents to save, values are the names of attributes in the shape file \n \t\n#### Definition\n\nAllows to save data in a file. The type of file can be \"shp\", \"asc\", \"geotiff\", \"text\" or \"csv\".\n\n#### Usages\n\n* Its simple syntax is:\n\n```\nsave data to: output_file type: a_type_file;\n```\n\n\n* To save data in a text file:\n\n```\nsave (string(cycle) + \"->\"  + name + \":\" + location) to: \"save_data.txt\" type: \"text\";\n```\n\n\n* To save the values of some attributes of the current agent in csv file:\n\n```\nsave [name, location, host] to: \"save_data.csv\" type: \"csv\";\n```\n\n\n* To save the values of all attributes of all the agents of a species into a csv (with optional attributes):\n\n```\nsave species_of(self) to: \"save_csvfile.csv\" type: \"csv\" header: false;\n```\n\n\n* To save the geometries of all the agents of a species into a shapefile (with optional attributes):\n\n```\nsave species_of(self) to: \"save_shapefile.shp\" type: \"shp\" with: [name::\"nameAgent\", location::\"locationAgent\"] crs: \"EPSG:4326\";\n```\n\n\n* To save the grid_value attributes of all the cells of a grid into an ESRI ASCII Raster file:\n\n```\nsave grid to: \"save_grid.asc\" type: \"asc\";\n```\n\n\n* To save the grid_value attributes of all the cells of a grid into geotiff:\n\n```\nsave grid to: \"save_grid.tif\" type: \"geotiff\";\n```\n\n\n* To save the grid_value attributes of all the cells of a grid into png (with a worldfile):\n\n```\nsave grid to: \"save_grid.png\" type: \"image\";\n```\n\n\n* The save statement can be use in an init block, a reflex, an action or in a user command. Do not use it in experiments.\n\n#### Embedments\n* The `save` statement is of type: **Single statement**\n* The `save` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `save` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_save_batch)\n### save_batch \n#### Facets \n  \n  * **`to`** (a label): \n  * `data` (any type), (omissible) : \n  * `rewrite` (boolean): \n\n#### Embedments\n* The `save_batch` statement is of type: **Batch method**\n* The `save_batch` statement can be embedded into: Experiment, \n* The `save_batch` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_set)\n### set \n#### Facets \n  \n  * **`name`** (any type), (omissible) : the name of an existing variable or attribute to be modified  \n  * **`value`** (any type): the value to affect to the variable or attribute \n \t\n#### Definition\n\nAllows to assign a value to the variable or attribute specified\n\n#### Usages\n\n\n#### Embedments\n* The `set` statement is of type: **Single statement**\n* The `set` statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, \n* The `set` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_setup)\n### setup \n#### Facets \n \n \t\n#### Definition\n\nThe setup statement is used to define the set of instructions that will be executed before every [#test test].\n\n#### Usages\n\n* As every test should be independent from the others, the setup will mainly contain initialization of variables that will be used in each test.\n\n```\nspecies Tester {\n    int val_to_test;\n\n    setup {\n        val_to_test <- 0;\n    }\n\n    test t1 {\n       // [set of instructions, including asserts]\n    }\n}\n```\n\n    \n* See also: [test](#test), [assert](#assert), \n\n#### Embedments\n* The `setup` statement is of type: **Sequence of statements or action**\n* The `setup` statement can be embedded into: Species, Experiment, Model, \n* The `setup` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_simulate)\n### simulate \n#### Facets \n  \n  * **`comodel`** (file), (omissible) : \n  * `repeat` (int): \n  * `reset` (boolean): \n  * `share` (list): \n  * `until` (boolean): \n  * `with_experiment` (string): \n  * `with_input` (map): \n  * `with_output` (map):  \n \t\n#### Definition\n\nAllows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. It obeys the following syntax, where the target attribute denotes the receiver agent(s):\n\n#### Usages\n\n* Other examples of use: \n```\nask receiver_agent(s) {\n     // [statements]\n}\n``` \n  \n\n#### Embedments\n* The `simulate` statement is of type: **Single statement**\n* The `simulate` statement can be embedded into: chart, Experiment, Species, Behavior, Sequence of statements or action, \n* The `simulate` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_socialize)\n### socialize \n#### Facets \n\n  * `name` (an identifier), (omissible) : the identifier of the socialize statement\n  * `agent` (agent): the agent value of the created social link\n  * `dominance` (float): the dominance value of the created social link\n  * `familiarity` (float): the familiarity value of the created social link\n  * `liking` (float): the appreciation value of the created social link\n  * `solidarity` (float): the solidarity value of the created social link\n  * `when` (boolean): A boolean value to socialize only with a certain condition \n \t\n#### Definition\n\nenables to directly add a social link from a perceived agent.\n\n#### Usages\n\n* Other examples of use: \n```\nsocialize;\n``` \n  \n\n#### Embedments\n* The `socialize` statement is of type: **Single statement**\n* The `socialize` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `socialize` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_solve)\n### solve \n#### Facets \n  \n  * **`equation`** (an identifier), (omissible) : the equation system identifier to be numerically solved\n  * `cycle_length` (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1)\n  * `discretizing_step` (int): number of discrete between 2 steps of simulation (default value: 0)\n  * `integrated_times` (list): time interval inside integration process\n  * `integrated_values` (list): list of variables's value inside integration process\n  * `max_step` (float): maximal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value\n  * `method` (an identifier), takes values in: {Euler, ThreeEighthes, Midpoint, Gill, Luther, rk4, dp853, AdamsBashforth, AdamsMoulton, DormandPrince54, GraggBulirschStoer, HighamHall54}: integrate method (can be only \"Euler\", \"ThreeEighthes\", \"Midpoint\", \"Gill\", \"Luther\", \"rk4\" or \"dp853\", \"AdamsBashforth\", \"AdamsMoulton\", \"DormandPrince54\", \"GraggBulirschStoer\",  \"HighamHall54\") (default value: \"rk4\")\n  * `min_step` (float): minimal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value\n  * `scalAbsoluteTolerance` (float): allowed absolute error (used with dp853 method only)\n  * `scalRelativeTolerance` (float): allowed relative error (used with dp853 method only)\n  * `step` (float): integration step, use with most integrator methods (default value: 1)\n  * `time_final` (float): target time for the integration (can be set to a value smaller than t0 for backward integration)\n  * `time_initial` (float): initial time \n \t\n#### Definition\n\nSolves all equations which matched the given name, with all systems of agents that should solved simultaneously.\n\n#### Usages\n\n* Other examples of use: \n```\nsolve SIR method: \"rk4\" step:0.001;\n``` \n  \n\n#### Embedments\n* The `solve` statement is of type: **Single statement**\n* The `solve` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `solve` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_species)\n### species \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : the identifier of the species\n  * `cell_height` (float): (grid only), the height of the cells of the grid\n  * `cell_width` (float): (grid only), the width of the cells of the grid\n  * `compile` (boolean): \n  * `control` (22): defines the architecture of the species (e.g. fsm...)\n  * `edge_species` (species): In the case of a species defining a graph topology for its instances (nodes of the graph), specifies the species to use for representing the edges\n  * `file` (file): (grid only), a bitmap file that will be loaded at runtime so that the value of each pixel  can be assigned to the attribute 'grid_value'\n  * `frequency` (int): The execution frequency of the species (default value: 1). For instance, if frequency is set to 10, the population of agents will be executed only every 10 cycles.\n  * `height` (int): (grid only),  the height of the grid (in terms of agent number)\n  * `mirrors` (any type in [list, species]): The species this species is mirroring. The population of this current species will be dependent of that of the species mirrored (i.e. agents creation and death are entirely taken in charge by GAMA with respect to the demographics of the species mirrored). In addition, this species is provided with an attribute called 'target', which allows each agent to know which agent of the mirrored species it is representing.\n  * `neighbors` (int): (grid only), the chosen neighborhood (4, 6 or 8)\n  * `neighbours` (int): (grid only), the chosen neighborhood (4, 6 or 8)\n  * `parallel` (any type in [boolean, int]): (experimental) setting this facet to 'true' will allow this species to use concurrency when scheduling its agents; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet has a default set in the preferences (Under Performances > Concurrency)\n  * `parent` (species): the parent class (inheritance)\n  * `schedules` (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. For instance, 'species a schedules: (10 among a)' will result in a population that schedules only 10 of its own agents every cycle. 'species b schedules: []' will prevent the agents of 'b' to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining 'global schedules: [] {...} species b schedules: []; species c schedules: b + world; ' allows to simulate a model where the agents of b are scheduled first, followed by the world, without even having to create an instance of c.\n  * `skills` (list): The list of skills that will be made available to the instances of this species. Each new skill provides attributes and actions that will be added to the ones defined in this species\n  * `topology` (topology): The topology of the population of agents defined by this species. In case of nested species, it can for example be the shape of the macro-agent. In case of grid or graph species, the topology is automatically computed and cannot be redefined\n  * `torus` (boolean): is the topology toric (defaut: false). Needs to be defined on the global species.\n  * `use_individual_shapes` (boolean): (grid only),(true by default). Allows to specify whether or not the agents of the grid will have distinct geometries. If set to false, they will all have simpler proxy geometries\n  * `use_neighbors_cache` (boolean): (grid only),(true by default). Allows to turn on or off the use of the neighbors cache used for grids. Note that if a diffusion of variable occurs, GAMA will emit a warning and automatically switch to a caching version\n  * `use_regular_agents` (boolean): (grid only),(true by default). Allows to specify if the agents of the grid are regular agents (like those of any other species) or minimal ones (which can't have sub-populations, can't inherit from a regular species, etc.)\n  * `width` (int): (grid only), the width of the grid (in terms of agent number) \n \t\n#### Definition\n\nThe species statement allows modelers to define new species in the model. `global` and `grid` are speciel cases of species: `global` being the definition of the global agent (which has automatically one instance, world) and `grid` being a species with a grid topology.\n\n#### Usages\n\n* Here is an example of a species definition with a FSM architecture and the additional skill moving:\n\n```\nspecies ant skills: [moving] control: fsm {\n```\n\n\n* In the case of a species aiming at mirroring another one:\n\n```\nspecies node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent {\n```\n\n\n* The definition of the single grid of a model will automatically create gridwidth x gridheight agents:\n\n```\ngrid ant_grid width: gridwidth height: gridheight file: grid_file neighbors: 8 use_regular_agents: false { \n```\n\n\n* Using a file to initialize the grid can replace width/height facets:\n\n```\ngrid ant_grid file: grid_file neighbors: 8 use_regular_agents: false { \n```\n\n\n\n#### Embedments\n* The `species` statement is of type: **Species**\n* The `species` statement can be embedded into: Model, Environment, Species, \n* The `species` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_state)\n### state \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : the identifier of the state\n  * `final` (boolean): specifies whether the state is a final one (i.e. there is no transition from this state to another state) (default value= false)\n  * `initial` (boolean): specifies whether the state is the initial one (default value = false) \n \t\n#### Definition\n\nA state, like a reflex, can contains several statements that can be executed at each time step by the agent.\n\n#### Usages\n\n* Here is an exemple integrating 2 states and the statements in the FSM architecture:\n\n```\n\tstate s_init initial: true {\n\t\tenter { write \"Enter in\" + state; }\n\t\t\twrite \"Enter in\" + state;\n\t\t}\n\n\t\twrite state;\n\n\t\ttransition to: s1 when: (cycle > 2) {\n\t\t\twrite \"transition s_init -> s1\";\n\t\t}\n\n\t\texit {\n\t\t\twrite \"EXIT from \"+state;\n\t\t}\n\t}\n\tstate s1 {\n\n\tenter {write 'Enter in '+state;}\n\n\twrite state;\n\n\texit {write 'EXIT from '+state;}\n}\n```\n\n    \n* See also: [enter](#enter), [exit](#exit), [transition](#transition), \n\n#### Embedments\n* The `state` statement is of type: **Behavior**\n* The `state` statement can be embedded into: fsm, Species, Experiment, Model, \n* The `state` statement embeds statements: [enter](#enter),  [exit](#exit),  \n\n----\n\n[//]: # (keyword|statement_status)\n### status \n#### Facets \n  \n  * **`message`** (any type), (omissible) : Allows to display a necessarily short message in the status box in the upper left corner. No formatting characters (carriage returns, tabs, or Unicode characters) should be used, but a background color can be specified. The message will remain in place until it is replaced by another one or by nil, in which case the standard status (number of cycles) will be displayed again\n  * `color` (rgb):  \n \t\n#### Definition\n\nThe statement makes the agent output an arbitrary message in the status box.\n\n#### Usages\n\n* Outputting a message\n\n```\nstatus ('This is my status ' + self) color: #yellow;\n```\n\n\n\n#### Embedments\n* The `status` statement is of type: **Single statement**\n* The `status` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `status` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_switch)\n### switch \n#### Facets \n  \n  * **`value`** (any type), (omissible) : an expression \n \t\n#### Definition\n\nThe \"switch... match\" statement is a powerful replacement for imbricated \"if ... else ...\" constructs. All the blocks that match are executed in the order they are defined. The block prefixed by default is executed only if none have matched (otherwise it is not).\n\n#### Usages\n\n* The prototypical syntax is as follows:\n\n```\nswitch an_expression {\n        match value1 {...}\n        match_one [value1, value2, value3] {...}\n        match_between [value1, value2] {...}\n        default {...}\n}\n```\n\n\n* Example:\n\n```\nswitch 3 {\n   match 1 {write \"Match 1\"; }\n   match 2 {write \"Match 2\"; }\n   match 3 {write \"Match 3\"; }\n   match_one [4,4,6,3,7]  {write \"Match one_of\"; }\n   match_between [2, 4] {write \"Match between\"; }\n   default {write \"Match Default\"; }\n}\n```\n\n    \n* See also: [match](#match), [default](#default), [if](#if), \n\n#### Embedments\n* The `switch` statement is of type: **Sequence of statements or action**\n* The `switch` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `switch` statement embeds statements: [default](#default),  [match](#match),  \n\n----\n\n[//]: # (keyword|statement_tabu)\n### tabu \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : \n  * `aggregation` (a label), takes values in: {min, max}: the agregation method\n  * `iter_max` (int): number of iterations\n  * `maximize` (float): the value the algorithm tries to maximize\n  * `minimize` (float): the value the algorithm tries to minimize\n  * `tabu_list_size` (int): size of the tabu list \n \t\n#### Definition\n\nThis algorithm is an implementation of the Tabu Search algorithm. See the wikipedia article and [batch161 the batch dedicated page].\n\n#### Usages\n\n* As other batch methods, the basic syntax of the tabu statement uses `method tabu` instead of the expected `tabu name: id` : \n\n```\nmethod tabu [facet: value];\n```\n\n\n* For example: \n\n```\nmethod tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered;\n```\n\n\n\n#### Embedments\n* The `tabu` statement is of type: **Batch method**\n* The `tabu` statement can be embedded into: Experiment, \n* The `tabu` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_task)\n### task \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : the identifier of the task  \n  * **`weight`** (float): the priority level of the task \n \t\n#### Definition\n\nAs reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.\n\n#### Usages\n\n\n#### Embedments\n* The `task` statement is of type: **Behavior**\n* The `task` statement can be embedded into: weighted_tasks, sorted_tasks, probabilistic_tasks, Species, Experiment, Model, \n* The `task` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_test)\n### test \n#### Facets \n\n  * `name` (an identifier), (omissible) : identifier of the test \n \t\n#### Definition\n\nThe test statement allows modeler to define a set of assertions that will be tested. Before the execution of the embedded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue (if GAMA is configured in the preferences that the program does not stop at the first exception).\n\n#### Usages\n\n* An example of use:\n\n```\nspecies Tester {\n    // set of attributes that will be used in test\n\n    setup {\n        // [set of instructions... in particular initializations]\n    }\n\n    test t1 {\n       // [set of instructions, including asserts]\n    }\n}\n```\n\n    \n* See also: [setup](#setup), [assert](#assert), \n\n#### Embedments\n* The `test` statement is of type: **Behavior**\n* The `test` statement can be embedded into: Species, Experiment, Model, \n* The `test` statement embeds statements: [assert](#assert),  \n\n----\n\n[//]: # (keyword|statement_trace)\n### trace \n#### Facets \n \n \t\n#### Definition\n\nAll the statements executed in the trace statement are displayed in the console.\n\n#### Usages\n\n\n#### Embedments\n* The `trace` statement is of type: **Sequence of statements or action**\n* The `trace` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `trace` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_transition)\n### transition \n#### Facets \n  \n  * **`to`** (an identifier): the identifier of the next state\n  * `when` (boolean), (omissible) : a condition to be fulfilled to have a transition to another given state \n \t\n#### Definition\n\nIn an FSM architecture, `transition` specifies the next state of the life cycle. The transition occurs when the condition is fulfilled. The embedded statements are executed when the transition is triggered.\n\n#### Usages\n\n* In the following example, the transition is executed when after 2 steps:\n\n```\n\tstate s_init initial: true {\n\t\twrite state;\n\t\ttransition to: s1 when: (cycle > 2) {\n\t\t\twrite \"transition s_init -> s1\";\n\t\t}\n\t}\n```\n\n    \n* See also: [enter](#enter), [state](#state), [exit](#exit), \n\n#### Embedments\n* The `transition` statement is of type: **Sequence of statements or action**\n* The `transition` statement can be embedded into: Sequence of statements or action, Behavior, \n* The `transition` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_unconscious_contagion)\n### unconscious_contagion \n#### Facets \n  \n  * **`emotion`** (546706): the emotion that will be copied with the contagion\n  * `name` (an identifier), (omissible) : the identifier of the unconscious contagion\n  * `charisma` (float): The charisma value of the perceived agent (between 0 and 1)\n  * `receptivity` (float): The receptivity value of the current agent (between 0 and 1)\n  * `threshold` (float): The threshold value to make the contagion\n  * `when` (boolean): A boolean value to get the emotion only with a certain condition \n \t\n#### Definition\n\nenables to directly copy an emotion presents in the perceived specie.\n\n#### Usages\n\n* Other examples of use: \n```\nunconscious_contagion emotion:fearConfirmed; \nunconscious_contagion emotion:fearConfirmed charisma: 0.5 receptivity: 0.5;\n``` \n  \n\n#### Embedments\n* The `unconscious_contagion` statement is of type: **Single statement**\n* The `unconscious_contagion` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `unconscious_contagion` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_user_command)\n### user_command \n#### Facets \n  \n  * **`name`** (a label), (omissible) : the identifier of the user_command\n  * `action` (26): the identifier of the action to be executed. This action should be accessible in the context in which the user_command is defined (an experiment, the global section or a species). A special case is allowed to maintain the compatibility with older versions of GAMA, when the user_command is declared in an experiment and the action is declared in 'global'. In that case, all the simulations managed by the experiment will run the action in response to the user executing the command\n  * `color` (rgb): The color of the button to display\n  * `continue` (boolean): Whether or not the button, when clicked, should dismiss the user panel it is defined in. Has no effect in other contexts (menu, parameters, inspectors)\n  * `when` (boolean): the condition that should be fulfilled (in addition to the user clicking it) in order to execute this action\n  * `with` (map): the map of the parameters::values required by the action \n \t\n#### Definition\n\nAnywhere in the global block, in a species or in an (GUI) experiment, user_command statements allows to either call directly an existing action (with or without arguments) or to be followed by a block that describes what to do when this command is run.\n\n#### Usages\n\n* The general syntax is for example:\n\n```\nuser_command kill_myself action: some_action with: [arg1::val1, arg2::val2, ...];\n```\n\n    \n* See also: [user_init](#user_init), [user_panel](#user_panel), [user_input](#user_input), \n\n#### Embedments\n* The `user_command` statement is of type: **Sequence of statements or action**\n* The `user_command` statement can be embedded into: user_panel, Species, Experiment, Model, \n* The `user_command` statement embeds statements: [user_input](#user_input),  \n\n----\n\n[//]: # (keyword|statement_user_init)\n### user_init \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : The name of the panel\n  * `initial` (boolean): Whether or not this panel will be the initial one \n \t\n#### Definition\n\nUsed in the user control architecture, user_init is executed only once when the agent is created. It opens a special panel (if it contains user_commands statements). It is the equivalent to the init block in the basic agent architecture.\n\n#### Usages\n    \n* See also: [user_command](#user_command), [user_init](#user_init), [user_input](#user_input), \n\n#### Embedments\n* The `user_init` statement is of type: **Behavior**\n* The `user_init` statement can be embedded into: Species, Experiment, Model, \n* The `user_init` statement embeds statements: [user_panel](#user_panel),  \n\n----\n\n[//]: # (keyword|statement_user_input)\n### user_input \n#### Facets \n  \n  * **`returns`** (a new identifier): a new local variable containing the value given by the user\n  * `name` (a label), (omissible) : the displayed name\n  * `among` (list): the set of acceptable values for the variable\n  * `init` (any type): the init value\n  * `max` (float): the maximum value\n  * `min` (float): the minimum value\n  * `slider` (boolean): Whether to display a slider or not when applicable\n  * `type` (a datatype identifier): the variable type \n \t\n#### Definition\n\nIt allows to let the user define the value of a variable.\n\n#### Usages\n\n* Other examples of use: \n```\nuser_panel \"Advanced Control\" {\n\tuser_input \"Location\" returns: loc type: point <- {0,0};\n\tcreate cells number: 10 with: [location::loc];\n}\n``` \n      \n* See also: [user_command](#user_command), [user_init](#user_init), [user_panel](#user_panel), \n\n#### Embedments\n* The `user_input` statement is of type: **Single statement**\n* The `user_input` statement can be embedded into: user_command, \n* The `user_input` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_user_panel)\n### user_panel \n#### Facets \n  \n  * **`name`** (an identifier), (omissible) : The name of the panel\n  * `initial` (boolean): Whether or not this panel will be the initial one \n \t\n#### Definition\n\nIt is the basic behavior of the user control architecture (it is similar to state for the FSM architecture). This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have a enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel.\n\n#### Usages\n\n* The general syntax is for example:\n\n```\nuser_panel default initial: true {\n\tuser_input 'Number' returns: number type: int <- 10;\n\task (number among list(cells)){ do die; }\n\ttransition to: \"Advanced Control\" when: every (10);\n}\n\nuser_panel \"Advanced Control\" {\n\tuser_input \"Location\" returns: loc type: point <- {0,0};\n\tcreate cells number: 10 with: [location::loc];\n}\n```\n\n    \n* See also: [user_command](#user_command), [user_init](#user_init), [user_input](#user_input), \n\n#### Embedments\n* The `user_panel` statement is of type: **Behavior**\n* The `user_panel` statement can be embedded into: fsm, user_first, user_last, user_init, user_only, Species, Experiment, Model, \n* The `user_panel` statement embeds statements: [user_command](#user_command),  \n\n----\n\n[//]: # (keyword|statement_using)\n### using \n#### Facets \n  \n  * **`topology`** (topology), (omissible) : the topology \n \t\n#### Definition\n\n`using` is a statement that allows to set the topology to use by its sub-statements. They can gather it by asking the scope to provide it.\n\n#### Usages\n\n* All the spatial operations are topology-dependent (e.g. neighbors are not the same in a continuous and in a grid topology). So `using` statement allows modelers to specify the topology in which the spatial operation will be computed.\n\n```\nfloat dist <- 0.0;\nusing topology(grid_ant) {\n\td (self.location distance_to target.location);\n}\n```\n\n\n\n#### Embedments\n* The `using` statement is of type: **Sequence of statements or action**\n* The `using` statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, \n* The `using` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_Variable_container)\n### Variable_container \n#### Facets \n  \n  * **`name`** (a new identifier), (omissible) : The name of the attribute\n  * `category` (a label): Soon to be deprecated. Declare the parameter in an experiment instead\n  * `const` (boolean): Indicates whether this attribute can be subsequently modified or not\n  * `fill_with` (any type): \n  * `function` (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:' and 'update:'\n  * `index` (a datatype identifier): \n  * `init` (any type): The initial value of the attribute\n  * `of` (a datatype identifier): \n  * `on_change` (any type): Provides a block of statements that will be executed whenever the value of the attribute changes\n  * `parameter` (a label): Soon to be deprecated. Declare the parameter in an experiment instead\n  * `size` (any type in [int, point]): \n  * `type` (a datatype identifier): \n  * `update` (any type): An expression that will be evaluated each cycle to compute a new value for the attribute\n  * `value` (any type):  \n \t\n#### Definition\n\nAllows to declare an attribute of a species or an experiment\n\n#### Usages\n\n\n#### Embedments\n* The `Variable_container` statement is of type: **Variable (container)**\n* The `Variable_container` statement can be embedded into: Species, Experiment, Model, \n* The `Variable_container` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_Variable_number)\n### Variable_number \n#### Facets \n  \n  * **`name`** (a new identifier), (omissible) : The name of the attribute\n  * `among` (list): A list of constant values among which the attribute can take its value\n  * `category` (a label): Soon to be deprecated. Declare the parameter in an experiment instead\n  * `const` (boolean): Indicates whether this attribute can be subsequently modified or not\n  * `function` (any type in [int, float]): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:' and 'update:'\n  * `init` (any type in [int, float]): The initial value of the attribute\n  * `max` (any type in [int, float]): The maximum value this attribute can take.\n  * `min` (any type in [int, float]): The minimum value this attribute can take\n  * `on_change` (any type): Provides a block of statements that will be executed whenever the value of the attribute changes\n  * `parameter` (a label): Soon to be deprecated. Declare the parameter in an experiment instead\n  * `step` (int): \n  * `type` (a datatype identifier): The type of the attribute, either 'int' or 'float'\n  * `update` (any type in [int, float]): An expression that will be evaluated each cycle to compute a new value for the attribute\n  * `value` (any type in [int, float]):  \n \t\n#### Definition\n\nAllows to declare an attribute of a species or experiment\n\n#### Usages\n\n\n#### Embedments\n* The `Variable_number` statement is of type: **Variable (number)**\n* The `Variable_number` statement can be embedded into: Species, Experiment, Model, \n* The `Variable_number` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_Variable_regular)\n### Variable_regular \n#### Facets \n  \n  * **`name`** (a new identifier), (omissible) : The name of the attribute\n  * `among` (list): A list of constant values among which the attribute can take its value\n  * `category` (a label): Soon to be deprecated. Declare the parameter in an experiment instead\n  * `const` (boolean): Indicates whether this attribute can be subsequently modified or not\n  * `function` (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:' and 'update:'\n  * `index` (a datatype identifier): The type of the index used to retrieve elements if the type of the attribute is a container type\n  * `init` (any type): The initial value of the attribute\n  * `of` (a datatype identifier): The type of the elements contained in the type of this attribute if it is a container type\n  * `on_change` (any type): Provides a block of statements that will be executed whenever the value of the attribute changes\n  * `parameter` (a label): Soon to be deprecated. Declare the parameter in an experiment instead\n  * `type` (a datatype identifier): The type of this attribute. Can be combined with facets 'of' and 'index' to describe container types\n  * `update` (any type): An expression that will be evaluated each cycle to compute a new value for the attribute\n  * `value` (any type):  \n \t\n#### Definition\n\nAllows to declare an attribute of a species or an experiment\n\n#### Usages\n\n\n#### Embedments\n* The `Variable_regular` statement is of type: **Variable (regular)**\n* The `Variable_regular` statement can be embedded into: Species, Experiment, Model, \n* The `Variable_regular` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_warn)\n### warn \n#### Facets \n  \n  * **`message`** (string), (omissible) : the message to display as a warning. \n \t\n#### Definition\n\nThe statement makes the agent output an arbitrary message in the error view as a warning.\n\n#### Usages\n\n* Emmitting a warning\n\n```\nwarn 'This is a warning from ' + self;\n```\n\n\n\n#### Embedments\n* The `warn` statement is of type: **Single statement**\n* The `warn` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `warn` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_write)\n### write \n#### Facets \n  \n  * **`message`** (any type), (omissible) : the message to display. Modelers can add some formatting characters to the message (carriage returns, tabs, or Unicode characters), which will be used accordingly in the console.\n  * `color` (rgb): The color with wich the message will be displayed. Note that different simulations will have different (default) colors to use for this purpose if this facet is not specified \n \t\n#### Definition\n\nThe statement makes the agent output an arbitrary message in the console.\n\n#### Usages\n\n* Outputting a message\n\n```\nwrite 'This is a message from ' + self;\n```\n\n\n\n#### Embedments\n* The `write` statement is of type: **Single statement**\n* The `write` statement can be embedded into: Behavior, Sequence of statements or action, Layer, \n* The `write` statement embeds statements: ","url":"wiki/Statements.md"},"UnitsAndConstants.md":{"title":" Units and constants","content":"# Units and constants\n \t\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Introduction\nUnits can be used to qualify the values of numeric variables. By default, unqualified values are considered as:\n* meters for distances, lengths...\n* seconds for durations\n* cubic meters for volumes\n* kilograms for masses \n\nSo, an expression like:\n```\nfloat foo <- 1;\n```\n\nwill be considered as 1 meter if `foo` is a distance, or 1 second if it is a duration, or 1 meter/second if it is a speed. If one wants to specify the unit, it can be done very simply by adding the unit symbol (`°` or `#`) followed by an unit name after the numeric value, like:\n\n```\nfloat foo <- 1 °centimeter;\n```\n\nor\n\n```\nfloat foo <- 1 #centimeter;\n```\n\nIn that case, the numeric value of `foo` will be automatically translated to 0.01 (meter). It is recommended to always use float as the type of the variables that might be qualified by units (otherwise, for example in the previous case, they might be truncated to 0). \nSeveral units names are allowed as qualifiers of numeric variables. \nThese units represent the basic metric and US units. Composed and derived units (like velocity, acceleration, special volumes or surfaces) can be obtained by combining these units using the `*` and `/` operators. For instance:\n```\nfloat one_kmh <- 1 °km / °h const: true;\nfloat one_millisecond <-1 °sec / 1000;\nfloat one_cubic_inch <- 1 °sqin * 1 °inch;\n... etc ...\n```\n\n\n## Table of Contents\n<wiki:toc max_depth=\"3\" />\n\n\t\n\t\t\n----\n\n## Constants\n\n[//]: # (keyword|constant_#e)\n* **`#e`**, value= 2.718281828459045, Comment: The e constant\n\n[//]: # (keyword|constant_#infinity)\n* **`#infinity`**, value= Infinity, Comment: A constant holding the positive infinity of type (Java Double.POSITIVE_INFINITY)\n\n[//]: # (keyword|constant_#max_float)\n* **`#max_float`**, value= 1.7976931348623157E308, Comment: A constant holding the largest positive finite value of type float (Java Double.MAX_VALUE)\n\n[//]: # (keyword|constant_#max_int)\n* **`#max_int`**, value= 2.147483647E9, Comment: A constant holding the maximum value an int can have (Java Integer.MAX_VALUE)\n\n[//]: # (keyword|constant_#min_float)\n* **`#min_float`**, value= 4.9E-324, Comment: A constant holding the smallest positive nonzero value of type float (Java Double.MIN_VALUE)\n\n[//]: # (keyword|constant_#min_int)\n* **`#min_int`**, value= -2.147483648E9, Comment: A constant holding the minimum value an int can have (Java Integer.MIN_VALUE)\n\n[//]: # (keyword|constant_#nan)\n* **`#nan`**, value= NaN, Comment: A constant holding a Not-a-Number (NaN) value of type float (Java Double.POSITIVE_INFINITY)\n\n[//]: # (keyword|constant_#pi)\n* **`#pi`**, value= 3.141592653589793, Comment: The PI constant\n\n[//]: # (keyword|constant_#to_deg)\n* **`#to_deg`**, value= 57.29577951308232, Comment: A constant holding the value to convert radians into degrees\n\n[//]: # (keyword|constant_#to_rad)\n* **`#to_rad`**, value= 0.017453292519943295, Comment: A constant holding the value to convert degrees into radians\n\t\t\n----\n\n## Graphics units\n\n[//]: # (keyword|constant_#bold)\n* **`#bold`**, value= 1, Comment: This constant allows to build a font with a bold face. Can be combined with #italic\n\n[//]: # (keyword|constant_#camera_location)\n* **`#camera_location`**, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current position of the camera as a point\n\n[//]: # (keyword|constant_#camera_orientation)\n* **`#camera_orientation`**, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current orientation of the camera as a point\n\n[//]: # (keyword|constant_#camera_target)\n* **`#camera_target`**, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current target of the camera as a point\n\n[//]: # (keyword|constant_#display_height)\n* **`#display_height`**, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics...\n\n[//]: # (keyword|constant_#display_width)\n* **`#display_width`**, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics...\n\n[//]: # (keyword|constant_#flat)\n* **`#flat`**, value= 2, Comment: This constant represents a flat line buffer end cap style\n\n[//]: # (keyword|constant_#horizontal)\n* **`#horizontal`**, value= 3, Comment: This constant represents a layout where all display views are aligned horizontally\n\n[//]: # (keyword|constant_#italic)\n* **`#italic`**, value= 2, Comment: This constant allows to build a font with an italic face. Can be combined with #bold\n\n[//]: # (keyword|constant_#none)\n* **`#none`**, value= 0, Comment: This constant represents the absence of a predefined layout\n\n[//]: # (keyword|constant_#pixels)\n* **`#pixels`** (#px), value= 1.0, Comment: This unit, only available when running aspects or declaring displays,  returns a dynamic value instead of a fixed one. px (or pixels), returns the value of one pixel on the current view in terms of model units.\n\n[//]: # (keyword|constant_#plain)\n* **`#plain`**, value= 0, Comment: This constant allows to build a font with a plain face\n\n[//]: # (keyword|constant_#round)\n* **`#round`**, value= 1, Comment: This constant represents a round line buffer end cap style\n\n[//]: # (keyword|constant_#split)\n* **`#split`**, value= 2, Comment: This constant represents a layout where all display views are split in a grid-like structure\n\n[//]: # (keyword|constant_#square)\n* **`#square`**, value= 3, Comment: This constant represents a square line buffer end cap style\n\n[//]: # (keyword|constant_#stack)\n* **`#stack`**, value= 1, Comment: This constant represents a layout where all display views are stacked\n\n[//]: # (keyword|constant_#user_location)\n* **`#user_location`**, value= No Default Value, Comment: This unit contains in permanence the location of the mouse on the display in which it is situated. The latest location is provided when it is out of a display\n\n[//]: # (keyword|constant_#vertical)\n* **`#vertical`**, value= 4, Comment: This constant represents a layout where all display views are aligned vertically\n\n[//]: # (keyword|constant_#zoom)\n* **`#zoom`**, value= 1.0, Comment: This unit, only available when running aspects or declaring displays, returns the current zoom level of the display as a positive float, where 1.0 represent the neutral zoom (100%)\n\t\t\n----\n\n## Length units\n\n[//]: # (keyword|constant_#cm)\n* **`#cm`** (#centimeter,#centimeters), value= 0.009999999776482582, Comment: centimeter unit\n\n[//]: # (keyword|constant_#dm)\n* **`#dm`** (#decimeter,#decimeters), value= 0.10000000149011612, Comment: decimeter unit\n\n[//]: # (keyword|constant_#foot)\n* **`#foot`** (#feet,#ft), value= 0.3047999931871891, Comment: foot unit\n\n[//]: # (keyword|constant_#inch)\n* **`#inch`** (#inches), value= 0.025399999432265757, Comment: inch unit\n\n[//]: # (keyword|constant_#km)\n* **`#km`** (#kilometer,#kilometers), value= 1000.0, Comment: kilometer unit\n\n[//]: # (keyword|constant_#m)\n* **`#m`** (#meter,#meters), value= 1.0, Comment: meter: the length basic unit\n\n[//]: # (keyword|constant_#mile)\n* **`#mile`** (#miles), value= 1609.344, Comment: mile unit\n\n[//]: # (keyword|constant_#mm)\n* **`#mm`** (#milimeter,#milimeters), value= 9.999999776482583E-4, Comment: millimeter unit\n\n[//]: # (keyword|constant_#yard)\n* **`#yard`** (#yards), value= 0.9144, Comment: yard unit\n\t\t\n----\n\n## Surface units\n\n[//]: # (keyword|constant_#m2)\n* **`#m2`**, value= 1.0, Comment: square meter: the basic unit for surfaces\n\n[//]: # (keyword|constant_#sqft)\n* **`#sqft`** (#square_foot,#square_feet), value= 0.09290303584691051, Comment: square foot unit\n\n[//]: # (keyword|constant_#sqin)\n* **`#sqin`** (#square_inch,#square_inches), value= 6.451599711591008E-4, Comment: square inch unit\n\n[//]: # (keyword|constant_#sqmi)\n* **`#sqmi`** (#square_mile,#square_miles), value= 2589988.110336, Comment: square mile unit\n\t\t\n----\n\n## Time units\n\n[//]: # (keyword|constant_#custom)\n* **`#custom`**, value= CUSTOM, Comment: custom: a custom date/time pattern that can be defined in the preferences of GAMA and reused in models\n\n[//]: # (keyword|constant_#cycle)\n* **`#cycle`** (#cycles), value= 1, Comment: cycle: the discrete measure of time in the simulation. Used to force a temporal expression to be expressed in terms of cycles rather than seconds\n\n[//]: # (keyword|constant_#day)\n* **`#day`** (#days), value= 86400.0, Comment: day time unit: defines an exact duration of 24 hours\n\n[//]: # (keyword|constant_#epoch)\n* **`#epoch`**, value= No Default Value, Comment: The epoch default starting date as defined by the ISO format (1970-01-01T00:00Z)\n\n[//]: # (keyword|constant_#h)\n* **`#h`** (#hour,#hours), value= 3600.0, Comment: hour time unit: defines an exact duration of 60 minutes\n\n[//]: # (keyword|constant_#iso_local)\n* **`#iso_local`**, value= ISO_LOCAL_DATE_TIME, Comment: iso_local: the standard ISO 8601 output / parsing format for local dates (i.e. with no time-zone information)\n\n[//]: # (keyword|constant_#iso_offset)\n* **`#iso_offset`**, value= ISO_OFFSET_DATE_TIME, Comment: iso_offset: the standard ISO 8601 output / parsing format for dates with a time offset\n\n[//]: # (keyword|constant_#iso_zoned)\n* **`#iso_zoned`**, value= ISO_ZONED_DATE_TIME, Comment: iso_zoned: the standard ISO 8601 output / parsing format for dates with a time zone\n\n[//]: # (keyword|constant_#minute)\n* **`#minute`** (#minutes,#mn), value= 60.0, Comment: minute time unit: defined an exact duration of 60 seconds\n\n[//]: # (keyword|constant_#month)\n* **`#month`** (#months), value= 2592000.0, Comment: month time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.\n\n[//]: # (keyword|constant_#msec)\n* **`#msec`** (#millisecond,#milliseconds,#ms), value= 0.001, Comment: millisecond time unit: defines an exact duration of 0.001 second\n\n[//]: # (keyword|constant_#now)\n* **`#now`**, value= 1.0, Comment: This value represents the current date\n\n[//]: # (keyword|constant_#sec)\n* **`#sec`** (#second,#seconds,#s), value= 1.0, Comment: second: the time basic unit, with a fixed value of 1. All other durations are expressed with respect to it\n\n[//]: # (keyword|constant_#week)\n* **`#week`** (#weeks), value= 604800.0, Comment: week time unit: defines an exact duration of  7 days\n\n[//]: # (keyword|constant_#year)\n* **`#year`** (#years,#y), value= 3.1104E7, Comment: year time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.\n\t\t\n----\n\n## Volume units\n\n[//]: # (keyword|constant_#cl)\n* **`#cl`** (#centiliter,#centiliters), value= 1.0E-5, Comment: centiliter unit\n\n[//]: # (keyword|constant_#dl)\n* **`#dl`** (#deciliter,#deciliters), value= 1.0E-4, Comment: deciliter unit\n\n[//]: # (keyword|constant_#hl)\n* **`#hl`** (#hectoliter,#hectoliters), value= 0.1, Comment: hectoliter unit\n\n[//]: # (keyword|constant_#l)\n* **`#l`** (#liter,#liters,#dm3), value= 0.001, Comment: liter unit\n\n[//]: # (keyword|constant_#m3)\n* **`#m3`**, value= 1.0, Comment: cube meter: the basic unit for volumes\n\t\t\n----\n\n## Weight units\n\n[//]: # (keyword|constant_#gram)\n* **`#gram`** (#grams), value= 0.001, Comment: gram unit\n\n[//]: # (keyword|constant_#kg)\n* **`#kg`** (#kilo,#kilogram,#kilos), value= 1.0, Comment: second: the basic unit for weights\n\n[//]: # (keyword|constant_#longton)\n* **`#longton`** (#lton), value= 1016.0469088000001, Comment: short ton unit\n\n[//]: # (keyword|constant_#ounce)\n* **`#ounce`** (#oz,#ounces), value= 0.028349523125, Comment: ounce unit\n\n[//]: # (keyword|constant_#pound)\n* **`#pound`** (#lb,#pounds,#lbm), value= 0.45359237, Comment: pound unit\n\n[//]: # (keyword|constant_#shortton)\n* **`#shortton`** (#ston), value= 907.18474, Comment: short ton unit\n\n[//]: # (keyword|constant_#stone)\n* **`#stone`** (#st), value= 6.35029318, Comment: stone unit\n\n[//]: # (keyword|constant_#ton)\n* **`#ton`** (#tons), value= 1000.0, Comment: ton unit\n\n\n----\n\n## Colors\n\nIn addition to the previous units, GAML provides a direct access to the 147 named colors defined in CSS (see http://www.cssportal.com/css3-color-names/). E.g,\n```\nrgb my_color <- °teal;\n```\n\n\n[//]: # (keyword|constant_#aliceblue)\n* **`#aliceblue`**, value= r=240, g=248, b=255, alpha=1\n\n[//]: # (keyword|constant_#antiquewhite)\n* **`#antiquewhite`**, value= r=250, g=235, b=215, alpha=1\n\n[//]: # (keyword|constant_#aqua)\n* **`#aqua`**, value= r=0, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#aquamarine)\n* **`#aquamarine`**, value= r=127, g=255, b=212, alpha=1\n\n[//]: # (keyword|constant_#azure)\n* **`#azure`**, value= r=240, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#beige)\n* **`#beige`**, value= r=245, g=245, b=220, alpha=1\n\n[//]: # (keyword|constant_#bisque)\n* **`#bisque`**, value= r=255, g=228, b=196, alpha=1\n\n[//]: # (keyword|constant_#black)\n* **`#black`**, value= r=0, g=0, b=0, alpha=1\n\n[//]: # (keyword|constant_#blanchedalmond)\n* **`#blanchedalmond`**, value= r=255, g=235, b=205, alpha=1\n\n[//]: # (keyword|constant_#blue)\n* **`#blue`**, value= r=0, g=0, b=255, alpha=1\n\n[//]: # (keyword|constant_#blueviolet)\n* **`#blueviolet`**, value= r=138, g=43, b=226, alpha=1\n\n[//]: # (keyword|constant_#brown)\n* **`#brown`**, value= r=165, g=42, b=42, alpha=1\n\n[//]: # (keyword|constant_#burlywood)\n* **`#burlywood`**, value= r=222, g=184, b=135, alpha=1\n\n[//]: # (keyword|constant_#cadetblue)\n* **`#cadetblue`**, value= r=95, g=158, b=160, alpha=1\n\n[//]: # (keyword|constant_#chartreuse)\n* **`#chartreuse`**, value= r=127, g=255, b=0, alpha=1\n\n[//]: # (keyword|constant_#chocolate)\n* **`#chocolate`**, value= r=210, g=105, b=30, alpha=1\n\n[//]: # (keyword|constant_#coral)\n* **`#coral`**, value= r=255, g=127, b=80, alpha=1\n\n[//]: # (keyword|constant_#cornflowerblue)\n* **`#cornflowerblue`**, value= r=100, g=149, b=237, alpha=1\n\n[//]: # (keyword|constant_#cornsilk)\n* **`#cornsilk`**, value= r=255, g=248, b=220, alpha=1\n\n[//]: # (keyword|constant_#crimson)\n* **`#crimson`**, value= r=220, g=20, b=60, alpha=1\n\n[//]: # (keyword|constant_#cyan)\n* **`#cyan`**, value= r=0, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#darkblue)\n* **`#darkblue`**, value= r=0, g=0, b=139, alpha=1\n\n[//]: # (keyword|constant_#darkcyan)\n* **`#darkcyan`**, value= r=0, g=139, b=139, alpha=1\n\n[//]: # (keyword|constant_#darkgoldenrod)\n* **`#darkgoldenrod`**, value= r=184, g=134, b=11, alpha=1\n\n[//]: # (keyword|constant_#darkgray)\n* **`#darkgray`**, value= r=169, g=169, b=169, alpha=1\n\n[//]: # (keyword|constant_#darkgreen)\n* **`#darkgreen`**, value= r=0, g=100, b=0, alpha=1\n\n[//]: # (keyword|constant_#darkgrey)\n* **`#darkgrey`**, value= r=169, g=169, b=169, alpha=1\n\n[//]: # (keyword|constant_#darkkhaki)\n* **`#darkkhaki`**, value= r=189, g=183, b=107, alpha=1\n\n[//]: # (keyword|constant_#darkmagenta)\n* **`#darkmagenta`**, value= r=139, g=0, b=139, alpha=1\n\n[//]: # (keyword|constant_#darkolivegreen)\n* **`#darkolivegreen`**, value= r=85, g=107, b=47, alpha=1\n\n[//]: # (keyword|constant_#darkorange)\n* **`#darkorange`**, value= r=255, g=140, b=0, alpha=1\n\n[//]: # (keyword|constant_#darkorchid)\n* **`#darkorchid`**, value= r=153, g=50, b=204, alpha=1\n\n[//]: # (keyword|constant_#darkred)\n* **`#darkred`**, value= r=139, g=0, b=0, alpha=1\n\n[//]: # (keyword|constant_#darksalmon)\n* **`#darksalmon`**, value= r=233, g=150, b=122, alpha=1\n\n[//]: # (keyword|constant_#darkseagreen)\n* **`#darkseagreen`**, value= r=143, g=188, b=143, alpha=1\n\n[//]: # (keyword|constant_#darkslateblue)\n* **`#darkslateblue`**, value= r=72, g=61, b=139, alpha=1\n\n[//]: # (keyword|constant_#darkslategray)\n* **`#darkslategray`**, value= r=47, g=79, b=79, alpha=1\n\n[//]: # (keyword|constant_#darkslategrey)\n* **`#darkslategrey`**, value= r=47, g=79, b=79, alpha=1\n\n[//]: # (keyword|constant_#darkturquoise)\n* **`#darkturquoise`**, value= r=0, g=206, b=209, alpha=1\n\n[//]: # (keyword|constant_#darkviolet)\n* **`#darkviolet`**, value= r=148, g=0, b=211, alpha=1\n\n[//]: # (keyword|constant_#deeppink)\n* **`#deeppink`**, value= r=255, g=20, b=147, alpha=1\n\n[//]: # (keyword|constant_#deepskyblue)\n* **`#deepskyblue`**, value= r=0, g=191, b=255, alpha=1\n\n[//]: # (keyword|constant_#dimgray)\n* **`#dimgray`**, value= r=105, g=105, b=105, alpha=1\n\n[//]: # (keyword|constant_#dimgrey)\n* **`#dimgrey`**, value= r=105, g=105, b=105, alpha=1\n\n[//]: # (keyword|constant_#dodgerblue)\n* **`#dodgerblue`**, value= r=30, g=144, b=255, alpha=1\n\n[//]: # (keyword|constant_#firebrick)\n* **`#firebrick`**, value= r=178, g=34, b=34, alpha=1\n\n[//]: # (keyword|constant_#floralwhite)\n* **`#floralwhite`**, value= r=255, g=250, b=240, alpha=1\n\n[//]: # (keyword|constant_#forestgreen)\n* **`#forestgreen`**, value= r=34, g=139, b=34, alpha=1\n\n[//]: # (keyword|constant_#fuchsia)\n* **`#fuchsia`**, value= r=255, g=0, b=255, alpha=1\n\n[//]: # (keyword|constant_#gainsboro)\n* **`#gainsboro`**, value= r=220, g=220, b=220, alpha=1\n\n[//]: # (keyword|constant_#ghostwhite)\n* **`#ghostwhite`**, value= r=248, g=248, b=255, alpha=1\n\n[//]: # (keyword|constant_#gold)\n* **`#gold`**, value= r=255, g=215, b=0, alpha=1\n\n[//]: # (keyword|constant_#goldenrod)\n* **`#goldenrod`**, value= r=218, g=165, b=32, alpha=1\n\n[//]: # (keyword|constant_#gray)\n* **`#gray`**, value= r=128, g=128, b=128, alpha=1\n\n[//]: # (keyword|constant_#green)\n* **`#green`**, value= r=0, g=128, b=0, alpha=1\n\n[//]: # (keyword|constant_#greenyellow)\n* **`#greenyellow`**, value= r=173, g=255, b=47, alpha=1\n\n[//]: # (keyword|constant_#grey)\n* **`#grey`**, value= r=128, g=128, b=128, alpha=1\n\n[//]: # (keyword|constant_#honeydew)\n* **`#honeydew`**, value= r=240, g=255, b=240, alpha=1\n\n[//]: # (keyword|constant_#hotpink)\n* **`#hotpink`**, value= r=255, g=105, b=180, alpha=1\n\n[//]: # (keyword|constant_#indianred)\n* **`#indianred`**, value= r=205, g=92, b=92, alpha=1\n\n[//]: # (keyword|constant_#indigo)\n* **`#indigo`**, value= r=75, g=0, b=130, alpha=1\n\n[//]: # (keyword|constant_#ivory)\n* **`#ivory`**, value= r=255, g=255, b=240, alpha=1\n\n[//]: # (keyword|constant_#khaki)\n* **`#khaki`**, value= r=240, g=230, b=140, alpha=1\n\n[//]: # (keyword|constant_#lavender)\n* **`#lavender`**, value= r=230, g=230, b=250, alpha=1\n\n[//]: # (keyword|constant_#lavenderblush)\n* **`#lavenderblush`**, value= r=255, g=240, b=245, alpha=1\n\n[//]: # (keyword|constant_#lawngreen)\n* **`#lawngreen`**, value= r=124, g=252, b=0, alpha=1\n\n[//]: # (keyword|constant_#lemonchiffon)\n* **`#lemonchiffon`**, value= r=255, g=250, b=205, alpha=1\n\n[//]: # (keyword|constant_#lightblue)\n* **`#lightblue`**, value= r=173, g=216, b=230, alpha=1\n\n[//]: # (keyword|constant_#lightcoral)\n* **`#lightcoral`**, value= r=240, g=128, b=128, alpha=1\n\n[//]: # (keyword|constant_#lightcyan)\n* **`#lightcyan`**, value= r=224, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#lightgoldenrodyellow)\n* **`#lightgoldenrodyellow`**, value= r=250, g=250, b=210, alpha=1\n\n[//]: # (keyword|constant_#lightgray)\n* **`#lightgray`**, value= r=211, g=211, b=211, alpha=1\n\n[//]: # (keyword|constant_#lightgreen)\n* **`#lightgreen`**, value= r=144, g=238, b=144, alpha=1\n\n[//]: # (keyword|constant_#lightgrey)\n* **`#lightgrey`**, value= r=211, g=211, b=211, alpha=1\n\n[//]: # (keyword|constant_#lightpink)\n* **`#lightpink`**, value= r=255, g=182, b=193, alpha=1\n\n[//]: # (keyword|constant_#lightsalmon)\n* **`#lightsalmon`**, value= r=255, g=160, b=122, alpha=1\n\n[//]: # (keyword|constant_#lightseagreen)\n* **`#lightseagreen`**, value= r=32, g=178, b=170, alpha=1\n\n[//]: # (keyword|constant_#lightskyblue)\n* **`#lightskyblue`**, value= r=135, g=206, b=250, alpha=1\n\n[//]: # (keyword|constant_#lightslategray)\n* **`#lightslategray`**, value= r=119, g=136, b=153, alpha=1\n\n[//]: # (keyword|constant_#lightslategrey)\n* **`#lightslategrey`**, value= r=119, g=136, b=153, alpha=1\n\n[//]: # (keyword|constant_#lightsteelblue)\n* **`#lightsteelblue`**, value= r=176, g=196, b=222, alpha=1\n\n[//]: # (keyword|constant_#lightyellow)\n* **`#lightyellow`**, value= r=255, g=255, b=224, alpha=1\n\n[//]: # (keyword|constant_#lime)\n* **`#lime`**, value= r=0, g=255, b=0, alpha=1\n\n[//]: # (keyword|constant_#limegreen)\n* **`#limegreen`**, value= r=50, g=205, b=50, alpha=1\n\n[//]: # (keyword|constant_#linen)\n* **`#linen`**, value= r=250, g=240, b=230, alpha=1\n\n[//]: # (keyword|constant_#magenta)\n* **`#magenta`**, value= r=255, g=0, b=255, alpha=1\n\n[//]: # (keyword|constant_#maroon)\n* **`#maroon`**, value= r=128, g=0, b=0, alpha=1\n\n[//]: # (keyword|constant_#mediumaquamarine)\n* **`#mediumaquamarine`**, value= r=102, g=205, b=170, alpha=1\n\n[//]: # (keyword|constant_#mediumblue)\n* **`#mediumblue`**, value= r=0, g=0, b=205, alpha=1\n\n[//]: # (keyword|constant_#mediumorchid)\n* **`#mediumorchid`**, value= r=186, g=85, b=211, alpha=1\n\n[//]: # (keyword|constant_#mediumpurple)\n* **`#mediumpurple`**, value= r=147, g=112, b=219, alpha=1\n\n[//]: # (keyword|constant_#mediumseagreen)\n* **`#mediumseagreen`**, value= r=60, g=179, b=113, alpha=1\n\n[//]: # (keyword|constant_#mediumslateblue)\n* **`#mediumslateblue`**, value= r=123, g=104, b=238, alpha=1\n\n[//]: # (keyword|constant_#mediumspringgreen)\n* **`#mediumspringgreen`**, value= r=0, g=250, b=154, alpha=1\n\n[//]: # (keyword|constant_#mediumturquoise)\n* **`#mediumturquoise`**, value= r=72, g=209, b=204, alpha=1\n\n[//]: # (keyword|constant_#mediumvioletred)\n* **`#mediumvioletred`**, value= r=199, g=21, b=133, alpha=1\n\n[//]: # (keyword|constant_#midnightblue)\n* **`#midnightblue`**, value= r=25, g=25, b=112, alpha=1\n\n[//]: # (keyword|constant_#mintcream)\n* **`#mintcream`**, value= r=245, g=255, b=250, alpha=1\n\n[//]: # (keyword|constant_#mistyrose)\n* **`#mistyrose`**, value= r=255, g=228, b=225, alpha=1\n\n[//]: # (keyword|constant_#moccasin)\n* **`#moccasin`**, value= r=255, g=228, b=181, alpha=1\n\n[//]: # (keyword|constant_#navajowhite)\n* **`#navajowhite`**, value= r=255, g=222, b=173, alpha=1\n\n[//]: # (keyword|constant_#navy)\n* **`#navy`**, value= r=0, g=0, b=128, alpha=1\n\n[//]: # (keyword|constant_#oldlace)\n* **`#oldlace`**, value= r=253, g=245, b=230, alpha=1\n\n[//]: # (keyword|constant_#olive)\n* **`#olive`**, value= r=128, g=128, b=0, alpha=1\n\n[//]: # (keyword|constant_#olivedrab)\n* **`#olivedrab`**, value= r=107, g=142, b=35, alpha=1\n\n[//]: # (keyword|constant_#orange)\n* **`#orange`**, value= r=255, g=165, b=0, alpha=1\n\n[//]: # (keyword|constant_#orangered)\n* **`#orangered`**, value= r=255, g=69, b=0, alpha=1\n\n[//]: # (keyword|constant_#orchid)\n* **`#orchid`**, value= r=218, g=112, b=214, alpha=1\n\n[//]: # (keyword|constant_#palegoldenrod)\n* **`#palegoldenrod`**, value= r=238, g=232, b=170, alpha=1\n\n[//]: # (keyword|constant_#palegreen)\n* **`#palegreen`**, value= r=152, g=251, b=152, alpha=1\n\n[//]: # (keyword|constant_#paleturquoise)\n* **`#paleturquoise`**, value= r=175, g=238, b=238, alpha=1\n\n[//]: # (keyword|constant_#palevioletred)\n* **`#palevioletred`**, value= r=219, g=112, b=147, alpha=1\n\n[//]: # (keyword|constant_#papayawhip)\n* **`#papayawhip`**, value= r=255, g=239, b=213, alpha=1\n\n[//]: # (keyword|constant_#peachpuff)\n* **`#peachpuff`**, value= r=255, g=218, b=185, alpha=1\n\n[//]: # (keyword|constant_#peru)\n* **`#peru`**, value= r=205, g=133, b=63, alpha=1\n\n[//]: # (keyword|constant_#pink)\n* **`#pink`**, value= r=255, g=192, b=203, alpha=1\n\n[//]: # (keyword|constant_#plum)\n* **`#plum`**, value= r=221, g=160, b=221, alpha=1\n\n[//]: # (keyword|constant_#powderblue)\n* **`#powderblue`**, value= r=176, g=224, b=230, alpha=1\n\n[//]: # (keyword|constant_#purple)\n* **`#purple`**, value= r=128, g=0, b=128, alpha=1\n\n[//]: # (keyword|constant_#red)\n* **`#red`**, value= r=255, g=0, b=0, alpha=1\n\n[//]: # (keyword|constant_#rosybrown)\n* **`#rosybrown`**, value= r=188, g=143, b=143, alpha=1\n\n[//]: # (keyword|constant_#royalblue)\n* **`#royalblue`**, value= r=65, g=105, b=225, alpha=1\n\n[//]: # (keyword|constant_#saddlebrown)\n* **`#saddlebrown`**, value= r=139, g=69, b=19, alpha=1\n\n[//]: # (keyword|constant_#salmon)\n* **`#salmon`**, value= r=250, g=128, b=114, alpha=1\n\n[//]: # (keyword|constant_#sandybrown)\n* **`#sandybrown`**, value= r=244, g=164, b=96, alpha=1\n\n[//]: # (keyword|constant_#seagreen)\n* **`#seagreen`**, value= r=46, g=139, b=87, alpha=1\n\n[//]: # (keyword|constant_#seashell)\n* **`#seashell`**, value= r=255, g=245, b=238, alpha=1\n\n[//]: # (keyword|constant_#sienna)\n* **`#sienna`**, value= r=160, g=82, b=45, alpha=1\n\n[//]: # (keyword|constant_#silver)\n* **`#silver`**, value= r=192, g=192, b=192, alpha=1\n\n[//]: # (keyword|constant_#skyblue)\n* **`#skyblue`**, value= r=135, g=206, b=235, alpha=1\n\n[//]: # (keyword|constant_#slateblue)\n* **`#slateblue`**, value= r=106, g=90, b=205, alpha=1\n\n[//]: # (keyword|constant_#slategray)\n* **`#slategray`**, value= r=112, g=128, b=144, alpha=1\n\n[//]: # (keyword|constant_#slategrey)\n* **`#slategrey`**, value= r=112, g=128, b=144, alpha=1\n\n[//]: # (keyword|constant_#snow)\n* **`#snow`**, value= r=255, g=250, b=250, alpha=1\n\n[//]: # (keyword|constant_#springgreen)\n* **`#springgreen`**, value= r=0, g=255, b=127, alpha=1\n\n[//]: # (keyword|constant_#steelblue)\n* **`#steelblue`**, value= r=70, g=130, b=180, alpha=1\n\n[//]: # (keyword|constant_#tan)\n* **`#tan`**, value= r=210, g=180, b=140, alpha=1\n\n[//]: # (keyword|constant_#teal)\n* **`#teal`**, value= r=0, g=128, b=128, alpha=1\n\n[//]: # (keyword|constant_#thistle)\n* **`#thistle`**, value= r=216, g=191, b=216, alpha=1\n\n[//]: # (keyword|constant_#tomato)\n* **`#tomato`**, value= r=255, g=99, b=71, alpha=1\n\n[//]: # (keyword|constant_#transparent)\n* **`#transparent`**, value= r=0, g=0, b=0, alpha=0\n\n[//]: # (keyword|constant_#turquoise)\n* **`#turquoise`**, value= r=64, g=224, b=208, alpha=1\n\n[//]: # (keyword|constant_#violet)\n* **`#violet`**, value= r=238, g=130, b=238, alpha=1\n\n[//]: # (keyword|constant_#wheat)\n* **`#wheat`**, value= r=245, g=222, b=179, alpha=1\n\n[//]: # (keyword|constant_#white)\n* **`#white`**, value= r=255, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#whitesmoke)\n* **`#whitesmoke`**, value= r=245, g=245, b=245, alpha=1\n\n[//]: # (keyword|constant_#yellow)\n* **`#yellow`**, value= r=255, g=255, b=0, alpha=1\n\n[//]: # (keyword|constant_#yellowgreen)\n* **`#yellowgreen`**, value= r=154, g=205, b=50, alpha=1","url":"wiki/UnitsAndConstants.md"},"UnitsAndConstantsPDF.md":{"title":" Units and constants","content":"# Units and constants\n \t\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Introduction\nUnits can be used to qualify the values of numeric variables. By default, unqualified values are considered as:\n* meters for distances, lengths...\n* seconds for durations\n* cubic meters for volumes\n* kilograms for masses \n\nSo, an expression like:\n```\nfloat foo <- 1;\n```\n\nwill be considered as 1 meter if `foo` is a distance, or 1 second if it is a duration, or 1 meter/second if it is a speed. If one wants to specify the unit, it can be done very simply by adding the unit symbol (`°` or `#`) followed by an unit name after the numeric value, like:\n\n```\nfloat foo <- 1 °centimeter;\n```\n\nor\n\n```\nfloat foo <- 1 #centimeter;\n```\n\nIn that case, the numeric value of `foo` will be automatically translated to 0.01 (meter). It is recommended to always use float as the type of the variables that might be qualified by units (otherwise, for example in the previous case, they might be truncated to 0). \nSeveral units names are allowed as qualifiers of numeric variables. \nThese units represent the basic metric and US units. Composed and derived units (like velocity, acceleration, special volumes or surfaces) can be obtained by combining these units using the `*` and `/` operators. For instance:\n```\nfloat one_kmh <- 1 °km / °h const: true;\nfloat one_millisecond <-1 °sec / 1000;\nfloat one_cubic_inch <- 1 °sqin * 1 °inch;\n... etc ...\n```\n\n\n## Table of Contents\n<wiki:toc max_depth=\"3\" />\n\n\t\n\t\t\n----\n\n## Constants\n\n[//]: # (keyword|constant_#e)\n* **`\\#e`**, value= 2.718281828459045, Comment: The e constant\n\n[//]: # (keyword|constant_#infinity)\n* **`\\#infinity`**, value= Infinity, Comment: A constant holding the positive infinity of type (Java Double.POSITIVE_INFINITY)\n\n[//]: # (keyword|constant_#max_float)\n* **`\\#max_float`**, value= 1.7976931348623157E308, Comment: A constant holding the largest positive finite value of type float (Java Double.MAX_VALUE)\n\n[//]: # (keyword|constant_#max_int)\n* **`\\#max_int`**, value= 2.147483647E9, Comment: A constant holding the maximum value an int can have (Java Integer.MAX_VALUE)\n\n[//]: # (keyword|constant_#min_float)\n* **`\\#min_float`**, value= 4.9E-324, Comment: A constant holding the smallest positive nonzero value of type float (Java Double.MIN_VALUE)\n\n[//]: # (keyword|constant_#min_int)\n* **`\\#min_int`**, value= -2.147483648E9, Comment: A constant holding the minimum value an int can have (Java Integer.MIN_VALUE)\n\n[//]: # (keyword|constant_#nan)\n* **`\\#nan`**, value= NaN, Comment: A constant holding a Not-a-Number (NaN) value of type float (Java Double.POSITIVE_INFINITY)\n\n[//]: # (keyword|constant_#pi)\n* **`\\#pi`**, value= 3.141592653589793, Comment: The PI constant\n\n[//]: # (keyword|constant_#to_deg)\n* **`\\#to_deg`**, value= 57.29577951308232, Comment: A constant holding the value to convert radians into degrees\n\n[//]: # (keyword|constant_#to_rad)\n* **`\\#to_rad`**, value= 0.017453292519943295, Comment: A constant holding the value to convert degrees into radians\n\t\t\n----\n\n## Graphics units\n\n[//]: # (keyword|constant_#bold)\n* **`\\#bold`**, value= 1, Comment: This constant allows to build a font with a bold face. Can be combined with #italic\n\n[//]: # (keyword|constant_#camera_location)\n* **`\\#camera_location`**, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current position of the camera as a point\n\n[//]: # (keyword|constant_#camera_orientation)\n* **`\\#camera_orientation`**, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current orientation of the camera as a point\n\n[//]: # (keyword|constant_#camera_target)\n* **`\\#camera_target`**, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current target of the camera as a point\n\n[//]: # (keyword|constant_#display_height)\n* **`\\#display_height`**, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics...\n\n[//]: # (keyword|constant_#display_width)\n* **`\\#display_width`**, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics...\n\n[//]: # (keyword|constant_#flat)\n* **`\\#flat`**, value= 2, Comment: This constant represents a flat line buffer end cap style\n\n[//]: # (keyword|constant_#horizontal)\n* **`\\#horizontal`**, value= 3, Comment: This constant represents a layout where all display views are aligned horizontally\n\n[//]: # (keyword|constant_#italic)\n* **`\\#italic`**, value= 2, Comment: This constant allows to build a font with an italic face. Can be combined with #bold\n\n[//]: # (keyword|constant_#none)\n* **`\\#none`**, value= 0, Comment: This constant represents the absence of a predefined layout\n\n[//]: # (keyword|constant_#pixels)\n* **`\\#pixels`** (#px), value= 1.0, Comment: This unit, only available when running aspects or declaring displays,  returns a dynamic value instead of a fixed one. px (or pixels), returns the value of one pixel on the current view in terms of model units.\n\n[//]: # (keyword|constant_#plain)\n* **`\\#plain`**, value= 0, Comment: This constant allows to build a font with a plain face\n\n[//]: # (keyword|constant_#round)\n* **`\\#round`**, value= 1, Comment: This constant represents a round line buffer end cap style\n\n[//]: # (keyword|constant_#split)\n* **`\\#split`**, value= 2, Comment: This constant represents a layout where all display views are split in a grid-like structure\n\n[//]: # (keyword|constant_#square)\n* **`\\#square`**, value= 3, Comment: This constant represents a square line buffer end cap style\n\n[//]: # (keyword|constant_#stack)\n* **`\\#stack`**, value= 1, Comment: This constant represents a layout where all display views are stacked\n\n[//]: # (keyword|constant_#user_location)\n* **`\\#user_location`**, value= No Default Value, Comment: This unit contains in permanence the location of the mouse on the display in which it is situated. The latest location is provided when it is out of a display\n\n[//]: # (keyword|constant_#vertical)\n* **`\\#vertical`**, value= 4, Comment: This constant represents a layout where all display views are aligned vertically\n\n[//]: # (keyword|constant_#zoom)\n* **`\\#zoom`**, value= 1.0, Comment: This unit, only available when running aspects or declaring displays, returns the current zoom level of the display as a positive float, where 1.0 represent the neutral zoom (100%)\n\t\t\n----\n\n## Length units\n\n[//]: # (keyword|constant_#cm)\n* **`\\#cm`** (#centimeter,#centimeters), value= 0.009999999776482582, Comment: centimeter unit\n\n[//]: # (keyword|constant_#dm)\n* **`\\#dm`** (#decimeter,#decimeters), value= 0.10000000149011612, Comment: decimeter unit\n\n[//]: # (keyword|constant_#foot)\n* **`\\#foot`** (#feet,#ft), value= 0.3047999931871891, Comment: foot unit\n\n[//]: # (keyword|constant_#inch)\n* **`\\#inch`** (#inches), value= 0.025399999432265757, Comment: inch unit\n\n[//]: # (keyword|constant_#km)\n* **`\\#km`** (#kilometer,#kilometers), value= 1000.0, Comment: kilometer unit\n\n[//]: # (keyword|constant_#m)\n* **`\\#m`** (#meter,#meters), value= 1.0, Comment: meter: the length basic unit\n\n[//]: # (keyword|constant_#mile)\n* **`\\#mile`** (#miles), value= 1609.344, Comment: mile unit\n\n[//]: # (keyword|constant_#mm)\n* **`\\#mm`** (#milimeter,#milimeters), value= 9.999999776482583E-4, Comment: millimeter unit\n\n[//]: # (keyword|constant_#yard)\n* **`\\#yard`** (#yards), value= 0.9144, Comment: yard unit\n\t\t\n----\n\n## Surface units\n\n[//]: # (keyword|constant_#m2)\n* **`\\#m2`**, value= 1.0, Comment: square meter: the basic unit for surfaces\n\n[//]: # (keyword|constant_#sqft)\n* **`\\#sqft`** (#square_foot,#square_feet), value= 0.09290303584691051, Comment: square foot unit\n\n[//]: # (keyword|constant_#sqin)\n* **`\\#sqin`** (#square_inch,#square_inches), value= 6.451599711591008E-4, Comment: square inch unit\n\n[//]: # (keyword|constant_#sqmi)\n* **`\\#sqmi`** (#square_mile,#square_miles), value= 2589988.110336, Comment: square mile unit\n\t\t\n----\n\n## Time units\n\n[//]: # (keyword|constant_#custom)\n* **`\\#custom`**, value= CUSTOM, Comment: custom: a custom date/time pattern that can be defined in the preferences of GAMA and reused in models\n\n[//]: # (keyword|constant_#cycle)\n* **`\\#cycle`** (#cycles), value= 1, Comment: cycle: the discrete measure of time in the simulation. Used to force a temporal expression to be expressed in terms of cycles rather than seconds\n\n[//]: # (keyword|constant_#day)\n* **`\\#day`** (#days), value= 86400.0, Comment: day time unit: defines an exact duration of 24 hours\n\n[//]: # (keyword|constant_#epoch)\n* **`\\#epoch`**, value= No Default Value, Comment: The epoch default starting date as defined by the ISO format (1970-01-01T00:00Z)\n\n[//]: # (keyword|constant_#h)\n* **`\\#h`** (#hour,#hours), value= 3600.0, Comment: hour time unit: defines an exact duration of 60 minutes\n\n[//]: # (keyword|constant_#iso_local)\n* **`\\#iso_local`**, value= ISO_LOCAL_DATE_TIME, Comment: iso_local: the standard ISO 8601 output / parsing format for local dates (i.e. with no time-zone information)\n\n[//]: # (keyword|constant_#iso_offset)\n* **`\\#iso_offset`**, value= ISO_OFFSET_DATE_TIME, Comment: iso_offset: the standard ISO 8601 output / parsing format for dates with a time offset\n\n[//]: # (keyword|constant_#iso_zoned)\n* **`\\#iso_zoned`**, value= ISO_ZONED_DATE_TIME, Comment: iso_zoned: the standard ISO 8601 output / parsing format for dates with a time zone\n\n[//]: # (keyword|constant_#minute)\n* **`\\#minute`** (#minutes,#mn), value= 60.0, Comment: minute time unit: defined an exact duration of 60 seconds\n\n[//]: # (keyword|constant_#month)\n* **`\\#month`** (#months), value= 2592000.0, Comment: month time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.\n\n[//]: # (keyword|constant_#msec)\n* **`\\#msec`** (#millisecond,#milliseconds,#ms), value= 0.001, Comment: millisecond time unit: defines an exact duration of 0.001 second\n\n[//]: # (keyword|constant_#now)\n* **`\\#now`**, value= 1.0, Comment: This value represents the current date\n\n[//]: # (keyword|constant_#sec)\n* **`\\#sec`** (#second,#seconds,#s), value= 1.0, Comment: second: the time basic unit, with a fixed value of 1. All other durations are expressed with respect to it\n\n[//]: # (keyword|constant_#week)\n* **`\\#week`** (#weeks), value= 604800.0, Comment: week time unit: defines an exact duration of  7 days\n\n[//]: # (keyword|constant_#year)\n* **`\\#year`** (#years,#y), value= 3.1104E7, Comment: year time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.\n\t\t\n----\n\n## Volume units\n\n[//]: # (keyword|constant_#cl)\n* **`\\#cl`** (#centiliter,#centiliters), value= 1.0E-5, Comment: centiliter unit\n\n[//]: # (keyword|constant_#dl)\n* **`\\#dl`** (#deciliter,#deciliters), value= 1.0E-4, Comment: deciliter unit\n\n[//]: # (keyword|constant_#hl)\n* **`\\#hl`** (#hectoliter,#hectoliters), value= 0.1, Comment: hectoliter unit\n\n[//]: # (keyword|constant_#l)\n* **`\\#l`** (#liter,#liters,#dm3), value= 0.001, Comment: liter unit\n\n[//]: # (keyword|constant_#m3)\n* **`\\#m3`**, value= 1.0, Comment: cube meter: the basic unit for volumes\n\t\t\n----\n\n## Weight units\n\n[//]: # (keyword|constant_#gram)\n* **`\\#gram`** (#grams), value= 0.001, Comment: gram unit\n\n[//]: # (keyword|constant_#kg)\n* **`\\#kg`** (#kilo,#kilogram,#kilos), value= 1.0, Comment: second: the basic unit for weights\n\n[//]: # (keyword|constant_#longton)\n* **`\\#longton`** (#lton), value= 1016.0469088000001, Comment: short ton unit\n\n[//]: # (keyword|constant_#ounce)\n* **`\\#ounce`** (#oz,#ounces), value= 0.028349523125, Comment: ounce unit\n\n[//]: # (keyword|constant_#pound)\n* **`\\#pound`** (#lb,#pounds,#lbm), value= 0.45359237, Comment: pound unit\n\n[//]: # (keyword|constant_#shortton)\n* **`\\#shortton`** (#ston), value= 907.18474, Comment: short ton unit\n\n[//]: # (keyword|constant_#stone)\n* **`\\#stone`** (#st), value= 6.35029318, Comment: stone unit\n\n[//]: # (keyword|constant_#ton)\n* **`\\#ton`** (#tons), value= 1000.0, Comment: ton unit\n\n\n----\n\n## Colors\n\nIn addition to the previous units, GAML provides a direct access to the 147 named colors defined in CSS (see http://www.cssportal.com/css3-color-names/). E.g,\n```\nrgb my_color <- °teal;\n```\n\n\n[//]: # (keyword|constant_#aliceblue)\n* **`\\#aliceblue`**, value= r=240, g=248, b=255, alpha=1\n\n[//]: # (keyword|constant_#antiquewhite)\n* **`\\#antiquewhite`**, value= r=250, g=235, b=215, alpha=1\n\n[//]: # (keyword|constant_#aqua)\n* **`\\#aqua`**, value= r=0, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#aquamarine)\n* **`\\#aquamarine`**, value= r=127, g=255, b=212, alpha=1\n\n[//]: # (keyword|constant_#azure)\n* **`\\#azure`**, value= r=240, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#beige)\n* **`\\#beige`**, value= r=245, g=245, b=220, alpha=1\n\n[//]: # (keyword|constant_#bisque)\n* **`\\#bisque`**, value= r=255, g=228, b=196, alpha=1\n\n[//]: # (keyword|constant_#black)\n* **`\\#black`**, value= r=0, g=0, b=0, alpha=1\n\n[//]: # (keyword|constant_#blanchedalmond)\n* **`\\#blanchedalmond`**, value= r=255, g=235, b=205, alpha=1\n\n[//]: # (keyword|constant_#blue)\n* **`\\#blue`**, value= r=0, g=0, b=255, alpha=1\n\n[//]: # (keyword|constant_#blueviolet)\n* **`\\#blueviolet`**, value= r=138, g=43, b=226, alpha=1\n\n[//]: # (keyword|constant_#brown)\n* **`\\#brown`**, value= r=165, g=42, b=42, alpha=1\n\n[//]: # (keyword|constant_#burlywood)\n* **`\\#burlywood`**, value= r=222, g=184, b=135, alpha=1\n\n[//]: # (keyword|constant_#cadetblue)\n* **`\\#cadetblue`**, value= r=95, g=158, b=160, alpha=1\n\n[//]: # (keyword|constant_#chartreuse)\n* **`\\#chartreuse`**, value= r=127, g=255, b=0, alpha=1\n\n[//]: # (keyword|constant_#chocolate)\n* **`\\#chocolate`**, value= r=210, g=105, b=30, alpha=1\n\n[//]: # (keyword|constant_#coral)\n* **`\\#coral`**, value= r=255, g=127, b=80, alpha=1\n\n[//]: # (keyword|constant_#cornflowerblue)\n* **`\\#cornflowerblue`**, value= r=100, g=149, b=237, alpha=1\n\n[//]: # (keyword|constant_#cornsilk)\n* **`\\#cornsilk`**, value= r=255, g=248, b=220, alpha=1\n\n[//]: # (keyword|constant_#crimson)\n* **`\\#crimson`**, value= r=220, g=20, b=60, alpha=1\n\n[//]: # (keyword|constant_#cyan)\n* **`\\#cyan`**, value= r=0, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#darkblue)\n* **`\\#darkblue`**, value= r=0, g=0, b=139, alpha=1\n\n[//]: # (keyword|constant_#darkcyan)\n* **`\\#darkcyan`**, value= r=0, g=139, b=139, alpha=1\n\n[//]: # (keyword|constant_#darkgoldenrod)\n* **`\\#darkgoldenrod`**, value= r=184, g=134, b=11, alpha=1\n\n[//]: # (keyword|constant_#darkgray)\n* **`\\#darkgray`**, value= r=169, g=169, b=169, alpha=1\n\n[//]: # (keyword|constant_#darkgreen)\n* **`\\#darkgreen`**, value= r=0, g=100, b=0, alpha=1\n\n[//]: # (keyword|constant_#darkgrey)\n* **`\\#darkgrey`**, value= r=169, g=169, b=169, alpha=1\n\n[//]: # (keyword|constant_#darkkhaki)\n* **`\\#darkkhaki`**, value= r=189, g=183, b=107, alpha=1\n\n[//]: # (keyword|constant_#darkmagenta)\n* **`\\#darkmagenta`**, value= r=139, g=0, b=139, alpha=1\n\n[//]: # (keyword|constant_#darkolivegreen)\n* **`\\#darkolivegreen`**, value= r=85, g=107, b=47, alpha=1\n\n[//]: # (keyword|constant_#darkorange)\n* **`\\#darkorange`**, value= r=255, g=140, b=0, alpha=1\n\n[//]: # (keyword|constant_#darkorchid)\n* **`\\#darkorchid`**, value= r=153, g=50, b=204, alpha=1\n\n[//]: # (keyword|constant_#darkred)\n* **`\\#darkred`**, value= r=139, g=0, b=0, alpha=1\n\n[//]: # (keyword|constant_#darksalmon)\n* **`\\#darksalmon`**, value= r=233, g=150, b=122, alpha=1\n\n[//]: # (keyword|constant_#darkseagreen)\n* **`\\#darkseagreen`**, value= r=143, g=188, b=143, alpha=1\n\n[//]: # (keyword|constant_#darkslateblue)\n* **`\\#darkslateblue`**, value= r=72, g=61, b=139, alpha=1\n\n[//]: # (keyword|constant_#darkslategray)\n* **`\\#darkslategray`**, value= r=47, g=79, b=79, alpha=1\n\n[//]: # (keyword|constant_#darkslategrey)\n* **`\\#darkslategrey`**, value= r=47, g=79, b=79, alpha=1\n\n[//]: # (keyword|constant_#darkturquoise)\n* **`\\#darkturquoise`**, value= r=0, g=206, b=209, alpha=1\n\n[//]: # (keyword|constant_#darkviolet)\n* **`\\#darkviolet`**, value= r=148, g=0, b=211, alpha=1\n\n[//]: # (keyword|constant_#deeppink)\n* **`\\#deeppink`**, value= r=255, g=20, b=147, alpha=1\n\n[//]: # (keyword|constant_#deepskyblue)\n* **`\\#deepskyblue`**, value= r=0, g=191, b=255, alpha=1\n\n[//]: # (keyword|constant_#dimgray)\n* **`\\#dimgray`**, value= r=105, g=105, b=105, alpha=1\n\n[//]: # (keyword|constant_#dimgrey)\n* **`\\#dimgrey`**, value= r=105, g=105, b=105, alpha=1\n\n[//]: # (keyword|constant_#dodgerblue)\n* **`\\#dodgerblue`**, value= r=30, g=144, b=255, alpha=1\n\n[//]: # (keyword|constant_#firebrick)\n* **`\\#firebrick`**, value= r=178, g=34, b=34, alpha=1\n\n[//]: # (keyword|constant_#floralwhite)\n* **`\\#floralwhite`**, value= r=255, g=250, b=240, alpha=1\n\n[//]: # (keyword|constant_#forestgreen)\n* **`\\#forestgreen`**, value= r=34, g=139, b=34, alpha=1\n\n[//]: # (keyword|constant_#fuchsia)\n* **`\\#fuchsia`**, value= r=255, g=0, b=255, alpha=1\n\n[//]: # (keyword|constant_#gainsboro)\n* **`\\#gainsboro`**, value= r=220, g=220, b=220, alpha=1\n\n[//]: # (keyword|constant_#ghostwhite)\n* **`\\#ghostwhite`**, value= r=248, g=248, b=255, alpha=1\n\n[//]: # (keyword|constant_#gold)\n* **`\\#gold`**, value= r=255, g=215, b=0, alpha=1\n\n[//]: # (keyword|constant_#goldenrod)\n* **`\\#goldenrod`**, value= r=218, g=165, b=32, alpha=1\n\n[//]: # (keyword|constant_#gray)\n* **`\\#gray`**, value= r=128, g=128, b=128, alpha=1\n\n[//]: # (keyword|constant_#green)\n* **`\\#green`**, value= r=0, g=128, b=0, alpha=1\n\n[//]: # (keyword|constant_#greenyellow)\n* **`\\#greenyellow`**, value= r=173, g=255, b=47, alpha=1\n\n[//]: # (keyword|constant_#grey)\n* **`\\#grey`**, value= r=128, g=128, b=128, alpha=1\n\n[//]: # (keyword|constant_#honeydew)\n* **`\\#honeydew`**, value= r=240, g=255, b=240, alpha=1\n\n[//]: # (keyword|constant_#hotpink)\n* **`\\#hotpink`**, value= r=255, g=105, b=180, alpha=1\n\n[//]: # (keyword|constant_#indianred)\n* **`\\#indianred`**, value= r=205, g=92, b=92, alpha=1\n\n[//]: # (keyword|constant_#indigo)\n* **`\\#indigo`**, value= r=75, g=0, b=130, alpha=1\n\n[//]: # (keyword|constant_#ivory)\n* **`\\#ivory`**, value= r=255, g=255, b=240, alpha=1\n\n[//]: # (keyword|constant_#khaki)\n* **`\\#khaki`**, value= r=240, g=230, b=140, alpha=1\n\n[//]: # (keyword|constant_#lavender)\n* **`\\#lavender`**, value= r=230, g=230, b=250, alpha=1\n\n[//]: # (keyword|constant_#lavenderblush)\n* **`\\#lavenderblush`**, value= r=255, g=240, b=245, alpha=1\n\n[//]: # (keyword|constant_#lawngreen)\n* **`\\#lawngreen`**, value= r=124, g=252, b=0, alpha=1\n\n[//]: # (keyword|constant_#lemonchiffon)\n* **`\\#lemonchiffon`**, value= r=255, g=250, b=205, alpha=1\n\n[//]: # (keyword|constant_#lightblue)\n* **`\\#lightblue`**, value= r=173, g=216, b=230, alpha=1\n\n[//]: # (keyword|constant_#lightcoral)\n* **`\\#lightcoral`**, value= r=240, g=128, b=128, alpha=1\n\n[//]: # (keyword|constant_#lightcyan)\n* **`\\#lightcyan`**, value= r=224, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#lightgoldenrodyellow)\n* **`\\#lightgoldenrodyellow`**, value= r=250, g=250, b=210, alpha=1\n\n[//]: # (keyword|constant_#lightgray)\n* **`\\#lightgray`**, value= r=211, g=211, b=211, alpha=1\n\n[//]: # (keyword|constant_#lightgreen)\n* **`\\#lightgreen`**, value= r=144, g=238, b=144, alpha=1\n\n[//]: # (keyword|constant_#lightgrey)\n* **`\\#lightgrey`**, value= r=211, g=211, b=211, alpha=1\n\n[//]: # (keyword|constant_#lightpink)\n* **`\\#lightpink`**, value= r=255, g=182, b=193, alpha=1\n\n[//]: # (keyword|constant_#lightsalmon)\n* **`\\#lightsalmon`**, value= r=255, g=160, b=122, alpha=1\n\n[//]: # (keyword|constant_#lightseagreen)\n* **`\\#lightseagreen`**, value= r=32, g=178, b=170, alpha=1\n\n[//]: # (keyword|constant_#lightskyblue)\n* **`\\#lightskyblue`**, value= r=135, g=206, b=250, alpha=1\n\n[//]: # (keyword|constant_#lightslategray)\n* **`\\#lightslategray`**, value= r=119, g=136, b=153, alpha=1\n\n[//]: # (keyword|constant_#lightslategrey)\n* **`\\#lightslategrey`**, value= r=119, g=136, b=153, alpha=1\n\n[//]: # (keyword|constant_#lightsteelblue)\n* **`\\#lightsteelblue`**, value= r=176, g=196, b=222, alpha=1\n\n[//]: # (keyword|constant_#lightyellow)\n* **`\\#lightyellow`**, value= r=255, g=255, b=224, alpha=1\n\n[//]: # (keyword|constant_#lime)\n* **`\\#lime`**, value= r=0, g=255, b=0, alpha=1\n\n[//]: # (keyword|constant_#limegreen)\n* **`\\#limegreen`**, value= r=50, g=205, b=50, alpha=1\n\n[//]: # (keyword|constant_#linen)\n* **`\\#linen`**, value= r=250, g=240, b=230, alpha=1\n\n[//]: # (keyword|constant_#magenta)\n* **`\\#magenta`**, value= r=255, g=0, b=255, alpha=1\n\n[//]: # (keyword|constant_#maroon)\n* **`\\#maroon`**, value= r=128, g=0, b=0, alpha=1\n\n[//]: # (keyword|constant_#mediumaquamarine)\n* **`\\#mediumaquamarine`**, value= r=102, g=205, b=170, alpha=1\n\n[//]: # (keyword|constant_#mediumblue)\n* **`\\#mediumblue`**, value= r=0, g=0, b=205, alpha=1\n\n[//]: # (keyword|constant_#mediumorchid)\n* **`\\#mediumorchid`**, value= r=186, g=85, b=211, alpha=1\n\n[//]: # (keyword|constant_#mediumpurple)\n* **`\\#mediumpurple`**, value= r=147, g=112, b=219, alpha=1\n\n[//]: # (keyword|constant_#mediumseagreen)\n* **`\\#mediumseagreen`**, value= r=60, g=179, b=113, alpha=1\n\n[//]: # (keyword|constant_#mediumslateblue)\n* **`\\#mediumslateblue`**, value= r=123, g=104, b=238, alpha=1\n\n[//]: # (keyword|constant_#mediumspringgreen)\n* **`\\#mediumspringgreen`**, value= r=0, g=250, b=154, alpha=1\n\n[//]: # (keyword|constant_#mediumturquoise)\n* **`\\#mediumturquoise`**, value= r=72, g=209, b=204, alpha=1\n\n[//]: # (keyword|constant_#mediumvioletred)\n* **`\\#mediumvioletred`**, value= r=199, g=21, b=133, alpha=1\n\n[//]: # (keyword|constant_#midnightblue)\n* **`\\#midnightblue`**, value= r=25, g=25, b=112, alpha=1\n\n[//]: # (keyword|constant_#mintcream)\n* **`\\#mintcream`**, value= r=245, g=255, b=250, alpha=1\n\n[//]: # (keyword|constant_#mistyrose)\n* **`\\#mistyrose`**, value= r=255, g=228, b=225, alpha=1\n\n[//]: # (keyword|constant_#moccasin)\n* **`\\#moccasin`**, value= r=255, g=228, b=181, alpha=1\n\n[//]: # (keyword|constant_#navajowhite)\n* **`\\#navajowhite`**, value= r=255, g=222, b=173, alpha=1\n\n[//]: # (keyword|constant_#navy)\n* **`\\#navy`**, value= r=0, g=0, b=128, alpha=1\n\n[//]: # (keyword|constant_#oldlace)\n* **`\\#oldlace`**, value= r=253, g=245, b=230, alpha=1\n\n[//]: # (keyword|constant_#olive)\n* **`\\#olive`**, value= r=128, g=128, b=0, alpha=1\n\n[//]: # (keyword|constant_#olivedrab)\n* **`\\#olivedrab`**, value= r=107, g=142, b=35, alpha=1\n\n[//]: # (keyword|constant_#orange)\n* **`\\#orange`**, value= r=255, g=165, b=0, alpha=1\n\n[//]: # (keyword|constant_#orangered)\n* **`\\#orangered`**, value= r=255, g=69, b=0, alpha=1\n\n[//]: # (keyword|constant_#orchid)\n* **`\\#orchid`**, value= r=218, g=112, b=214, alpha=1\n\n[//]: # (keyword|constant_#palegoldenrod)\n* **`\\#palegoldenrod`**, value= r=238, g=232, b=170, alpha=1\n\n[//]: # (keyword|constant_#palegreen)\n* **`\\#palegreen`**, value= r=152, g=251, b=152, alpha=1\n\n[//]: # (keyword|constant_#paleturquoise)\n* **`\\#paleturquoise`**, value= r=175, g=238, b=238, alpha=1\n\n[//]: # (keyword|constant_#palevioletred)\n* **`\\#palevioletred`**, value= r=219, g=112, b=147, alpha=1\n\n[//]: # (keyword|constant_#papayawhip)\n* **`\\#papayawhip`**, value= r=255, g=239, b=213, alpha=1\n\n[//]: # (keyword|constant_#peachpuff)\n* **`\\#peachpuff`**, value= r=255, g=218, b=185, alpha=1\n\n[//]: # (keyword|constant_#peru)\n* **`\\#peru`**, value= r=205, g=133, b=63, alpha=1\n\n[//]: # (keyword|constant_#pink)\n* **`\\#pink`**, value= r=255, g=192, b=203, alpha=1\n\n[//]: # (keyword|constant_#plum)\n* **`\\#plum`**, value= r=221, g=160, b=221, alpha=1\n\n[//]: # (keyword|constant_#powderblue)\n* **`\\#powderblue`**, value= r=176, g=224, b=230, alpha=1\n\n[//]: # (keyword|constant_#purple)\n* **`\\#purple`**, value= r=128, g=0, b=128, alpha=1\n\n[//]: # (keyword|constant_#red)\n* **`\\#red`**, value= r=255, g=0, b=0, alpha=1\n\n[//]: # (keyword|constant_#rosybrown)\n* **`\\#rosybrown`**, value= r=188, g=143, b=143, alpha=1\n\n[//]: # (keyword|constant_#royalblue)\n* **`\\#royalblue`**, value= r=65, g=105, b=225, alpha=1\n\n[//]: # (keyword|constant_#saddlebrown)\n* **`\\#saddlebrown`**, value= r=139, g=69, b=19, alpha=1\n\n[//]: # (keyword|constant_#salmon)\n* **`\\#salmon`**, value= r=250, g=128, b=114, alpha=1\n\n[//]: # (keyword|constant_#sandybrown)\n* **`\\#sandybrown`**, value= r=244, g=164, b=96, alpha=1\n\n[//]: # (keyword|constant_#seagreen)\n* **`\\#seagreen`**, value= r=46, g=139, b=87, alpha=1\n\n[//]: # (keyword|constant_#seashell)\n* **`\\#seashell`**, value= r=255, g=245, b=238, alpha=1\n\n[//]: # (keyword|constant_#sienna)\n* **`\\#sienna`**, value= r=160, g=82, b=45, alpha=1\n\n[//]: # (keyword|constant_#silver)\n* **`\\#silver`**, value= r=192, g=192, b=192, alpha=1\n\n[//]: # (keyword|constant_#skyblue)\n* **`\\#skyblue`**, value= r=135, g=206, b=235, alpha=1\n\n[//]: # (keyword|constant_#slateblue)\n* **`\\#slateblue`**, value= r=106, g=90, b=205, alpha=1\n\n[//]: # (keyword|constant_#slategray)\n* **`\\#slategray`**, value= r=112, g=128, b=144, alpha=1\n\n[//]: # (keyword|constant_#slategrey)\n* **`\\#slategrey`**, value= r=112, g=128, b=144, alpha=1\n\n[//]: # (keyword|constant_#snow)\n* **`\\#snow`**, value= r=255, g=250, b=250, alpha=1\n\n[//]: # (keyword|constant_#springgreen)\n* **`\\#springgreen`**, value= r=0, g=255, b=127, alpha=1\n\n[//]: # (keyword|constant_#steelblue)\n* **`\\#steelblue`**, value= r=70, g=130, b=180, alpha=1\n\n[//]: # (keyword|constant_#tan)\n* **`\\#tan`**, value= r=210, g=180, b=140, alpha=1\n\n[//]: # (keyword|constant_#teal)\n* **`\\#teal`**, value= r=0, g=128, b=128, alpha=1\n\n[//]: # (keyword|constant_#thistle)\n* **`\\#thistle`**, value= r=216, g=191, b=216, alpha=1\n\n[//]: # (keyword|constant_#tomato)\n* **`\\#tomato`**, value= r=255, g=99, b=71, alpha=1\n\n[//]: # (keyword|constant_#transparent)\n* **`\\#transparent`**, value= r=0, g=0, b=0, alpha=0\n\n[//]: # (keyword|constant_#turquoise)\n* **`\\#turquoise`**, value= r=64, g=224, b=208, alpha=1\n\n[//]: # (keyword|constant_#violet)\n* **`\\#violet`**, value= r=238, g=130, b=238, alpha=1\n\n[//]: # (keyword|constant_#wheat)\n* **`\\#wheat`**, value= r=245, g=222, b=179, alpha=1\n\n[//]: # (keyword|constant_#white)\n* **`\\#white`**, value= r=255, g=255, b=255, alpha=1\n\n[//]: # (keyword|constant_#whitesmoke)\n* **`\\#whitesmoke`**, value= r=245, g=245, b=245, alpha=1\n\n[//]: # (keyword|constant_#yellow)\n* **`\\#yellow`**, value= r=255, g=255, b=0, alpha=1\n\n[//]: # (keyword|constant_#yellowgreen)\n* **`\\#yellowgreen`**, value= r=154, g=205, b=50, alpha=1","url":"wiki/UnitsAndConstantsPDF.md"},"VariablesAndAttributes.md":{"title":" Variables and Attributes","content":"\n# Variables and Attributes\n\n\n\nVariables and attributes represent named data that can be used in an expression. They can be accessed depending on their _scope_:\n  * the scope of attributes declared in a species is itself, its child species and its micro-species.\n  * the scope of temporary variables is the one in which they have been declared, and all its sub-scopes.\nOutside its _scope_ of validity, an expression cannot use a variable or an attribute directly. However, attributes can be used in a remote fashion by using a dotted notation on a given agent (see [here](#Remote_Access)).\n\n\n## Table of contents \n\n* [Variables and Attributes](#variables-and-attributes)\n\t* [Direct Access](#direct-access)\n\t* [Remote Access](#remote-access)\n\n\n\n## Direct Access\nWhen an agent wants to use either one of the variables declared locally, one of the attributes declared in its species (or parent species), one of the attributes declared in the macro-species of its species, it can directly invoke its name and the compiler will do the rest (i.e. finding the variable or attribute in the right scope).\nFor instance, we can have a look at the following example:\n\n```\nspecies animal {\n   float energy <- 1000 min: 0 max: 2000 update: energy - 0.001;\n   int age_in_years <- 1 update: age_in_years + int (time / 365);\n   \n   action eat (float amount <- 0) {\n       float gain <- amount / age_in_years;\n       energy <- energy + gain;\n   }\n\n   reflex feed {\n      int food_found <- rnd(100);\n      do eat (amount: food_found); \n   }\n\n}\n```\n\n  * **Species declaration**\n> Everywhere in the species declaration, we are able to directly name and use:\n    * `time`, a global built-in variable,\n    * `energy` and `age_in_years`, the two species attributes.\n> Nevertheless, in the species declaration, but outside of the action `eat` and the reflex `feed`, we **cannot** name the variables:\n    * `amount`, the argument of `eat` action,\n    * `gain`, a local variable defined into the `eat` action,\n    * `food_found`, the local variable defined into the `feed` reflex.\n\n  * **`Eat` action declaration**\n> In the `eat` action declaration, we can directly name and use:\n    * `time`, a global built-in variable,\n    * `energy` and `age_in_years`, the two species attributes,\n    * `amount`, which is an argument to the action `eat`,\n    * `gain`, a temporary variable within the action.\n> We **cannot** name and use the variables:\n    * `food_found`, the local variable defined into the `feed` reflex.\n\n  * **`feed` reflex declaration**\n> Similarly, in the `feed` reflex declaration, we can directly name and use:\n    * `time`, a global built-in variable,\n    * `energy` and `age_in_years`, the two species variables,\n    * `food_found`, the local variable defined into the reflex.\n> But we **cannot** access to variables:\n    * `amount`, the argument of `eat` action,\n    * `gain`, a local variable defined into the `eat` action.\n\n\n\n\n\n## Remote Access\nWhen an expression needs to get access to the attribute of an agent which does not belong to its scope of execution, a special notation (similar to that used in Java) has to be used:\n\n```\nremote_agent.variable\n```\n\nwhere remote\\_agent can be the name of an agent, an expression returning an agent, self, myself or each. For instance, if we modify the previous species by giving its agents the possibility to feed another agent found in its neighbourhood, the result would be:\n\n```\nspecies animal {\n   float energy <- 1000 min: 0 max: 2000 update: energy - 0.001;\n   int age_in_years <- 1 update: age_in_years + int (time / 365);\n   action eat (float amount <- 0.0) {\n       float gain <- amount / age_in_years;\n       energy <- energy + gain;\n   }\n   action feed (animal target){\n       if (agent_to_feed != nil) and (agent_to_feed.energy < energy { // verifies that the agent exists and that it need to be fed\n            ask agent_to_feed {\n                do eat amount: myself.energy / 10; // asks the agent to eat 10% of our own energy\n            }\n            energy <- energy - (energy / 10); // reduces the energy by 10%\n       }\n   }\n   reflex {\n       animal candidates <- agents_overlapping (10 around agent.shape); gathers all the neighbours\n       agent_to_feed value: candidates with_min_of (each.energy); //grabs one agent with the lowest energy \n       do feed target: agent_to_feed; // tries to feed it\n   }\n}\n```\n\nIn this example, agent\\_to\\_feed.energy, myself.energy and each.energy show different remote accesses to the attribute energy. The dotted notation used here can be employed in assignments as well. For instance, an action allowing two agents to exchange their energy could be defined as:\n\n```\naction random_exchange {//exchanges our energy with that of the closest agent\n     animal one_agent <- agent_closest_to (self)/>\n     float temp  <-one_agent.energy; // temporary storage of the agent's energy\n     one_agent.energy <- energy; // assignment of the agent's energy with our energy\n     energy <- temp;\n}\n```","url":"wiki/VariablesAndAttributes.md"},"Diffusion-Statement-Anisotropic-Diffusion-(Simple).md":{"title":" Anisotropic diffusion (Simple)","content":"[//]: # (keyword|operator_hsb)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_diffusion)\n[//]: # (keyword|concept_matrix)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_elevation)\n# Anisotropic diffusion (Simple)\n\n\n_Author : Benoit Gaudou_\n\nThis model is used to show how to construct an anisotropic diffusion through a grid. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion.\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Anisotropic Diffusion (Simple)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel anisotropic_diffusion\n\nglobal {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(size) * 10);\n  \tcells selected_cells;\n  \t\n  \t// Declare the anisotropic matrix (diffuse to the left-upper direction)\n\tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[4/9,2/9,0/9],\n\t\t\t\t\t\t\t\t\t[2/9,1/9,0.0],\n\t\t\t\t\t\t\t\t\t[0/9,0.0,0.0]]);\n\t\n\treflex diff { \n\t\tdiffuse var: phero on: cells matrix:mat_diff;\n\t}\n\n\t// Initialize the emiter cell as the cell at the center of the word\n\tinit {\n\t\tselected_cells <- location as cells;\n\t}\n\treflex new_Value {\n\t\task selected_cells {\n\t\t\tphero <- 1.0;\n\t\t}\n\t}\n}\n\n\ngrid cells height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay a type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells elevation: true triangulation: true;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Diffusion-Statement-Anisotropic-Diffusion-(Simple).md"},"Diffusion-Statement-Anisotropic-Diffusion-(Toroidal).md":{"title":" Anisotropic diffusion (Toroidal)","content":"[//]: # (keyword|operator_hsb)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_diffusion)\n[//]: # (keyword|concept_matrix)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_elevation)\n# Anisotropic diffusion (Toroidal)\n\n\n_Author : Benoit Gaudou_\n\nThis model is used to show how to construct an anisotropic diffusion through a grid. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion, in a toroidal world.\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Anisotropic Diffusion (Toroidal)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel anisotropic_diffusion_torus\n\nglobal torus: true {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(size) * 10);\n  \tcells selected_cells;\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[4/9,2/9,0/9],\n\t\t\t\t\t\t\t\t\t[2/9,1/9,0.0],\n\t\t\t\t\t\t\t\t\t[0/9,0.0,0.0]]);\n\tinit {\n\t\tselected_cells <- location as cells;\n\t}\n\treflex new_Value {\n\t\task selected_cells{\n\t\t\tphero <- 1.0;\n\t\t}  \n\t}\n\n\treflex diff {\n\t\tdiffuse var: phero on: cells matrix: mat_diff method:dot_product;\t\n\t}\n}\n\n\ngrid cells height: size width: size  {\n\tfloat phero  <- 0.0;\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay a type: opengl {\n\t\t\tgrid cells elevation: true triangulation: true;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Diffusion-Statement-Anisotropic-Diffusion-(Toroidal).md"},"Diffusion-Statement-Anisotropic-Diffusion-(Various-Methods).md":{"title":" Anisotropic diffusion with several computation method","content":"[//]: # (keyword|operator_hsb)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_diffusion)\n[//]: # (keyword|concept_matrix)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_elevation)\n# Anisotropic diffusion with several computation method\n\n\n_Author : Benoit Gaudou_\n\nThis model is used to show two different computation methods to use diffusion : with the dot product method and with the convolution method. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion. \n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Anisotropic Diffusion (Various Methods)/convol-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Anisotropic Diffusion (Various Methods)/dot-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel diffusion_computation_method\n\nglobal{\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(size) * 10);\n  \tcells_dot selected_cells_dot;\n  \tcells_convol selected_cells_convol;\n  \t// Declare the anisotropic matrix (diffuse to the left-upper direction)\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[2/9,2/9,1/9],\n\t\t\t\t\t\t\t\t\t[2/9,1/9,0.0],\n\t\t\t\t\t\t\t\t\t[1/9,0.0,0.0]]);\n\n\t// Initialize the emiter cell as the cell at the center of the word\n\tinit {\n\t\tselected_cells_dot <- location as cells_dot;\n  \t\tselected_cells_convol <- location as cells_convol;\n\t}\n\treflex new_Value {\n\t\task(selected_cells_dot){\n\t\t\tphero <- 1.0;\n\t\t}\n\t\task(selected_cells_convol){\n\t\t\tphero <- 1.0;\n\t\t}\t\t\n\t}\n\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells_dot\" (with a dot product computation) and on \"cells_convol\" (with a convol computation). \n\t\t// The value of the diffusion will be store in the new variable \"phero\" of the cell.\n\t\tdiffuse var: phero on: cells_dot matrix: mat_diff method: \"dot_product\";\t\n\t\tdiffuse var: phero on: cells_convol matrix: mat_diff method: \"convolution\";\t\t\t\n\t}\n}\n\n\ngrid cells_dot height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// The color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\ngrid cells_convol height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// The color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay dot type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_dot elevation: true triangulation: true;\n\t\t}\n\t\tdisplay convol type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_convol elevation: true triangulation: true;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Diffusion-Statement-Anisotropic-Diffusion-(Various-Methods).md"},"Diffusion-Statement-Blend-color-in-a-cuve-(Multiple-Signals).md":{"title":" Blend color in a cuve","content":"[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_diffusion)\n[//]: # (keyword|concept_matrix)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_color)\n[//]: # (keyword|concept_elevation)\n# Blend color in a cuve\n\n\n_Author : Julien Mazars_\n\nThis model is used to show how we can diffuse several variables in the same grid. At the cycle 0, 3 different pheromons are emited in 3 of the 4 corners of the cuve (each one associated to a color). Thanks to the diffusion mechanism, all the 3 colors will blend each other. The process is accelerated by using the facet \"cycle_length\". The \"avoid_mask\" facet is used in order to have a constant sum of pheromon. \n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Blend color in a cuve (Multiple Signals)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel cycle_length\n\nglobal {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n\tint cycle_length <- 5;\n  \tgeometry shape <- envelope(square(size));\n  \tlist<cells> top_left_cells;\n  \tlist<cells> top_right_cells;\n  \tlist<cells> bot_left_cells;\n  \t// Declare the uniform matrix\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9]]);\n\n\t// Initialize the emiter cells\n\tinit {\n\t\ttop_left_cells <- list<cells>(cells where (each.grid_x < location.x\n\t\t\tand each.grid_x > cycle_length\n\t\t\tand each.grid_y < location.y\n\t\t\tand each.grid_y > cycle_length\n\t\t));\n\t\ttop_right_cells <- list<cells>(cells where (each.grid_x < size-cycle_length\n\t\t\tand each.grid_x > location.x\n\t\t\tand each.grid_y < location.y\n\t\t\tand each.grid_y > cycle_length\n\t\t));\n\t\tbot_left_cells <- list<cells>(cells where (each.grid_x < location.x\n\t\t\tand each.grid_x > cycle_length\n\t\t\tand each.grid_y < size-cycle_length\n\t\t\tand each.grid_y > location.y\n\t\t));\n\t}\n\treflex init_value when:cycle=0 {\n\t\task(top_left_cells){\n\t\t\tphero1 <- 1.0;\n\t\t}\n\t\task(top_right_cells){\n\t\t\tphero2 <- 1.0;\n\t\t}\n\t\task(bot_left_cells){\n\t\t\tphero3 <- 1.0;\n\t\t}\t\n\t}\n\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\" for each one of the pheromons. \n\t\t// In order to not loosing phero value, we apply a hand made mask (with the operator \"where\") and we turn the \"avoid_mask\" facet to true.\n\t\tlist cells_where_diffuse <- cells where (each.grid_x < size-cycle_length and each.grid_x > cycle_length and each.grid_y < size-cycle_length and each.grid_y > cycle_length);\n\t\tdiffuse var: phero1 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;\n\t\tdiffuse var: phero2 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;\n\t\tdiffuse var: phero3 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;\n\t}\n}\n\n\ngrid cells height: size width: size {\n\t// \"phero1\", \"phero2\", \"phero3\" are the variables storing the value of the diffusion\n\tfloat phero1  <- 0.0;\n\tfloat phero2  <- 0.0;\n\tfloat phero3  <- 0.0;\n\t// The color of the cell is construct using the 3 pheromons.\n\trgb color <- rgb(phero1*256,phero2*256,phero3*256) update: rgb(phero1*256,phero2*256,phero3*256);\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay a type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells elevation: (phero1+phero2+phero3)*10 triangulation: true;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Diffusion-Statement-Blend-color-in-a-cuve-(Multiple-Signals).md"},"Diffusion-Statement-Diffusion-in-a-cuve-(Cycle-length).md":{"title":" Diffusion in a cuve (Cycle length)","content":"[//]: # (keyword|operator_hsb)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_diffusion)\n[//]: # (keyword|concept_matrix)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_elevation)\n# Diffusion in a cuve (Cycle length)\n\n\n_Author : Julien Mazars_\n\nThis model is used to show how to use diffusion on a grid, and how to accelerate the process by computing several times the diffusion at each step. The cells at the center of the grid emit a pheromon at the cycle 0, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion. The \"avoid_mask\" facet is used in order to have a constant sum of pheromon. \n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Diffusion in a cuve (Cycle length)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Diffusion in a cuve (Cycle length)/quick-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel cycle_length\n\nglobal {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n\tint cycle_length <- 5;\n  \tgeometry shape <- envelope(square(size));\n  \tlist<cells> selected_cells;\n  \tlist<quick_cells> selected_quick_cells;\n  \t// Declare an uniform diffusion matrix\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9]]);\n\t\t\t\t\t\t\t\t\t\n\tint impulse_area_size <- 6;\n\n\t// Initialize the emiter cells as the cells at the center of the word\n\tinit {\n\t\tselected_cells <- list<cells>(cells where (each.grid_x < location.x+impulse_area_size\n\t\t\tand each.grid_x > location.x-impulse_area_size\n\t\t\tand each.grid_y < location.y+impulse_area_size\n\t\t\tand each.grid_y > location.y-impulse_area_size\n\t\t));\n\t\tselected_quick_cells <- list<quick_cells>(quick_cells where (each.grid_x < location.x+impulse_area_size\n\t\t\tand each.grid_x > location.x-impulse_area_size\n\t\t\tand each.grid_y < location.y+impulse_area_size\n\t\t\tand each.grid_y > location.y-impulse_area_size\n\t\t));\n\t}\n\treflex init_value when:cycle=0 {\n\t\task(selected_cells){\n\t\t\tphero <- 1.0;\n\t\t}\n\t\task(selected_quick_cells){\n\t\t\tphero <- 1.0;\n\t\t}\t\t\n\t}\n\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\" and on \"quick_cells\". The diffusion declared on \"quick_cells\" will make 5 computations at each step to accelerate the process. \n\t\t// The value of the diffusion will be store in the new variable \"phero\" of the cell.\n\t\t// In order to not loosing phero value, we apply a hand made mask (with the operator \"where\") and we turn the \"avoid_mask\" facet to true.\n\t\tlist cells_where_diffuse <- cells where (each.grid_x < size-cycle_length and each.grid_x > cycle_length and each.grid_y < size-cycle_length and each.grid_y > cycle_length);\n\t\tdiffuse var: phero on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product;\t\n\t\tlist quick_cells_where_diffuse <- quick_cells where (each.grid_x < size-cycle_length and each.grid_x > cycle_length and each.grid_y < size-cycle_length and each.grid_y > cycle_length);\n\t\tdiffuse var: phero on: quick_cells_where_diffuse matrix: mat_diff avoid_mask: true cycle_length: 10 method:dot_product;\n\t}\n}\n\n\ngrid cells height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// The color of the cell is linked to the value of \"phero\".\n\trgb color <- (phero = 0) ? #black : hsb(phero,1.0,1.0) update: (phero = 0) ? #black : hsb(phero,1.0,1.0);\n} \n\ngrid quick_cells height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// The color of the cell is linked to the value of \"phero\".\n\trgb color <- (phero = 0) ? #black : hsb(phero,1.0,1.0) update: (phero = 0) ? #black : hsb(phero,1.0,1.0);\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay a type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells elevation: phero*10 triangulation: true;\n\t\t}\n\t\tdisplay quick type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid quick_cells elevation: phero*10 triangulation: true;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Diffusion-Statement-Diffusion-in-a-cuve-(Cycle-length).md"},"Diffusion-Statement-Kernel-matrix-generation.md":{"title":" Generate diffusion matrix with parameters","content":"[//]: # (keyword|operator_cube)\n[//]: # (keyword|operator_hsb)\n[//]: # (keyword|operator_font)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|constant_#zoom)\n[//]: # (keyword|constant_#bold)\n[//]: # (keyword|constant_#msec)\n[//]: # (keyword|concept_diffusion)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_matrix)\n# Generate diffusion matrix with parameters\n\n\n_Author : Julien Mazars_\n\nThis model shows how to create a diffusion matrix by using the 4 parameters variation, proportion, radius and min-value. Manipulate the parameters to see in real time the result. The number displayed in each cells are the ratio of the initial signal diffused at the end of a step.\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Kernel matrix generation/my_display-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel kernelmatrixgeneration\n\nglobal {\n\t// parameters\n\tfloat variation <- 0.0;\n\tfloat proportion <- 1.0;\n\tint radius <- 1;\n\tfloat min_value <- 0.0;\n\tint cycle_length <- 1;\n\t\n\t// global variables\n\tint cell_max_size <- 51;\n\tint x_min <- cell_max_size;\n\tint x_max <- 0;\n\tint y_min <- cell_max_size;\n\tint y_max <- 0;\n\t\n\tfloat world_size <- 100.0;\n\tgeometry shape <- cube(world_size);\n\t\n\tbuffer_cells selected_cells;\n\t\n\t// init the emiter cell as the one in the center of the world.\n\tinit {\n\t\tselected_cells <- location as buffer_cells;\n\t\t// no need to have a faster display. Let's cool down your computer a bit ;)\n\t\tminimum_cycle_duration <- 200#ms;\n\t}\n\t\n\treflex update {\n\t\tx_min <- cell_max_size;\n\t\tx_max <- 0;\n\t\ty_min <- cell_max_size;\n\t\ty_max <- 0;\n\t\t// copy the values of the buffer_cells (of the previous step) to the grid which will be displayed.\n\t\task cells {\n\t\t\tvalue <- (location as buffer_cells).value;\n\t\t}\n\t\task buffer_cells {\n\t\t\t// find the boundaries of the diffusion\n\t\t\tif (value != 0.0) {\n\t\t\t\tif (grid_x > x_max) {\n\t\t\t\t\tx_max <- grid_x;\n\t\t\t\t}\n\t\t\t\tif (grid_x < x_min) {\n\t\t\t\t\tx_min <- grid_x;\n\t\t\t\t}\n\t\t\t\tif (grid_y > y_max) {\n\t\t\t\t\ty_max <- grid_y;\n\t\t\t\t}\n\t\t\t\tif (grid_y < y_min) {\n\t\t\t\t\ty_min <- grid_y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// re-initialize the value of the buffer grid to 0, and the value of the central cell to 1.\n\t\task buffer_cells {\n\t\t\tvalue <- 0.0;\n\t\t\tif (self = selected_cells) {\n\t\t\t\tvalue <- 1.0;\n\t\t\t}\n\t\t}\n\t\t// diffuse the value over the buffer grid, according to the parameters choosen.\n\t\tdiffuse var:value on:buffer_cells variation:variation proportion:proportion radius:radius cycle_length:cycle_length min_value:min_value;\n\t}\n}\n\n// the buffer grid will be used to compute the diffusion at each step.\ngrid buffer_cells height:cell_max_size width:cell_max_size {\n\t// the diffused variable\n\tfloat value <- 0.0;\n}\n\n// this grid is the copy of the buffer grid at the end of each step. Indeed, we have to display the grid once the diffusion has been done.\ngrid cells height:cell_max_size width:cell_max_size {\n\t// the diffused variable\n\tfloat value <- 0.0;\n\t\n\taspect base {\n\t\t// we only display the cells wich contains a non null value\n\t\tif (grid_x <= x_max and grid_x >= x_min and grid_y <= y_max and grid_y >= y_min)\n\t\t{\n\t\t\t// compute dynamically the size of the current cell.\n\t\t\tfloat size_cell <- world_size/(x_max-x_min+1);\n\t\t\t// compute dynamically the position of the current cell.\n\t\t\tpoint pos <- {(grid_x-x_min+1)*size_cell-0.5*size_cell,(grid_y-y_min+1)*size_cell-0.5*size_cell};\n\t\t\t// display each cell as a square. The color is linked to the value of the diffused variable.\n\t\t\tdraw square(size_cell) color:hsb(value,1.0,1.0) border:#black at:pos;\n\t\t\t// display the ratio in each square.\n\t\t\tdraw string(value) at: pos + {-size_cell/3,0} color: °black font: font(\"Helvetica\", size_cell * #zoom * 2/3, #bold) perspective:true;\n\t\t}\n\t}\n}\n\nexperiment my_experiment type:gui {\n\tparameter \"proportion\" var:proportion;\n\tparameter \"variation\" var:variation;\n\tparameter \"min_value\" var:min_value;\n\tparameter \"radius\" var:radius;\n\tparameter \"cycle_length\" var:cycle_length;\n\toutput {\n\t\tdisplay my_display {\n\t\t\tspecies cells aspect:base;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Diffusion-Statement-Kernel-matrix-generation.md"},"Diffusion-Statement-Uniform-diffusion-with-mask-(Avoid-mask).md":{"title":" Uniform diffusion with mask (Avoid mask)","content":"[//]: # (keyword|operator_as_matrix)\n[//]: # (keyword|operator_row_at)\n[//]: # (keyword|operator_hsb)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_diffusion)\n[//]: # (keyword|concept_matrix)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_obstacle)\n[//]: # (keyword|concept_elevation)\n# Uniform diffusion with mask (Avoid mask)\n\n\n_Author : Julien Mazars_\n\nThis model is used to show how a uniform diffusion can be used with a mask. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism. A mask is used to restrict the diffusion to a \"corridor\" (the white part of the bmp image). The first display shows a diffusion avoiding the masked cells (the value is redistributed to the neighboring cells, to have a constant number of pheromon), the second display shows a diffusion without avoiding the masked cells (the value is diffused in the masked cell, and never rediffused again).\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Uniform diffusion with mask (Avoid mask)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Uniform diffusion with mask (Avoid mask)/b-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel diffusion_with_mask\n\nglobal {\n\tint grid_size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(grid_size) * 10);\n  \tcells_avoid_mask selected_cells1;\n  \tcells_diffuse_on_mask selected_cells2;\n  \t// Load the image mask as a matrix. The white part of the image is the part where diffusion will work, and the black part is where diffusion will be blocked.\n  \tmatrix mymask <- file(\"../includes/complex_mask.bmp\") as_matrix({grid_size,grid_size});\n  \t// Declare a uniform diffusion matrix\n  \tmatrix<float> mat_diff <- matrix([\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\n\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9]]);\n\t// Initialize the emiter cell as the cell at the center of the word\n\tinit {\n\t\tselected_cells1 <- location as cells_avoid_mask;\n\t\tselected_cells2 <- location as cells_diffuse_on_mask;\n\t}\n\treflex new_Value {\n\t\task selected_cells1 {\n\t\t\tphero <- 1.0;\n\t\t}\n\t\task selected_cells2 {\n\t\t\tphero <- 1.0;\n\t\t}\n\t}\n\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\". The value of the diffusion will be store in the new variable \"phero\" of the cell.\n\t\tdiffuse var: phero on: cells_avoid_mask matrix: mat_diff mask: mymask avoid_mask: true;\n\t\tdiffuse var: phero on: cells_diffuse_on_mask matrix: mat_diff mask: mymask;\t\n\t}\n}\n\n\ngrid cells_avoid_mask height: grid_size width: grid_size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0) update: (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\ngrid cells_diffuse_on_mask height: grid_size width: grid_size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0) update: (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay a type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_avoid_mask elevation: true triangulation: true;\n\t\t}\n\t\tdisplay b type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_diffuse_on_mask elevation: true triangulation: true;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Diffusion-Statement-Uniform-diffusion-with-mask-(Avoid-mask).md"},"Diffusion-Statement-Uniform-Diffusion.md":{"title":" Uniform diffusion","content":"[//]: # (keyword|operator_hsb)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|concept_diffusion)\n[//]: # (keyword|concept_matrix)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_elevation)\n# Uniform diffusion\n\n\n_Author : Benoit Gaudou_\n\nThis model is used to show how a diffusion works with a uniform matrix of diffusion in a grid. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism. Without passing a diffusion matrix, the default diffusion matrix is a uniform matrix 3x3, with value 1/nb_neighbors.\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Uniform Diffusion/uniform_diffusion_in_4_neighbors_grid-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Uniform Diffusion/uniform_diffusion_in_8_neighbors_grid-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel uniform_diffusion\n\nglobal {\n\tint size <- 64; // better to have a pow of 2 for the size of the grid\n  \tgeometry shape <- envelope(square(size) * 10);\n  \tcells_eight_nb selected_cells_8;\n  \tcells_four_nb selected_cells_4;\n\n\t// Initialize the emiter cell as the cell at the center of the word\n\tinit {\n\t\tselected_cells_8 <- location as cells_eight_nb;\n\t\tselected_cells_4 <- location as cells_four_nb;\n\t}\n\treflex new_Value {\n\t\task selected_cells_4 {\n\t\t\tphero <- 1.0;\n\t\t}\n\t\task selected_cells_8 {\n\t\t\tphero <- 1.0;\n\t\t}\n\t}\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\", with a uniform matrix of diffusion. The value of the diffusion\n\t\t// will be store in the new variable \"phero\" of the cell.\n\t\tdiffuse var: phero on: cells_eight_nb ;\n\t\tdiffuse var: phero on: cells_four_nb ;\n\t}\n}\n\n\ngrid cells_eight_nb height: size width: size neighbors: 8 {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\ngrid cells_four_nb height: size width: size neighbors: 4 {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// the color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n\t// Update the \"grid_value\", which will be used for the elevation of the cell\n\tfloat grid_value update: phero * 100;\n} \n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay uniform_diffusion_in_8_neighbors_grid type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_eight_nb elevation: true triangulation: true;\n\t\t}\n\t\tdisplay uniform_diffusion_in_4_neighbors_grid type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells_four_nb elevation: true triangulation: true;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Diffusion-Statement-Uniform-Diffusion.md"},"FIPA-Skill-FIPA-CFP-(1).md":{"title":" FIPA Contract Net","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Contract Net\n\n\nThis model demonstrates a use-case of the FIPA Contract Net interaction protocol. One initiator sends a 'cfp' message to other participants. All participants reply with a 'refuse' messages which end the interaction protocol.\n\n\nCode of the model : \n\n```\n\nmodel cfp_cfp_1\n\nglobal {\n\tint nbOfParticipants <- 5;\n\t\n\tinit {\n\t\tcreate initiator;\n\t\tcreate participant number: nbOfParticipants;\n\n\t\twrite 'Please step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies initiator skills: [fipa] { \n\t\n\treflex send_cfp_to_participants when: (time = 1) {\n\t\t//list<participant> participants <- list(participant);\n\t\t\n\t\twrite '(Time ' + time + '): ' + name + ' sends a cfp message to all participants';\n\t\tdo start_conversation (to: list(participant), protocol: 'fipa-contract-net', performative: 'cfp', contents: ['Go swimming']);\n\t}\n\t\n\treflex receive_refuse_messages when: !empty(refuses) {\n\t\twrite '(Time ' + time + '): ' + name + ' receives refuse messages';\n\t\t\n\t\tloop r over: refuses {\n\t\t\twrite '\\t' + name + ' receives a refuse message from ' + r.sender + ' with content ' + r.contents ;\n\t\t}\n\t}\n}\n\nspecies participant skills: [fipa] {\n\t\n\treflex receive_cfp_from_initiator when: !empty(cfps) {\n\t\t\n\t\tmessage proposalFromInitiator <- cfps[0];\n\t\twrite '(Time ' + time + '): ' + name + ' receives a cfp message from ' + agent(proposalFromInitiator.sender).name + ' and replies with a refuse message';\n\t\tdo refuse (message: proposalFromInitiator, contents: ['I am busy today'] );\n\t\t\n\t}\n}\n\nexperiment test type: gui { \n\toutput {\n\t\t\n\t}\n}\n```\n","url":"wiki/FIPA-Skill-FIPA-CFP-(1).md"},"FIPA-Skill-FIPA-CFP-(2).md":{"title":" FIPA Contract Net (2)","content":"[//]: # (keyword|operator_in)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Contract Net (2)\n\n\nThis model demonstrates a use-case of the FIPA Contract Net interaction protocol. \n\nOne initiator sends a 'cfp' message to 5 participants.\nThe first participants (participant0) replies with a refuse message.\nFour participants (participant1, participant2, participant3, participant4) reply with four propose messages.\n\nWhen the initiator receives the propose messages, it proceeds as follows:\nThe initiator replies the participant1 with a reject_proposal message.\nThe initiator replies participant2, participant3, participant4 with three accept_proposal messages respectively.\n\nWhen participant2, participant3 and participant4 receive the accept_proposal messages from the initiator, they proceed as follows:\nParticipant2 replies with a failure message.\nParticipant3 replies with an inform_done message.\nParticipant4 replies with an inform_result message.\n\n\nCode of the model : \n\n```\n\nmodel cfp_cfp_2\n\nglobal {\n\tint nbOfParticipants <- 5;\n\tparticipant refuser;\n\tlist<participant> proposers;\n\tparticipant reject_proposal_participant;\n\tlist<participant> accept_proposal_participants ;\n\tparticipant failure_participant;\n\tparticipant inform_done_participant;\n\tparticipant inform_result_participant;\n\t\n\t\n\tinit {\n\t\tcreate initiator;\n\t\tcreate participant number: nbOfParticipants returns: ps;\n\t\t\n\t\trefuser <- ps[0];\n\t\t\n\t\tadd ps all: true to: proposers;\n\t\tremove refuser from: proposers;\n\t\t\n\t\treject_proposal_participant <- proposers[0];\n\t\t\n\t\tadd proposers all: true to: accept_proposal_participants;\n\t\tremove reject_proposal_participant from: accept_proposal_participants;\n\t\t\n\t\tfailure_participant <- accept_proposal_participants[0];\n\t\tinform_done_participant <- accept_proposal_participants[1];\n\t\tinform_result_participant <- accept_proposal_participants[2];\n\t\t\n\t\twrite 'Please step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies initiator skills: [fipa] {\n\t\n\treflex send_cfp_to_participants when: (time = 1) {\n\t\t\n\t\twrite '(Time ' + time + '): ' + name + ' sends a cfp message to all participants';\n\t\tdo start_conversation with: [ to :: list(participant), protocol :: 'fipa-contract-net', performative :: 'cfp', contents :: ['Go swimming'] ];\n\t}\n\t\n\treflex receive_refuse_messages when: !empty(refuses) {\n\t\twrite '(Time ' + time + '): ' + name + ' receives refuse messages';\n\t\t\n\t\tloop r over: refuses {\n\t\t\twrite '\\t' + name + ' receives a refuse message from ' + agent(r.sender).name + ' with content ' + r.contents ;\n\t\t}\n\t}\n\t\n\treflex receive_propose_messages when: !empty(proposes) {\n\t\twrite '(Time ' + time + '): ' + name + ' receives propose messages';\n\t\t\n\t\tloop p over: proposes {\n\t\t\twrite '\\t' + name + ' receives a propose message from ' + agent(p.sender).name + ' with content ' + p.contents ;\n\t\t\t\n\t\t\tif (p.sender = reject_proposal_participant) {\n\t\t\t\twrite '\\t' + name + ' sends a reject_proposal message to ' + p.sender;\n\t\t\t\tdo reject_proposal with: [ message :: p, contents :: ['Not interested in your proposal'] ];\n\t\t\t} else {\n\t\t\t\twrite '\\t' + name + ' sends a accept_proposal message to ' + p.sender;\n\t\t\t\tdo accept_proposal with: [ message :: p, contents :: ['Interesting proposal. Go do it'] ];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex receive_failure_messages when: !empty(failures) {\n\t\tmessage f <- failures[0];\n\t\twrite '\\t' + name + ' receives a failure message from ' + agent(f.sender).name + ' with content ' + f.contents ;\n\t}\n\t\n\treflex receive_inform_messages when: !empty(informs) {\n\t\twrite '(Time ' + time + '): ' + name + ' receives inform messages';\n\t\t\n\t\tloop i over: informs {\n\t\t\twrite '\\t' + name + ' receives a inform message from ' + agent(i.sender).name + ' with content ' + i.contents ;\n\t\t}\n\t}\n}\n\nspecies participant skills: [fipa] {\n\t\n\treflex receive_cfp_from_initiator when: !empty(cfps) {\n\t\t\n\t\tmessage proposalFromInitiator <- cfps[0];\n\t\twrite '(Time ' + time + '): ' + name + ' receives a cfp message from ' + agent(proposalFromInitiator.sender).name + ' with content ' + proposalFromInitiator.contents;\n\t\t\n\t\tif (self = refuser) {\n\t\t\twrite '\\t' + name + ' sends a refuse message to ' + agent(proposalFromInitiator.sender).name;\n\t\t\tdo refuse with: [ message :: proposalFromInitiator, contents :: ['I am busy today'] ];\n\t\t}\n\t\t\n\t\tif (self in proposers) {\n\t\t\twrite '\\t' + name + ' sends a propose message to ' + agent(proposalFromInitiator.sender).name;\n\t\t\tdo propose with: [ message :: proposalFromInitiator, contents :: ['Ok. That sound interesting'] ];\n\t\t}\n\t}\n\t\n\treflex receive_reject_proposals when: !empty(reject_proposals) {\n\t\tmessage r <- reject_proposals[0];\n\t\twrite '(Time ' + time + '): ' + name + ' receives a reject_proposal message from ' + agent(r.sender).name + ' with content ' + r.contents;\n\t}\n\t\n\treflex receive_accept_proposals when: !empty(accept_proposals) {\n\t\tmessage a <- accept_proposals[0];\n\t\twrite '(Time ' + time + '): ' + name + ' receives a accept_proposal message from ' + agent(a.sender).name + ' with content ' + a.contents;\n\t\t\n\t\tif (self = failure_participant) {\n\t\t\twrite '\\t' + name + ' sends a failure message to ' + agent(a.sender).name;\n\t\t\tdo failure with: [ message :: a, contents :: ['Failure'] ];\n\t\t}\n\t\t\n\t\tif (self = inform_done_participant) {\n\t\t\twrite '\\t' + name + ' sends an inform_done message to ' + agent(a.sender).name;\n\t\t\tdo inform with: [ message :: a, contents :: ['Inform done'] ];\n\t\t}\n\t\t\n\t\tif (self = inform_result_participant) {\n\t\t\twrite '\\t' + name + ' sends an inform_result message to ' + agent(a.sender).name;\n\t\t\tdo inform with: [ message :: a, contents :: ['Inform result'] ];\n\t\t}\n\t}\n}\n\nexperiment test type: gui {\n\toutput {\n\t\t\n\t}\n}\n```\n","url":"wiki/FIPA-Skill-FIPA-CFP-(2).md"},"FIPA-Skill-FIPA-No-Protocol.md":{"title":" FIPA no protocol","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA no protocol\n\n\nThis model demonstrates a usecase of 'no-protocol' interaction protocol.\n'no-protocol' is a freestyle intecraction protocol in which the modeller\n(1) can send whatever type of message (i.e., message performative) in the corresponding conversation\n(2) is responsible for marking the end of the conversation by sending a message with 'end_conversation' performative. \n\n\nCode of the model : \n\n```\nmodel no_protocol_1\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\tp <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; mailbox: ' + (string(mailbox));\n\t}\n\n\treflex say_hello when: (time = 1) {\n\t\tdo start_conversation with: [ to :: [p], protocol :: 'no-protocol', performative :: 'inform', contents :: [ ('Hello from ' + name)] ];\n\t}\n\t\n\treflex read_hello_from_participant when: (time = 3) {\n\t\tloop i over: informs {\n\t\t\twrite name + ' receives message with content: ' + (string(i.contents));\n\t\t\tdo inform with: [ message :: i, contents :: [ ('Goodbye from ' + name)] ];\n\t\t}\n\t}\n\t\n\treflex read_rebound_goodbye when: (time = 5) {\n\t\tloop i over: mailbox {\n\t\t\twrite name + ' receives message with content: ' + (string(i.contents));\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; mailbox: ' + (string(mailbox));\n\t}\n\n\treflex reply_hello when: (time = 2) {\n\t\tloop m over: informs {\n\t\t\twrite name + ' receives message with content: ' + (string(m.contents));\n\t\t\tdo inform with: [ message :: m, contents :: [ ('Rebound hello from ' + name) ] ];\n\t\t}\n\t}\n\t\n\treflex read_goodbye when: (time = 4) {\n\t\tloop i over: informs {\n\t\t\twrite name + ' receives message with content: ' + (string(i.contents));\n\t\t\tdo end_conversation with: [ message :: i, contents :: [ ('Rebound goodbye from' + name) ] ];\n\t\t}\n\t}\n}\n\n\nexperiment test_no_protocol type: gui {}\n```\n","url":"wiki/FIPA-Skill-FIPA-No-Protocol.md"},"FIPA-Skill-FIPA-Propose-(1).md":{"title":" FIPA Propose","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Propose\n\n\nThis model demontrates a usecase of the FIPA Propose interaction protocol. (Please see http://www.fipa.org/specs/fipa00036/SC00036H.html for the detail description of this protocol).\n\nThe Initiator agent begins the conversation/interaction protocol by sending a 'propose' message to the Participant agent with 'Go swimming?' as content.\nOn receiving the 'propose' message, the participant agent replies with an 'accept_proposal' message indicating that it agrees to go swimming.\nAfter the Initiator agent reads the 'accept_proposal' message, the conversation ends.\n\n\nCode of the model : \n\n```\nmodel fipa_propose_1\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\tp <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex send_propose_message when: (time = 1) {\n\t\twrite name + ' sends a propose message';\n\t\tdo start_conversation ( to : [p], protocol : 'fipa-propose', performative : 'propose', contents : ['Go swimming?'] );\n\t}\n\t\n\treflex read_accept_proposals when: !(empty(accept_proposals)) {\n\t\twrite name + ' receives accept_proposal messages';\n\t\tloop i over: accept_proposals {\n\t\t\twrite 'accept_proposal message with content: ' + (string(i.contents));\n\t\t}\n\t}\n\t\n}\n\nspecies Participant skills: [fipa] {\n\treflex accept_proposal when: !(empty(proposes)) {\n\t\tmessage proposalFromInitiator <- proposes at 0;\n\t\t\n\t\tdo accept_proposal ( message : proposalFromInitiator, contents : ['OK! It \\'s hot today!'] );\n\t}\n}\n\nexperiment test_propose_interaction_protocol type: gui {}\n```\n","url":"wiki/FIPA-Skill-FIPA-Propose-(1).md"},"FIPA-Skill-FIPA-Propose-(2).md":{"title":" FIPA Propose (2)","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Propose (2)\n\n\nThis model demontrates a usecase of the FIPA Propose interaction protocol. (Please see http://www.fipa.org/specs/fipa00036/SC00036H.html for the detail description of this protocol).\n\nThe Initiator agent begins the conversation/interaction protocol by sending a 'propose' message to the Participant agent with 'Go swimming?' as content.\nOn receiving the 'propose' message, the participant agent replies with an 'reject_proposal' message indicating that it refuses to go swimming.\nAfter the Initiator agent reads the 'reject_proposal' message, the conversation ends.\n\n\nCode of the model : \n\n```\nmodel fipa_propose_2\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex send_propose_message when: (time = 1) {\n\t\twrite name + ' sends a propose message';\n\t\tdo start_conversation with: [ to :: [p], protocol :: 'fipa-propose', performative :: 'propose', contents :: ['Go swimming?'] ];\n\t}\n\n\treflex read_accept_proposals when: !(empty(reject_proposals)) {\n\t\twrite name + ' receives reject_proposal messages';\n\t\tloop i over: reject_proposals {\n\t\t\twrite 'reject_proposal message with content: ' + (string(i.contents));\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex accept_proposal when: !(empty(proposes)) {\n\t\tmessage proposalFromInitiator <- proposes at 0;\n\t\t\n\t\tdo reject_proposal with: [ message :: proposalFromInitiator, contents :: ['No! It \\'s too cold today!'] ];\n\t}\n}\n\nexperiment test_propose_interaction_protocol type: gui {}\n```\n","url":"wiki/FIPA-Skill-FIPA-Propose-(2).md"},"FIPA-Skill-FIPA-Query-(1).md":{"title":" FIPA Query","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Query\n\n\nThis model demontrates a usecase of the FIPA Query interaction protocol. (Please see http://www.fipa.org/specs/fipa00027/SC00027H.html for the detail description of this protocol).\n\nThe Initiator agent begins the 'fipa-query' conversation/interaction protocol by sending a 'query' message to the Participant agent with 'your name?' as content.\nOn receiving the 'query' message, the Participant agent replies with two consecutive messages :\n(1) an 'agree' message indicating that the Participant agent accepts to execute the query of the Initiator agent,\n(2) an 'inform' message informing the Initiation agent of Participant agent's name.\n\nAfter the Initiator agent read the 'inform' message from the Participant agent, the conversation ends.\n\n\nCode of the model : \n\n```\nmodel fipa_query_1\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex send_query_message when: (time = 1) {\n\t\twrite name + ' sends query message';\n\t\tdo start_conversation with: [ to :: [p], protocol :: 'fipa-query', performative :: 'query', contents :: ['your name?'] ];\n\t}\n\t\n\treflex read_inform_message when: !(empty(informs)) {\n\t\twrite name + ' reads inform messages';\n\t\tloop i over: informs {\n\t\t\twrite 'inform message with content: ' + (string(i.contents));\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\n\treflex reply_query_messages when: !(empty(queries)) {\n\t\tmessage queryFromInitiator <- queries at 0;\n\t\t\n\t\twrite name + ' reads a query message with content : ' + (string(queryFromInitiator.contents));\n\t\t\n\t\tdo agree with: [ message :: queryFromInitiator, contents :: ['OK, I will answer you'] ];\t\t\n\t\tdo inform with: [ message :: queryFromInitiator, contents :: [ 'My name is ' + name ] ];\n\t}\n}\n\nexperiment test_query_interaction_protocol type: gui {}\n```\n","url":"wiki/FIPA-Skill-FIPA-Query-(1).md"},"FIPA-Skill-FIPA-Query-(2).md":{"title":" FIPA Query (2)","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Query (2)\n\n\nThis model demontrates a usecase of the FIPA Query interaction protocol. (Please see http://www.fipa.org/specs/fipa00027/SC00027H.html for the detail description of this protocol).\n\nThe Intiator agent begins the 'fipa-query' conversation/interaction protocol by sending a 'query' message to the Participant agent with 'your name?' as content.\nOn receiving the 'query' message, the Participant agent replies with a 'refuse' message indicating that its name is a secret!\nAfter the Initiator agent reads the 'refuse' message, the conversation ends.\n\n\nCode of the model : \n\n```\nmodel fipa_query_2\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex send_query_message when: (time = 1) {\n\t\twrite name + ' sends a query message';\n\t\tdo start_conversation (to :: [p], protocol :: 'fipa-query', performative :: 'query', contents :: ['your name?']);\n\t}\n\t\n\treflex read_refuse_messages when: !(empty(refuses)) {\n\t\twrite name + ' receives refuse messages';\n\t\tloop i over: refuses {\n\t\t\twrite 'refuse message with content: ' + (string(i.contents));\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex reply_query_messages when: !(empty(queries)) {\n\t\tmessage queryFromInitiator  <- queries at 0;\n\t\t\n\t\twrite name + ' reads a query message with content : ' + (string(queryFromInitiator.contents));\n\t\t\n\t\tdo refuse with: [ message :: queryFromInitiator, contents :: ['No! That is a secret!'] ];\t\t\n\t}\n}\n\nexperiment test_query_interaction_protocol type: gui {}\n```\n","url":"wiki/FIPA-Skill-FIPA-Query-(2).md"},"FIPA-Skill-FIPA-Request-(1).md":{"title":" FIPA Request","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Request\n\n\nThis model demontrates a usecase of the FIPA Request interaction protocol. (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).\n\nThe Initiator agent begins the 'fipa-request' conversation/interaction protocol by sending a 'request' message to the Participant agent with 'go sleeping' as content.\nOn receiving the 'request' message, the Participant agent replies with a 'refuse' message.\nAfter the Initiator reads the 'refuse' message, the 'fipa-request' conversation ends.\n\n\nCode of the model : \n\n```\nmodel fipa_request_1\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\n\t}\n\t\n\treflex send_request when: (time = 1) {\n\t\twrite 'send message';\n\t\tdo start_conversation with: [ to :: [p], protocol :: 'fipa-request', performative :: 'request', contents :: ['go sleeping'] ];\n\t}\n\t\n\treflex read_refuse_message when: !(empty(refuses)) {\n\t\twrite 'read refuse messages';\n\t\tloop r over: refuses {\n\t\t\twrite 'refuse message with content: ' + string(r.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\n\t}\n\n\treflex reply_messages when: (!empty(mailbox)) {\n\t\twrite name + ' sends a refuse message';\n\t\tdo refuse with: [ message :: (mailbox at 0), contents :: ['I don\\'t want'] ];\n\t}\n}\n\n\n\nexperiment test_request_interaction_protocol type: gui {}\n```\n","url":"wiki/FIPA-Skill-FIPA-Request-(1).md"},"FIPA-Skill-FIPA-Request-(2).md":{"title":" FIPA Request (2)","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Request (2)\n\n\nThis model demontrates a usecase of the FIPA Request interaction protocol. (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).\n\nThe Initiator agent begins the 'fipa-request' conversation/interaction protocol by sending a 'request' message to the Participant agent with 'go sleeping' as content.\nOn receiving the 'request' message, the Participant agent replies with two consecutive messages : \n(1) an 'agree' message indicating that the Participant agent accepts to execute the request of the Initiator agent, \n(2) a 'failure' message indicating that the Participant agent fails to (can not) execute the requestion of the Initiator agent (in this case, the Participant agent says that it can not go sleeping because the bed is broken!).\nAfter the Initiator reads the 'failure' message from the Participant, the corresponding conversation ends.\n\n\nCode of the model : \n\n```\nmodel fipa_request_2\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\t p <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\n\t}\n\t\n\treflex send_request when: (time = 1) {\n\t\twrite 'send message';\n\t\tdo start_conversation (to :: [p], protocol :: 'fipa-request', performative :: 'request', contents :: ['go sleeping'] );\n\t}\n\t\n\treflex read_agree_message when: !(empty(agrees)) {\n\t\twrite 'read agree messages';\n\t\tloop a over: agrees {\n\t\t\twrite 'agree message with content: ' + string(a.contents);\n\t\t}\n\t}\n\t\n\treflex read_failure_message when: !(empty(failures)) {\n\t\twrite 'read failure messages';\n\t\tloop f over: failures {\n\t\t\twrite 'failure message with content: ' + (string(f.contents));\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\n\t}\n\n\treflex reply_messages when: (!empty(mailbox)) {\n\t\tmessage requestFromInitiator <- (mailbox at 0);\n\t\twrite 'agree message';\n\t\tdo agree with: (message: requestFromInitiator, contents: ['I will']);\n\t\t\n\t\twrite 'inform the initiator of the failure';\n\t\tdo failure (message: requestFromInitiator, contents: ['The bed is broken']);\n\t}\n}\n\n\n\nexperiment test_request_interaction_protocol type: gui {}\n```\n","url":"wiki/FIPA-Skill-FIPA-Request-(2).md"},"FIPA-Skill-FIPA-Request-(3).md":{"title":" FIPA Request (3)","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Request (3)\n\n\nThis model demontrates a usecase of the FIPA Request interaction protocol. (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).\n\nThe Initiator agent begins the 'fipa-request' conversation/interaction protocol by sending a 'request'  message to the Participant agent with 'go sleeping' as content.\nOn receiving the 'request' message, the Participant replies with two consecutive messages :\n(1) an 'agree' message indicating that the Participant agent accepts to execute the request of the Initiator agent,\n(2) an 'inform' message indicating that the Participant agent has already executed the request of the Initiator agent (in this case, the 'inform' message informs the Initiator that the Participant agent has already gone to bed!).\nAfter the Initiator agent reads the 'inform' message, the conversation ends.\n\n\nCode of the model : \n\n```\nmodel fipa_request_3\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\tp <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\n\t}\n\t\n\treflex send_request when: (time = 1) {\n\t\twrite 'send message';\n\t\tdo start_conversation (to :: [p], protocol :: 'fipa-request', performative :: 'request', contents :: ['go sleeping'] );\n\t}\n\n\treflex read_agree_message when: !(empty(agrees)) {\n\t\twrite 'read agree messages';\n\t\tloop a over: agrees {\n\t\t\twrite 'agree message with content: ' + string(a.contents);\n\t\t}\n\t}\n\t\n\treflex read_inform_message when: !(empty(informs)) {\n\t\twrite 'read inform messages';\n\t\tloop i over: informs {\n\t\t\twrite 'inform message with content: ' + (string(i.contents));\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\n\t}\n\n\treflex reply_messages when: (!empty(mailbox)) {\n\t\tmessage requestFromInitiator <- (mailbox at 0);\n\t\twrite 'agree message';\n\t\tdo agree with: [ message :: requestFromInitiator, contents :: ['I will'] ];\n\t\t\n\t\twrite 'inform the initiator';\n\t\tdo inform with: [ message :: requestFromInitiator, contents :: ['I\\'m in bed already'] ];\n\t}\n}\n\n\n\nexperiment test_request_interaction_protocol type: gui {}\n```\n","url":"wiki/FIPA-Skill-FIPA-Request-(3).md"},"FIPA-Skill-FIPA-Request-(4).md":{"title":" FIPA Request (4)","content":"[//]: # (keyword|skill_fipa)\n[//]: # (keyword|type_message)\n[//]: # (keyword|concept_fipa)\n# FIPA Request (4)\n\n\nThis model demontrates a usecase of the FIPA Request interaction protocol. \n * (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).\n \n \n * The Initiator agent begins the 'fipa-request' conversation/intaction protocol by sending a 'request' \n * message to the Participant agent with 'go sleeping' as content.\n \n * On receiving a 'request' message, the Participant agent replies with an 'inform' message. \n * According to the specification of the FIPA Requestion interaction protocol, the next possible messages \n * after receiving a 'request' message are either 'refuse' message or 'agree' message. \n * Hence replying with an 'inform' message upon receiving a 'request' message violates the protocol specification. \n * GAMA will hence raise a GamaRuntimeException. \n * A conversation is automatically ended in case of GamaRuntimeException raised. Hence this conversation ends.\n \n\nCode of the model : \n\n```\nmodel fipa_request_4\n\nglobal {\n\tParticipant p;\n\t\n\tinit {\n\t\tcreate Initiator;\n\t\tcreate Participant returns: ps;\n\t\t\n\t\tp <- ps at 0;\n\t\t\n\t\twrite 'Step the simulation to observe the outcome in the console';\n\t}\n}\n\nspecies Initiator skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\n\t}\n\t\n\treflex send_request when: (time = 1) {\n\t\twrite 'send message';\n\t\tdo start_conversation with: [ to :: [p], protocol :: 'fipa-request', performative :: 'request', contents :: ['go sleeping'] ];\n\t}\n\t\n\treflex read_refuse_message when: !(empty(refuses)) {\n\t\twrite 'read refuse messages';\n\t\tloop r over: refuses {\n\t\t\twrite 'refuse message with content: ' + string(r.contents);\n\t\t}\n\t}\n}\n\nspecies Participant skills: [fipa] {\n\treflex print_debug_infor {\n\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\n\t}\n\n\treflex reply_messages when: (!empty(mailbox)) {\n\t\twrite name + ' sends an inform message';\n\t\t\n\t\t\n\t\twrite 'A GamaRuntimeException is raised to inform that the message\\'s performative doesn\\'t respect the \\'request\\' interaction protocol\\' specification';\n\t\tdo inform with: [ message :: (mailbox at 0), contents :: ['I don\\'t want'] ]; // Attention: note that GAMA will raise an exception because an 'inform' message is not appropriate here.\n\t}\n}\n\n\nexperiment test_request_interaction_protocol type: gui {}\n```\n","url":"wiki/FIPA-Skill-FIPA-Request-(4).md"},"Ordinary-Differential-Equations-Built-In-Equations.md":{"title":" Predefined equestions","content":"[//]: # (keyword|operator_diff)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n# Predefined equestions\n\n\n_Author : Benoit Gaudou_\n\nPresentation of all the predefined equation systems.Comparaison with hand-written systems to test them.\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/diff-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/LV-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SEIR-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SI-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SIR-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SIRS-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SISs-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\nmodel all_predefined_equations\n\nglobal {\n\tfloat mu <- 0.02;\n\tfloat alpha <- 35.842;\n\tfloat gamma <- 100.0;\n\tfloat beta0 <- 1884.95;\n\tfloat beta1 <- 0.255;\n\tfloat hKR4 <- 0.01;\n\t\n\tinit {\n\t\tcreate preSI  with: [h::0.1,N::500,I::1.0];\n\t\tcreate userSI with: [h::0.1,N::500,I::1.0];\n\n\t\tcreate preSIS  with: [h::0.1,N::500,I::1.0];\n\t\tcreate userSIS with: [h::0.1,N::500,I::1.0];\n\t\t\t\t\n\t\tcreate preSIR  with: [h::0.1,N::500,I::1.0];\n\t\tcreate userSIR with: [h::0.1,N::500,I::1.0];\n\t\t\n\t\tcreate preSIRS  with: [h::0.1,N::500,I::1.0];\n\t\tcreate userSIRS with: [h::0.1,N::500,I::1.0];\t\n\t\t\n\t\tcreate preSEIR  with: [h::0.1,N::500,I::1.0];\n\t\tcreate userSEIR with: [h::0.1,N::500,I::1.0];\t\t\n\t\t\n\t\tcreate preLV  with: [h::0.1,x::2.0,y::2.0];\n\t\tcreate userLV with: [h::0.1,x::2.0,y::2.0];\t\t\t\n\t}\n}\n\n\nspecies preSI {\n\tfloat t;\n\tint N;\n\tfloat I ; \n\tfloat S <- N - I; \n\tfloat h;\n\tfloat beta<-0.4;\n\n\t// must be followed with exact order S, I, t  and N,beta\n\tequation eqSI type: SI vars: [S,I,t] params: [N,beta] ;\n\t/*reflex solving {\n\t\tlist i_list;\n\t\t//solve eqSI method: \"dp853\" step: 0.01 cycle_length: 100 min_step: 1 max_step: 1 scalAbsoluteTolerance: 1 scalRelativeTolerance: 1 integrated_times: i_list ;\n\t\t//solve eqSI method:rk4 step:h;\n\t}*/\n\t\n\treflex solving {\n\t\tlist i_list;\n\t\tlist v_list ;\n\t\tsolve eqSI method: \"rk4\" step: h ;//cycle_length: 1/h integrated_times: i_list integrated_values: v_list;\n\t\twrite \"i_list: \" + i_list;\n\t\twrite \"v_list:\" + v_list;\n\t}\n}\n\nspecies userSI {\n\tfloat t;\n\tint N;\n\tfloat I ; \n\tfloat S <- N - I; \n\tfloat h;\n\tfloat beta<-0.4;\n\t\n\tequation eqSI {\n\t\tdiff(S,t) = -beta * S * I / N ;\n\t\tdiff(I,t) = beta * S * I / N ;\n\t}\t\t\n\treflex solving{solve eqSI method:rk4 step:h;}\n\t\n}\n\n\nspecies preSIS {\n\tfloat t;\n\tint N;\n\tfloat I ; \n\tfloat S <- N - I; \n\tfloat h;\n\tfloat beta<-0.4;\n\tfloat gamma<-0.01;    \t\t\n\n\t// must be followed with exact order S, I, t  and N,beta\n\tequation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma] ;\n\treflex solving {\n\t\tsolve eqSIS method:rk4 step:h;\n\t}\n}\n\nspecies userSIS {\n\tfloat t;\n\tint N;\n\tfloat I ; \n\tfloat S <- N - I; \n\tfloat h;\n\tfloat beta<-0.4;\n\tfloat gamma<-0.01;    \t\t\n\t\n\tequation eqSIS {\n\t\tdiff(S,t) = -beta * S * I / N + gamma * I;\n\t\tdiff(I,t) = beta * S * I / N - gamma * I;\n\t}\t\t\n\treflex solving {\t\n\t\tsolve eqSIS method:rk4 step:h;\n\t}\n}\n\n\nspecies preSIR {\n\tfloat t;\n\tint N;\n\tfloat I ; \n\tfloat S <- N - I; \n\tfloat R <- 0.0; \n\tfloat h;\n\tfloat beta<-0.4;\n\tfloat gamma<-0.01; \n\n\t// must be followed with exact order S, I, R, t  and N,beta,delta\n\tequation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma] ;\n\treflex solving {\t\n\t\tsolve eqSIR method:rk4 step:h;\n\t}\n}\n\nspecies userSIR{\n\tfloat t;\n\tint N;\n\tfloat I ; \n\tfloat S <- N - I; \n\tfloat R <- 0.0; \n\tfloat h;\n\tfloat beta<-0.4;\n\tfloat gamma<-0.01; \t\t\t\t\n\t\n\tequation eqSIR {\n\t\tdiff(S,t) = (- beta * S * I / N);\n\t\tdiff(I,t) = (beta * S * I / N) - (gamma * I);\n\t\tdiff(R,t) = (gamma * I);\n\t}\t\t\n\treflex solving {\n\t\tsolve eqSIR method:rk4 step:h;\n\t}\n}\n\n\nspecies preSIRS {\n\tfloat t;\n\tint N;\n\tfloat I ; \n\tfloat S <- N - I; \n\tfloat R <- 0.0; \n\tfloat h;\n\tfloat beta<-0.4;\n\tfloat gamma<-0.01; \n\tfloat omega <- 0.05;\n\tfloat mu <- 0.01;\n\n\t// must be followed with exact order S, I, R, t  and N,beta,delta\n\tequation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu] ;\n\treflex solving {\n\t\tsolve eqSIRS method:rk4 step:h;\n\t}\n}\n\nspecies userSIRS {\n\tfloat t;\n\tint N;\n\tfloat I ; \n\tfloat S <- N - I; \n\tfloat R <- 0.0; \n\tfloat h;\n\tfloat beta<-0.4;\n\tfloat gamma<-0.01; \t\n\tfloat omega <- 0.05;\n\tfloat mu <- 0.01;   \t\t\t\t\t\n\t\n\tequation eqSIRS {\n\t\t diff(S,t) = mu * N + omega * R + - beta * S * I / N - mu * S ;\n\t\t diff(I,t) = beta * S * I / N - gamma * I - mu * I ;\n\t\t diff(R,t) = gamma * I - omega * R - mu * R ;\n\t}\t\t\n\treflex solving {\n\t\tsolve eqSIRS method:rk4 step:h;\n\t}\n}\n\n\nspecies preSEIR {\n\tfloat t;\n\tint N;\n\tfloat S <- N - I;     \t\n\tfloat E <- 0.0;\n\tfloat I ; \n\tfloat R <- 0.0; \n\tfloat h;\n\tfloat beta<-0.4;\n\tfloat gamma<-0.01; \n\tfloat sigma <- 0.05;\n\tfloat mu <- 0.01;\n\n\t// must be followed with exact order S, E, I, R, t  and N,beta,gamma,sigma,mu\n\tequation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu] ;\n\treflex solving {\n\t\tsolve eqSEIR method:rk4 step:h;\n\t}\n}\n\nspecies userSEIR {\n\tfloat t;\n\tint N;\n\tfloat S <- N - I;     \t\n\tfloat E <- 0.0;\n\tfloat I ; \n\tfloat R <- 0.0; \n\tfloat h;\n\tfloat beta<-0.4;\n\tfloat gamma<-0.01; \t\n\tfloat sigma <- 0.05;\n\tfloat mu <- 0.01;   \t\t\t\t\t\n\t\n\tequation eqSEIR {\n\t\tdiff(S,t) = mu * N - beta * S * I / N - mu * S ;\n\t\tdiff(E,t) = beta * S * I / N - mu * E - sigma * E ;\n\t\tdiff(I,t) = sigma * E - mu * I - gamma * I;\n\t\tdiff(R,t) = gamma * I - mu * R ;\n\t}\t\t\n\treflex solving {\n\tsolve eqSEIR method:rk4 step:h;\n\t}\n}\n\n\nspecies preLV {\n\tfloat t;\n\tfloat x ; \n\tfloat y ; \n\tfloat h;\n\tfloat alpha <- 0.8 ;\n\tfloat beta  <- 0.3 ;\n\tfloat gamma <- 0.2 ;\n\tfloat delta <- 0.85;\n\n\t// must be followed with exact order x, y, t  and  alpha,beta,delta,gamma\n\tequation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;\n\treflex solving {\n\t\tsolve eqLV method:rk4 step:h;\n\t}\n}\n\nspecies userLV {\n\tfloat t;\n\tfloat x ; \n\tfloat y ; \n\tfloat h;\n\tfloat alpha <- 0.8 ;\n\tfloat beta  <- 0.3 ;\n\tfloat gamma <- 0.2 ;\n\tfloat delta <- 0.85;\n\t\n\tequation eqLV { \n\t\tdiff(x,t) =   x * (alpha - beta * y);\n\t\tdiff(y,t) = - y * (delta - gamma * x);\n    }\t\t\n\treflex solving {\n\t\tsolve eqLV method:rk4 step:h;\n\t}\n}\n\n\n\nexperiment examples type: gui {\n\toutput {\t\t\n\t\tdisplay SI  {\n\t\t\tchart 'examplePreSI' type: series background: #lightgray position: {0,0} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(preSI).S color: #green;\n\t\t\t\tdata \"I\" value: first(preSI).I color: #red;\n\t\t\t}\n\t\t\tchart 'examplesUserSI' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(userSI).S color: #green;\n\t\t\t\tdata \"I\" value: first(userSI).I color: #red;\n\t\t\t}\n\t\t}\n\n\t\tdisplay SISs  {\n\t\t\tchart 'examplePreSIS' type: series background: #lightgray position: {0,0} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(preSIS).S color: #green;\n\t\t\t\tdata \"I\" value: first(preSIS).I color: #red;\n\t\t\t}\n\t\t\tchart 'examplesUserSIS' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(userSIS).S color: #green;\n\t\t\t\tdata \"I\" value: first(userSIS).I color: #red;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tdisplay SIR  {\n\t\t\tchart 'examplePreSIR' type: series background: #lightgray position: {0,0} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(preSIR).S color: #green;\n\t\t\t\tdata \"I\" value: first(preSIR).I color: #red;\n\t\t\t\tdata \"R\" value: first(preSIR).R color: #blue;\n\t\t\t}\n\t\t\tchart 'examplesUserSIR' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(userSIR).S color: #green;\n\t\t\t\tdata \"I\" value: first(userSIR).I color: #red;\n\t\t\t\tdata \"R\" value: first(userSIR).R color: #blue;\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tdisplay SIRS  {\n\t\t\tchart 'examplePreSIRS' type: series background: #lightgray position: {0,0} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(preSIRS).S color: #green;\n\t\t\t\tdata \"I\" value: first(preSIRS).I color: #red;\n\t\t\t\tdata \"R\" value: first(preSIRS).R color: #blue;\n\t\t\t}\n\t\t\tchart 'examplesUserSIRS' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(userSIRS).S color: #green;\n\t\t\t\tdata \"I\" value: first(userSIRS).I color: #red;\n\t\t\t\tdata \"R\" value: first(userSIRS).R color: #blue;\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tdisplay SEIR  {\n\t\t\tchart 'examplePreSEIR' type: series background: #lightgray position: {0,0} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(preSEIR).S color: #green;\n\t\t\t\tdata \"E\" value: first(preSEIR).E color: #yellow;\n\t\t\t\tdata \"I\" value: first(preSEIR).I color: #red;\n\t\t\t\tdata \"R\" value: first(preSEIR).R color: #blue;\n\t\t\t}\n\t\t\tchart 'examplesUserSEIR' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\n\t\t\t\tdata \"S\" value: first(userSEIR).S color: #green;\n\t\t\t\tdata \"E\" value: first(userSEIR).E color: #yellow;\t\t\t\t\n\t\t\t\tdata \"I\" value: first(userSEIR).I color: #red;\n\t\t\t\tdata \"R\" value: first(userSEIR).R color: #blue;\n\t\t\t}\n\t\t}\n\n\t\tdisplay LV  {\n\t\t\tchart 'examplePreLV' type: series background: #lightgray position: {0,0} size:{1,0.5} {\n\t\t\t\tdata \"x\" value: first(preLV).x color: #yellow;\n\t\t\t\tdata \"y\" value: first(preLV).y color: #blue;\n\t\t\t}\n\t\t\tchart 'examplesUserLV' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\n\t\t\t\tdata \"x\" value: first(userLV).x color: #yellow;\n\t\t\t\tdata \"y\" value: first(userLV).y color: #blue;\n\t\t\t}\t\t\t\n\t\t}\t\t\t\t\t\t\n\t}\n}\n\nexperiment diff_predefined_defined_by_user type: gui {\n\toutput {\n\t\tdisplay diff  {\n\t\t\tchart 'diffSI' type: series background: #lightgray  position: {0,0} size:{0.5, 0.33} {\n\t\t\t\tdata \"dS\" value: (first(userSI).S - first(preSI).S) color: #yellow;\n\t\t\t\tdata \"dI\" value: (first(userSI).I - first(preSI).I) color: #blue;\n\t\t\t}\n\t\t\tchart 'diffSIS' type: series background: #lightgray position: {0.5,0} size:{0.5, 0.33} {\n\t\t\t\tdata \"dS\" value: (first(userSIS).S - first(preSIS).S) color: #yellow;\n\t\t\t\tdata \"dI\" value: (first(userSIS).I - first(preSIS).I) color: #blue;\n\t\t\t}\n\t\t\tchart 'diffSIR' type: series background: #lightgray position: {0,0.33} size:{0.5, 0.33} {\n\t\t\t\tdata \"dS\" value: (first(userSIR).S - first(preSIR).S) color: #yellow;\n\t\t\t\tdata \"dI\" value: (first(userSIR).I - first(preSIR).I) color: #blue;\n\t\t\t\tdata \"dR\" value: (first(userSIR).R - first(preSIR).R) color: #red;\n\t\t\t}\t\t\n\t\t\tchart 'diffSIRS' type: series background: #lightgray position: {0.5,0.33} size:{0.5, 0.33} {\n\t\t\t\tdata \"dS\" value: (first(userSIRS).S - first(preSIRS).S) color: #yellow;\n\t\t\t\tdata \"dI\" value: (first(userSIRS).I - first(preSIRS).I) color: #blue;\n\t\t\t\tdata \"dR\" value: (first(userSIRS).R - first(preSIRS).R) color: #red;\n\t\t\t}\t\n\t\t\tchart 'diffSEIR' type: series background: #lightgray position: {0,0.66} size:{0.5, 0.33} {\n\t\t\t\tdata \"dS\" value: (first(userSEIR).S - first(preSEIR).S) color: #yellow;\n\t\t\t\tdata \"dE\" value: (first(userSEIR).E - first(preSEIR).E) color: #yellow;\t\t\t\t\n\t\t\t\tdata \"dI\" value: (first(userSEIR).I - first(preSEIR).I) color: #blue;\n\t\t\t\tdata \"dR\" value: (first(userSEIR).R - first(preSEIR).R) color: #red;\n\t\t\t}\t\n\t\t\tchart 'diffLV' type: series background: #lightgray position: {0.5,0.66} size:{0.5, 0.33} {\n\t\t\t\tdata \"dx\" value: (first(userLV).x - first(preLV).x) color: #yellow;\n\t\t\t\tdata \"dy\" value: (first(userLV).y - first(preLV).y) color: #red;\t\t\t\t\n\t\t\t}\t\t\t\t\t\n\t\t}\t\n\t}\n}\n\n```\n","url":"wiki/Ordinary-Differential-Equations-Built-In-Equations.md"},"Ordinary-Differential-Equations-SIR-(Influence-of-Integration-Step).md":{"title":" SIR (Influence of Integration Step).gaml","content":"[//]: # (keyword|operator_diff)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|constant_#sec)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n# SIR (Influence of Integration Step).gaml\n\n\n_Author : hqnghi_\n\nA SIR model to illustrate the impact of the change of the integration parameters.\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Influence of Integration Step)/SIR_1-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Influence of Integration Step)/SIR_10-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Influence of Integration Step)/SIR_100-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel SIR_influence_of_integration_step\n\nglobal { \n\tfloat step<-1#s;\n\tfloat beta <- 0.8 ; \t\n\tfloat delta <- 0.01 ; \n\t\n\tfloat s1 <- 1#s;\n\tfloat s2 <- 1.5#s;\n\tfloat s3 <- 2#s;\n\t\n\tinit {\n\t\tcreate SIR_agt with: [h::1,myUnit::s1];\n\t\tcreate SIR_agt with: [h::0.1,myUnit::s2];\n\t\tcreate SIR_agt with: [h::0.01,myUnit::s3];\t\n  \t}  \n}\n\n\n\nspecies SIR_agt {\n\tint N <- 500;\n    float t;    \n\n\tfloat I <- 1.0; \n\tfloat S <- N - I; \n\tfloat R <- 0.0; \n\t\t\n   \tfloat h;   \t\t\n\tfloat myUnit<-1#s;\n\tequation SIR{ \n\t\tdiff(S,t) =myUnit* (- beta  * S * I / N);\n\t\tdiff(I,t) =myUnit* (beta * S * I / N) - (delta * I);\n\t\tdiff(R,t) =myUnit* (delta * I);\n\t} \n\n\treflex solving {\n\t\tsolve SIR method: \"rk4\" step: h;// cycle_length:mycycle ;\n//\t\tS<-S*myUnit;\n//\t\tI<-I*myUnit;\n//\t\tR<-R*myUnit;\n\t}      \n}\n\n\nexperiment mysimulation1 type: gui { \n \toutput { \n\t\tdisplay SIR_1  {\n\t\t\tchart \"SI - h=1\" type: series background: #white {\n\t\t\t\tdata 'S' value: first(SIR_agt where (each.myUnit = s1)).S color: #green;\t\t\t\t\n\t\t\t\tdata 'I' value: first(SIR_agt where (each.myUnit = s1)).I color: #red ;\n\t\t\t\tdata 'R' value: first(SIR_agt where (each.myUnit = s1)).R color: #blue ;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay SIR_10 {\n\t\t\tchart \"SI - h=0.1\" type: series background: #white{\n\t\t\t\tdata 'S' value: first(SIR_agt where (each.myUnit = s2)).S color: #green;\t\t\t\t\n\t\t\t\tdata 'I' value: first(SIR_agt where (each.myUnit = s2)).I color: #red ;\n\t\t\t\tdata 'R' value: first(SIR_agt where (each.myUnit = s2)).R color: #blue ;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay SIR_100  {\n\t\t\tchart \"SI - h=0.01\" type: series background: #white {\n\t\t\t\tdata 'S' value: first(SIR_agt where (each.myUnit = s3)).S color: #green;\t\t\t\t\n\t\t\t\tdata 'I' value: first(SIR_agt where (each.myUnit = s3)).I color: #red ;\n\t\t\t\tdata 'R' value: first(SIR_agt where (each.myUnit = s3)).R color: #blue ;\t\t\t\t\n\t\t\t}\n\t\t}\t\n\t}\n}\n```\n","url":"wiki/Ordinary-Differential-Equations-SIR-(Influence-of-Integration-Step).md"},"Ordinary-Differential-Equations-SIR-(Simple-with-charts).md":{"title":" SIR (Simple)","content":"[//]: # (keyword|operator_diff)\n[//]: # (keyword|operator_internal_integrated_value)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n# SIR (Simple)\n\n\n_Author : hqnghi_\n\nA simple example of ODE use into agents with the example of the SIR equation system.\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Simple with charts)/display_charts-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Simple with charts)/display_chartsH-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Simple with charts)/display_charts_radar-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel simple_ODE_SIR\n\nglobal {\n\tinit{\n\t\tcreate aSIR number:10{\n\t\t\tS<-S-(int(self)*10000);\n\t\t}\n\t}\n\tlist S_3d->{aSIR collect each.S};\n\tlist I_3d->{aSIR collect each.I};\n\tlist R_3d->{aSIR collect each.R};\n\treflex ss when: cycle>=40{\n    \tdo pause;\n\t\t\n\t}\n}\n\n\nspecies aSIR {\n\tint N <- 150000 ;\n\tint iInit <- 1000;\t\t\n\n    float t;  \n\tfloat S <- N - float(iInit); \t      \n\tfloat I <- float(iInit); \n\tfloat R <- 0.0; \n\t\n\tfloat alpha <- 0.2 min: 0.0 max: 1.0;\n\tfloat beta <- 0.8  min: 0.0 max: 1.0;\n\n\tfloat h <- 0.1;\n   \n\tequation SIR{ \n\t\tdiff(S,t) = (- beta * S * I / N);\n\t\tdiff(I,t) = (beta * S * I / N) - (alpha * I);\n\t\tdiff(R,t) = (alpha * I);\n\t}\n                \n    reflex solving {\n    \tsolve SIR method: \"rk4\" step: h ;//cycle_length: 1/h ;\n    }    \n}\n\n\nexperiment maths type: gui {\n\t\tfloat minimum_cycle_duration<-0.2;\n\t\n\toutput { \n\t\tdisplay display_charts {\n\t\t\tchart \"SIR_agent\" type: series background: #white {\n\t\t\t\tdata 'S0' value: (aSIR[0]).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'S1' value: (aSIR[1]).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'S2' value: (aSIR[2]).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'S3' value: (aSIR[3]).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'S4' value: (aSIR[4]).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'S5' value: (aSIR[5]).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'S6' value: (aSIR[6]).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'S7' value: (aSIR[7]).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'S8' value: (aSIR[8]).S color: #green ;\t\t\n\t\t\t\tdata 'S9' value: (aSIR[9]).S color: #green ;\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\tdata 'I0' value: (aSIR[0]).I color: #red ;\t\t\t\t\n\t\t\t\tdata 'I1' value: (aSIR[1]).I color: #red ;\t\t\t\t\n\t\t\t\tdata 'I2' value: (aSIR[2]).I color: #red ;\t\t\t\t\n\t\t\t\tdata 'I3' value: (aSIR[3]).I color: #red ;\t\t\t\t\n\t\t\t\tdata 'I4' value: (aSIR[4]).I color: #red ;\t\t\t\t\n\t\t\t\tdata 'I5' value: (aSIR[5]).I color: #red ;\t\t\t\t\n\t\t\t\tdata 'I6' value: (aSIR[6]).I color: #red ;\t\t\t\t\n\t\t\t\tdata 'I7' value: (aSIR[7]).I color: #red ;\t\t\t\t\n\t\t\t\tdata 'I8' value: (aSIR[8]).I color: #red ;\t\t\n\t\t\t\tdata 'I9' value: (aSIR[9]).I color: #red ;\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\tdata 'R0' value: (aSIR[0]).R color: #blue ;\t\t\t\t\n\t\t\t\tdata 'R1' value: (aSIR[1]).R color: #blue ;\t\t\t\t\n\t\t\t\tdata 'R2' value: (aSIR[2]).R color: #blue ;\t\t\t\t\n\t\t\t\tdata 'R3' value: (aSIR[3]).R color: #blue ;\t\t\t\t\n\t\t\t\tdata 'R4' value: (aSIR[4]).R color: #blue ;\t\t\t\t\n\t\t\t\tdata 'R5' value: (aSIR[5]).R color: #blue ;\t\t\t\t\n\t\t\t\tdata 'R6' value: (aSIR[6]).R color: #blue ;\t\t\t\t\n\t\t\t\tdata 'R7' value: (aSIR[7]).R color: #blue ;\t\t\t\t\n\t\t\t\tdata 'R8' value: (aSIR[8]).R color: #blue ;\t\t\n\t\t\t\tdata 'R9' value: (aSIR[9]).R color: #blue ;\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay display_charts_radar {\n\t\t\tchart \"SIR_agent\" type: radar background: #white axes:#white {\n\t\t\t\tdata 'S0' value: (aSIR[0]).S[] color: #green ;\t\t\t\n\t\t\t\tdata 'I0' value: (aSIR[0]).I[] color: #red ;\t\n\t\t\t\tdata 'R0' value: (aSIR[0]).R[] color: #blue ;\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tdisplay display_chartsH {\n\t\t\tchart \"SIR_agent\" type: heatmap background: #white\n\t\t\treverse_axes: true\n\t\t\t {\n\t\t\t\tdata 'S0' value: S_3d color: #green ;\t\n\t\t\t\tdata 'I0' value: I_3d color: #red ;\t\n\t\t\t\tdata 'R0' value: R_3d color: #blue ;\t\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Ordinary-Differential-Equations-SIR-(Simple-with-charts).md"},"Ordinary-Differential-Equations-SIR-(Simple).md":{"title":" SIR (Simple)","content":"[//]: # (keyword|operator_diff)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n# SIR (Simple)\n\n\n_Author : hqnghi_\n\nA simple example of ODE use into agents with the example of the SIR equation system.\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Simple)/display_charts-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\n\nmodel simple_ODE_SIR\n\nglobal {\n\tinit{\n\t\tcreate agent_with_SIR_dynamic number:1;\n\t}\n}\n\n\nspecies agent_with_SIR_dynamic {\n\tint N <- 1500 ;\n\tint iInit <- 1;\t\t\n\n    float t;  \n\tfloat S <- N - float(iInit); \t      \n\tfloat I <- float(iInit); \n\tfloat R <- 0.0; \n\t\n\tfloat alpha <- 0.2 min: 0.0 max: 1.0;\n\tfloat beta <- 0.8 min: 0.0 max: 1.0;\n\n\tfloat h <- 0.01;\n   \n\tequation SIR{ \n\t\tdiff(S,t) = (- beta * S * I / N);\n\t\tdiff(I,t) = (beta * S * I / N) - (alpha * I);\n\t\tdiff(R,t) = (alpha * I);\n\t}\n                \n    reflex solving {\n    \tsolve SIR method: \"rk4\" step: h ;//cycle_length: 1/h ;\n    }    \n}\n\n\nexperiment maths type: gui {\n\toutput { \n\t\tdisplay display_charts {\n\t\t\tchart \"SIR_agent\" type: series background: #white {\n\t\t\t\tdata 'S' value: first(list(agent_with_SIR_dynamic)).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'I' value: first(list(agent_with_SIR_dynamic)).I color: #red ;\n\t\t\t\tdata 'R' value: first(list(agent_with_SIR_dynamic)).R color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Ordinary-Differential-Equations-SIR-(Simple).md"},"Ordinary-Differential-Equations-SIR-(Split-in-Agents,-Multiple-Strains).md":{"title":" SIR (Split in Agents, Multiple Strains)","content":"[//]: # (keyword|operator_diff)\n[//]: # (keyword|operator_sum)\n[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n# SIR (Split in Agents, Multiple Strains)\n\n\n_Author : tri and nghi_\n\nThis model is an extension of the model SIR_split_in_agents.gaml. It creates several agents of one compartment type (here typically several I_agt).\n\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Split in Agents, Multiple Strains)/chart_1system_eq-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Split in Agents, Multiple Strains)/chart_3system_eq-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>Code of the model : \n\n```\nmodel SIR_split_in_agents_multiple_strains\n\nglobal {\n\t// Parameters\n\tint number_S <- 495 ; // The number of susceptible\n\tint number_I <- 5 ; // The number of infected\n\tint number_R <- 0 ; // The number of removed \n\n\tfloat _beta <- 1.0 ; // The parameter Beta\n\tfloat _delta <- 0.01 ; // The parameter Delta\n\t\n\t// Global variables\n\tint strain_number <- 2;\n\tint N <- number_S + number_I * strain_number + number_R;\t\n\tfloat hKR4 <- 0.01;\n\t\n\tinit {\n\t\tcreate S_agt {\n\t\t\tSsize <- float(number_S);\n\t\t}\n\n\t\tcreate I_agt number: strain_number {\n\t\t\tIsize <- float(number_I);\n\t\t\tself.beta <- _beta; \n\t\t\tself.delta <- _delta; \n\t\t}\n\n\t\tcreate R_agt {\n\t\t\tRsize <- float(number_R);\n\t\t}\n\n\t\tcreate my_SIR_maths {\n\t\t\tself.Sm <- float(number_S);\n\t\t\tself.Im <- float(number_I) * strain_number;\n\t\t\tself.Rm <- float(number_R);\n\t\t}\n\n\t\twrite 'Basic Reproduction Number (R0): ' + string(_beta * number_S / (_delta));\n\t}\n\n}\n\n\nspecies S_agt {\n\tfloat t;\t\t\n\tfloat Ssize;\n\t\n\tequation evol simultaneously: [I_agt, R_agt] {\n\t\tdiff(self.Ssize, t) = (- sum(I_agt accumulate [each.beta * each.Isize]) * self.Ssize / N);\n\t}\n\n\treflex solving {solve evol method: \"rk4\" step: hKR4 ;}\n}\n\nspecies I_agt {\n\tfloat t;\t\t\n\tfloat Isize;\n\t \n\tfloat beta;\n\tfloat delta;\n\t\n\tequation evol simultaneously: [S_agt, R_agt] {\n\t\tdiff(self.Isize, t) = (beta * first(S_agt).Ssize * self.Isize / N) - (delta * self.Isize);\n\t}\n}\n\nspecies R_agt {\n\tfloat t;\t\t\n\tfloat Rsize;\n\n\tequation evol simultaneously: [I_agt] {\n\t\tdiff(self.Rsize, t) = (sum(I_agt collect (each.delta * each.Isize)));\n\t}\n}\n\nspecies my_SIR_maths {\n\tfloat t;\n\tfloat Im;\n\tfloat Sm;\n\tfloat Rm;\n\t\n\tequation SIR {\n\t\tdiff(self.Sm, t) = (-_beta * Sm * Im / N);\n\t\tdiff(self.Im, t) = (_beta * Sm * Im / N) - (_delta * Im);\n\t\tdiff(self.Rm, t) = (_delta * Im);\n\t}\n\n\treflex solving {solve SIR method: \"rk4\" step: hKR4;}\n}\n\n\n\nexperiment Simulation type: gui {\n\tparameter 'Number of Susceptible' type: int var: number_S <- 495 category: \"Initial population\"; \n\tparameter 'Number of Infected'    type: int var: number_I <- 5   category: \"Initial population\";\n\tparameter 'Number of Removed'     type: int var: number_R <- 0   category: \"Initial population\";\n\n\tparameter 'Beta (S->I)'  type: float var: _beta <- 1.0   category: \"Parameters\";\n\tparameter 'Delta (I->R)' type: float var: _delta <- 0.01 category: \"Parameters\";\t\n\t\n\toutput {\n\t\tdisplay chart_3system_eq {\n\t\t\tchart 'Split system' type: series background: #lightgray {\n\t\t\t\tdata 'susceptible' value: first(S_agt).Ssize color: #green;\n\t\t\t\tdata 'infected0' value: first(I_agt).beta * first(I_agt).Isize color: #white;\n\t\t\t\tdata 'infected1' value: last(I_agt).beta * last(I_agt).Isize color: #yellow;\n\t\t\t\tdata 'i1+i2' value: sum(I_agt accumulate (each.beta * each. Isize)) color: rgb ( 'red' ) ;\t\t\t\t\n\t\t\t\tdata 'recovered' value: first(R_agt).Rsize color: #blue;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay chart_1system_eq  {\n\t\t\tchart 'unified system' type: series background: #lightgray {\n\t\t\t\tdata 'susceptible_maths' value: first(my_SIR_maths).Sm color: #green;\n\t\t\t\tdata 'infected_maths' value: first(my_SIR_maths).Im color: #red;\n\t\t\t\tdata 'recovered_maths' value: first(my_SIR_maths).Rm color: #blue;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n","url":"wiki/Ordinary-Differential-Equations-SIR-(Split-in-Agents,-Multiple-Strains).md"},"Physics-Engine-Hello-World.md":{"title":" Falling Balls","content":"[//]: # (keyword|skill_physics)\n[//]: # (keyword|concept_physics_engine)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_spatial_computation)\n[//]: # (keyword|concept_3d)\n# Falling Balls\n\n\n_Author : Arnaud Grignard_\n\nThis is a model that shows how the physics engine work by displaying two species (a floor and balls). Ball agents use the skill physical3D. The ball agents fall on a floor and fall from the floor to the void. \n\n\nCode of the model : \n\n```\n\nmodel FallingHelloWorld\n\n\n\nglobal {\n\tint environment_size <- 500; \n \n\t \n\tint number_of_ball parameter: 'Number of ball' min:1 <- 100  category: 'Model'; \n\tint ball_radius parameter: 'Ball radius' min:1 <- 25  category: 'Model'; \n\t\n\tfile imageRaster <- file('./../images/wood-floor.jpg') ;\n\tgeometry shape <- square(environment_size);\n\t\n\t\n\t//Physic World used to simulate gravity and compute forces\n\tphysic_world world2;\n\t\n\t\n\tinit {\n\t\tcreate ball number: number_of_ball{\n\t\t\tlocation <-  {rnd(environment_size),rnd(environment_size),rnd(environment_size)};\n            radius <-float(rnd(ball_radius)+1);\n            //Bounds to compute the collision for the ball agents\n\t\t\tcollisionBound <-  [\"shape\"::\"sphere\",\"radius\"::radius];\n\t\t\tmass <-1.0;\n\t\t}\n\t\t\n\t\tcreate ground {\n\t\t\tlocation <- {environment_size/2,environment_size/2,0};\n            //Bounds to compute the collision for the floor agent\n\t\t\tcollisionBound <-  [\"shape\"::\"floor\",\"x\"::environment_size/2, \"y\":: environment_size/2, \"z\"::0];\n\t\t\tmass <-0.0;\n\t\t}\n\n\t\tcreate physic_world{\n\t\t  world2 <- self;\n\t\t  //Add to the agents that will be used to compute the forces.\n\t\t  ask world2 {agents <-  (ball as list) + (ground as list);}\n\t\t  //Boolean to set gravity \t\n\t\t  world2.gravity <- true;\n\t\t}\n\t}\n\t\n\t//Reflex to compute the forces at each step\n\treflex computeForces  {\n\t  ask world2 {do compute_forces step: 1;}\n\t} \t\t\t\n} \n\n\nspecies physic_world parent: physical_world ;\n\nspecies ground skills: [physics]{    \t\n\taspect image{\n\t\tdraw imageRaster size: environment_size;\n\t}\n}\n \nspecies ball skills: [physics] {  \n\trgb color <- rgb (217,229,143); \n\tfloat radius;\n\n\taspect sphere{\n\t\tdraw sphere(radius) color: color ;\n\t}\t\n}\nexperiment Falling_Hello_world type: gui {\n\tinit{\n\t\tminimum_cycle_duration <-0.001;\n\t}\n\t\n\toutput {\t\t\n\t\tdisplay Rain  type: opengl background:rgb(0,58,64) draw_env:false{\n\t\t\tspecies ground aspect:image;\n\t\t    species ball aspect:sphere;\t\t\t\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Physics-Engine-Hello-World.md"},"Physics-Engine-Perfect-Gas.md":{"title":" Balls without gravity","content":"[//]: # (keyword|skill_physics)\n[//]: # (keyword|concept_physics_engine)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_spatial_computation)\n# Balls without gravity\n\n\n_Author : Arnaud Grignard_\n\nThis is a model that shows how the physics engine work without gravity. Balls can collide each other and can't go further than the wall and the ground agents.\n\n\nCode of the model : \n\n```\nmodel Perfect_Gas\n\n \n \nglobal {\n\t//Bounds of the environment\n\tint width_of_environment parameter: 'Dimensions' init:200 ; \n\tint height_of_environment parameter: 'Dimensions' init:200  ; \n\t\n\t//Range, Speed ans Size of the agents\n\tint range_of_agents parameter: 'Range of Agents' min: 1 <- 25 ;\n\tfloat speed_of_agents parameter: 'Speed of Agents' min: 0.1  <- 2.0 ; \n\tint size_of_agents <- 10;\n\t\n\t\n\tfloat size_of_the_wall <- 10.0;\n\tint offset<-10;\n\tgeometry shape <- rectangle(width_of_environment, height_of_environment);\n\n\t//Physic engines that will compute the forces\n\tphysic_world world2;\n\tinit {\n\t\tcreate ball number: 1000{\n\t\t\tradius <-2;\n\t\t\tlocation <-  {offset+ rnd(width_of_environment-offset*2), offset+ rnd(height_of_environment- offset*2),offset+ rnd(width_of_environment-offset*2)};\n\t\t\tmass <-0.001;\n\t\t\tcollisionBound <-  [\"shape\"::\"sphere\",\"radius\"::radius];\n\t\t}\n\t\t\n\t\tcreate ground \n\t\t{   \n\t\t\tlocation <- {width_of_environment/2,height_of_environment/2,0};\n\t\t\tcollisionBound <-  [\"shape\"::\"floor\",\"x\"::width_of_environment/2 , \"y\":: height_of_environment/2, \"z\"::size_of_the_wall];\n\t\t\tshape <- rectangle(width_of_environment,height_of_environment);\n\t\t\tmass <-0.0;\n\t\t}\n\t\t\n\t\t//Sky\n\t\tcreate ground{\n\t\t\tlocation <- {width_of_environment/2,height_of_environment/2,width_of_environment};\n\t\t\tcollisionBound <-  [\"shape\"::\"floor\",\"x\"::width_of_environment/2 , \"y\":: height_of_environment/2, \"z\"::size_of_the_wall];\n\t\t\tshape <- rectangle(width_of_environment,height_of_environment);\n\t\t\tmass <-0.0;\n\t\t}\n\n\t\t//down wall\n\t\tcreate wall{\n\t\t\tlocation <- {width_of_environment/2,height_of_environment,0};\n\t\t\theight <- float(width_of_environment);\n\t\t\tshape <- rectangle(width_of_environment,2);\n\t\t\tcollisionBound <-  [\"shape\"::\"floor\",\"x\"::width_of_environment/2, \"y\":: size_of_the_wall, \"z\"::height];\n\t\t\tmass <-0.0;\n\t\t}\n\t\t//upper wall\n\t\tcreate wall{\n\t\t\tlocation <- {width_of_environment/2,0,0};\n\t\t\theight <- float(width_of_environment);\n\t\t\tshape <- rectangle(width_of_environment,2);\n\t\t\tcollisionBound <-  [\"shape\"::\"floor\",\"x\"::width_of_environment/2, \"y\":: size_of_the_wall, \"z\"::height];\n\t\t\tmass <-0.0;\n\t\t}\n\t\t//left wall\n\t\tcreate wall{\n\t\t\tlocation <- {0.0,height_of_environment/2,0.0};\n\t\t\theight <- float(width_of_environment);\n\t\t\tshape <- rectangle(2,height_of_environment);\n\t\t\tcollisionBound <-  [\"shape\"::\"floor\",\"x\"::size_of_the_wall, \"y\":: height_of_environment/2, \"z\"::height];\n\t\t\tmass <-0.0;\t\t\t\n\t\t}\n\t\t//right wall\n\t\tcreate wall{\n\t\t\tlocation <- {width_of_environment,height_of_environment/2,0};\n\t\t\theight <- float(width_of_environment);\n\t\t\tshape <- rectangle(2,height_of_environment);\n\t\t\tcollisionBound <-  [\"shape\"::\"floor\",\"x\"::size_of_the_wall, \"y\":: height_of_environment/2, \"z\"::height];\n\t\t\tmass <-0.0;\n\t\t\t\n\t\t}\n\t\t\n\t\t//Create the physic engine without gravity computed\n\t\tcreate physic_world {\n\t\t\tgravity <- false;\n\t\t\tworld2 <- self;\n\t\t}\n\t\t\n\t\t//Add the agents to compute their forces\n\t\task world2 {agents <-  (ball as list) + (ground as list) + (wall as list);}\n\t\t\n\t}\n\t\n\t//Reflex to compute the forces at each step\n\treflex computeForces  {\n\t\task world2 {do compute_forces step: 1;}\n\t} \n\t\t\t\n} \n//Species to represent the physic engine, derivated from the Physical3DWorld built-in species\nspecies physic_world parent: physical_world ;\n \n//Species to represent the ground using the physical3D skill\nspecies ground skills: [physics]{\n\taspect default {\n\t\tdraw shape color: #black empty:true;\n\t}\n}\n\n//Species to represent the wall using the physical3D skill\nspecies wall skills: [physics]{\n\trgb color;\n\tfloat height;\n    aspect default {\n\t\tdraw shape color: #black depth:height empty:true;\n\t}\n}\n \t\n//Species to represent the ball using the physical3D skill\nspecies ball skills: [physics] {  \n\trgb color;\n\tint radius;\n\tint size  <- size_of_agents;\n\tint range  <- range_of_agents; \n\tfloat speed  <- speed_of_agents;  \n\tint heading <- rnd(359);\n\n\taspect sphere{\n\t\tdraw sphere(radius) color: rgb(135,201,255) ;\n\t}\t\n}\n\nexperiment perfect_gas type: gui {\n\tinit{\n\t\tminimum_cycle_duration <-0.001;\n\t}\n\toutput {\n\t\tdisplay Cube type:opengl background:rgb(20,79,127) draw_env:false{\n\t\t\tspecies ground transparency:0.5;\n\t\t\tspecies wall transparency:0.5;\n\t    \tspecies ball aspect:sphere;\t\t\t\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Physics-Engine-Perfect-Gas.md"},"Physics-Engine-Pool.md":{"title":" Pool using Physic Engine","content":"[//]: # (keyword|skill_physics)\n[//]: # (keyword|concept_physics_engine)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_spatial_computation)\n[//]: # (keyword|concept_obstacle)\n# Pool using Physic Engine\n\n\n_Author : Arnaud Grignard_\n\nThis is a model that shows how the physics engine works using a pool with balls, collided by a white ball. The balls use the skill Physical3D.\n\n\nCode of the model : \n\n```\nmodel pool3D\n\nglobal {\n\t//Parameters for the environment\n\tint width_of_environment <- 200;\n\tint height_of_environment <- 300;\n\t\n\t//Parameters for the balls\n\tfloat speed_of_agents <- 2.0;\n\tint size_of_agents <- 10;\n\t\n\trgb colorwood <- rgb([178, 112, 62]);\n\t\n\t//Physical Engine\n\tphysic_world world2;\n\tgeometry shape <- rectangle(width_of_environment, height_of_environment);\n\tinit {\n\t\t\n\t\t//Creation of the white ball\n\t\tcreate ball {\n\t\t\tlocation <- { width_of_environment / 2, 4 * height_of_environment / 5, 5.0 };\n\t\t\tmass <- 3.0;\n\t\t\t//a random velocity between 500 and 1000\n\t\t\tvelocity <- [0.0, -float(500 + rnd(500)), 0.0];\n\t\t\tcollisionBound <- [\"shape\"::\"sphere\", \"radius\"::5];\n\t\t}\n\n\t\tint i <- 0;\n\t\tint deltaI <- 0;\n\t\tint initX <- 75;\n\t\tint initY <- int(height_of_environment / 8);\n\t\t\n\t\t//Create the other balls for the pool\n\t\tcreate ball number: 15 {\n\t\t\tlocation <- { initX + (i - deltaI) * 10, initY, 5.0 };\n\t\t\theading <- 90;\n\t\t\tspeed <- 0.0;\n\t\t\tmass <- 3.0;\n\t\t\tcollisionBound <- [\"shape\"::\"sphere\", \"radius\"::5];\n\t\t\ti <- i + 1;\n\t\t\t\n\t\t\tif ((i mod 2) = 0) {\n\t\n\t\t\t\tcolor <- #red;\n\t\t\t} else {\n\t\t\t\tcolor <- #yellow;\n\t\t\t}\n\n\t\t\tif (i = 5) {\n\t\t\t\tinitX <- initX + 5;\n\t\t\t\tinitY <- initY + 9;\n\t\t\t\tdeltaI <- 5;\n\t\t\t}\n\n\t\t\tif (i = 9) {\n\t\t\t\tinitX <- initX + 5;\n\t\t\t\tinitY <- initY + 9;\n\t\t\t\tdeltaI <- 9;\n\t\t\t}\n\n\t\t\tif (i = 12) {\n\t\t\t\tinitX <- initX + 5;\n\t\t\t\tinitY <- initY + 9;\n\t\t\t\tdeltaI <- 12;\n\t\t\t}\n\n\t\t\tif (i = 14) {\n\t\t\t\tinitX <- initX + 5;\n\t\t\t\tinitY <- initY + 9;\n\t\t\t\tdeltaI <- 14;\n\t\t\t}\n\n\t\t}\n\n\t\tcreate ground {\n\t\t\tlocation <- { width_of_environment / 2, height_of_environment / 2, 0 };\n\t\t\tshape <- rectangle({ width_of_environment - 24, height_of_environment - 24 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2 - 12, \"y\"::height_of_environment / 2 - 12, \"z\"::0];\n\t\t\tmass <- 0.0;\n\t\t}\n\n\t\tcreate ground {\n\t\t\tlocation <- { width_of_environment / 2, 6, 0 };\n\t\t\tshape <- rectangle({ width_of_environment - 24, 12 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2 - 12, \"y\"::6, \"z\"::0];\n\t\t\tmass <- 0.0;\n\t\t}\n\n\t\tcreate ground {\n\t\t\tlocation <- { width_of_environment / 2, height_of_environment - 6, 0 };\n\t\t\tshape <- rectangle({ width_of_environment - 24, 12 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2 - 12, \"y\"::6, \"z\"::0];\n\t\t\tmass <- 0.0;\n\t\t}\n\n\t\tcreate ground {\n\t\t\tlocation <- { 6, height_of_environment / 4 + 3, 0 };\n\t\t\tshape <- rectangle({ 12, height_of_environment / 2 - 18 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::6, \"y\"::height_of_environment / 4 - 9, \"z\"::0];\n\t\t\tmass <- 0.0;\n\t\t}\n\n\t\tcreate ground {\n\t\t\tlocation <- { 6, 3 * height_of_environment / 4 - 3, 0 };\n\t\t\tshape <- rectangle({ 12, height_of_environment / 2 - 18 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::6, \"y\"::height_of_environment / 4 - 9, \"z\"::0];\n\t\t\tmass <- 0.0;\n\t\t}\n\n\t\tcreate ground {\n\t\t\tlocation <- { width_of_environment - 6, height_of_environment / 4 + 3, 0 };\n\t\t\tshape <- rectangle({ 12, height_of_environment / 2 - 18 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::6, \"y\"::height_of_environment / 4 - 9, \"z\"::0];\n\t\t\tmass <- 0.0;\n\t\t}\n\n\t\tcreate ground {\n\t\t\tlocation <- { width_of_environment - 6, 3 * height_of_environment / 4 - 3, 0 };\n\t\t\tshape <- rectangle({ 12, height_of_environment / 2 - 18 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::6, \"y\"::height_of_environment / 4 - 9, \"z\"::0];\n\t\t\tmass <- 0.0;\n\t\t}\n\n\t\t//down wall\n\t\tcreate wall {\n\t\t\tlocation <- { width_of_environment / 2, height_of_environment, 0 };\n\t\t\tshape <- rectangle({ width_of_environment, 2 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::1, \"z\"::10];\n\t\t\tmass <- 0.0;\n\t\t\tcolor <- colorwood;\n\t\t}\n\t\t//upper wall\n\t\tcreate wall {\n\t\t\tlocation <- { width_of_environment / 2, 0, 0 };\n\t\t\tshape <- rectangle({ width_of_environment, 2 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::1, \"z\"::10];\n\t\t\tmass <- 0.0;\n\t\t\tcolor <- colorwood;\n\t\t}\n\t\t//left wall\n\t\tcreate wall {\n\t\t\tlocation <- { 0, height_of_environment / 2, 0 };\n\t\t\tshape <- rectangle({ 2, height_of_environment });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::1, \"y\"::height_of_environment / 2, \"z\"::10];\n\t\t\tmass <- 0.0;\n\t\t\tcolor <- colorwood;\n\t\t}\n\t\t//right wall\n\t\tcreate wall {\n\t\t\tlocation <- { width_of_environment, height_of_environment / 2, 0 };\n\t\t\tshape <- rectangle({ 2, height_of_environment });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::1, \"y\"::height_of_environment / 2, \"z\"::10];\n\t\t\tmass <- 0.0;\n\t\t\tcolor <- colorwood;\n\t\t}\n\t\t\n\t\t//Create the physic engine with gravity\n\t\tcreate physic_world {\n\t\t\tgravity <- true;\n\t\t\tworld2 <- self;\n\t\t}\n\n\t\t//Add the agents inside the registered agents in the physic engine\n\t\task world2 {\n\t\t\tagents <- (ball as list) + (ground as list) + (wall as list);\n\t\t}\n\n\t}\n\n\t//Reflex to compute the forces at each step\n\treflex computeForces {\n\t\task world2 {\n\t\t\tdo compute_forces step: 1;\n\t\t}\n\n\t}\n\n}\n\n//Species corresponding to the physics engine, derivated from the built-in species Physical3DWorld\nspecies physic_world parent: physical_world ;\n\n//Species representing the ground agents used for the computation of the forces, using the skill physical3D\nspecies ground skills: [physics] {\n\taspect default {\n\t\tdraw shape color: rgb([10, 114, 63]) border: rgb([10, 114, 63]);\n\t}\n\n}\n\n//Species representing the wall agents of the pool using the skill physical3D\nspecies wall skills: [physics] {\n\trgb color;\n\taspect default {\n\t\tdraw shape color: color depth: 10;\n\t}\n\n}\n\n//Species representing the ball agents of the pool using the skill physical3D\nspecies ball skills: [physics] {\n\trgb color<-#white;\n\tint size <- size_of_agents;\n\tfloat speed <- speed_of_agents;\n\tint heading <- rnd(359);\n\n\taspect sphere {\n\t\tdraw sphere(5) color:color;\n\t}\n\n}\n\nexperiment pool type: gui {\n\toutput {\n\t\tdisplay Circle type: opengl tesselation: true background: #white draw_env: false { species ground aspect: default;\n\t\tspecies wall aspect: default;\n\t\tspecies ball aspect: sphere;\n\t\t}\n\t}\n\n}\n\n```\n","url":"wiki/Physics-Engine-Pool.md"},"Physics-Engine-Water-Tank.md":{"title":" Water Tank","content":"[//]: # (keyword|skill_physics)\n[//]: # (keyword|concept_physics_engine)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_spatial_computation)\n# Water Tank\n\n\n_Author : Arnaud Grignard_\n\nThis is a model that shows how the physics engine works using a tank, with a floor and 4 walls, and balls falling into it. The floor doesn't have any mass, \n\n\nCode of the model : \n\n```\nmodel Tank\n\nglobal {\n\t\n\t//Dimensions of the environment\n\tint width_of_environment parameter: 'Dimensions' init: 100;\n\tint height_of_environment parameter: 'Dimensions' init: 100;\n\t\n\t//Parameters for the ball species\n\tint nb_balls parameter: 'Number of Agents' min: 1 <- 500;\n\tint size_of_agents parameter: 'Size of Agents' min: 1 <- 1;\n\t\n\t\n\tint wall_height parameter: 'Wall height' min: 1 <- 25;\n\tgeometry shape <- rectangle(width_of_environment, height_of_environment);\n\t\n\t//Physics engine\n\tphysic_world world2;\n\t\n\t\n\tinit {\n\t\t\n\t\t//Creation of the ball agents\n\t\tcreate ball number: nb_balls {\n\t\t\tlocation <- { rnd(width_of_environment - size_of_agents), rnd(height_of_environment - size_of_agents), rnd(height_of_environment - size_of_agents) };\n\t\t\tradius <- float(size_of_agents);\n\t\t\t\n\t\t\t//Attributes to know the collision bounds of the agent\n\t\t\tcollisionBound <- [\"shape\"::\"sphere\", \"radius\"::radius];\n\t\t}\n\n\t\t//Create the ground of the tank\n\t\tcreate ground {\n\t\t\tlocation <- { width_of_environment / 2, height_of_environment / 2, 0 };\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::height_of_environment / 2, \"z\"::0];\n\t\t\tshape <- rectangle({ width_of_environment, height_of_environment });\n\t\t\tmass <- 0.0;\n\t\t}\n\t\t//down wall\n\t\tcreate wall {\n\t\t\tlocation <- { width_of_environment / 2, height_of_environment, 0 };\n\t\t\tshape <- rectangle({ width_of_environment, 2 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::1, \"z\"::wall_height];\n\t\t\tmass <- 0.0;\n\t\t}\n\t\t//upper wall\n\t\tcreate wall {\n\t\t\tlocation <- { width_of_environment / 2, 0, 0 };\n\t\t\tshape <- rectangle({ width_of_environment, 2 });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::1, \"z\"::wall_height];\n\t\t\tmass <- 0.0;\n\t\t}\n\t\t//left wall\n\t\tcreate wall {\n\t\t\tlocation <- { 0, height_of_environment / 2, 0 };\n\t\t\tshape <- rectangle({ 2, height_of_environment });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::1, \"y\"::height_of_environment / 2, \"z\"::wall_height];\n\t\t\tmass <- 0.0;\n\t\t}\n\t\t//right wall\n\t\tcreate wall {\n\t\t\tlocation <- { width_of_environment, height_of_environment / 2, 0 };\n\t\t\tshape <- rectangle({ 2, height_of_environment });\n\t\t\tcollisionBound <- [\"shape\"::\"floor\", \"x\"::1, \"y\"::height_of_environment / 2, \"z\"::wall_height];\n\t\t\tmass <- 0.0;\n\t\t}\n\t\t//Initialisation of the physic engine\n\t\tcreate physic_world {\n\t\t\tworld2 <- self;\n\t\t}\n\t\t\n\t\t//The physic engine agent gets all the other agents of the world to compute their forces\n\t\task world2 {\n\t\t\tagents <- (ball as list) + (ground as list) + (wall as list);\n\t\t}\n\n\t\tworld2.gravity <- true;\n\t}\n\n\t//Reflex to compute the forces at each step\n\treflex computeForces {\n\t\task world2 {\n\t\t\tdo compute_forces step: 1;\n\t\t}\n\n\t}\n\n}\n\n//Species that will represent the physic engine, derivated from builti-in species Physical3DWorld\nspecies physic_world parent: physical_world ;\n\n//Species that will represent the ground of the tank, using the skill physical 3D\nspecies ground skills: [physics] {\n\taspect default {\n\t\tdraw shape color: rgb(60, 60, 60);\n\t}\n\n}\n\n\n//Species that will represent the walls of the tank, using the skill physical 3D\nspecies wall skills: [physics] {\n\trgb color;\n\taspect default {\n\t\tdraw shape color: rgb(40, 40, 40) depth: wall_height;\n\t}\n\n}\n\n\n//Species that will represent the balls falling in the tank, using the skill physical 3D\nspecies ball skills: [physics] {\n\tfloat radius;\n\taspect default {\n\t\tdraw sphere(radius) color: rgb(4, 158, 189);\n\t}\n\n}\n\nexperiment tank type: gui {\n\tinit{\n\t\tminimum_cycle_duration <-0.001;\n\t}\n\toutput {\n\t\tdisplay Circle type: opengl background: rgb(230, 230, 230) { \n\t\t\tspecies ground;\n\t\t\tspecies wall;\n\t\t\tspecies ball;\n\t\t}\n\t}\n\n}\n\n```\n","url":"wiki/Physics-Engine-Water-Tank.md"},"Diffusion-Statement.md":{"title":" Diffusion Statement","content":"# Diffusion Statement\n\nThis sub-section is composed of the following models :\n\n* [Anisotropic diffusion (Simple)](references#DiffusionStatementAnisotropicDiffusion(Simple))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Anisotropic Diffusion (Simple)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [Anisotropic diffusion (Toroidal)](references#DiffusionStatementAnisotropicDiffusion(Toroidal))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Anisotropic Diffusion (Toroidal)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [Anisotropic diffusion with several computation method](references#DiffusionStatementAnisotropicDiffusion(VariousMethods))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Anisotropic Diffusion (Various Methods)/convol-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Anisotropic Diffusion (Various Methods)/dot-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [Blend color in a cuve](references#DiffusionStatementBlendcolorinacuve(MultipleSignals))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Blend color in a cuve (Multiple Signals)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [Diffusion in a cuve (Cycle length)](references#DiffusionStatementDiffusioninacuve(Cyclelength))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Diffusion in a cuve (Cycle length)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Diffusion in a cuve (Cycle length)/quick-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [Generate diffusion matrix with parameters](references#DiffusionStatementKernelmatrixgeneration)\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Kernel matrix generation/my_display-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [Uniform diffusion with mask (Avoid mask)](references#DiffusionStatementUniformdiffusionwithmask(Avoidmask))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Uniform diffusion with mask (Avoid mask)/a-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Uniform diffusion with mask (Avoid mask)/b-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [Uniform diffusion](references#DiffusionStatementUniformDiffusion)\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Uniform Diffusion/uniform_diffusion_in_4_neighbors_grid-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Uniform Diffusion/uniform_diffusion_in_8_neighbors_grid-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>","url":"wiki/Diffusion-Statement.md"},"FIPA-Skill.md":{"title":" FIPA Skill","content":"# FIPA Skill\n\nThis sub-section is composed of the following models :\n\n* [FIPA Contract Net](references#FIPASkillFIPACFP(1))\n\n* [FIPA Contract Net (2)](references#FIPASkillFIPACFP(2))\n\n* [FIPA no protocol](references#FIPASkillFIPANoProtocol)\n\n* [FIPA Propose](references#FIPASkillFIPAPropose(1))\n\n* [FIPA Propose (2)](references#FIPASkillFIPAPropose(2))\n\n* [FIPA Query](references#FIPASkillFIPAQuery(1))\n\n* [FIPA Query (2)](references#FIPASkillFIPAQuery(2))\n\n* [FIPA Request](references#FIPASkillFIPARequest(1))\n\n* [FIPA Request (2)](references#FIPASkillFIPARequest(2))\n\n* [FIPA Request (3)](references#FIPASkillFIPARequest(3))\n\n* [FIPA Request (4)](references#FIPASkillFIPARequest(4))\n\n","url":"wiki/FIPA-Skill.md"},"Ordinary-Differential-Equations.md":{"title":" Ordinary Differential Equations","content":"# Ordinary Differential Equations\n\nThis sub-section is composed of the following models :\n\n* [Predefined equestions](references#OrdinaryDifferentialEquationsBuilt-InEquations)\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/diff-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/LV-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SEIR-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SI-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SIR-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SIRS-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations Built-In Equations/SISs-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [SIR (Influence of Integration Step).gaml](references#OrdinaryDifferentialEquationsSIR(InfluenceofIntegrationStep))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Influence of Integration Step)/SIR_1-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Influence of Integration Step)/SIR_10-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Influence of Integration Step)/SIR_100-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [SIR (Simple)](references#OrdinaryDifferentialEquationsSIR(Simplewithcharts))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Simple with charts)/display_charts-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Simple with charts)/display_chartsH-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Simple with charts)/display_charts_radar-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [SIR (Simple)](references#OrdinaryDifferentialEquationsSIR(Simple))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Simple)/display_charts-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>* [SIR (Split in Agents, Multiple Strains)](references#OrdinaryDifferentialEquationsSIR(SplitinAgents,MultipleStrains))\n\n<p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Split in Agents, Multiple Strains)/chart_1system_eq-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p><p><img src=\"gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Ordinary Differential Equations/Ordinary Differential Equations SIR (Split in Agents, Multiple Strains)/chart_3system_eq-10.png\" alt=\"Eclipse folder.\" title class=\"img-responsive\"> == $0</p>","url":"wiki/Ordinary-Differential-Equations.md"},"Physics-Engine.md":{"title":" Physics Engine","content":"# Physics Engine\n\nThis sub-section is composed of the following models :\n\n* [Falling Balls](references#PhysicsEngineHelloWorld)\n\n* [Balls without gravity](references#PhysicsEnginePerfectGas)\n\n* [Pool using Physic Engine](references#PhysicsEnginePool)\n\n* [Water Tank](references#PhysicsEngineWaterTank)\n\n","url":"wiki/Physics-Engine.md"},"Agent-movement-Follow-Path.md":{"title":"  Movement of an agent on different paths","content":"[//]: # (keyword|operator_as_path)\n[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n#  Movement of an agent on different paths\n\n\n_Author : _\n\nModel showing the movement of an agent following three different paths : one defined by its vertices, an other defined thanks to all the roads species, and finally a path defined by a graph with weights (graph created thanks to an other species)\n\n\nCode of the model : \n\n```\nmodel path_and_follow\n\nglobal{\n\tgraph the_graph;\n    init{\n    \t\t//It is possible to define a road by defining its shape, being a line. The line need to be created by passing the location of the vertices\n       create road {\n       \t\tshape <- line([{0,50},{40,60}]);\n       }\n       create road {\n       \t\tshape <- line([{40,60},{50,50},{55,60}]);\n       }\n       create road {\n       \t\tshape <- line([{55,60},{65,40}]);\n       }\n       \n       create road_of_graph {\n       \t\tshape <- line([{65,40},{75,35}]);\n       }\n       create road_of_graph {\n       \t\tshape <- line([{75,35},{85,40},{80,60}]);\n       }\n       //It is possible to define a weights map by linking the road and their weights (the road will be the key of the weight)\n       map<road_of_graph,float> weight_map <- road_of_graph as_map (each::each.shape.perimeter * 10);\n       \n       //A graph can be defined by using a list or all the agents of a species and it is possible to use a map of weights with each key \n       // of the map being a road to link the road and its weight\n       //The as_edge_graph operator is an operator creating a graph using the list of agents passed as edges of the graph\n       the_graph <- as_edge_graph(road_of_graph) with_weights weight_map;\n      \n       create myCircle {\n       \t\tlocation <- {0,0};\n       }\n      \n    }  \n}\n\nspecies myCircle skills:[moving]{\n\t//The different ways to declare a path : declaring all the lines of the path using their vertices\n\t//\t\t\t\t\t\t\t  using a list of agents representing the lines of the path\n\t//\t\t\t\t\t\t\t  using the graph as a path\n\t\n\t\n \tpath path_to_follow1 <- path([{0,0},{10,10},{0,20},{20,30},{20,40},{0,50}]);\t\n \tpath path_to_follow2 <- path(list(road));\t\n \tpath path_to_follow3 <- list(road_of_graph) as_path the_graph;\t\n \t\n \t//These two variables will change when the cycle will be higher than 100 and 200\n \tpath path_following<- path_to_follow1;\n \trgb color <- #green;\n \t\n\treflex myfollow{ \n\t\t//The operator follow make the agent move from the starting vertice of the starting edge of a path to the last vertice of the last edge of the path\n\t\t// but following the edges of the concerned path\n\t \tdo follow path: path_following;\t\n\t \tif(cycle>200)\n\t \t{\n\t \t\tpath_following<- path_to_follow3;\t\n\t \t\tcolor<-#pink;\n\t \t}\n\t \telse\n\t \t{\n\t \t\tif(cycle>100)\n\t\t \t{\n\t\t \t\tpath_following<- path_to_follow2;\t\n\t\t \t\tcolor<-#blue;\n\t\t \t}\n\t \t}\n\t}\n\t\n\taspect base {\n\t  draw circle(1) color:#red ;\t\n\t  //We loop on all the edges of the path the agent follow to display them\n\t  \tloop seg over: path_following.edges {\n\t  \t\tdraw seg color: color;\n\t \t }\n\t  \n\t} \n}\n\nspecies road {\n\taspect base {\n\t  draw shape color:#blue ;\t\n\t  \n\t} \n}\n\nspecies road_of_graph {\n\taspect base {\n\t  draw shape color:#red ;\t\n\t  \n\t} \n}\n\nexperiment main type: gui {\n\tfloat minimum_cycle_duration <- 0.10;\n\toutput {\n\t\tdisplay myView { \n\t\t\tspecies myCircle aspect:base; \n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n```\n","url":"wiki/Agent-movement-Follow-Path.md"},"Agent-movement-Follow-Weighted-Network-(Agents).md":{"title":"  Follow Weighted Network","content":"[//]: # (keyword|operator_path_between)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n#  Follow Weighted Network\n\n\n_Author :  Martine Taillandier_\n\nModel representing how to make a weighted graph and the impacts of the weights on the time to follow the path for the agents. Two agents are represented to show this difference : one knowing the weights and following a fast path, an other following a path longer without knowing it's a longer path.\n\n\nCode of the model : \n\n```\n\nmodel weightperagents\n\nglobal {\n\tmap<road, float> roads_weight;\n\tgraph road_network;\n\tfloat slow_coeff <- 3.0;\n\tinit {\n\t\t//This road will be slow\n\t\tcreate road {\n\t\t\tshape <- line ([{10,50},{90,50}]);\n\t\t\tslow <- true;\n\t\t}\n\t\t//The others will be faster\n\t\tcreate road {\n\t\t\tshape <- line ([{10,50},{10,10}]);\n\t\t\tslow <- false;\n\t\t}\n\t\tcreate road {\n\t\t\tshape <- line ([{10,10},{90,10}]);\n\t\t\tslow <- false;\n\t\t}\n\t\tcreate road {\n\t\t\tshape <- line ([{90,10},{90,50}]);\n\t\t\tslow <- false;\n\t\t}\n\t\t\n\t\t//Weights map of the graph for those who will know the shortest road by taking into account the weight of the edges\n\t\troads_weight <- road as_map (each:: each.shape.perimeter * (each.slow ? slow_coeff : 1.0));\n\t\troad_network <- as_edge_graph(road);\n\t\t\n\t\t//people with information about the traffic\n\t\tcreate people {\n\t\t\tcolor <- #blue;\n\t\t\tsize <- 2.0;\n\t\t\troads_knowledge <- roads_weight;\n\t\t}\n\t\t\n\t\t//people without information about the traffic\n\t\tcreate people {\n\t\t\tcolor <- #yellow;\n\t\t\tsize <- 1.0;\n\t\t\troads_knowledge <- road as_map (each:: each.shape.perimeter);\n\t\t}\n\t}\n\t\n}\n\nspecies road {\n\tbool slow;\n\taspect geom {\n\t\tdraw shape color: slow ? #red : #green;\n\t}\n}\n\t\nspecies people skills: [moving] {\n\tmap<road, float> roads_knowledge;\n\tpoint the_target;\n\trgb color;\n\tfloat size;\n\tpath path_to_follow;\n\t\n\tinit {\n\t\tthe_target <- {90,50};\n\t\tlocation <- {10,50};\n\t}\n\t\t\n\treflex movement when: location != the_target{\n\t\tif (path_to_follow = nil) {\n\t\t\t\n\t\t\t//Find the shortest path using the agent's own weights to compute the shortest path\n\t\t\tpath_to_follow <- path_between(road_network with_weights roads_knowledge, location,the_target);\n\t\t}\n\t\t//the agent follows the path it computed but with the real weights of the graph\n\t\tdo follow path:path_to_follow speed: 5 move_weights: roads_weight;\n\t}\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n}\n\nexperiment weightperagents type: gui {\n\tfloat minimum_cycle_duration <- 0.1;\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies road aspect: geom;\n\t\t\tspecies people aspect: base;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Agent-movement-Follow-Weighted-Network-(Agents).md"},"Agent-movement-Goto-Directed-Graph.md":{"title":"  Directed Graph Model","content":"[//]: # (keyword|operator_polyline)\n[//]: # (keyword|operator_reverse)\n[//]: # (keyword|operator_directed)\n[//]: # (keyword|statement_switch)\n[//]: # (keyword|statement_match)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n#  Directed Graph Model\n\n\n_Author :  Patrick Taillandier_\n\nModel representing how to directed graph using GIS Data for the road networks : the GIS contains a column defining the direction of the roads and people moving from one random point to another on this graph\n\n\nCode of the model : \n\n```\n\nmodel simplemodel\n\nglobal {\n\tfile road_file <- file(\"../includes/gis/roads.shp\");\n\tgeometry shape <- envelope(road_file);\n\tgraph the_graph; \n\t\n\tinit {\n\t\tcreate road from: road_file with:[direction::int(read(\"DIRECTION\"))] {\n\t\t\tswitch direction {\n\t\t\t\tmatch 0 {color <- #green;}\n\t\t\t\tmatch 1 {color <- #red;\n\t\t\t\t\t//inversion of the road geometry\n\t\t\t\t\tshape <- polyline(reverse(shape.points));\n\t\t\t\t}\n\t\t\t\tmatch 2 {color <- #blue;\n\t\t\t\t\t//bidirectional: creation of the inverse road\n\t\t\t\t\tcreate road {\n\t\t\t\t\t\tshape <- polyline(reverse(myself.shape.points));\n\t\t\t\t\t\tdirection <- 2;\n\t\t\t\t\t\tcolor <- #blue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\t//The operator directed modify the graph created by as_edge_graph(road) to a directed graph\n\t\tthe_graph <- directed(as_edge_graph(road)) ;\n\t\t\n\t\t\n\t\tcreate people number: 1000 {\n\t\t\t//The operator any_location_in returns a random point located in one of the road agents\n\t\t\ttarget <- any_location_in(one_of (road)) ;\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t\tsource <- location;\n\t\t} \n\t}\n}\n\nspecies road {\n\tint direction;\n\trgb color;\n\taspect geom {\n\t\tdraw shape color: color;\n\t}\n}\n//The people agents use the skill moving which have built-in variables such as speed, target, location, heading and built-in operators\nspecies people skills: [moving] {\n\tpoint target;\n\tpath my_path; \n\tpoint source;\n\tstring r_s;\n\tstring r_t; \n\taspect circle {\n\t\tdraw circle(10) color: #green;\n\t}\n\t\n\treflex movement {\n\t\t\n\t\t//The operator goto is a built-in operator derivated from the moving skill, moving the agent from its location to its target, \n\t\t//   restricted by the on variable, with the speed and returning the path followed\n\t\tmy_path <- self goto (on:the_graph, target:target, speed:10, return_path: true);\n\t\t\n\t\t//If the agent arrived to its target location, then it choose randomly an other target on the road\n\t\tif (target = location) {\t\t\t\n\t\t\ttarget <- any_location_in(one_of (road)) ;\n\t\t\tsource <- location;\n\t\t}\n\t}\n}\n\nexperiment simplemodel type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies road aspect: geom;\n\t\t\tspecies people aspect: circle;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Agent-movement-Goto-Directed-Graph.md"},"Agent-movement-Goto-Grid.md":{"title":"  Movement on a Grid of Cells","content":"[//]: # (keyword|operator_intersects)\n[//]: # (keyword|constant_#magenta)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_obstacle)\n[//]: # (keyword|concept_shortest_path)\n#  Movement on a Grid of Cells\n\n\n_Author :  Patrick Taillandier_\n\nModel to represent how the agents move from one point to a target agent on a grid of cells with obstacles, following the shortest path and coloring in magenta the cells intersecting the path of an agent\n\n\nCode of the model : \n\n```\n\nmodel Grid\n\nglobal {\n\tinit {    \n\t\tcreate goal{\n\t\t\tlocation <- (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t\tcreate people number: 10 {\n\t\t\ttarget <- one_of (goal);\n\t\t\tlocation <-  (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t} \n}\n\ngrid cell width: 50 height: 50 neighbors: 4 {\n\tbool is_obstacle <- flip(0.2);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\t \nspecies goal {\n\taspect default { \n\t\tdraw circle(0.5) color: #red;\n\t}\n}  \n\t\n\t  \nspecies people skills: [moving] {\n\tgoal target;\n\tfloat speed <- float(3);\n\t\n\taspect default {\n\t\tdraw circle(0.5) color: #green;\n\t}\n\t\n\treflex move when: location != target{\n\t\t//Neighs contains all the neighbours cells that are reachable by the agent plus the cell where it's located\n\t\tlist<cell> neighs <- (cell(location) neighbors_at speed) + cell(location); \n\t\t\n\t\t//We restrain the movements of the agents only at the grid of cells that are not obstacle using the on facet of the goto operator and we return the path\n\t\t//followed by the agent\n\t\t//the recompute_path is used to precise that we do not need to recompute the shortest path at each movement (gain of computation time): the obtsacles on the grid never change.\n\t\tpath followed_path <- self goto (on:(cell where not each.is_obstacle), target:target, speed:speed, return_path:true, recompute_path: false);\n\t\t\n\t\t//As a side note, it is also possible to use the path_between operator and follow action with a grid\n\t\t//Add a my_path attribute of type path to the people species\n\t\t//if my_path = nil {my_path <- path_between((cell where not each.is_obstacle), location, target);}\n\t\t//path followed_path <- self follow (path: my_path,  return_path:true);\n\t\t\n\t\tif (followed_path != nil) and not empty(followed_path.segments) {\n\t\t\tgeometry path_geom <- geometry(followed_path.segments);\n\t\t\t\n\t\t\t//The cells intersecting the path followed by the agent are colored in magenta\n\t\t\task (neighs where (each.shape intersects path_geom)) { color <- #magenta;}\n\t\t}\t\n\t}\n}\n\nexperiment goto_grid type: gui {\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tgrid cell lines: #black;\n\t\t\tspecies goal aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Agent-movement-Goto-Grid.md"},"Agent-movement-Goto-Network.md":{"title":"  Shortest Path Computation on a Graph","content":"[//]: # (keyword|operator_with_optimizer_type)\n[//]: # (keyword|operator_use_cache)\n[//]: # (keyword|operator_load_shortest_paths)\n[//]: # (keyword|operator_all_pairs_shortest_path)\n[//]: # (keyword|statement_save)\n[//]: # (keyword|type_path)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_shortest_path)\n[//]: # (keyword|concept_algorithm)\n#  Shortest Path Computation on a Graph\n\n\n_Author :  Patrick Taillandier_\n\nModel to show how to use the optimizer methods to compute the shortest path for the agents placed on a network with all of them having the same goal location. It also shows how to save these paths computed into a text file.\n\n\nCode of the model : \n\n```\n\nmodel Network\n\nglobal {\n\tfile shape_file_in <- file('../includes/gis/roads.shp') ;\n\tgraph the_graph; \n\tgeometry shape <- envelope(shape_file_in);\n\tbool save_shortest_paths <- false;\n\tbool load_shortest_paths <- false;\n\tstring shortest_paths_file <- \"../includes/shortest_paths.csv\";\n\tbool memorize_shortest_paths <- true;\n\t\n\t/*4 type of optimizer can be used for the shortest path computation:\n\t *    - Djikstra: the default one - ensure to find the best shortest path - compute one shortest path at a time (by default, memorise the shortest path found)\n\t * \t  - Bellmann: ensure to find the best shortest path - compute one shortest path at a time (by default, memorise the shortest path found)\n\t * \t  - AStar: do not ensure to find the best shortest path - compute one shortest path at a time (by default, memorise the shortest path found)\n\t *    - Floyd Warshall: ensure to find the best shortest path - compute all the shortest pathes at the same time (and keep them in memory)\n\t */\n\tstring optimizer_type <- \"Djikstra\";\n\tint nb_people <- 100;\n\tinit {    \n\t\tcreate road from: shape_file_in ;\n\t\tthe_graph <- as_edge_graph(list(road));\n\t\t\n\t\t//allows to choose the type of algorithm to use compute the shortest paths\n\t\tthe_graph <- the_graph with_optimizer_type optimizer_type;\n\t\t\n\t\t//allows to define if the shortest paths computed should be memorized (in a cache) or not\n\t\tthe_graph <- the_graph use_cache memorize_shortest_paths;\n\t\t\n\t\t//computes all the shortest paths, puts them in a matrix, then saves the matrix in a file\n\t\tif save_shortest_paths {\n\t\t\tmatrix ssp <- all_pairs_shortest_path(the_graph);\n\t\t\tsave ssp type:\"text\" to:shortest_paths_file;\n\t\t\t\n\t\t//loads the file of the shortest paths as a matrix and uses it to initialize all the shortest paths of the graph\n\t\t} else if load_shortest_paths {\n\t\t\tthe_graph <- the_graph load_shortest_paths matrix(file(shortest_paths_file));\n\t\t}\n\t\t\n\t\tcreate goal number: 1 {\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t}\n\t\tcreate people number: nb_people {\n\t\t\ttarget <- one_of (goal) ;\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t} \n\t}\n}\n\nspecies road  {\n\tfloat speed_coef ;\n\taspect default {\n\t\tdraw shape color: #black ;\n\t}\n} \n\t\nspecies goal {\n\taspect default {\n\t\tdraw circle(50) color: #red;\n\t}\n}\n\t\nspecies people skills: [moving] {\n\tgoal target;\n\tpath my_path; \n\t\n\taspect default {\n\t\tdraw circle(50) color: #green;\n\t}\n\treflex movement {\n\t\tdo goto on:the_graph target:target speed:1;\n\t}\n}\n\n\nexperiment goto_network type: gui {\n\tparameter \"Type of optimizer\" var: optimizer_type among: [\"Djikstra\", \"AStar\", \"Bellmann\", \"Floyd Warshall\"];\n\tparameter \"Number of people\" var: nb_people min: 1 max: 1000000;\n\tparameter \"Computed all the shortest paths and save the results\" var: save_shortest_paths;\n\tparameter \"Load the shortest paths from the file\" var: load_shortest_paths;\n\t\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tspecies road aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t\tspecies goal aspect: default ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Agent-movement-Goto-Network.md"},"Agent-movement-Goto-Polygon.md":{"title":"  Movement on a Graph created by Polygons","content":"[//]: # (keyword|operator_triangulate)\n[//]: # (keyword|operator_skeletonize)\n[//]: # (keyword|operator_split_lines)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_shortest_path)\n#  Movement on a Graph created by Polygons\n\n\n_Author :  Patrick Taillandier_\n\nModel to show how to create a graph using a polygon shapefile by skeletonizing it, and creating roads using the skeleton. All of the agents will use this graph to go to the same targeted location.\n\n\nCode of the model : \n\n```\n\nmodel polygon\nglobal {\n\t//Import of the shapefile containing the different polygons\n\tfile shape_file_in <- file('../includes/gis/squareHole.shp') ;\n\tgraph the_graph;\n\t\n\tgeometry shape <- envelope(shape_file_in);\n\t\n\tinit {    \n\t\tcreate object from: shape_file_in ;\n\t\tobject the_object <- first(object);\n\t\t\n\t\t//triangulation of the object to get the different triangles of the polygons\n\t\tlist<geometry> triangles <- list(triangulate(the_object));\n\t\t\n\t\tloop trig over: triangles {\n\t\t\tcreate triangle_obj {\n\t\t\t\tshape <- trig;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//creation of a list of skeleton from the object \n\t\tlist<geometry> skeletons <- list(skeletonize(the_object));\n\t\t\n\t\t//Split of the skeletons list according to their intersection points\n\t\tlist<geometry> skeletons_split  <- split_lines(skeletons);\n\t\tloop sk over: skeletons_split {\n\t\t\tcreate skeleton {\n\t\t\t\tshape <- sk;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Creation of the graph using the edges resulting of the splitted skeleton\n\t\t the_graph <- as_edge_graph(skeleton);\n\t\t \n\t\t \n\t\tcreate goal  {\n\t\t\t location <- any_location_in (one_of(skeleton)); \n\t\t}\n\t\tcreate people number: 100 {\n\t\t\t target <- one_of (goal) ; \n\t\t\t location <- any_location_in (one_of(skeleton));\n\t\t} \n\t}\n}\n\nspecies object  {\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}\n\nspecies triangle_obj  {\n\trgb color <- rgb(150 +rnd(100),150 + rnd(100),150 + rnd(100));\n\taspect default {\n\t\tdraw shape color: color ; \n\t}\n}\n\nspecies skeleton  {\n\taspect default {\n\t\tdraw shape + 0.2 color: #red ;\n\t}\n}\n\t\nspecies goal {\n\taspect default {\n\t\tdraw circle(3) color:#red;\n\t}\n}\n\nspecies people skills: [moving] {\n\tgoal target;\n\tpath my_path; \n\t\n\treflex goto {\n\t\tdo goto on:the_graph target:target speed:1;\n\t}\n\taspect default {\n\t\tdraw circle(3) color: #green;\n\t}\n}\n\nexperiment goto_polygon type: gui {\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tspecies object aspect: default ;\n\t\t\tspecies triangle_obj aspect: default ;\n\t\t\tspecies skeleton aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t\tspecies goal aspect: default ;\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Agent-movement-Goto-Polygon.md"},"Agent-movement-Moving3D.md":{"title":"  Movement in 3D","content":"[//]: # (keyword|operator_cube)\n[//]: # (keyword|operator_sin)\n[//]: # (keyword|operator_floor)\n[//]: # (keyword|operator_as_distance_graph)\n[//]: # (keyword|skill_moving3D)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_skill)\n#  Movement in 3D\n\n\n_Author :  Arnaud Grignard - Tri Nguyen Huu_\n\nThis model illustrates the different action and effect offered by the movingSkill3D (move,wander,goto and follow)\n\n\nCode of the model : \n\n```\n\n\n\nmodel Moving3DModel   \n\nglobal {\n\tint number_of_agents parameter: 'Number of Agents' min: 1 <- 250 step:10 category: 'Initialization'; \n\tint envSize <-100; //max:100;\n\tint mazeSize <-10;\n\tint radius parameter: 'Radius' min: 1 <- 1 ;\n\tint directionSize parameter: 'direction size' min: 1 <- 10 ;\n\tstring effectType <-\"\";// among:[\"\",\"firework\", \"blob\",\"direction\"];\n\tstring movingType <-\"move\";\n\tgraph mazeGraph;\n\tgeometry shape <- cube(envSize);\n\tbool trace <-false;\n\tstring agentAspect <- \"sphere\" among:[\"circle\", \"sphere\",\"direction\"];\n\n\tinit { \n\t\t\n\t\tif(movingType = \"move\" or movingType = \"complete\"){\n\t\t  create movingAgent number: number_of_agents{\n\t\t  \tif(effectType = \"firework\"){\n\t\t  \t  location <- {envSize/2, envSize/2, envSize/2};\t\n\t\t  \t}\n\t\t  \telse{\n\t\t  \t\tlocation <- {rnd(envSize), rnd(envSize), rnd(envSize)};\n\t\t  \t}\n\t\t    color<-°red;\t\n\t\t  }\t\n\t\t}\n\t\t\n\t\tif(movingType = \"wander\" or movingType = \"complete\"){\n\t\t\tcreate wanderAgent number: number_of_agents{\n\t\t\t  location <- {rnd(envSize), rnd(envSize), rnd(envSize)};\n\t\t\t  color<-°green;\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(movingType = \"goto\" or movingType = \"complete\"){\n\t\t\tcreate gotoAgent number: number_of_agents{\n\t\t\t  location <- {rnd(envSize), rnd(envSize), rnd(envSize)};\n\t\t\t  myTarget <-{rnd(envSize),rnd(envSize),rnd(envSize)};\n\t\t\t  color<-°yellow;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(movingType = \"gotoOnNetwork\" or movingType = \"complete\"){\n\t\t\t\n\t\t\tloop i from:0 to:mazeSize{\n\t\t      loop j from:0 to: mazeSize{\n\t\t\t    loop k from:0 to:mazeSize{\n\t\t\t      create cell{\n\t\t\t\t    location <-{(i)*envSize/mazeSize,(j)*envSize/mazeSize, (k)*envSize/mazeSize};\n\t\t\t      }\t\n\t\t\t    }\t\n\t          }\n\t\t    }\n\t\t    create gotoAgentOnNetwork number: number_of_agents{\n\t\t\t  location <- {floor(rnd(envSize)/mazeSize)*10, floor(rnd(envSize)/mazeSize)*10, floor(rnd(envSize)/mazeSize)*10};\n\t\t\t  myTarget <-{0,0,0};\n\t\t\t  speed <-0.1;\n\t\t\t  color<-°orange;\t\t\n\t\t\t}\n\t\t    mazeGraph <- as_distance_graph(cell, [\"distance\"::10.0,\"species\"::edge_agent]);\n\t\t}\n\t }\n}\n\nspecies abstractAgent skills: [moving3D]{\n\trgb color;\n\taspect default {\n\t\tif(agentAspect = \"sphere\"){\n\t\t\tdraw sphere(radius) color:color;\n\t\t}\n\t\tif(agentAspect = \"circle\"){\n\t\t\tdraw circle(radius) color:color;\n\t\t}\n\t\tif(agentAspect = \"direction\"){\n\t\t  draw sphere(radius) color:color;\n          draw line([{location.x,location.y,location.z},{location.x+directionSize*cos(pitch)*cos(heading),location.y+directionSize*cos(pitch)*sin(heading),location.z+directionSize*sin(pitch)}]) end_arrow:1.0 color:color;\t\n\t\t}  \t \t\n    }\n} \n\nspecies movingAgent  parent:abstractAgent{ \n\treflex move{\n\t  do move;\n\t}\t\t\n}\n\nspecies wanderAgent parent:abstractAgent{ \n\treflex wander{\n\t  do wander amplitude:90;\n\t}\n}\n\nspecies gotoAgent parent:abstractAgent{ \n\tpoint myTarget;\n\tstring gotoType;\n\treflex goto{\n\t\tif(effectType = \"blob\"){\n\t\t\tmyTarget<-{rnd(envSize),rnd(envSize),rnd(envSize)};\n\t\t}\n\t  \tdo goto target:myTarget;\t  \n\t}\n}\n\nspecies gotoAgentOnNetwork parent:abstractAgent{ \n\tpoint myTarget;\n\tstring gotoType;\n\treflex goto{\n\t  \tdo goto target:myTarget on: mazeGraph;\n\t}\t\t\n}\n\nspecies followAgent parent:abstractAgent{ \n\tpoint myTarget;\n\tstring gotoType;\n\treflex goto{\n\t  if(gotoType = \"goto\"){\n\t  \tdo goto target:myTarget;\n\t  }\n\t  if(gotoType = \"gotoOnNetwork\"){\n\t  \tdo goto target:myTarget on: mazeGraph;\n\t  }\n\t  \n\t}\t\n}\n    \nspecies cell schedules:[]{\n\t\n\taspect myPoint{\n\t\tdraw sphere(0.01 * envSize/mazeSize) color:rgb(255,255,255,0.5) at:location ;\n\t}\n\t\n}\n\nspecies edge_agent schedules:[]{\n\taspect base2 {\n\t\tdraw shape color: rgb(255,255,255);\n\t}\n}\n\t\n\nexperiment Moving  type: gui {\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"move\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\tparameter \"Effect type\" var:effectType <- \"\" among:[\"\",\"firework\"];\n\toutput {\t\n\t\tdisplay MovingAgent type:opengl  background:rgb(10,40,55) {\n\t\t\tspecies movingAgent trace:trace;\n\t\t}\n\t}\n}\n\nexperiment Wandering  type: gui {\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"wander\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\toutput {\t\n\t\tdisplay WanderingAgent type:opengl  background:rgb(10,40,55) {\n\t\t\tspecies wanderAgent trace:trace;\n\t\t}\n\t}\n}\n\nexperiment Goto  type: gui {\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"goto\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\tparameter \"Effect Type\" var:effectType <- \"\" among:[\"\",\"blob\"];\n\toutput {\t\n\t\tdisplay GotoAgent type:opengl  background:rgb(10,40,55) {\n\t\t\tspecies gotoAgent trace:trace;\n\t\t}\n\t}\n}\n\nexperiment GotoOnNetwork  type: gui {\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"gotoOnNetwork\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\toutput {\n\t\t\t\n\t\tdisplay GotoOnNetworkAgent type:opengl background:rgb(10,40,55) {\n\t\t\tspecies gotoAgentOnNetwork trace:trace;\n\t\t\tspecies cell aspect:myPoint;\n\t\t\tspecies edge_agent aspect: base2 ;\n\t\t}\n\t}\n}\n\nexperiment Complete  type: gui {\n\tparameter \"Trace\" var:trace <- false;\n\tparameter \"Movement\" var:movingType <- \"complete\";\n\tparameter \"Agent Aspect\" var:agentAspect <- \"direction\";\n\toutput {\n\t\t\t\n\t\tdisplay GotoOnNetworkAgent type:opengl background:rgb(10,40,55) {\n\t\t\tspecies movingAgent position:{0,0,0} trace:trace;\n\t\t\tspecies wanderAgent position:{envSize,0,0} trace:trace;\n\t\t\tspecies gotoAgent position:{envSize*2,0,0} trace:trace;\n\t\t\tspecies gotoAgentOnNetwork position:{envSize*3,0,0} trace:trace;\n\t\t\tspecies cell aspect:myPoint position:{envSize*3,0,0};\n\t\t\tspecies edge_agent aspect: base2 position:{envSize*3,0,0};\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n```\n","url":"wiki/Agent-movement-Moving3D.md"},"Batch-Batch.md":{"title":"  Model using Batch mode","content":"[//]: # (keyword|operator_among)\n[//]: # (keyword|statement_save)\n[//]: # (keyword|statement_exhaustive)\n[//]: # (keyword|statement_permanent)\n[//]: # (keyword|statement_genetic)\n[//]: # (keyword|statement_tabu)\n[//]: # (keyword|constant_#darkgreen)\n[//]: # (keyword|concept_batch)\n[//]: # (keyword|concept_algorithm)\n[//]: # (keyword|concept_save_file)\n#  Model using Batch mode\n\n\n_Author :  Patrick Taillandier_\n\nA model showing how to use batch experiments to find the best combination of parameters to minimize the numbers of infected people in a SIR infection model where agents infect others and become immune for a certain time. The batch mode uses three different methods : Exhaustive, GA and Tabu Search. The model proposes five experiments : one simple with a User Interface, one running 5 experiments and saving the data, and one for each strategy. \n\n\nCode of the model : \n\n```\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 300;  // The init number of people\n    int number_I <- 1 ;\t// The init number of infected\n    float infection_rate <- 0.1 ; // The infection rate\n\tfloat infection_distance <- 5.0 ; // infection distance (in meters)\n\tint immune_step <- 30 ; // number of steps before becoming immune after infection\n\tint end_immunity_step <-50; // number of steps before not being immune anymore\n\tfloat speed_people <- 5.0 ; // speed of the Host\n\n\tint nb_infected <- 0;\n\tinit {\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex end_of_immunity when: is_immune {\n\t\tif (cpt > end_immunity_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- false;\n\t\t\tcolor <-  #green;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t\tnb_infected <- nb_infected + 1;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of infected people\" value: nb_infected;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\n\n// This experiment runs the simulation 5 times.\n// At the end of each simulation, the people agents are saved in a shapefile\nexperiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {\n\t\n\t// the reflex will be activated at the end of each run; in this experiment a run consists of the execution of 5 simulations (repeat: 5)\n\treflex end_of_runs\n\t{\n\t\tint cpt <- 0;\n\t\t// each simulation of the run is an agent; it is possible to access to the list of these agents by using the variable \"simulations\" of the experiment. \n\t\t// Another way of accessing to the simulations consists in using the name of model + _model: here \"batch_example_model\"\n\t\t//in this example, we ask all the simulation agents of the run to save (at the end of the simulation) the people population in a shapefile with their is_infected and is_immune attributes \n\t\task simulations\n\t\t{\n\t\t\tsave people type: \"shp\" to: \"people_shape\" + cpt + \".shp\" with: [is_infected::\"INFECTED\", is_immune::\"IMMUNE\"];\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n}\n\n// This experiment explores two parameters with an exhaustive strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the mean fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment 'Exhaustive optimization' type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {\n\tparameter 'Infection rate' var: infection_rate among: [ 0.1 , 0.5 , 1.0 ];\n\tparameter 'Speed of people:' var: speed_people min: 1.0 max: 3.0 step:1.0;\n\tmethod exhaustive minimize: nb_infected;\n\t\n\t//the permanent section allows to define a output section that will be kept during all the batch experiment\n\tpermanent {\n\t\tdisplay Comparison {\n\t\t\tchart \"Number of people infected\" type: series {\n\t\t\t\t//we can access to all the simulations of a run (here composed of 5 simulation -> repeat: 5) by the variable \"simulations\" of the experiment.\n\t\t\t\t//here we display for the 5 simulations, the mean, min and max values of the nb_infected variable.\n\t\t\t\tdata \"Mean\" value: mean(simulations collect each.nb_infected ) style: spline color: #blue ;\n\t\t\t\tdata \"Min\" value:  min(simulations collect each.nb_infected ) style: spline color: #darkgreen ;\n\t\t\t\tdata \"Max\" value:  max(simulations collect each.nb_infected ) style: spline color: #red ;\n\t\t\t}\n\t\t}\t\n\t}\n}\n\n// This experiment explores two parameters with a GA strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the min fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Genetic type: batch keep_seed: true repeat: 3 until: ( time > 1000 ) {\n\tparameter 'Infection rate' var: infection_rate among: [ 0.1 ,0.2, 0.5 , 0.6,0.8, 1.0 ];\n\tparameter 'Speed of people:' var: speed_people min: 1.0 max: 10.0 step:1.0;\n\tmethod genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1\n\tnb_prelim_gen: 1 max_gen: 5  minimize: nb_infected  aggregation: \"min\";\n}\n\n// This experiment explores two parameters with a Tabu Search strategy,\n// repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n// in order to find the best combination of parameters to minimize the number of infected people\nexperiment Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 1000 ) {\n\tparameter 'Infection rate' var: infection_rate among: [ 0.1 ,0.2, 0.5 , 0.6,0.8, 1.0 ];\n\tparameter 'Speed of people:' var: speed_people min: 1.0 max: 10.0 step:1.0;\n\tmethod tabu iter_max: 10 tabu_list_size: 5 minimize: nb_infected aggregation: \"max\";\n}\n```\n","url":"wiki/Batch-Batch.md"},"Charts-Ant-Foraging-(Charts-examples).md":{"title":" Ant Foraging (Charts examples)","content":"[//]: # (keyword|operator_min_of)\n[//]: # (keyword|operator_sort)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_contains)\n[//]: # (keyword|operator_distribution_of)\n[//]: # (keyword|operator_reverse)\n[//]: # (keyword|operator_distribution2d_of)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|statement_datalist)\n[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|constant_#violet)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_chart)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_diffusion)\n# Ant Foraging (Charts examples)\n\n\n_Author : _\n\nToy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. In this model, the charts are particularly used.\n\n\nCode of the model : \n\n```\nmodel ants\n\nglobal {\n\t//Number of ants\n\tint ants_number <- 100 min: 1 max: 2000 ;\n\t//Evaporation value per cycle for the pheromons\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 ;\n\t//Diffusion rate for the pheromons\n\tfloat diffusion_rate <- 1.0 min: 0.0 max: 1.0 ;\n\tbool use_icons <- true ;\n\tbool display_state <- true;\n\t//Size of the grid\n\tint gridsize <- 75 ;\n\t//Center of the grid to put the location of the nest\n\tpoint center const: true <- { (gridsize / 2),  (gridsize / 2)} ;\n\tfile types const: true <- (pgm_file('../images/environment75x75.pgm')) ;\n\tstring ant_shape_empty const: true <- '../icons/ant.png' ;\n\tstring ant_shape_full const: true <- '../icons/full_ant.png'  ;\n\trgb C00CC00 const: true <- rgb('#00CC00') ;    \n\trgb C009900 const: true <- rgb('#009900') ; \n\trgb C005500 const: true <- rgb('#005500') ; \n\tint food_gathered <- 0 ;   \n\tgeometry shape <- square(gridsize);\n\tinit{  \n\t\t//Ant are placed randomly in the nest\n\t\tcreate ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;\n\t}\n\t\n\t//Reflex to diffuse the road of pheromon on the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;\n   }\n\n\n\n}\n\n//Grid to discretize space for the food and the nest\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {\n\tbool multiagent <- true ;\n\tfloat road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\n\tint type <- int(types at {grid_x,grid_y}) ;\n\tbool isNestLocation <- (self distance_to center) < 4 ; \n\tbool isFoodLocation <- type = 2 ; \n\trgb color <- isNestLocation ? °violet:((food > 0)? °blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) update: isNestLocation ? °violet:((food > 0)? °blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) ;\n\tint food <- isFoodLocation ? 5 : 0 ;\n\tint nest const: true <- 300 - int(self distance_to center) ;\n\t\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 2.0 ;\n\tant_grid place update: ant_grid (location ); \n\tstring im <- 'ant_shape_empty' ;\n\tbool hasFood <- false ;\n\n\n\n\treflex diffuse_road when:hasFood=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n   //Action to pick food\n\taction pick {\n\t\tim <- ant_shape_full ;\n\t\thasFood <- true ;\n\t\tplace.food <- place.food - 1 ;\n\t}\n\t//Action to drop food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1 ;\n\t\thasFood <- false ;\n\t\theading <- heading - 180 ;\n\t}\n\t//Action to chose the best place according to the possible food in the neighbour cells\n\taction choose_best_place type: ant_grid {\n\t\tlist<ant_grid> list_places <- place.neighbors ;\n\t\tif (list_places count (each.food > 0)) > 0  {\n\t\t\treturn (list_places first_with (each.food > 0)) ;\n\t\t} else {\n\t\t\t\tint min_nest  <-  (list_places min_of (each.nest)) ;\n\t\t\t\tlist_places <- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;\n\t\t\t\treturn last(list_places) ;\n\t\t\t}\n\t}\n\t\n\t//Initial state of the ant : wander until it finds food or find a road to follow\n\tstate wandering initial: true {\n\t\tdo wander amplitude:120 ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: followingRoad when: place.road > 0.05 ;\n\t}\n\t//State to carry food to the nest once the food is found\n\tstate carryingFood {\n\t\tdo goto target: center ;\n\t\ttransition to: wandering when: place.isNestLocation { \n\t\t\tdo drop ;\n\t\t}\n\t}\n\t//State to follow a road \n\tstate followingRoad {\n\t\tlocation <- (self choose_best_place []) as point ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: wandering when: (place.road < 0.05) ;\n\t}\n\taspect text {\n\t\tif use_icons {\n\t\t\tdraw  hasFood ? file(ant_shape_full) : file(ant_shape_empty) rotate: heading at: location size: {7,5} ;\n\t\t} else {\n\t\t\tdraw circle(1.0) empty: !hasFood color: rgb ('orange') ;\n\t\t}\n\t\tif display_state {\n\t\t\tdraw state at: location + {-3,1.5} color: °white size: 0.8 ;\n\t\t}\n\t}\n\taspect default {\n\t\tdraw circle(1.0) empty: !hasFood color: #orange ; \n\t}\n}\nexperiment Ant type: gui {\n\t//Parameters to play with  in the gui\n\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\n\tparameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\n\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\n\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\n\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\n\n\tlist<list<int>> nbants<-[[0]];\n\tlist<string> statesnames<-[\"wandering\"];\n\tlist<string> categnames<-[\"empty\",\"carry\"];\n\tlist<list<int>> nbantsbydist<-[[0]];\n\tlist xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\n\tlist<list<int>> xyval<-[[1,1],[2,1],[3,2]];\n\n\t//Reflex to update the charts, belonging to the experiment bloc as it will not be used by other experiment which don't have the charts\n\treflex update_charts\n\t{\n\t\tnbants<-list<list<int>>([]);\n\t\tstatesnames<-list<string>([]);\n\t\tcategnames<-[\"empty\",\"carry\"];\n\t\tnbantsbydist<-list<list<int>>([]);\n\t\tant x<-one_of(world.ant);\n\t\tloop x over:list(world.ant)\n\t\t{\n\t\t\tif !(statesnames contains (x.state))\n\t\t\t{\t\t\t\t\n\t\t\tadd [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;\n\t\t\tadd (x.state) to:statesnames;\t\t\t\t\n\t\t\tint d<-0;\n\t\t\tlist<int> nl<-list<int>([]);\n\t\t\tloop d from:0 to:9\n\t\t\t\t{\n\t\t\tadd (list(ant) count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;\n\t\t\t\t}\n\t\t\tadd nl to:nbantsbydist;\n\t\t\t}\n//\t\t\tadd length((list(world.ant) collect (each.next_place distance_to each.location)) where (each=x)) to:nbants;\n\t\t}\n\t\t//write(\"nbants\"+nbants);\n\t\t//write(\"nbantsbydist\"+nbantsbydist);\n\t\t//write(\"states\"+statesnames);\t\t\n\t}\n\t\n\t//The different displays\n\toutput {\n\t\tdisplay Ants type: opengl {\n\t\t\tgrid ant_grid ;\n\t\t\tspecies ant aspect: text ;\n\t\t}\n\t\tdisplay ProportionCarryFood {\n\t\t\tchart \"Proportions carrying: Pie\"  size: {0.5,0.5} position: {0, 0} type:pie\n\t\t\t{\n\t\t\t\tdata \"empty_ants\" value:(list(ant) count (!each.hasFood)) color:°red;\n\t\t\t\tdata \"carry_food_ants\" value:(list(ant) count (each.hasFood)) color:°green;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tchart \"Proportions carrying: Radar\"  size: {0.5,0.5} position: {0.5, 0} type:radar\n\t\t\taxes:#white\n\n\t\t\t{\n\t\t\t\tdata \"empty\" value:(list(ant) count (!each.hasFood)) \n\t\t\t\taccumulate_values:true\n\t\t\t\tcolor:°red;\t\t\t\t\n\t\t\t\tdata \"carry\" value:(list(ant) count (each.hasFood)) \n\t\t\t\taccumulate_values:true\n\t\t\t\tcolor:°blue;\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tchart \"Proportion: serie\"   size: {1.0,0.5} position: {0, 0.5} type:series \n\t\t\tseries_label_position: legend\n\t\t\tstyle:stack\n\t\t\t{\n\t\t\t\tdatalist [\"empty\",\"carry\"] accumulate_values:true \n\t\t\t\tvalue:[(list(ant) count (!each.hasFood)),(list(ant) count (each.hasFood))] \n\t\t\t\tcolor:[°red,°green];\t\t\t\t\n\t\t\t}\n\t\t}\n// idem with stacked bar:\n/* \n\t\tdisplay ProportionByState {\n\t\t\tchart \"DataListListBar\" type:histogram \n\t\t\tx_serie_labels: categnames \n\t\t\tseries_label_position: legend\n\t\t\t{\n\t\t\t\tdatalist value:nbants legend:statesnames style:stack;\n\t\t\t}\n\t\t\t\n\t\t}\n*/\n\t\t\t// Idem with datalist:\n//\t\tdisplay PositionByState {\n//\t\t\tchart \"Position by state (datalist)\" type:scatter\n//\t\t\t{\n//\t\t\t\tdatalist [\"empty\",\"carry\"] value:[((list(ant) where (!each.hasFood))  collect each.location),((list(ant) where (each.hasFood))  collect each.location)] color:[°red,°green] line_visible:false;\t\t\t\t\n//\t\t\t}\n//\t\t}\n\t\tdisplay CentroidPosition {\n\t\t\tchart \"Positions and History of Centroide and size by Carry state\" type:scatter\n\t\t\t{\n\t\t\t\tdatalist [\"avg-carry\",\"avg-empty\"] value:[mean((list(ant) where (each.hasFood)) collect each.location),\n\t\t\t\t\tmean((list(ant) where (!each.hasFood)) collect each.location)\n\t\t\t\t]\n\t\t\t\tmarker_size: [length(list(ant) where (each.hasFood))/20,length(list(ant) where (!each.hasFood))/20]\n\t\t\t\t\t color:[°red,°green] \n\t\t\t\t\t fill:false\n\t\t\t\t\t line_visible:true;\t\t\t\t\n\t\t\t\tdata \"empty_ants\" value:((list(ant) where (!each.hasFood)) collect each.location) color:°red \n\t\t\t\taccumulate_values:false\n\t\t\t\tline_visible:false;\n\t\t\t\tdata \"carry_food_ants\" value:((list(ant) where (each.hasFood)) collect each.location) \n\t\t\t\taccumulate_values:false\n\t\t\t\tcolor:°green line_visible:false;\n\n\t\t\t}\n\t\t}\t\n\t\tdisplay Distribution2dPosition {\n\t\t\tchart \"Distribution of the X positions\"   size: {0.65,0.3} position: {0.05, 0} type:histogram\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist (distribution_of(list(ant) collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:(distribution_of(list(ant) collect each.location.x,10,0,100) at \"values\");\n\t\t\t}\n\t\t\tchart \"Distribution of the Y positions\"   size: {0.3,0.7} position: {0.7, 0.28} type:histogram\n\t\t\treverse_axes:true\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist reverse(distribution_of(list(ant) collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:reverse(distribution_of(list(ant) collect each.location.x,10,0,100) at \"values\");\n\t\t\t}\n\n\t\t\tchart \"Distribution2d of the XvsY positions- heatmap\"   size: {0.7,0.7} position: {0, 0.3} type:heatmap\n\t\t\tx_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"legendx\")\n\t\t\ty_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"legendy\")\n\t\t\tseries_label_position:none\n\t\t\t{\n\t\t\t\tdata  \"XYdistrib\"\n\t\t\t\t\tvalue:(distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"values\")\n\t\t\t\t\tcolor:[#red];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay DistributionPosition {\n\t\t\tchart \"Distribution of the X positions\"   size: {0.92,0.3} position: {0, 0} type:histogram\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist (distribution_of(list(ant) collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:(distribution_of(list(ant) collect each.location.x,10,0,100) at \"values\");\n\t\t\t}\n\t\t\tchart \"Distribution of the X positions- heatmap\"   size: {1.0,0.7} position: {0, 0.3} type:heatmap\n\t\t\tx_serie_labels: (distribution_of(list(ant) collect each.location.x,10,0,100) at \"legend\")\n\t\t\ty_range:50\n\t\t\t{\n\t\t\t\tdata  \"Xdistrib\"\n\t\t\t\t\tvalue:(distribution_of(list(ant) collect each.location.x,10,0,100) at \"values\")\n\t\t\t\t\tcolor:[#red];\n\t\t\t}\n\t\t}\t\n\t\t}\n\t\n\t}\n\t\n//Experiment with only two display : the grid and the ants, and a chart\nexperiment AntOneDisp type: gui {\n\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\n\tparameter 'Evaporation of the signal unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\n\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\n\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\n\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\n\n\tlist<list<int>> nbants<-[[0]];\n\tlist<string> statesnames<-[\"\"];\n\tlist<string> categnames<-[\"empty\",\"carry\"];\n\tlist<list<int>> nbantsbydist<-[[0]];\n\tlist xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\n\tlist<list<int>> xyval<-[[1,1],[2,1],[3,2]];\n\n\treflex update_charts\n\t{\n\t\tant x<-one_of(world.ant);\n\t\tnbants<-list<list<int>>([]);\n\t\tstatesnames<-list<string>([]);\n\t\tloop x over:list(world.ant)\n\t\t{\n\t\t\tif !(statesnames contains (x.state))\n\t\t\t{\t\t\t\t\n\t\t\tadd [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;\n\t\t\tadd (x.state) to:statesnames;\t\t\t\t\n\t\t\tint d<-0;\n\t\t\tlist<int> nl<-list<int>([]);\n\t\t\tloop d from:0 to:9\n\t\t\t\t{\n\t\t\tadd (list(ant) count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;\n\t\t\t\t}\n\t\t\tadd nl to:nbantsbydist;\n\t\t\t}\n\t\t}\n\t\twrite(\"nbants\"+nbants);\n\t\twrite(\"nbantsbydist\"+nbantsbydist);\n\t\twrite(\"states\"+statesnames);\t\t\n\t}\n\toutput {\n\t\tdisplay Ants type: opengl {\n\t\t\tgrid ant_grid ;\n\t\t\tspecies ant aspect: text ;\n\t\t}\n\n\t\tdisplay ChartScatter {\n\t\t\tchart \"Distribution2d of the XvsY positions- heatmap\"   size: {0.7,0.7} position: {0, 0.3} type:heatmap\n\t\t\tx_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"legendx\")\n\t\t\ty_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"legendy\")\n\t\t\tseries_label_position:none\n\t\t\t{\n\t\t\t\tdata  \"XYdistrib\"\n\t\t\t\t\tvalue:(distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"values\")\n\t\t\t\t\tcolor:[#red];\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t}\n}\n\n\n\n\n\n```\n","url":"wiki/Charts-Ant-Foraging-(Charts-examples).md"},"Clustering-Clustering.md":{"title":"  Clustering of agents by K Means and DBScan","content":"[//]: # (keyword|operator_dbscan)\n[//]: # (keyword|operator_rnd_color)\n[//]: # (keyword|operator_kmeans)\n[//]: # (keyword|constant_#grey)\n[//]: # (keyword|concept_clustering)\n[//]: # (keyword|concept_statistic)\n#  Clustering of agents by K Means and DBScan\n\n\n_Author :  Patrick Taillandier_\n\nA model to show how to use clustering operators and two methods of clustering (K Means and DBScan) with the goal of regrouping agents in clusters\n\n\nCode of the model : \n\n```\n\nmodel clustering\n\nglobal {\n\t//the number of groups to create (kmeans)\n\tint k <- 4;\n\t\n\t//the maximum radius of the neighborhood (DBscan)\n\tfloat eps <- 10.0; \n\t\n\t//the minimum number of elements needed for a cluster (DBscan)\n\tint minPoints <- 3;\n\t\n\tinit {\n\t\t//create dummy agents\n\t\tcreate dummy number: 100;\n\t}\n\t\n\treflex cluster_building {\n\t\t//create a list of list containing for each dummy agent a list composed of its x and y values\n\t\tlist<list> instances <- dummy collect ([each.location.x, each.location.y]);\n\t\t\n\t\t//from the previous list, create groups with the eps and minPoints parameters and the DBSCAN algorithm (https://en.wikipedia.org/wiki/DBSCAN)\n\t\tlist<list<int>> clusters_dbscan <- list<list<int>>(dbscan(instances, eps,minPoints));\n\t\t\n\t\t//We give a random color to each group (i.e. to each dummy agents of the group)\n       loop cluster over: clusters_dbscan {\n\t\t\trgb col <- rnd_color(255);\n\t\t\tloop i over: cluster {\n\t\t\t\task dummy[i] {color_dbscan <- col;}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//from the previous list, create k groups  with the Kmeans algorithm (https://en.wikipedia.org/wiki/K-means_clustering)\n\t\tlist<list<int>> clusters_kmeans <- list<list<int>>(kmeans(instances, k));\n\t\t\n\t\t//We give a random color to each group (i.e. to each dummy agents of the group)\n\t\tloop cluster over: clusters_kmeans {\n\t\t\trgb col <- rnd_color(255);\n\t\t\tloop i over: cluster {\n\t\t\t\task dummy[i] {color_kmeans <- col;}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nspecies dummy {\n\trgb color_dbscan <- #grey;\n\trgb color_kmeans <- #grey;\n\taspect dbscan_aspect {\n\t\tdraw circle(2) color: color_dbscan;\n\t}\n\taspect kmeans_aspect {\n\t\tdraw circle(2) color: color_kmeans;\n\t}\n}\n\nexperiment clustering type: gui {\n\tparameter \"Number of clusters to split the data into\" var: k category: \"KMEANS\";\n\tparameter \"Maximum radius of the neighborhood to be considered\" var: eps category: \"DBSCAN\";\n\tparameter \"Minimum number of points needed for a cluster \" var: minPoints category: \"DBSCAN\";\n\toutput {\n\t\tdisplay map_dbscan{\n\t\t\tspecies dummy aspect: dbscan_aspect;\n\t\t}\n\t\tdisplay map_kmeans{\n\t\t\tspecies dummy aspect: kmeans_aspect;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Clustering-Clustering.md"},"Clustering-Spatial-Clustering.md":{"title":"  Clustering of agents by their distance ","content":"[//]: # (keyword|operator_is)\n[//]: # (keyword|operator_polyline)\n[//]: # (keyword|operator_simple_clustering_by_distance)\n[//]: # (keyword|operator_rnd_color)\n[//]: # (keyword|operator_hierarchical_clustering)\n[//]: # (keyword|operator_union)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_clustering)\n[//]: # (keyword|concept_statistic)\n[//]: # (keyword|concept_grid)\n#  Clustering of agents by their distance \n\n\n_Author :  Patrick Taillandier_\n\nA model to show how to use clustering operators with simple_clustering_by_distance to take into account the distances between agents or between cells to create the clusters,  and showing the relations between the people from the same cluster. \n\n\nCode of the model : \n\n```\n\nmodel clustering\n\nglobal {\n\t//define the maximal distance between people in the continuous environement (in meters): if the distance between 2 people is lower than this value, they will be in the same group\n\tfloat max_dist_people <- 20.0;\n\t\n\t//define the maximal distance between cells (in number of cells): if the distance between 2 cells is lower than this value, they will be in the same group\n\tint max_dist_cell <- 1;\n\t\n\t//probability for a cell to have vegetation\n\tfloat proba_vegetation <- 0.2;\n\t\n\t//create the people agents\n\tinit {\n\t\tcreate people number:20; \n    }\n    \n    //reflex that builds the people clusters\n    reflex people_clustering {\n    \t//clustering by using the simple clustering operator: two people agents are in the same groups if their distance is lower than max_dist_people (in meters)\n    \t//returns a list of lists (i.e. a list of groups, a group is a list of people agents)\n    \tlist<list<people>> clusters <- list<list<people>>(simple_clustering_by_distance(people, max_dist_people));\n        \n        //We give a random color to each group (i.e. to each people agents of the group)\n        loop cluster over: clusters {\n        \trgb rnd_color <- rnd_color(255);\n        \task cluster {\n        \t\tcolor_cluster <- rnd_color;\n        \t}\n        }\n        \n        //build the hierchical clustering (https://en.wikipedia.org/wiki/Hierarchical_clustering)\n        list clustering_tree <- hierarchical_clustering (people, max_dist_people);\n        \n        //create groups from the results of the hierarchical clustering\n        do create_groups(clustering_tree, nil);\n    }\n    \n    //recursive action that create group_people agents from the list of group.\n    action create_groups (list group, group_people parent_gp) {\n    \tbool compute_shape <- false;\n    \tloop el over: group {\n    \t\tif (el is people) {\n    \t\t\tparent_gp.shape <- people(el).shape;\n    \t\t}\n    \t\telse {\n    \t\t\tcreate group_people returns: created_g{\n    \t\t\t\tif (parent_gp != nil) {\n    \t\t\t\t\tadd self to: parent_gp.sub_groups;\n    \t\t\t\t}\n    \t\t\t\tparent <- parent_gp;\n    \t\t\t}\n    \t\t\tdo create_groups(el, first(created_g));\n    \t\t\tcompute_shape <- true;\n    \t\t}\n    \t}\n    \tif (compute_shape and parent_gp != nil) {\n    \t\task parent_gp {\n    \t\t\tshape <- polyline (sub_groups collect each.location);\n    \t\t}\n    \t\t\n    \t}\n    }\n    //reflex that builds the cell clusters\n    reflex forest_clustering {\n    \tlist<list<vegetation_cell>> clusters <- list<list<vegetation_cell>>(simple_clustering_by_distance(vegetation_cell where (each.color = #green), max_dist_cell));\n        loop cluster over: clusters {\n        \tcreate forest {\n        \t\tcells <- cluster;\n        \t\tshape <- union (cells);\n        \t}\n        }\n        list clustering_tree <- hierarchical_clustering (people, max_dist_people);\n    }\n    \n}\ngrid vegetation_cell width: 25 height: 25 neighbors: 4{\n\trgb color <- flip (proba_vegetation) ? #green : #white;\n}\n\nspecies forest {\n\tlist<vegetation_cell> cells;\n\taspect default {\n\t\tdraw shape.contour + 0.5 color: #red;\n\t}\n}\n\nspecies people {\n\trgb color_cluster <- #black;\n\trgb color_tree <- #black;\n\taspect cluster {\n\t\tdraw circle(2) color: color_cluster;\n\t}\n\taspect tree {\n\t\tdraw circle(2) color: color_tree;\n\t}\n}\n\nspecies group_people {\n\tlist<group_people> sub_groups;\n\tgroup_people parent;\n\taspect default {\n\t\tdraw shape + 0.2 color: #red;\n\t\tif (parent != nil) {\n\t\t\tdraw line ([location, parent.location]) end_arrow: 2 color: #red;\n\t\t}\n\t}\n}\n\nexperiment clustering type: gui {\n\tparameter \"Maximal distance for people clustering\" var: max_dist_people min: 0.0 max: 100.0 category: \"People\";\n\tparameter \"Maximal distance for vegetation cell clustering\" var: max_dist_cell min: 0 max: 5 category: \"Forest\";\n\tparameter \"Probability for vegetation cells\" var: proba_vegetation min: 0.1 max: 1.0 category: \"Forest\";\n\toutput {\n\t\tdisplay map_people_clusters {\n\t\t\tspecies people aspect: cluster;\n\t\t}\n\t\tdisplay map_people_tree {\n\t\t\tspecies people aspect: tree;\n\t\t\tspecies group_people;\n\t\t}\n\t\tdisplay map_forest_clusters {\n\t\t\tgrid vegetation_cell lines: #black;\n\t\t\tspecies forest;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Clustering-Spatial-Clustering.md"},"Co-model-Usage-comodel_mix_behaviors.md":{"title":" comodel with mixed behaviors ","content":"[//]: # (keyword|operator_dead)\n[//]: # (keyword|operator_any)\n[//]: # (keyword|operator_triangle)\n[//]: # (keyword|operator_sort)\n[//]: # (keyword|operator_round)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_font)\n[//]: # (keyword|operator_distance_between)\n[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|statement_agents)\n[//]: # (keyword|statement_overlay)\n[//]: # (keyword|statement_inspect)\n[//]: # (keyword|statement_exhaustive)\n[//]: # (keyword|statement_permanent)\n[//]: # (keyword|statement_genetic)\n[//]: # (keyword|constant_#lime)\n[//]: # (keyword|constant_#zoom)\n[//]: # (keyword|constant_#bold)\n[//]: # (keyword|constant_#plain)\n[//]: # (keyword|constant_#darkgray)\n[//]: # (keyword|constant_#pixels)\n[//]: # (keyword|constant_#darkgreen)\n[//]: # (keyword|concept_comodel)\n# comodel with mixed behaviors \n\n\n_Author : HUYNH Quang Nghi_\n\nThis is a simple comodel serve to demonstrate the mixing behaviors of preyPredator with the Ants. Ants are the prey, fleeing from Predators, when they are not chasing, they try to do job of the ants.\n\n\nImported models : \n\n```\nmodel ants\n\nglobal {\n\t//Evaporation value per cycle\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 parameter: 'Evaporation of the signal (unit/cycle):' category: 'Signals';\n\t//Diffusion rate of the pheromon among the grid\n\tfloat diffusion_rate <- 1.0 min: 0.0 max: 1.0 parameter: 'Rate of diffusion of the signal (%/cycle):' category: 'Signals';\n\t//Size of the grid\n\tint gridsize <- 100 min: 30 parameter: 'Width and Height of the grid:' category: 'Environment and Population';\n\t//Number of ants\n\tint ants_number <- 200 min: 1 parameter: 'Number of ants:' category: 'Environment and Population';\n\t//Frequency of update of the grid\n\tint grid_frequency <- 1 min: 1 max: 100 parameter: 'Grid updates itself every:' category: 'Environment and Population';\n\t//Number of food places among the grid\n\tint number_of_food_places <- 5 min: 1 parameter: 'Number of food depots:' category: 'Environment and Population';\n\tfloat grid_transparency <- 1.0;\n\tfile ant_shape_empty const: true <- file('../icons/ant.png');\n\timage_file ant_shape_full const: true <- file('../icons/full_ant.png');\n\t//The center of the grid that will be considered as the nest location\n\tpoint center const: true <- { round(gridsize / 2), round(gridsize / 2) };\n\tint food_gathered <- 1;\n\tint food_placed <- 1;\n\trgb background const: true <- rgb(#99CC66);\n\trgb food_color const: true <- rgb(#312200);\n\trgb nest_color const: true <- rgb(#000000); \n\n\tgeometry shape <- square(gridsize);\n\tinit {\n\t\t//Creation of the food places placed randomly with a certain distance between each\n\t\tloop times: number_of_food_places {\n\t\t\tpoint loc <- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };\n\t\t\tlist<ant_grid> food_places <- (ant_grid where ((each distance_to loc) < 5));\n\t\t\task food_places {\n\t\t\t\tif food = 0 {\n\t\t\t\t\tfood <- 5;\n\t\t\t\t\tfood_placed <- food_placed + 5;\n\t\t\t\t\tcolor <- food_color;  \n\t\t\t\t}                                           \n\t\t\t}\n\t\t}\n\t\t//Creation of the ants that will be placed in the nest\n\t\tcreate ant number: ants_number with: (location: center);\n\t}\n\t//Reflex to diffuse the pheromon among the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:3 propagation: gradient method:convolution;\n   }\n  \n}\n\n//Grid used to discretize the space to place food\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 frequency: grid_frequency use_regular_agents: false use_individual_shapes: false{\n\tbool is_nest const: true <- (topology(ant_grid) distance_between [self, center]) < 4;\n\tfloat road <- 0.0 max: 240.0 update: (road <= evaporation_per_cycle) ? 0.0 : road - evaporation_per_cycle;\n\trgb color <- is_nest ? nest_color : ((food > 0) ? food_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food > 0) ?\n\tfood_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5)));\n\tint food <- 0;\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 1.0;\n\tbool has_food <- false;\n\t\n\t//Reflex to place a pheromon stock in the cell\n\treflex diffuse_road when:has_food=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n\t//Action to pick food\n\taction pick (int amount) {\n\t\thas_food <- true;\n\t\tant_grid place <- ant_grid(location);\n\t\tplace.food <- place.food - amount;\n\t}\n\t//Action to drop food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1;\n\t\thas_food <- false;\n\t\theading <- heading - 180;\n\t}\n\t//Action to find the best place in the neighborhood cells\n\tpoint choose_best_place {\n\t\tcontainer list_places <- ant_grid(location).neighbors;\n\t\tif (list_places count (each.food > 0)) > 0 {\n\t\t\treturn point(list_places first_with (each.food > 0));\n\t\t} else {\n\t\t\tlist_places <- (list_places where ((each.road > 0) and ((each distance_to center) > (self distance_to center)))) sort_by (each.road);\n\t\t\treturn point(last(list_places));\n\t\t}\n\n\t}\n\t//Reflex to drop food once the ant is in the nest\n\treflex drop when: has_food and (ant_grid(location)).is_nest {\n\t\tdo drop();\n\t}\n\t//Reflex to pick food when there is one at the same location\n\treflex pick when: !has_food and (ant_grid(location)).food > 0 {\n\t\tdo pick(1);\n\t}\n\t//Initial state to make the ant wander \n\tstate wandering initial: true {\n\t\tdo wander(amplitude: 90);\n\t\tfloat pr <- (ant_grid(location)).road;\n\t\ttransition to: carryingFood when: has_food;\n\t\ttransition to: followingRoad when: (pr > 0.05) and (pr < 4);\n\t}\n\t//State to carry food once it has been found\n\tstate carryingFood {\n\t\tdo goto(target: center);\n\t\ttransition to: wandering when: !has_food;\n\t}\n\t//State to follow a pheromon road if once has been found\n\tstate followingRoad {\n\t\tpoint next_place <- choose_best_place();\n\t\tfloat pr <- (ant_grid(location)).road;\n\t\tlocation <- next_place;\n\t\ttransition to: carryingFood when: has_food;\n\t\ttransition to: wandering when: (pr < 0.05) or (next_place = nil);\n\t}\n\n\taspect info {\n\t\tdraw circle(1) empty: !has_food color: #red;\n\t\tif (destination != nil) {\n\t\t\tdraw line([location + {0,0,0.5}, destination + {0,0,0.5}]) + 0.1 color: #white border: false;\n\t\t}\n\n\t\tdraw circle(4) empty: true color: #white;\n\t\tdraw string(self as int) color: #white font: font(\"Helvetica\", 12 * #zoom, #bold) at: my location - {1, 1, -0.5};\n\t\tdraw state color: #yellow  font: font(\"Helvetica\", 10 * #zoom, #plain) at: my location + { 1, 1, 0.5 } perspective: false;\n\t}\n\n\taspect icon {\n\t\tdraw ant_shape_empty size: {7,5} rotate: my heading + 1;\n\t}\n\n\taspect default {\n\t\tdraw square(1) empty: !has_food color: #blue rotate: my heading;\n\t}\n}\t\n//Simple experiment to display the ants\nexperiment Displays type: gui {\n\tpoint quadrant_size <- { 0.5, 0.5 };\n\tfloat inc <- 0.001;\n\tfloat pos <- 0.0;\n\treflex moving_quadrant {\n\t//pos <- pos + inc;\n\t\tif (pos > 0.5 or pos <= 0) {\n\t\t\tinc <- -inc;\n\t\t}\n\t\t\n\t}\n\n\toutput {\n\t\tdisplay Ants background: #white type: opengl {\n\t\t\timage '../images/soil.jpg' position: { pos, pos } size: quadrant_size;\n\t\t\tagents \"agents\" transparency: 0.5 position: { pos, pos } size: quadrant_size value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n\t\t\tspecies ant position: { pos, pos } size: quadrant_size aspect: icon;\n\t\t\tgrid ant_grid lines: #darkgray position: { 0.5, 0 } size: quadrant_size;\n\t\t\tspecies ant position: { 0.5, 0 } size: quadrant_size aspect: info;\n\t\t}\n\t}\n}\n//Complete experiment that will inspect all ants in a table\nexperiment Complete type: gui {\n\tparameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\n\tparameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\n\tparameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\n\n\t// Experimentator\n\n\tinit {\n\t\twrite \"Experimentator agent running \" + self;\n\t   ants_number <- 200;\n\t}\n\n\n\toutput {\n\t\tdisplay Ants2D type: java2D {\n\t\t\timage '../images/soil.jpg' position: { 0.05, 0.05 } size: { 0.9, 0.9 };\n\t\t\tagents \"agents\" transparency: 0.7 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest)) ;\n\t\t\tspecies ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;\n\t\t\toverlay \"Texts\" transparency: 0.3 background: rgb (99, 85, 66,255)  position: {10°px, 10°px} size: {250°px, 150°px} border: rgb (99, 85, 66,255) rounded: true{\n\t\t\t\tdraw ant_shape_full at: {60°px, 70°px} size: {140°px, 100°px} rotate: -60;\n\t\t\t\tdraw ('Food foraged: ' + (((food_placed = 0 ? 0 : food_gathered / food_placed) * 100) with_precision 2) + '%') at: {40°px,70°px} font:font(\"Arial\", 18, #bold) color: #white;\n\t\t\t\tdraw ('Carrying ants: ' + (((100 * ant count (each.has_food or each.state = \"followingRoad\")) / length(ant)) with_precision 2) + '%') at: {40°px, 100°px} font:font(\"Arial\", 18 , #bold) color: #white;\n\t\t\t}\n\t\t\t\t\t\n\t\t}\n\t\tinspect \"All ants\" type: table value: ant attributes: ['name', 'location', 'heading','state'];\n\t}\n}\n//Batch experiment to find the best way to maximize the food gathered using exhaustive method\nexperiment Batch type: batch repeat: 4 keep_seed: true until: (food_gathered = food_placed) or (time > 1000) {\n\tparameter 'Size of the grid:' var: gridsize init: 75 unit: 'width and height';\n\tparameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';\n\tparameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';\n\tparameter  'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;\n\tmethod exhaustive maximize: food_gathered;\n\n\t\n\tpermanent {\n\t\tdisplay Comparison background: #white {\n\t\t\tchart \"Food Gathered\" type: series {\n\t\t\t\t\tdata \"Min\" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;\n\t\t\t\t\tdata \"Max\" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Batch experiment to find the best way to maximize the food gathered using genetic method\nexperiment Genetic type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time > 1000) {\n\tparameter 'Size of the grid:' var: gridsize init: 75 unit: '(width and height)';\n\tparameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';\n\tparameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';\n\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;\n\tmethod genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;\n\t\n\t\tpermanent {\n\t\tdisplay Comparison background: #white {\n\t\t\tchart \"Food Gathered\" type: series {\n\t\t\t\t\tdata \"Min\" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;\n\t\t\t\t\tdata \"Max\" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n\n```\nmodel Ants_coupling\n\nimport \"../../../Toy Models/Ants (Foraging and Sorting)/models/Ant Foraging (Complex).gaml\" \n\n\n\nexperiment Ants_coupling_exp type:gui  parent:Complete{\n\t\n\tlist<ant> getAnts{\n\t\treturn list(ant);\n\t}\n\t\n\tlist<ant_grid> getAnt_grid{\n\t\treturn list(ant_grid);\n\t}\n\t\n\toutput{\t\n\t}\n}\n```\n\n\n```\nmodel PreyPredator\n global\n{\n\tgeometry shape <- square(100);\n\tfloat perceipt_radius <- 20.0;\n\tint preyinit <- 500;\n\tint predatorinit <- 3;\n\tlist<agent> lstPredator <- list<agent>(predator);\n\tlist<agent> lstPrey <- list<agent>(prey);\n\tinit\n\t{\n\t\tcreate prey number: preyinit;\n\t\tcreate predator number: predatorinit;\n\t\tlstPredator <- list<agent>(predator);\n\t\tlstPrey <- list<agent>(prey);\n\t}\n\n}\n\nspecies generic_species skills: [moving]\n{\n\tfloat speed <- 1.0;\n\tpoint goal <- nil;\n\tbool is_chased <- false;\n\treflex live_with_my_goal\n\t{\n\t\tif (goal != nil)\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t\tdo goto target: goal speed: speed;\n\t\t} else\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t}\n\n\t}\n\n}\n\nspecies prey parent: generic_species\n{\n\tgeometry shape <- circle(0.5);\n\tfloat speed <- 0.2;\n\trgb color <- # green;\n\treflex fleeing\n\t{\n\t\tif (length((lstPredator where (each != nil and !dead(each) and each distance_to self < perceipt_radius))) > 0)\n\t\t{\n\t\t\tspeed <- 1.0;\n\t\t\tis_chased <- true;\n\t\t\tcolor <- # lime;\n\t\t\tif (goal = nil)\n\t\t\t{\n\t\t\t\tagent a <- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));\n\t\t\t\tif (a != nil and !dead(a))\n\t\t\t\t{\n\t\t\t\t\tif (flip(0.5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- a.location;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t\t}\n\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (goal != nil and self.location distance_to goal < 0.5)\n\t\t{\n\t\t\tgoal <- nil;\n\t\t}\n\n\t\tif (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self <= perceipt_radius)) = 0)\n\t\t{\n\t\t\tis_chased <- false;\n\t\t\tcolor <- # green;\n\t\t\tspeed <- 0.2;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw shape color: color;\n\t}\n\n}\n\nspecies predator parent: generic_species\n{\n\tgeometry shape <- triangle(2);\n\trgb color <- # red;\n\treflex hunting\n\t{\n\t\tif (goal = nil)\n\t\t{\n\t\t\tlist tmp <- (lstPrey where (!dead(each) and each.shape distance_to self.shape < perceipt_radius));\n\t\t\tif (length(tmp) > 0)\n\t\t\t{\n\t\t\t\tagent a <- first(tmp sort (each.shape distance_to self.shape));\n\t\t\t\tif (a = nil)\n\t\t\t\t{\n\t\t\t\t\ta <- any((lstPrey where (!dead(each))));\n\t\t\t\t}\n\n\t\t\t\tif (a != nil)\n\t\t\t\t{\n\t\t\t\t\tspeed <- 2.0;\n\t\t\t\t\tgoal <- a.location;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ((self.location distance_to goal < 0.5))\n\t\t{\n\t\t\task lstPrey where (!dead(each) and each.location distance_to goal < 0.5)\n\t\t\t{\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t\tgoal <- nil;\n\t\t\tspeed <- 1.0;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw circle(perceipt_radius) color: # pink empty: true;\n\t\tdraw shape color: color rotate: 90 + my heading;\n\t}\n\n}\n\nexperiment prey_predator_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay main_display\n\n\t\t{\n\t\t\tspecies prey;\n\t\t\tspecies predator;\n\t\t}\n\n\t}\n\n}\n```\n\n\n```\nmodel PreyPredator_coupling\nimport \"PreyPredator.gaml\"\n\nglobal\n{\t\n}\n\nexperiment PreyPredator_coupling_exp parent:prey_predator_exp type: gui\n{\ngeometry shape<- square(100);\n\tlist<prey> getPrey{\n\t\treturn list(prey);\n\t}\n\t\tlist<predator> getPredator{\n\t\treturn list(predator);\n\t}\n\t\n\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\n\toutput\n\t{\n\t}\n\n}\n\n\n```\n\n\nCode of the model : \n\n```\nmodel comodel_mix_behaviors\n\nimport \"PreyPredator_coupling.gaml\" as myPreyPredator\nimport \"Ants_coupling.gaml\" as myAnt\n\n\nglobal\n{\n\t//set the shape of environment: square 100 \n\tgeometry shape <- square(100);\n\t// the variable that refer to the ants population in micro-model \n\tlist<agent> theAnts;\n\t// the variable that refer to the prey population in micro-model\n\tlist<prey> thePreys;\n\t\n\tinit\n\t{\n\t\t//create the Ants micro-model with the size of grid is 100 and the population have 500 ants.\n\t\tcreate myAnt.Ants_coupling_exp with: [gridsize::100,ants_number::500];\n\t\t//create the PreyPredator micro-model with the parameters and the number of the prey is equal with the size of ants population\n\t\tcreate myPreyPredator.PreyPredator_coupling_exp with: [shape::square(100), preyinit::myAnt.Ants_coupling_exp[0].simulation.ants_number, predatorinit::3]  \n\t\t{\n\t\t\t// set the size of micro-model PreyPredator equal with the size of the grid of myAnt\n\t\t\tshape <- square(100);\n\t\t}\n\n\t\t// save the original population of the Ants and the Preys\n\t\ttheAnts <- myAnt.Ants_coupling_exp accumulate each.getAnts();\n\t\tthePreys <- list<prey>(myPreyPredator.PreyPredator_coupling_exp accumulate each.getPrey());\n\n\n\t}\n\n\treflex simulate_micro_models\n\t{\n\t\t// ask myAnt do a step\n\t\task (myAnt.Ants_coupling_exp collect each.simulation)\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\t\t// ask myPreyPredator do a step, too\n\t\task (myPreyPredator.PreyPredator_coupling_exp collect each.simulation)\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t//check if a Prey is chased, set the position of that agent to the location of prey \n\t\t//if not, set ant's location to agent location.\n\t\t// if the agent (prey) died, then tell the ant do die\n\t\tloop i from: 0 to: length(theAnts) - 1\n\t\t{\n\t\t\tif (!dead(thePreys at i) and !dead(theAnts at i))\n\t\t\t{\n\t\t\t\tif (!(thePreys at i).is_chased)\n\t\t\t\t{\n\t\t\t\t\t(thePreys at i).location <- (theAnts at i).location;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t(theAnts at i).location <- (thePreys at i).location;\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t{\n\t\t\t\task (theAnts at i)\n\t\t\t\t{\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment comodel_mix_behaviors_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay \"comodel\"\n\t\t{\n\t\t\tagents \"ant_grid\" value: myAnt.Ants_coupling_exp accumulate each.getAnt_grid() transparency: 0.7;\n\t\t\tagents \"agentprey\" value: (myPreyPredator.PreyPredator_coupling_exp accumulate each.getPrey());\n\t\t\tagents \"agentpredator\" value: (myPreyPredator.PreyPredator_coupling_exp accumulate each.getPredator());\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Co-model-Usage-comodel_mix_behaviors.md"},"Co-model-Usage-comodel_mutate_population.md":{"title":" comodel_with_the_coupling","content":"[//]: # (keyword|operator_dead)\n[//]: # (keyword|operator_any)\n[//]: # (keyword|operator_triangle)\n[//]: # (keyword|operator_sort)\n[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|statement_agents)\n[//]: # (keyword|constant_#lime)\n[//]: # (keyword|concept_comodel)\n# comodel_with_the_coupling\n\n\n_Author : HUYNH Quang Nghi_\n\nThis is a simple comodel serve to demonstrate the importation and instatiation of micro-model  using the couplings  with the mutation the population of micro-model. A population can be a collection from itself and from other mircro-model\n\n\nImported models : \n\n```\nmodel PreyPredator\n global\n{\n\tgeometry shape <- square(100);\n\tfloat perceipt_radius <- 20.0;\n\tint preyinit <- 500;\n\tint predatorinit <- 3;\n\tlist<agent> lstPredator <- list<agent>(predator);\n\tlist<agent> lstPrey <- list<agent>(prey);\n\tinit\n\t{\n\t\tcreate prey number: preyinit;\n\t\tcreate predator number: predatorinit;\n\t\tlstPredator <- list<agent>(predator);\n\t\tlstPrey <- list<agent>(prey);\n\t}\n\n}\n\nspecies generic_species skills: [moving]\n{\n\tfloat speed <- 1.0;\n\tpoint goal <- nil;\n\tbool is_chased <- false;\n\treflex live_with_my_goal\n\t{\n\t\tif (goal != nil)\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t\tdo goto target: goal speed: speed;\n\t\t} else\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t}\n\n\t}\n\n}\n\nspecies prey parent: generic_species\n{\n\tgeometry shape <- circle(0.5);\n\tfloat speed <- 0.2;\n\trgb color <- # green;\n\treflex fleeing\n\t{\n\t\tif (length((lstPredator where (each != nil and !dead(each) and each distance_to self < perceipt_radius))) > 0)\n\t\t{\n\t\t\tspeed <- 1.0;\n\t\t\tis_chased <- true;\n\t\t\tcolor <- # lime;\n\t\t\tif (goal = nil)\n\t\t\t{\n\t\t\t\tagent a <- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));\n\t\t\t\tif (a != nil and !dead(a))\n\t\t\t\t{\n\t\t\t\t\tif (flip(0.5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- a.location;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t\t}\n\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (goal != nil and self.location distance_to goal < 0.5)\n\t\t{\n\t\t\tgoal <- nil;\n\t\t}\n\n\t\tif (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self <= perceipt_radius)) = 0)\n\t\t{\n\t\t\tis_chased <- false;\n\t\t\tcolor <- # green;\n\t\t\tspeed <- 0.2;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw shape color: color;\n\t}\n\n}\n\nspecies predator parent: generic_species\n{\n\tgeometry shape <- triangle(2);\n\trgb color <- # red;\n\treflex hunting\n\t{\n\t\tif (goal = nil)\n\t\t{\n\t\t\tlist tmp <- (lstPrey where (!dead(each) and each.shape distance_to self.shape < perceipt_radius));\n\t\t\tif (length(tmp) > 0)\n\t\t\t{\n\t\t\t\tagent a <- first(tmp sort (each.shape distance_to self.shape));\n\t\t\t\tif (a = nil)\n\t\t\t\t{\n\t\t\t\t\ta <- any((lstPrey where (!dead(each))));\n\t\t\t\t}\n\n\t\t\t\tif (a != nil)\n\t\t\t\t{\n\t\t\t\t\tspeed <- 2.0;\n\t\t\t\t\tgoal <- a.location;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ((self.location distance_to goal < 0.5))\n\t\t{\n\t\t\task lstPrey where (!dead(each) and each.location distance_to goal < 0.5)\n\t\t\t{\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t\tgoal <- nil;\n\t\t\tspeed <- 1.0;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw circle(perceipt_radius) color: # pink empty: true;\n\t\tdraw shape color: color rotate: 90 + my heading;\n\t}\n\n}\n\nexperiment prey_predator_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay main_display\n\n\t\t{\n\t\t\tspecies prey;\n\t\t\tspecies predator;\n\t\t}\n\n\t}\n\n}\n```\n\n\n```\nmodel PreyPredator_coupling\nimport \"PreyPredator.gaml\"\n\nglobal\n{\t\n}\n\nexperiment PreyPredator_coupling_exp parent:prey_predator_exp type: gui\n{\ngeometry shape<- square(100);\n\tlist<prey> getPrey{\n\t\treturn list(prey);\n\t}\n\t\tlist<predator> getPredator{\n\t\treturn list(predator);\n\t}\n\t\n\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\n\toutput\n\t{\n\t}\n\n}\n\n\n```\n\n\nCode of the model : \n\n```\nmodel comodel_with_the_coupling\n\nimport \"PreyPredator_coupling.gaml\" as myP\n\n\nglobal\n{\n\t// set the shape of world as a rectangle 200 x 100\n\tgeometry shape <- rectangle(200, 100);\n\tinit\n\t{\n\t\t//instantiate three instant of micro-model PreyPredator\n\t\tcreate myP.PreyPredator_coupling_exp with: [shape::square(100), preyinit::rnd(20), predatorinit::1] number: 3;\n\t\t\n\t\t//explicitly save the orginal population of predator and original population of prey of each micro-model\n\t\tlist<agent> lstpredator0 <- myP.PreyPredator_coupling_exp[0].getPredator();\n\t\tlist<agent> lstprey0 <- myP.PreyPredator_coupling_exp[0].getPrey();\n\t\t\n\t\tlist<agent> lstpredator1 <- myP.PreyPredator_coupling_exp[1].getPredator();\n\t\tlist<agent> lstprey1 <- myP.PreyPredator_coupling_exp[1].getPrey();\n\t\t\n\t\tlist<agent> lstpredator2 <- myP.PreyPredator_coupling_exp[2].getPredator();\n\t\tlist<agent> lstprey2 <- myP.PreyPredator_coupling_exp[2].getPrey();\n\t\t\n\t\t//mutate the popuplation of micro-model by assigning the list above to  the population of micro-models\n\t\t(myP.PreyPredator_coupling_exp[0].simulation).lstPredator <- lstpredator2;\n\t\t(myP.PreyPredator_coupling_exp[1].simulation).lstPredator <- lstprey2;\n\t\t(myP.PreyPredator_coupling_exp[2].simulation).lstPredator <- lstprey1;\n\t\t\n\t\t\n\t\t(myP.PreyPredator_coupling_exp[0].simulation).lstPrey <- lstprey0 + lstprey1;\n\t\t(myP.PreyPredator_coupling_exp[1].simulation).lstPrey <- lstpredator1;\n\t\t(myP.PreyPredator_coupling_exp[2].simulation).lstPrey <- lstpredator0 + lstprey2;\n\t\t\n\t\t//change the shape correspond with the new role of agent in the new populations\n\t\task (myP.PreyPredator_coupling_exp accumulate each.simulation.lstPredator)\n\t\t{\n\t\t\tshape <- triangle(2);\n\t\t}\n\n\t\task (myP.PreyPredator_coupling_exp accumulate each.simulation.lstPrey)\n\t\t{\n\t\t\tshape <- circle(0.5);\n\t\t}\n\n\t}\n\n\treflex simulate_micro_models\n\t{\n\t\t// ask all simulation do their job\n\t\task (myP.PreyPredator_coupling_exp collect each.simulation)\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t}\n\n}\n\nexperiment comodel_with_the_coupling_exp type: gui\n{\n\toutput\n\t{\n\t\t//a mixing display of all agents from all populations\n\t\tdisplay \"comodel\"\n\t\t{\n\t\t\tagents \"agentprey\" value: (myP.PreyPredator_coupling_exp accumulate each.getPrey());\n\t\t\tagents \"agentpredator\" value: (myP.PreyPredator_coupling_exp accumulate each.getPredator());\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Co-model-Usage-comodel_mutate_population.md"},"Co-model-Usage-comodel_simple.md":{"title":" Simple syntax demonstration of Comodeling ","content":"[//]: # (keyword|concept_comodel)\n# Simple syntax demonstration of Comodeling \n\n\n_Author : HUYNH Quang Nghi_\n\nThis is a simple comodel serve to demonstrate the importation and instatiation of micro-model without using the couplings  \n\n\nImported models : \n\n```\nmodel M2\n\n\nglobal\n{\n\tint n <- 4;\n\tinit\n\t{\n\t\tcreate B number: n;\n\t}\n\n}\n\nspecies B skills: [moving]\n{\n\tint IQ <- rnd(100);\n\treflex dolive\n\t{\n\t\twrite \"\" + \"i'm alive !!\";\n\t\tdo wander;\n\t}\n\n\taspect default\n\t{\n\t\tdraw square(1) color: # red;\n\t}\n\n}\n\nexperiment M2_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay \"m2_disp\"\n\t\t{\n\t\t\tspecies B aspect: default;\n\t\t}\n\n\t}\n\n}\n\n\n```\n\n\n```\nmodel M1\n\n\nglobal\n{\n\tint n <- 8;\n\tinit\n\t{\n\t\tcreate A number: n;\n\t}\n\n}\n\nspecies A skills: [moving]\n{\n\tint IQ <- rnd(100);\n\treflex dolive\n\t{\n\t\twrite \"\" + \"i'm alive !!\";\n\t\tdo wander;\n\t}\n\n\taspect default\n\t{\n\t\tdraw square(1) color: # green;\n\t}\n\n}\n\nexperiment M1_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay \"m1_disp\"\n\t\t{\n\t\t\tspecies A aspect: default;\n\t\t}\n\n\t}\n\n}\n\n\n```\n\n\nCode of the model : \n\n```\nmodel Comodel_simple\n\nimport \"m1.gaml\" as micro_model_1\nimport \"m2.gaml\" as micro_model_2\n\n\nglobal\n{\n\tinit\n\t{\n\t//micro_model must be instantiated by create statement. We create an experiment inside the micro-model and the simulation will be created implicitly (1 experiment have only 1 simulation).\n\t\tcreate micro_model_1.M1_exp number: 5;\n\t\tcreate micro_model_2.M2_exp;\n\t}\n\n\treflex simulate_micro_models\n\t{\n\n\t//tell the first experiment of micro_model_1 do 1 step;\n\t\task first(micro_model_1.M1_exp).simulation\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t//tell the  experiment at 3 of micro_model_1 do 1 step;\n\t\task (micro_model_1.M1_exp at 3).simulation\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t//tell all experiments of micro_model_1 do 1 step;\n\t\task (micro_model_1.M1_exp collect each.simulation)\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t//tell all experiments of micro_model_2 do 1 step;\n\t\task (micro_model_2.M2_exp collect each.simulation)\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\t\t\n\t\t//kill simulation  of micro_model and recreate then\n\t\task  (micro_model_2.M2_exp collect each.simulation){\n\t\t\tdo die;\n\t\t}\n\t\task (micro_model_2.M2_exp){\n\t\t\tcreate simulation{do _init_;}\n\t\t}\n\t}\n}\n\nexperiment Comodel_simple_exp type: gui\n{\n}\n```\n","url":"wiki/Co-model-Usage-comodel_simple.md"},"Co-model-Usage-comodel_with_the_coupling.md":{"title":" comodel_with_the_coupling","content":"[//]: # (keyword|statement_agents)\n[//]: # (keyword|concept_comodel)\n# comodel_with_the_coupling\n\n\n_Author : HUYNH Quang Nghi_\n\nThis is a simple comodel serve to demonstrate the importation and instatiation of micro-model using the couplings  \n\n\nImported models : \n\n```\nmodel M2\n\n\nglobal\n{\n\tint n <- 4;\n\tinit\n\t{\n\t\tcreate B number: n;\n\t}\n\n}\n\nspecies B skills: [moving]\n{\n\tint IQ <- rnd(100);\n\treflex dolive\n\t{\n\t\twrite \"\" + \"i'm alive !!\";\n\t\tdo wander;\n\t}\n\n\taspect default\n\t{\n\t\tdraw square(1) color: # red;\n\t}\n\n}\n\nexperiment M2_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay \"m2_disp\"\n\t\t{\n\t\t\tspecies B aspect: default;\n\t\t}\n\n\t}\n\n}\n\n\n```\n\n\n```\nmodel M2_coupling\nimport \"m2.gaml\"\n\nglobal\n{\n}\n\nexperiment M2_coupling_exp parent:M2_exp type: gui\n{\n\tlist<B> getB{\n\t\treturn list(B);\n\t}\n\t\n\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\n\toutput\n\t{\n\t}\n\n}\n\n\n```\n\n\n```\nmodel M1\n\n\nglobal\n{\n\tint n <- 8;\n\tinit\n\t{\n\t\tcreate A number: n;\n\t}\n\n}\n\nspecies A skills: [moving]\n{\n\tint IQ <- rnd(100);\n\treflex dolive\n\t{\n\t\twrite \"\" + \"i'm alive !!\";\n\t\tdo wander;\n\t}\n\n\taspect default\n\t{\n\t\tdraw square(1) color: # green;\n\t}\n\n}\n\nexperiment M1_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay \"m1_disp\"\n\t\t{\n\t\t\tspecies A aspect: default;\n\t\t}\n\n\t}\n\n}\n\n\n```\n\n\n```\nmodel M1_coupling\nimport \"m1.gaml\"\n\nglobal\n{\n}\n\nexperiment M1_coupling_exp parent:M1_exp type: gui\n{\n\tlist<A> getA{\n\t\treturn list(A);\n\t}\n\t\n\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\n\toutput\n\t{\n\t}\n\n}\n\n\n```\n\n\nCode of the model : \n\n```\nmodel comodel_with_the_coupling\n\nimport \"m1_coupling.gaml\" as micro_model_1\nimport \"m2_coupling.gaml\" as micro_model_2\n\nglobal\n{\n\tgeometry shape<-envelope(square(100));\n\tinit{\n\t\t//micro_model must be instantiated by create statement. We create an experiment inside the micro-model and the simulation will be created implicitly (1 experiment have only 1 simulation).\n\t\tcreate micro_model_1.M1_coupling_exp;\n\t\tcreate micro_model_2.M2_coupling_exp number:5;\n\t}\n\treflex simulate_micro_models{\n\t\t\n\t\t//tell all experiments of micro_model_1 do 1 step;\n\t\task (micro_model_1.M1_coupling_exp collect each.simulation){\n\t\t\tdo _step_;\n\t\t}\n\t\t\n\t\t//tell the first experiment of micro_model_2 do 1 step;\n\t\task (micro_model_2.M2_coupling_exp collect each.simulation){\n\t\t\tdo _step_;\n\t\t}\n\t}\n}\n\nexperiment comodel_with_the_coupling type: gui{\n\toutput{\n\t\tdisplay \"comodel\" {\n\t\t\t//to display the agents of micro-models, we use the agent layer with the values come from the coupling.\n\t\t\tagents \"agentA\" value:first(micro_model_1.M1_coupling_exp).getA();\n\t\t\tagents \"agentB\" value:first(micro_model_2.M2_coupling_exp).getB();\n\t\t}\n\t}\n}\n```\n","url":"wiki/Co-model-Usage-comodel_with_the_coupling.md"},"Color-Bubble-Sort-3D.md":{"title":" Creating color and sort cubes by color","content":"[//]: # (keyword|operator_cube)\n[//]: # (keyword|operator_copy)\n[//]: # (keyword|constant_#magenta)\n[//]: # (keyword|constant_#cyan)\n[//]: # (keyword|concept_color)\n[//]: # (keyword|concept_3d)\n# Creating color and sort cubes by color\n\n\n_Author :  Arnaud Grignard_\n\nA model to show how to create color by using the rgb operator, the color depending on the position of cube in the xyz space. The cubes are randomly mixed to finally be sorted according to the color of each vertix of the whole big cube, using the bubble sort algorithm (https://en.wikipedia.org/wiki/Bubble_sort). \n\n\nCode of the model : \n\n```\n\nmodel bubblesort3D\n\n\nglobal {\n\n//Number of cubes by faces of the whole big cube\nint nb_cells<-15;\n\ngeometry shape <- cube(nb_cells) ;\n\n\nbool change <- true;\n\ninit {\n\t//We create nb_cells^3 cubes and we define their color depending on their position in XYZ\n\tloop i from:0 to:nb_cells-1{\n\t\tloop j from:0 to: nb_cells-1{\n\t\t\tloop k from:0 to:nb_cells-1{\n\t\t\t  create cells{\n\t\t\t\tlocation <-{i mod nb_cells,j mod nb_cells, k mod nb_cells};\n\t\t\t\t\n\t\t\t\t//The canal RGB limit color to 255 by canal\n\t\t\t\tred <- float((i mod nb_cells)* int(255 / nb_cells));\n\t\t\t\tgreen <- float((j mod nb_cells) * int(255 / nb_cells));\n\t\t\t\tblue <- float((k mod nb_cells) * int(255 / nb_cells));\n\t\t\t\t\n\t\t\t\t//We create the color according to the value of the red, green and blue canals\n\t\t\t\tcolor <- rgb(red,green,blue);\n\t\t\t  }\t\n\t\t\t}\t\n\t    }\n\t}\n\t\n\t//We mix all the cubes randomly by permuting two randomly chosen cubes\n\tloop times: 10000 {\n\t\t\task one_of(cells) {\n\t\t\t\tcells one_cells <- one_of(cells);\n\t\t\t\tif (self != one_cells) {\n\t\t\t\t\tpoint loc <- copy(location);\n\t\t\t\t\tlocation <- one_cells.location;\n\t\t\t\t\tone_cells.location <- loc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t\n\n}\n\n//Reflex to finish the execution of the model when nothing has changed during the cycle\nreflex end {\n\tif (not change) {\n\t\tdo pause;\t\n\t} \n\tchange <- false;\n\t}\n}\n\n\nspecies cells{\n\n\trgb color;\n\tfloat red;\n\tfloat green;\n\tfloat blue;\n\tlist<cells> neigbhours update: cells at_distance (1.1);\n\t\n\t//Update of the neighbours cubes at each cycle of the simulation according to their location\n\tcells upper_cell_y update: neigbhours first_with (shape.location.y > each.shape.location.y);\n\tcells upper_cell_x update: neigbhours first_with (shape.location.x > each.shape.location.x);\n\tcells upper_cell_z update: neigbhours first_with (shape.location.z > each.shape.location.z);\n\t\n\t//We permute the cube agent with its neighbour if its intensity is greater according to the canal related to its axis (z for canal blue, y for green and x for red)\n\treflex swap_z when: upper_cell_z != nil and blue < upper_cell_z.blue{ \n\t\tpoint tmp1Loc <-location;\n\t\tlocation <- upper_cell_z.location;  \n    \tupper_cell_z.location<-tmp1Loc; \t\n\t    change <- true;\t\n    }\n\t\n\treflex swap_y when: upper_cell_y != nil and green < upper_cell_y.green{ \n\t\tpoint tmp1Loc <-location;\n\t\tlocation <- upper_cell_y.location;  \n    \tupper_cell_y.location<-tmp1Loc; \t\n\t    change <- true;\t\n    }\n    \n    reflex swap_x when: upper_cell_x != nil and red < upper_cell_x.red{ \n\t\tpoint tmp1Loc <-location;\n\t\tlocation <- upper_cell_x.location;  \n    \tupper_cell_x.location<-tmp1Loc; \t\n\t    change <- true;\t\n    }\n\n\taspect default {\n\t\tdraw cube(1) color:color border:color at:location;\n\t}\t\n}\n\n\nexperiment Display type: gui {\n\toutput {\n\t\tdisplay View1 type:opengl draw_env:false{\n\t\t\tspecies cells transparency:0.1;\n\t\t\tgraphics \"di\"{\n\t\t\t draw \"black(0,0,0)\" at:{0,0,0} color:°black perspective:false;\n\t\t\t draw \"red(1,0,0)\" at:{world.shape.width,0,0} color:°red perspective:false;\n\t\t\t draw \"green(0,1,0)\" at:{0,world.shape.height,0} color:°green perspective:false;\n\t\t\t draw \"blue(0,0,1)\" at:{0,0,world.shape.width} color:°blue perspective:false;\n\t\t\t draw \"yellow(1,1,0)\" at:{world.shape.width,world.shape.height,0} color:°yellow perspective:false;\n\t\t\t draw \"magenta(1,0,1)\" at:{world.shape.width,0,world.shape.depth} color:°magenta perspective:false;\n\t\t\t draw \"cyan(0,1,1)\" at:{0,world.shape.height,world.shape.depth} color:°cyan perspective:false;\n\t\t\t draw \"white(1,1,1)\" at:{world.shape.width,world.shape.height,world.shape.depth} color:°white perspective:false;\t\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Color-Bubble-Sort-3D.md"},"Color-Color-Brewer.md":{"title":" Color defined by choosing a Color Brewer","content":"[//]: # (keyword|operator_brewer_palettes)\n[//]: # (keyword|operator_brewer_colors)\n[//]: # (keyword|concept_color)\n# Color defined by choosing a Color Brewer\n\n\n_Author :  Arnaud Grignard & Patrick Taillandier_\n\nA model to show how to use color brewer. In this model, two experiments are presents : one just to show the different colors present in some selected brewer, and a second one to show in a grid the different colors of brewler having at least a minimal number of colors passed in parameter.\n\n\nCode of the model : \n\n```\n\n\nmodel ColorBrewer\n\n\nglobal {\n\n//number of colors\nint nb_classes<-14 min:5 max: 15;\n\nint square_size <- 10;\n\n//list of palettes that have at least nb_classes\nlist<string> palettes <- brewer_palettes(nb_classes);\n\n//the current sequential palette from the list of all available sequential Palettes\nstring sequentialPalette <- \"YlOrRd\" among:[\"YlOrRd\",\"Grays\",\"PuBu\",\"BuPu\",\"YlOrBr\",\"Greens\",\"BuGn\",\"GnBu\",\"PuRd\",\"Purples\",\"Blues\",\"Oranges\",\"OrRd\",\"Reds\",\"YlGn\",\"YlGnBu\"];\n\n//the current diverging palette from the list of all available diverging Palettes\nstring divergingPalette <- \"BrBG\" among:[\"PRGn\",\"PuOr\",\"RdGy\",\"Spectral\",\"RdYlGn\",\"RdBu\",\"RdYlBu\",\"PiYG\",\"BrBG\"];\n\n//the current qualitative palette from the list of all available qualitative Palettes\nstring qualitativePalette <- \"Pastel1\" among:[\"Accents\",\"Paired\",\"Set3\",\"Set2\",\"Set1\",\"Dark2\",\"Pastel2\",\"Pastel1\"];\n\n//build the lists of colors from the palettes\nlist<rgb> SequentialColors<-list<rgb>(brewer_colors(sequentialPalette));\nlist<rgb> DivergingColors<-list<rgb>(brewer_colors(divergingPalette));\nlist<rgb> QualitativeColors<-list<rgb>(brewer_colors(qualitativePalette));\n\n\n\tinit {\n\t\t//if the palettes is not empty\n\t\tif (not empty(palettes)) {\n\t\t\t//for each palette\n\t\t\tloop i from: 0 to: length(palettes) - 1 {\n\t\t\t\t//define a  list of nb_classes colors from the current palette\n\t\t\t\tlist<rgb> colors<-list<rgb>(brewer_colors(palettes[i],nb_classes));\n\t\t\t\t\n\t\t\t\t//define the colors of the corresponding cells\n\t\t\t\task cell where (each.grid_y = i){\n\t\t\t\t\tcolor <- colors[grid_x,i];\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ngrid cell width:nb_classes height: max([1,length(palettes)]) ;\n\n\n//in this experiment, we do not use the cell agents, but we directlty draw the different palettes of colors\nexperiment BrewerPalette type: gui {\n\tparameter \"Sequential Palettes\" var:sequentialPalette category:\"Brewer\";\n\tparameter \"Diverging Palettes\" var:divergingPalette category:\"Brewer\";\n\tparameter \"Qualitatives Palettes\" var:qualitativePalette category:\"Brewer\";\n\toutput {\n\t\tdisplay View1 type:opengl draw_env:false{\n\t\t\tgraphics \"brewer\"{\n\t\t\t\t//Sequential\n\t\t\t\tdraw \"Sequential\" at:{-world.shape.width*0.2,0} color:°black perspective:true;\n\t\t\t\tloop i from:0 to:length(SequentialColors)-1{\n\t\t\t\t\tdraw square(square_size) color:SequentialColors[i] at: {square_size*(0.5 + i), 0, 0};\n\t\t\t\t}\n\t\t\t\t//Diverging\n\t\t\t\tloop i from:0 to:length(DivergingColors)-1{\n\t\t\t\t\tdraw \"Diverging\" at:{-world.shape.width*0.2,1*square_size} color:°black perspective:false;\n\t\t\t\t\tdraw square(square_size) color:DivergingColors[i] at: {square_size*(0.5 + i), 1*square_size, 0};\n\t\t\t\t}\n\t\t\t\t//Qualitative\t\t\n\t\t\t\tloop i from:0 to:length(QualitativeColors)-1{\n\t\t\t\t\tdraw \"Qualitative\" at:{-world.shape.width*0.2,2*square_size} color:°black perspective:false;\n\t\t\t\t\tdraw square(square_size) color:QualitativeColors[i] at: {square_size*(0.5 + i), 2*square_size, 0};\n\t\t\t\t}\n\t\t    }\n\t\t}\t\n\t}\n}\n\n//in this experiment, we display the cell agents with the  different aspects\nexperiment BrewerColoredAgent type: gui {\n\tparameter \"Number of data classes\" var:nb_classes category:\"Brewer\";\n\toutput {\n\t\tdisplay View1 {\n\t\t\tgrid cell lines: #black ;\n\t\t}\t\n\t}\n}\n```\n","url":"wiki/Color-Color-Brewer.md"},"Color-RGB-to-XYZ.md":{"title":" RGB color to XYZ position","content":"[//]: # (keyword|operator_rgb_to_xyz)\n[//]: # (keyword|operator_cube)\n[//]: # (keyword|concept_color)\n[//]: # (keyword|concept_3d)\n# RGB color to XYZ position\n\n\n_Author :  Arnaud Grignard_\n\nA model to show how to convert rgb values in xyz position using the operator rgb_to_xyz. Each pixel of a given image is used to create a point with its coordinates depending on its color : red value for x coordinate, green value for y coordinate and blue value for the z coordinate.\n\n\nCode of the model : \n\n```\n\nmodel rgbCube\n\nglobal {\n\t//import an image\n\tfile imageRaster <- file('images/RGB.jpg');\n\t\n\t//list of points  create from the image \n\tlist<point> p;\n\t\n\t//geometry of the world (environment)\n\tgeometry shape <- square(255);\n\t\n\t//create the list of points from the image: a point is defined per pixel, its coordinate correspond to the value of the red,green,blue color\n\tinit {\n\t\tp <- list<point> (rgb_to_xyz(imageRaster));\n\t}\n}\n\n\nexperiment Display type: gui {\n\toutput {\n\t\tdisplay RGB_to_XYZ type: opengl { \n\t\t\timage imageRaster.path refresh: false;\n\t\t\tgraphics \"pts\" refresh: false{\n\t\t\t\tloop pt over: p {\n\t\t\t\t\tdraw cube(1) at: pt color: rgb(pt.x, pt.y, pt.z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n```\n","url":"wiki/Color-RGB-to-XYZ.md"},"Data-Importation-3D-shapefile-Loading.md":{"title":" 3D shapefile loading","content":"[//]: # (keyword|operator_shape_file)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_load_file)\n# 3D shapefile loading\n\n\n_Author :  _\n\nModel which shows how to create a shape using a 3D Shapefile after this one has been loaded. \n\n\nCode of the model : \n\n```\nmodel shapefile_loading\n\nglobal {\n\t\n\t//file variable that will store the shape file\n\tfile shape_file_gis_3d_objects <- shape_file('../includes/Mobilier.shp', 0);\n\tgeometry shape <- envelope(shape_file_gis_3d_objects);\n\tinit {\n\t\tcreate gis_3d_object from: shape_file_gis_3d_objects;\n\t}\n}\n\nspecies gis_3d_object {\n\taspect base {\n\t\tdraw shape at:{world.shape.width/2,world.shape.height/2,0};\n\t}\n}\n\nexperiment display_shape type: gui {\n\n\toutput {\n\t\tdisplay city_display type: opengl draw_env:false{\n\t\t\tspecies gis_3d_object aspect: base;\n\t\t}\n\n\t}\n}\n\n```\n","url":"wiki/Data-Importation-3D-shapefile-Loading.md"},"Data-Importation-ASC-file-Import.md":{"title":" ESRI ASCII to grid model","content":"[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_asc)\n# ESRI ASCII to grid model\n\n\n_Author :  Patrick Taillandier_\n\nModel which shows how to initialize a grid using a ESRI ASCII file\n\n\nCode of the model : \n\n```\n\nmodel ascimport\n\nglobal {\n\t//definiton of the file to import\n\tfile grid_data <- file('../includes/hab10.asc') ;\n\t\n\t//computation of the environment size from the geotiff file\n\tgeometry shape <- envelope(grid_data);\t\n}\n\n\n\n//definition of the grid from the asc file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data{\n\tinit {\n\t\tcolor<- grid_value = 0.0 ? #black  : (grid_value = 1.0  ? #green :   #yellow);\n\t}\n}\n\nexperiment gridloading type: gui {\n\toutput {\n\t\tdisplay \"As DEM\" type: opengl{\n\t\t\tgrid cell lines: #gray elevation: grid_value * 300 ;\n\t\t}\n\t\t\n\t\tdisplay \"As 2D grid\"  type: java2D {\n\t\t\tgrid cell lines: #black;\n\t\t}\n\t} \n}\n\n\n```\n","url":"wiki/Data-Importation-ASC-file-Import.md"},"Data-Importation-Contour-Lines.md":{"title":" Contour Lines Import","content":"[//]: # (keyword|operator_triangulate)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|operator_set_z)\n[//]: # (keyword|constant_#grey)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_shapefile)\n# Contour Lines Import\n\n\n_Author : Patrick Taillandier_\n\nModel which imports a shapefile of contour lines, build triangles from these contour lines, compute their elevation by using the elevation attribute of the contour lines which had been linked to the elevation column of the shapefile. \n\n\nCode of the model : \n\n```\n\n\nmodel contour_lines_import\n\nglobal {\n\t//the contour lines shapefile\n\tfile shape_file_cl <- file('../includes/contourLines.shp') ;\n\t\n\t//define the size of the world from the countour line shapefile\n\tgeometry shape <- envelope(shape_file_cl);\n\t\n\tinit {\n\t\t//create the contour line agents from the shapefile, and init the elevation for each agent\n\t\tcreate contour_line from: shape_file_cl with: [elevation:: float(read(\"ELEVATION\"))];\n\t\t\n\t\t//triangulate the contour lines\n\t\tlist<geometry> triangles  <- triangulate (list(contour_line));\n\t\t\n\t\t//for each triangle geometry, create a triangle_ag agent and compute the elevation of each of its points (and modified their z value)\n\t\tloop tr over: triangles {\n\t\t\tcreate triangle_ag {\n\t\t\t\tshape <- tr;\n\t\t\t\tloop i from: 0 to: length(shape.points) - 1{ \n\t\t\t\t\tfloat val <- (contour_line closest_to (shape.points at i)).elevation;\n\t\t\t\t\tshape <- shape set_z (i,val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nspecies contour_line {\n\tfloat elevation;\n\taspect default {\n\t\tdraw shape + 5.0 color: #red depth: 10 at: {location.x,location.y, elevation}; \n\t}\n}\nspecies triangle_ag {\n\taspect default {\n\t\tdraw shape color: #grey ; \n\t}\n}\n\n\nexperiment contour_lines_import type: gui {\n\toutput {\n\t\tdisplay map type: opengl {\n\t\t\tspecies triangle_ag refresh: false;\n\t\t\tspecies contour_line refresh: false;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Data-Importation-Contour-Lines.md"},"Data-Importation-CSV-Agents.md":{"title":" CSV to Agents Model","content":"[//]: # (keyword|operator_csv_file)\n[//]: # (keyword|operator_get)\n[//]: # (keyword|concept_csv)\n[//]: # (keyword|concept_load_file)\n# CSV to Agents Model\n\n\n_Author :  Patrick Taillandier_\n\nModel which shows how to create agents by importing data of a CSV file. The model read the CSV File and create an agent Iris for each line of the CSV, linking its attributes to columns of the CSV File. \n\n\nCode of the model : \n\n```\n\nmodel CSVfileloading\n\nglobal {\n\t\n\tinit {\n\t\t//create iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files: \n\t\t//we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes\n\t\tcreate iris from:csv_file( \"../includes/iris.csv\",true) with:\n\t\t\t[sepal_length::float(get(\"sepallength\")), \n\t\t\t\tsepal_width::float(get(\"sepalwidth\")), \n\t\t\t\tpetal_length::float(get(\"petallength\")),\n\t\t\t\tpetal_width::float(get(\"petalwidth\")), \n\t\t\t\ttype::string(get(\"type\"))\n\t\t\t];\t\n\t}\n}\n\nspecies iris {\n\tfloat sepal_length;\n\tfloat sepal_width;\n\tfloat petal_length;\n\tfloat petal_width;\n\tstring type;\n\trgb color ;\n\t\n\tinit {\n\t\tcolor <- type =\"Iris-setosa\" ? #blue : ((type =\"Iris-virginica\") ? #red: #yellow);\n\t}\n\t\n\taspect default {\n\t\tdraw circle(petal_width) color: color; \n\t}\n}\n\nexperiment main type: gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies iris;\n\t\t}\n\t}\n\t\n}\n```\n","url":"wiki/Data-Importation-CSV-Agents.md"},"Data-Importation-CSV-File-Loading.md":{"title":" Convertion of CSV data to Matrix","content":"[//]: # (keyword|operator_csv_file)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_csv)\n[//]: # (keyword|concept_load_file)\n# Convertion of CSV data to Matrix\n\n\n_Author :  Patrick Taillandier_\n\nModel which shows how to initialize a matrix by using the content of a CSV File. The model load a CSV File, and write its content in the console. \n\n\nCode of the model : \n\n```\n\n\nmodel CSVfileloading\n\nglobal {\n\tfile my_csv_file <- csv_file(\"../includes/iris.csv\",\",\");\n\t\n\tinit {\n\t\t//convert the file into a matrix\n\t\tmatrix data <- matrix(my_csv_file);\n\t\t//loop on the matrix rows (skip the first header line)\n\t\tloop i from: 1 to: data.rows -1{\n\t\t\t//loop on the matrix columns\n\t\t\tloop j from: 0 to: data.columns -1{\n\t\t\t\twrite \"data rows:\"+ i +\" colums:\" + j + \" = \" + data[j,i];\n\t\t\t}\t\n\t\t}\t\t\n\t}\n}\n\nexperiment main type: gui;\n```\n","url":"wiki/Data-Importation-CSV-File-Loading.md"},"Data-Importation-DXF-Agents.md":{"title":" DXF to Agents Model","content":"[//]: # (keyword|operator_get)\n[//]: # (keyword|operator_group_by)\n[//]: # (keyword|operator_rnd_color)\n[//]: # (keyword|constant_#brown)\n[//]: # (keyword|concept_dxf)\n[//]: # (keyword|concept_load_file)\n# DXF to Agents Model\n\n\n_Author :  Patrick Taillandier_\n\nModel which shows how to create agents by importing data of a DXF file\n\n\nCode of the model : \n\n```\n\nmodel DXFAgents \n\nglobal {\n\tfile house_file <- file(\"../includes/house.dxf\");\n\t\n\t//compute the environment size from the dxf file envelope\n\tgeometry shape <- envelope(house_file);\n\t\n\tinit {\n\t\t//create house_element agents from the dxf file and initialized the layer attribute of the agents from the the file\n\t\tcreate house_element from: house_file with: [layer::string(get(\"layer\"))];\n\t\t\t\tcreate house_element from: house_file with: [layer::string(get(\"layer\"))];\n\t\t\t\t\t\tcreate house_element from: house_file with: [layer::string(get(\"layer\"))];\n\t\t//define a random color for each layer\n\t\tmap layers <- list(house_element) group_by each.layer;\n\t\tloop la over: layers.keys {\n\t\t\trgb col <- rnd_color(255);\n\t\t\task layers[la] {color <- col;}\n\t\t}\n\t}\n}\n\nspecies house_element {\n\tstring layer;\n\trgb color;\n\taspect default {\n\t\tdraw shape color: color;\n\t}\n} \n\nexperiment DXFAgents type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies house_element;\n\t\t}\n\t\t\n\t\tdisplay \"As_Image\" {\n\t\t\tgraphics \"House\" {\n\t\t\t\tdraw house_file color: #brown ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}\n```\n","url":"wiki/Data-Importation-DXF-Agents.md"},"Data-Importation-GEOTIFF-file-Import.md":{"title":" GeoTIFF file to Grid of Cells ","content":"[//]: # (keyword|operator_max_of)\n[//]: # (keyword|operator_min_of)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_tif)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_grid)\n# GeoTIFF file to Grid of Cells \n\n\n_Author :  Patrick Taillandier_\n\nModel which shows how to create a grid of cells by using a GeoTIFF File. \n\n\nCode of the model : \n\n```\n\nmodel geotiffimport\n\nglobal {\n\t//definiton of the file to import\n\tfile grid_data <- file('../includes/bogota_grid.tif') ;\n\t\n\t//computation of the environment size from the geotiff file\n\tgeometry shape <- envelope(grid_data);\t\n\t\n\tfloat max_value;\n\tfloat min_value;\n\tinit {\n\t\tmax_value <- cell max_of (each.grid_value);\n\t\tmin_value <- cell min_of (each.grid_value);\n\t\task cell {\n\t\t\tint val <- int(255 * ( 1  - (grid_value - min_value) /(max_value - min_value)));\n\t\t\tcolor <- rgb(val,val,val);\n\t\t}\n\t}\n}\n\n//definition of the grid from the geotiff file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data;\n\nexperiment show_example type: gui {\n\toutput {\n\t\tdisplay test {\n\t\t\tgrid cell lines: #black;\n\t\t}\n\t} \n}\n```\n","url":"wiki/Data-Importation-GEOTIFF-file-Import.md"},"Data-Importation-GIS-Export.md":{"title":" Shapefiles Import and Save","content":"[//]: # (keyword|operator_get)\n[//]: # (keyword|statement_save)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_save_file)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_3d)\n# Shapefiles Import and Save\n\n\n_Author : Patrick Taillandier_\n\nModel using shapefiles to create buildings, linking their height and type attributes to the height and nature columns of the shapefiles to finally save the data in an other shapefile.\n\n\nCode of the model : \n\n```\n  \n\nmodel saveGIS\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/buildings_simple.shp\");\n\tstring new_shape_file_buildings <- \"../results/buildings_final.shp\";\n\t\n\t//definition of the geometry of the world agent (environment) as the envelope of the shapefile\n\tgeometry shape <- envelope(shape_file_buildings);\n\t\n\tinit {\n\t\t//creation of the building agents from the shapefile: the height and type attributes of the building agents are initialized according to the HEIGHT and NATURE attributes of the shapefile\n\t\tcreate building from: shape_file_buildings with:[height::float(get(\"HEIGHT\")), type::string(get(\"NATURE\"))];\n\t}\n\t\n\t//when cycle = 5, save of the building agents in a shapefile with the attributes height, type and price.\n\treflex save_data when: cycle = 5 {\n\t\tsave building to: new_shape_file_buildings type:\"shp\" with:[height::\"HEIGHT\", type::\"NATURE\", price::\"PRICE\"];\n\t}\n}\n\nspecies building {\n\tfloat height;\n\tstring type;\n\tfloat price <- (shape.area * height) * (type = \"Industrial\" ? 0.5: 1) update: price * (90 +rnd(20)) / 100; \n\trgb color <- type = \"Industrial\" ? #pink : #gray;\n\t\n\taspect default {\n\t\tdraw shape depth: height color: color;\n\t}\n\t\n}\n\nexperiment GIS_agentification type: gui {\n\toutput {\n\t\tdisplay city_display type: opengl {\n\t\t\tspecies building;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Data-Importation-GIS-Export.md"},"Data-Importation-Grid-DEM.md":{"title":" ASCII File to DEM Representation","content":"[//]: # (keyword|operator_dem)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_dem)\n# ASCII File to DEM Representation\n\n\n_Author : Arnaud Grignard_\n\nModel to show how to import a ASCII File to make a DEM Representation and apply a Texture on it. In this model, three experiments are presented : DEM to show the grid elevation using the ASCII File as data for the height of the cells, and showing different 3D displays. GridDEMComplete shows more displays with the three of the previous experiment, the grid of the cells in a 2D Display, with the Elevation but without triangulation, and the grid with text values to show the content of the ASCII used by the cells. GraphicDEMComplete shows the use of the z_factor to amplify or reduces the difference between the z values of a Dem geometry.\n\n\nCode of the model : \n\n```\n\nmodel gridloading\n\nglobal {\n\tfile grid_data <- file(\"../includes/DEM-Vulcano/vulcano_50.asc\");\n\tfile dem parameter: 'DEM' <- file('../includes/DEM-Vulcano/DEM.png');\n\tfile texture parameter: 'Texture' <- file('../includes/DEM-Vulcano/Texture.png');\n\tgeometry shape <- envelope(200);\n\tinit\n\t{\n\t\task cell\n\t\t{\n\t\t\tfloat r;\n\t\t\tfloat g;\n\t\t\tfloat b;\n\t\t\tif(grid_value<20)\n\t\t\t{\n\t\t\t\tr<- 76+(26*(grid_value-7)/13);\n\t\t\t\tg<- 153-(51*(grid_value-7)/13);\n\t\t\t\tb<-0.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr<- 102+(122*(grid_value-20)/19);\n\t\t\t\tg<- 51+(173*(grid_value-20)/19);\n\t\t\t\tb<- 224*(grid_value-20)/19;\n\t\t\t}\n\t\t\tself.color<-rgb(r,g,b);\n\t\t}\n\t}\n}\n\ngrid cell file: grid_data {\n\trgb color;\n\treflex decreaseValue {\n\t\tgrid_value <- grid_value  + rnd (0.2) - 0.1;\n\t}\n}\n\nexperiment DEM type: gui {\n\toutput {\n\n\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)\n\t\tdisplay gridWithElevationTriangulated type: opengl autosave: true{ \n\t\t\tgrid cell elevation: true triangulation: true ;\n\t\t}\n\n\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255\n\t\tdisplay gridGrayScaledTriangulated type: opengl { \n\t\t\tgrid cell elevation: true grayscale: true triangulation: true;\n\t\t}\n\n\t\t//Display the textured grid in 3D with the cell altitude corresponding to its grid_value.\t\t\t\t\n\t\tdisplay gridTextured type: opengl { \n\t\t\tgrid cell texture: texture text: false triangulation: true elevation: true;\n\t\t}\n\t}\n\n}\n\nexperiment GridDEMComplete type: gui {\n\toutput {\n\n\t//Display the grid on a plan with cell color (if defined otherwise in black)\n\t\tdisplay grid type: opengl { //Same as in java2D\n\t\t\tgrid cell;\n\t\t}\n\n\t\t//Display the grid in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)\n\t\tdisplay gridWithElevation type: opengl { \n\t\t\tgrid cell elevation: true;\n\t\t}\n\n\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)\n\t\tdisplay gridWithElevationTriangulated type: opengl { \n\t\t\tgrid cell elevation: true triangulation: true ;\n\t\t}\n\n\t\t//Display the grid in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255\n\t\tdisplay gridGrayScaled type: opengl { \n\t\t\tgrid cell elevation: true grayscale: true;\n\t\t}\n\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255\n\t\tdisplay gridGrayScaledTriangulated type: opengl { \n\t\t\tgrid cell elevation: true grayscale: true triangulation: true;\n\t\t}\n\n\t\t//Display the textured grid in 3D with the cell altitude corresponding to its grid_value.\t\t\t\t\n\t\tdisplay gridTextured type: opengl { \n\t\t\tgrid cell texture: texture text: false triangulation: false elevation: true;\n\t\t}\n\n\t\t//Display the textured triangulated grid in 3D with the cell altitude corresponding to its grid_value.\n\t\tdisplay gridTexturedTriangulated type: opengl { \n\t\t\tgrid cell texture: texture text: false triangulation: true elevation: true;\n\t\t}\n\t\tdisplay gridWithText type: opengl { \n\t\t\tgrid cell text: true elevation: true grayscale: true;\n\t\t}\n\t}\n\n}\n\nexperiment GraphicDEMComplete type: gui {\n\toutput {\n\t\tdisplay VulcanoTexturedScaled type: opengl draw_env: false { \n\t\t\tgraphics 'GraphicPrimitive' {\n\t\t\t\tdraw dem(dem, texture, 0.1);\n\t\t\t}\n\t\t} \n\t\tdisplay VulcanoDEMScaled type: opengl draw_env: false { \n\t\t\tgraphics 'GraphicPrimitive' {\n\t\t\t\tdraw dem(dem, 0.1);\n\t\t\t}\n\t\t} \n\t\tdisplay VulcanoTextured type: opengl draw_env: false { \n\t\t\tgraphics 'GraphicPrimitive' {\n\t\t\t\tdraw dem(dem, texture);\n\t\t\t}\n\t\t} \n\t\tdisplay VulcanoDEM type: opengl draw_env: false { \n\t\t\tgraphics 'GraphicPrimitive' {\n\t\t\t\tdraw dem(dem);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Data-Importation-Grid-DEM.md"},"Data-Importation-OBJ-file-drawing.md":{"title":" OBJ File to Geometry","content":"[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_obj)\n# OBJ File to Geometry\n\n\n_Author :  Arnaud Grignard_\n\nModel which shows how to use a OBJ File to draw a complex geometry. The geometry is simply used, in this case, to draw the agents.\n\n\nCode of the model : \n\n```\n\n\nmodel obj_drawing   \n\nglobal {\n\tgeometry shape <- square(40);\n\n\tinit { \n\t\tcreate object number: 30;\n\t}  \n} \n\nspecies object skills: [moving]{\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\tint size <- rnd(10) + 1;\n\tint rot <- 1000 + rnd(1000);\n\treflex m when: every(100) {\n\t\tdo wander amplitude: 30 speed: 0.001;\n\t}\n\taspect obj {\n\t\tdraw obj_file(\"../includes/teapot.obj\") color: color size: size rotate: cycle/rot::{0,1,0};\n\t}\n}\t\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay ComplexObject type: opengl background:°orange{\n\t\t\tspecies object aspect:obj;\t\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Data-Importation-OBJ-file-drawing.md"},"Data-Importation-OBJ-file-loading.md":{"title":" Complex Object Loading","content":"[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_obj)\n# Complex Object Loading\n\n\n_Author :  Arnaud Grignard_\n\nProvides a  complex geometry to agents (svg,obj or 3ds are accepted). The geometry becomes that of the agents.\n\n\nCode of the model : \n\n```\n\nmodel obj_loading   \n\nglobal {\n\n\tinit { \n\t\tcreate object;\n\t}  \n} \n\nspecies object skills:[moving]{\n\t\n\tgeometry shape <- obj_file(\"../includes/teapot.obj\") as geometry;\n\t\n\treflex move{\n\t\tdo wander;\n\t}\n\taspect obj {\n\t\tdraw shape;\n\t}\n\t\t\t\n}\t\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay complex  background:#gray type: opengl{\n\t\t  species object aspect:obj;\t\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Data-Importation-OBJ-file-loading.md"},"Data-Importation-OSM-Loading.md":{"title":" OSM file to Agents","content":"[//]: # (keyword|operator_osm_file)\n[//]: # (keyword|operator_rnd_color)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_osm)\n[//]: # (keyword|concept_gis)\n# OSM file to Agents\n\n\n_Author :  Patrick Taillandier_\n\nModel which shows how to import a OSM File in GAMA and use it to create Agents. In this model, a filter is done to take only into account the roads and the buildings contained in the file. \n\n\nCode of the model : \n\n```\n\nmodel simpleOSMLoading \n \nglobal{\n\t\n\t//map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\n\tmap filtering <- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\",\"residential\", \"unclassified\"], \"building\"::[\"yes\"]]);\n\t//OSM file to load\n\tfile<geometry> osmfile <-  file<geometry>(osm_file(\"../includes/rouen.gz\", filtering))  ;\n\t\n\t//compute the size of the environment from the envelope of the OSM file\n\tgeometry shape <- envelope(osmfile);\n\t\n\tinit {\n\t\t//possibility to load all of the attibutes of the OSM data: for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\n\t\tcreate osm_agent from:osmfile with: [highway_str::string(read(\"highway\")), building_str::string(read(\"building\"))];\n\t\t\n\t\t//from the created generic agents, creation of the selected agents\n\t\task osm_agent {\n\t\t\tif (length(shape.points) = 1 and highway_str != nil ) {\n\t\t\t\tcreate node_agent with: [shape ::shape, type:: highway_str]; \n\t\t\t} else {\n\t\t\t\tif (highway_str != nil ) {\n\t\t\t\t\tcreate road with: [shape ::shape, type:: highway_str];\n\t\t\t\t} else if (building_str != nil){\n\t\t\t\t\tcreate building with: [shape ::shape];\n\t\t\t\t}  \n\t\t\t}\n\t\t\t//do the generic agent die\n\t\t\tdo die;\n\t\t}\n\t}\t\n}\n\nspecies osm_agent {\n\tstring highway_str;\n\tstring building_str;\n} \n\t\nspecies road {\n\trgb color <- rnd_color(255);\n\tstring type;\n\taspect default {\n\t\tdraw shape color: color; \n\t}\n} \n\t\nspecies node_agent {\n\tstring type;\n\taspect default { \n\t\tdraw square(3) color: #red ;\n\t}\n} \n\t\nspecies building {\n\taspect default { \n\t\tdraw shape color: rgb(200,200,200);\n\t}\n}  \n\nexperiment load_OSM type: gui {\n\toutput {\n\t\tdisplay map type: opengl {\n\t\t\tspecies building refresh: false;\n\t\t\tspecies road refresh: false  ;\n\t\t\tspecies node_agent refresh: false ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Data-Importation-OSM-Loading.md"},"Data-Importation-Raster-Image-Import.md":{"title":" Raster File in a Grid of cells","content":"[//]: # (keyword|operator_inside)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_raster)\n# Raster File in a Grid of cells\n\n\n_Author : Maroussia Vavasseur and Benoit Gaudou_\n\nModel which shows how to import a Raster file in GAMA and use it to initialize the color attributes of a grid of cells. This model represents a grid with a cell, each cell has a color, and this color is used for animals (izards) to be placed on a cell that verifies some conditions. The izards do not move once they have been placed. \n\n\nCode of the model : \n\n```\n\nmodel HowToImportRaster\n\nglobal {\t\n\t// Constants \n\tint heightImg const: true <- 5587;\n\tint widthImg const: true <- 6201;\t \n\t  \n\t// Global variables\n\tint factorDiscret <- 30 ;\n\tfile mntImageRaster <- image_file('../images/mnt/testAG.jpg') ;\n\t\n\tint nbIzard <- 250 ; \n\tfile izardShape <- file('../images/icons/izard.gif');\n\t\t\t\n\t// Initialization of grid and creation of the izard agents\n\t// - we use the as_matrix operator to transform a image file into a matrix of colors \n\t// (Note that as_matrix takes a Point as right operand, this point specifies the number of lines and columns of the matrix)\n\t// - we then set the color built-in attribute of the cell with the value of the corresponding matrix cell     \n\tinit {\n\t\t// set mapColor value: mntImageRaster as_matrix {widthImg/factorDiscret,heightImg/factorDiscret} ;\n\t\task cell {\t\t\n\t\t\tcolor <-rgb( (mntImageRaster) at {grid_x,grid_y}) ;\n\t\t}\n\t\tcreate izard number: nbIzard; \n    }\n}\n \n\n// We create izard agents and locate them on one'cell' among the list of cellules in which there is no izard \n// and with a color that is not white 'each.color != #white'\n// the shuffle operator is used to randomized the list of cells\n\n\nspecies izard {\t\n\tinit{\n\t\tlocation <- (shuffle(cell) first_with ((each.color != #white) and (empty(izard inside each)))).location ;\n\t}\t\t\n\taspect default{\n\t\tdraw square(1) color: #orange;\n\t}\n\taspect image{\n\t\tdraw izardShape size: 3;\n\t}\n}\n\n// We create a grid as environment with the same dimensions as the matrix in which we want to store the image\n// Note that the height (resp. the width) of the grid corresponds to the number of rows (resp. of columns) of the matrix:\n// - in the creation of a matrix: ([...] as_matrix {widthImg/factorDiscret,heightImg/factorDiscret} ;)\n// - in the creation of the grid: grid cellule width: widthImg/factorDiscret height: heightImg/factorDiscret;\n\ngrid cell  width: widthImg/factorDiscret height: heightImg/factorDiscret;\n\n\n\nexperiment main type: gui {\t\n\t// We display:\n\t// - the grid\n\t// - the original MNT image as background\n\t// - izard agents\n\t// We can thus compare the original MNT image and the discretized image in the grid.\n\t// For cosmetic need, we can choose to not display the grid. \n\toutput {\n\t\tdisplay HowToImportRaster {\n\t       grid cell;\n\t       image 'Background' file: mntImageRaster.path;\n\t       species izard aspect: image; \n\t    }   \n\t}\t\n}\n```\n","url":"wiki/Data-Importation-Raster-Image-Import.md"},"Data-Importation-Raster-Images-and-shapefile-Import.md":{"title":" Raster File and Shapefiles Import","content":"[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_as_matrix)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_raster)\n# Raster File and Shapefiles Import\n\n\n_Author : Maroussia Vavasseur and Benoit Gaudou_\n\nModel which imports data from a raster file and two shapefiles to initilalize a grid and two species. The roaster file initialize a grid attribute for the cells and the shapefiles a river species just with the same shape, and the managementUnit species with a link between the columns of the shapefile and the attributes of the species. \n\n\nCode of the model : \n\n```\n\nmodel RasterAndShapefiles\n\n\n \nglobal {\n\t// Constants\n\tint heightImg const: true <- 5587;\n\tint widthImg const: true <- 6201;\t\n\tfile boundsMNT const: true <- file(\"../images/mnt/boundsMNT.shp\"); \n\t\n\t\n// The environment bounds are defined using the hand-made boundsMNT shapefile.\n// This shapefile has been created as a georeferenced bounding box of the MNT raster image, using information of the .pgw file\n\tgeometry shape <- envelope(boundsMNT);\n\t\n\t// Global variables related to the MNT\n\tfile mntImageRaster <- image_file('../images/mnt/testAG.jpg') ;\n\tint factorDiscret  <- 10;\n\t\n\t// Global variables  related to the Management units\t\n\tfile ManagementUnitShape <- file('../images/ug/UGSelect.shp');\n\t\n\t// Global variables  related to the water network\n\tfile waterShape <- file('../images/reseauHydro/reseauEau.shp');\n\n\t// Global variables  related to izard agents\n\tint nbIzard <- 25 ;\n\tfile izardShape <-file('../images/icons/izard.gif') ;\n\t\t\n\t// Initialization of grid and creation of the izard agents.\n\t// Creation of managmentUnit and rivers agents from the corresponding shapefile\n\tinit {\n\t\tcreate managementUnit from: ManagementUnitShape \n\t\t\t\twith: [MUcode::int(read('Code_UG')), MULabel::string(read('Libelle_UG')), pgeSAGE::string(read('PGE_SAGE'))] ;\n\t\t\t\t\n\t\tcreate river from: waterShape;\n\t\t\t\t\n\t\tmatrix<int> mapColor <- matrix<int>(mntImageRaster as_matrix {widthImg/factorDiscret,heightImg/factorDiscret}) ;\n\t\task cell {\t\t\n\t\t\tcolor <- rgb( mapColor at {grid_x,grid_y} );\n\t\t}\n\t\tcreate izard number: nbIzard; \t\t\t\n    }\n}\n\nspecies river {\n\taspect default{\n\t\tdraw shape color: #blue;\n\t}\t\n}\n\nspecies managementUnit{\n\tint MUcode;\n\tstring MULabel;\n\tstring pgeSAGE;\n\t\n\taspect default{\n\t\tdraw shape;\n\t}\n}\t\nspecies izard {\t\n\tinit{\n\t\tlocation <- (shuffle(cell) first_with ((each.color != #white) and (empty(izard inside each)))).location ;\n\t}\t\n\taspect default{\n\t\tdraw square(5000) color: #orange;\n\t}\n\taspect image{\n\t\tdraw izardShape size: 5000;\n\t}\n}\t\n\n// We create a grid as environment with the same dimensions as the matrix in which we want to store the image\n\ngrid cell width: widthImg/factorDiscret height: heightImg/factorDiscret;\n\n\n\nexperiment main type: gui {\n\t\n\t// We display:\n\t// - the original MNT image as background\n\t// - the grid representing the MNT\n\t// - izard agents\n\t// - the management unit shapefile\n\t// - the river shapefile\n\t// We can thus compare the original MNT image and the discretized image in the grid.\n\t// For cosmetic need, we can choose to not display the grid. \n\toutput {\n\t\tdisplay HowToImportVectorial {\n\t        image 'Background' file: mntImageRaster.path;  \t\t\n\t       \tgrid cell;\n\t \t\tspecies managementUnit transparency: 0.5;\n\t \t\tspecies river ;\n\t \t\tspecies izard aspect: image;  \n\t\t}\n\t}\n}\n\n\n```\n","url":"wiki/Data-Importation-Raster-Images-and-shapefile-Import.md"},"Database-Usage-Agents-from-Database-in-MSSQL.md":{"title":"  Agents from Database in MSSQL","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Agents from Database in MSSQL\n\n\n_Author : Benoit Gaudou_\n\n This model does SQl query commands and create agents using the results\n\n\nCode of the model : \n\n```\nmodel DB2agentMSSQL\n\nglobal {\n\tmap<string,string> BOUNDS <- [\t//\"srid\"::\"32648\", // optinal\n\t\t\t\t\t\t\t\t\t\"host\"::\"localhost\",\n\t\t\t\t\t\t\t\t\t\"dbtype\"::\"sqlserver\",\n\t\t\t\t\t\t\t\t\t\"database\"::\"spatial_DB\",\n\t\t\t\t\t\t\t\t\t\"port\"::\"1433\",\n\t\t\t\t\t\t\t\t\t\"user\"::\"sa\",\n\t\t\t\t\t\t\t\t\t\"passwd\"::\"tmt\",\n\t\t\t\t\t\t\t\t  \t\"select\"::\"SELECT GEOM.STAsBinary() as GEOM FROM bounds;\" ];\n\tmap<string,string> PARAMS <- [\t//\"srid\"::\"32648\", // optinal\n\t\t\t\t\t\t\t\t\t\"host\"::\"localhost\",\n\t\t\t\t\t\t\t\t\t\"dbtype\"::\"sqlserver\",\n\t\t\t\t\t\t\t\t\t\"database\"::\"spatial_DB\",\n\t\t\t\t\t\t\t\t\t\"port\"::\"1433\",\n\t\t\t\t\t\t\t\t\t\"user\"::\"sa\",\n\t\t\t\t\t\t\t\t\t\"passwd\"::\"tmt\"];\n\t\n\tstring QUERY <- \"SELECT name, type, GEOM.STAsBinary() as GEOM FROM buildings ;\";\n\tgeometry shape <- envelope(BOUNDS);\t\t  \t\n\tinit {\n\t\tcreate DB_accessor {\n\t\t\tcreate buildings from: (self select [params:: PARAMS, select:: QUERY]) \n\t\t\t\t\t\t\t with:[ \"name\"::\"name\",\"type\"::\"type\", \"shape\":: geometry(\"geom\")];\n\t\t }\n\t}\n}\n\n\nspecies DB_accessor skills: [SQLSKILL];\n\t\nspecies buildings {\n\tstring type;\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\t\n}\t\n\nexperiment DB2agentMSSQL type: gui {\n\toutput {\n\t\tdisplay fullView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Database-Usage-Agents-from-Database-in-MSSQL.md"},"Database-Usage-Agents-from-Database-in-MySQL.md":{"title":"  Agents from Database in MySQL","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Agents from Database in MySQL\n\n\n_Author : Benoit Gaudou_\n\n This model does SQl query commands and create agents using the results\n\n\nCode of the model : \n\n```\nmodel DB2agentMySQL\n\nglobal {\n\tmap<string,string> BOUNDS <- [\t//'srid'::'32648', // optinal\n\t\t\t\t\t\t\t\t\t'host'::'localhost',\n\t\t\t\t\t\t\t\t\t'dbtype'::'MySQL',\n\t\t\t\t\t\t\t\t\t'database'::'spatial_DB',\n\t\t\t\t\t\t\t\t\t'port'::'8889',\n\t\t\t\t\t\t\t\t\t'user'::'root',\n\t\t\t\t\t\t\t\t\t'passwd'::'root',\n\t\t\t\t\t\t\t\t  \t\"select\"::\"SELECT geom FROM bounds;\" ];\n\tmap<string,string> PARAMS <- [\t//'srid'::'32648', // optinal\n\t\t\t\t\t\t\t\t\t'host'::'localhost',\n\t\t\t\t\t\t\t\t\t'dbtype'::'MySQL',\n\t\t\t\t\t\t\t\t\t'database'::'spatial_DB',\n\t\t\t\t\t\t\t\t\t'port'::'8889',\n\t\t\t\t\t\t\t\t\t'user'::'root',\n\t\t\t\t\t\t\t\t\t'passwd'::'root'];\n\t\n\tstring QUERY <- \"SELECT name, type, geom FROM buildings ;\";\n\tgeometry shape <- envelope(BOUNDS);\t\t  \t\n\t \t\n\tinit {\n\t\tcreate DB_accessor {\n\t\t\tcreate buildings from: list(self select [params:: PARAMS, select:: QUERY]) \n\t\t\t\t\t\t\t with:[ 'name'::\"name\",'type'::\"type\", 'shape':: geometry(\"geom\")];\n\t\t }\n\t}\n}\n\n\nspecies DB_accessor skills: [SQLSKILL];\n\nspecies buildings {\n\tstring type;\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\t\n}\t\n\nexperiment DB2agentSQLite type: gui {\n\toutput {\n\t\tdisplay fullView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Database-Usage-Agents-from-Database-in-MySQL.md"},"Database-Usage-Agents-from-Database-in-PostGIS.md":{"title":"  Agents from Database in PostGIS","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Agents from Database in PostGIS\n\n\n_Author : Benoit Gaudou_\n\n This model does SQL query commands and create agents using the results\n\n\nCode of the model : \n\n```\nmodel DB2agentMySQL \n\nglobal {\n\tmap<string,string> BOUNDS <- [\t//'srid'::'32648', // optinal\n\t \t\t\t\t\t\t\t\t'host'::'localhost',\n\t\t\t\t\t\t\t\t\t'dbtype'::'postgres',\n\t\t\t\t\t\t\t\t\t'database'::'spatial_DB',\n\t\t\t\t\t\t\t\t\t'port'::'5433',\n\t\t\t\t\t\t\t\t\t'user'::'postgres',\n\t\t\t\t\t\t\t\t\t'passwd'::'tmt',\n\t\t\t\t\t\t\t\t  \t'select'::'SELECT ST_AsBinary(geom) as geom FROM buildings;' ];\n\tmap<string,string> PARAMS <- [\t//'srid'::'32648', // optinal\n\t\t\t\t\t\t\t\t\t'host'::'localhost',\n\t\t\t\t\t\t\t\t\t'dbtype'::'postgres',\n\t\t\t\t\t\t\t\t\t'database'::'spatial_DB',\n\t\t\t\t\t\t\t\t\t'port'::'5433',\n\t\t\t\t\t\t\t\t\t'user'::'postgres',\n\t\t\t\t\t\t\t\t\t'passwd'::'tmt'];\n\t\n\tstring QUERY <- \"SELECT name, type, ST_AsBinary(geom) as geom FROM buildings ;\";\n\tgeometry shape <- envelope(BOUNDS);\t\t  \t\n\t\t  \t\n\tinit {\n\t\tcreate DB_accessor {\n\t\t\tcreate buildings from: (self select [params:: PARAMS, select:: QUERY]) \n\t\t\t\t\t\t\t with:[ 'name'::\"name\",'type'::\"type\", 'shape':: geometry(\"geom\")];\n\t\t }\n\t}\n}\n\nspecies DB_accessor skills: [SQLSKILL];\n\nspecies buildings {\n\tstring type;\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\t\n}\t\n\nexperiment DB2agentSQLite type: gui {\n\toutput {\n\t\tdisplay fullView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Database-Usage-Agents-from-Database-in-PostGIS.md"},"Database-Usage-Agents-from-Database-in-SQLite.md":{"title":"  Agents from Database in SQLite ","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Agents from Database in SQLite \n\n\n_Author : Benoit Gaudou_\n\n This model creates buildings agents from the sqlite database using the result of a query\n\n\nCode of the model : \n\n```\nmodel DB2agentSQLite\n\nglobal {\n//\tfile buildingsShp <- file('../../includes/building.shp');\n//\tfile boundsShp <- file('../../includes/bounds.shp');\n//\tgeometry shape <- envelope(boundsShp);\n\n\t\n\tmap<string,string> BOUNDS <- [\"dbtype\"::\"sqlite\",\n\t\t\t\t\t\t\t\t  'database'::'../../includes/spatialite.db',\n\t\t\t\t\t\t\t\t //'srid'::'32648',\n\t\t\t\t\t\t\t\t  \"select\"::\"SELECT AsBinary(geom) as geom FROM bounds;\"\t\t\t\t\n\t\t\t\t  \t\t\t\t ];\n\tmap<string,string> PARAMS <- [\"dbtype\"::\"sqlite\",\n\t\t\t\t\t\t\t\t  //'srid'::'32648',\n\t\t\t\t\t\t\t\t  'database'::'../../includes/spatialite.db'\n\t\t\t\t\t\t\t\t  ];\n\t\n\tstring QUERY <- \"SELECT name, type, AsBinary(geom) as geom FROM buildings ;\";\n\tgeometry shape <- envelope(BOUNDS);\t\t  \t\n\t  \t\n\tinit {\n\t\tcreate DB_accessor {\n\t\t\tcreate buildings from: list(self select [params:: PARAMS, select:: QUERY]) \n\t\t\t\t\t\t\t with:[ 'name'::\"name\",'type'::\"type\", 'shape':: geometry(\"geom\")];\n\t\t }\n\t}\n}\n\nspecies DB_accessor skills: [SQLSKILL];\n\nspecies buildings {\n\tstring type;\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\t\n}\t\n\nexperiment DB2agentSQLite type: gui {\n\toutput {\n\t\tdisplay fullView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Database-Usage-Agents-from-Database-in-SQLite.md"},"Database-Usage-Agents-from-Database-in-SQLite_QGis.md":{"title":"  Agents from Database in SQLite QGIS","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Agents from Database in SQLite QGIS\n\n\n_Author : Truong Minh Thai_\n\n This model loads data from vnm_adm2 that is created by QGis.\n\n * In this case we do not need using AsBinary() to convert blob data to WKB format.  \n \n * In other case, if we load Geometry data that is created by using libspatialite library then we must use Asbinary() \n * to convert geometry to WKB format (see SQLite_libspatialite model)\n\n\nCode of the model : \n\n```\nmodel Sqlite_QGis\n \n  \nglobal { \n\tmap BOUNDS <- [//'srid'::'4326', // optinal\n\t\t\t\t  \"dbtype\"::\"sqlite\",\n\t\t\t\t  \"database\"::\"../../includes/spatialite.db\"\n\t\t\t\t  ,\"select\"::\t\"select geom  from bounds;\" \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t  ]; \n\tmap PARAMS <- [//'srid'::'4326', // optinal\n\t\t\t\t\t\"dbtype\"::\"sqlite\",\n\t\t\t\t\t\"database\"::\"../../includes/bph.db\"];\n\tstring QUERY <- \"SELECT name, type, geom as geom FROM buildings ;\";\n\tgeometry shape <- envelope(BOUNDS);\t\t  \t\n\t\t  \t\n\tinit {\n\t\tcreate DB_accessor {\n\t\t\tcreate buildings from: (self select [params:: PARAMS, select:: QUERY]) \n\t\t\t\t\t\t\t with:[ 'name'::\"name\",'type'::\"type\", 'shape':: geometry(\"geom\")];\n\t\t }\n\t}\n}\n\nspecies DB_accessor skills: [SQLSKILL];\n\nspecies buildings {\n\tstring type;\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\t\n}\t\n\nexperiment DB2agentSQLite type: gui {\n\toutput {\n\t\tdisplay fullView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Database-Usage-Agents-from-Database-in-SQLite_QGis.md"},"Database-Usage-Agents-to-Database-in-MSSQL.md":{"title":"  Agents to Database in MSSQL","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Agents to Database in MSSQL\n\n\n_Author : Truong Minh Thai_\n\n This model shows how to Insert and Delete agents from a MSSQL DB\n\n\nCode of the model : \n\n```\nmodel agent2DB_MSSQL \n  \nglobal {  \n\tfile buildingsShp <- file('../../includes/building.shp');\n\tfile boundsShp <- file('../../includes/bounds.shp');\n\tgeometry shape <- envelope(boundsShp);\n\tmap<string,string> PARAMS <- [//'srid'::'4326', // optinal\n\t\t\t\t\t\t\t\t  'host'::'127.0.0.1','dbtype'::'sqlserver','database'::'spatial_DB',\n\t\t\t\t\t\t\t\t  'port'::'1433','user'::'sa','passwd'::'tmt'];\n\n\tinit {\n\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\n\t\tcreate bounds from: boundsShp;\n\t\t\n\t\tcreate DB_Accessor \n\t\t{ \t\t\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\n\t\t}\n\t\twrite \"Click on <<Step>> button to save data of agents to DB\";\t\t \n\t}\n}   \n  \nspecies DB_Accessor skills: [SQLSKILL] ;   \n\nspecies bounds {\n\treflex printdata{\n\t\t write ' name : ' + (name) ;\n\t}\n\t\n\treflex savetosql{  // save data into MSSQL\n\t\twrite \"begin\"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"bounds\"\n\t\t\t\t\t  columns: [\"geom\"]\n\t\t\t\t\t  values: [myself.shape];\n\t\t}\n\t    write \"finish \"+ name;\n\t}\t\t\n}\n\nspecies buildings {\n\tstring type;\n\t\n\treflex printdata{\n\t\t write ' name : ' + (name) + '; type: ' + (type) + \"shape:\" + shape;\n\t}\n\t\n\treflex savetosql{  // save data into MSSQL\n\t\twrite \"begin\"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"buildings\"\n\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\n\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\n\t\t}\n\t    write \"finish \"+ name;\n\t}\t\n\t\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}     \n\nexperiment default_expr type: gui {\n\toutput {\n\t\t\n\t\tdisplay GlobalView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Database-Usage-Agents-to-Database-in-MSSQL.md"},"Database-Usage-Agents-to-Database-in-MySQL.md":{"title":"  Agents to Database in MySQL","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Agents to Database in MySQL\n\n\n_Author : Truong Minh Thai_\n\n  init: Select data from table vnm_adm2 (Created via QGis software)  and create  agents\nsavetosql: Save data of agent into MySQL. \ntransform= true because you need to transform geometry data from Absolute(GAMA) to Gis\nNOTE: You should have imported the database (spatial_DB.sql) into the MySQL server in order that the model can run properly.\n\n\nCode of the model : \n\n```\n\nmodel agent2DB_MySQL \n  \nglobal { \n\tfile buildingsShp <- file('../../includes/building.shp');\n\tfile boundsShp <- file('../../includes/bounds.shp');\n\tgeometry shape <- envelope(boundsShp);\n\t\n\tmap<string,string> PARAMS <- ['srid'::'4326',\n\t\t\t\t                  'host'::'localhost','dbtype'::'MySQL','database'::'spatial_DB',\n\t\t\t\t                  'port'::'8889','user'::'root','passwd'::'root'];\n\n\tinit {\n\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\n\t\tcreate bounds from: boundsShp;\n\t\t\n\t\tcreate DB_Accessor number: 1  \n\t\t{ \t\t\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\n\t\t}\n\t\twrite \"Click on <<Step>> button to save data of agents to DB\";\t\t \n\t}\n}   \n \nspecies DB_Accessor skills: [SQLSKILL] ;   \n\nspecies bounds {\n\treflex printdata{\n\t\t write ' name : ' + (name) ;\n\t}\n\t\n\treflex savetosql{  // save data into MySQL\n\t\twrite \"begin\"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"bounds\"\n\t\t\t\t\t  columns: [\"geom\"]\n\t\t\t\t\t  values: [myself.shape];\n\t\t}\n\t    write \"finish \"+ name;\n\t}\t\t\n}\n\nspecies buildings {\n\tstring type;\n\t\n\treflex printdata{\n\t\t write ' name : ' + (name) + '; type: ' + (type) + \"shape:\" + shape;\n\t}\n\t\n\treflex savetosql{  // save data into MySQL\n\t\twrite \"begin\"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"buildings\"\n\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\n\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\n\t\t}\n\t    write \"finish \"+ name;\n\t}\t\n\t\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}     \n\nexperiment default_expr type: gui {\n\toutput {\n\t\t\n\t\tdisplay GlobalView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Database-Usage-Agents-to-Database-in-MySQL.md"},"Database-Usage-Agents-to-Database-in-PostGIS.md":{"title":"  Agents to Database in PostGIS","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Agents to Database in PostGIS\n\n\n_Author : Truong Minh Thai_\n\ninit: Select data from table vnm_adm2 (Created via QGis software)  and create  agents\nsavetosql: Save data of agent into MySQL.\ntransform= true because you need to transform geometry data from Absolute(GAMA) to Gis\nNOTE: You should have imported the database (spatial_DB.sql) into the MySQL server in order that the model can run properly.\n\n\n\nCode of the model : \n\n```\n\nmodel agent2DB_MySQL \n  \nglobal { \n\tfile buildingsShp <- file('../../includes/building.shp');\n\tfile boundsShp <- file('../../includes/bounds.shp');\n\tgeometry shape <- envelope(boundsShp);\n\t \n\tmap<string,string> PARAMS <-  [//'srid'::'4326', // optinal\n\t\t\t\t\t\t\t\t   'host'::'localhost','dbtype'::'Postgres','database'::'spatial_DB',\n\t\t\t\t\t\t\t\t   'port'::'5433','user'::'postgres','passwd'::'tmt'];\n\n\tinit {\n\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\n\t\tcreate bounds from: boundsShp;\n\t\t\n\t\tcreate DB_Accessor\n\t\t{ \t\t\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\n\t\t}\n\t\twrite \"Click on <<Step>> button to save data of agents to DB\";\t\t \n\t}\n}   \n  \nspecies DB_Accessor skills: [SQLSKILL] ;   \n\nspecies bounds {\n\treflex printdata{\n\t\t write \" name : \" + (name) ;\n\t}\n\t\n\treflex savetosql{  // save data into Postgres\n\t\twrite \"begin\"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"bounds\"\n\t\t\t\t\t  columns: [\"geom\"]\n\t\t\t\t\t  values: [myself.shape];\n\t\t}\n\t    write \"finish \"+ name;\n\t}\t\t\n}\n\nspecies buildings {\n\tstring type;\n\t\n\treflex printdata{\n\t\twrite \" name : \" + (name) + \"; type: \" + (type) + \"shape:\" + shape;\n\t}\n\t\n\treflex savetosql{  // save data into Postgres\n\t\twrite \"begin\"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"buildings\"\n\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\n\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\n\t\t}\n\t    write \"finish \"+ name;\n\t}\t\n\t\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}   \n\nexperiment default_expr type: gui {\n\toutput {\n\t\t\n\t\tdisplay GlobalView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Database-Usage-Agents-to-Database-in-PostGIS.md"},"Database-Usage-Agents-to-Database-in-SQLite.md":{"title":"  Agents to Database in SQLite","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Agents to Database in SQLite\n\n\n_Author : Truong Minh Thai_\n\n   init: Select data from table vnm_adm2 (Created via QGis software)  and create  agents\n\n * savetosql: Save data of agent into MySQL.\n \n * transform= true because you need to transform geometry data from Absolute(GAMA) to Gis\n \n\nCode of the model : \n\n```\n\nmodel agent2DB_SQLite  \n  \nglobal {  \n\tfile buildingsShp <- file('../../includes/building.shp');\n\tfile boundsShp <- file('../../includes/bounds.shp');\n\tgeometry shape <- envelope(boundsShp);\n\t\n\tmap<string,string> PARAMS <- [\n\t\t\t\t'dbtype'::'sqlite', \n\t\t\t\t//'srid'::'4326', // optinal\n\t\t\t\t'database'::'../../includes/spatialite.db'\n\t\t\t\n\t\t\t\t];\n\n\n\tinit {\n\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\n\t\tcreate bounds from: boundsShp;\n\t\t\n\t\tcreate DB_Accessor  \n\t\t{ \t\t\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\t\t\t\n\t\t}\n\t\twrite \"Click on <<Step>> button to save data of agents to DB\";\t\t \n\t}\n}   \n \nspecies DB_Accessor skills: [SQLSKILL] ;   \n\nspecies bounds {\n\treflex printdata{\n\t\t write ' name : ' + (name) ;\n\t}\n\t \n\treflex savetosql{  // save data into SQLite\n\t\twrite \"begin bound\";\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"bounds\"\n\t\t\t\t\t  columns: [\"geom\"]\n\t\t\t\t\t  values: [myself.shape];\n\t\t}\n\t    write \"finish bound\";\n\t}\t\t\n}\t\n\nspecies buildings {\n\tstring type;\n\t\n\treflex printdata{\n\t\t write ' name : ' + (name) + '; type: ' + (type) + \"shape:\" + shape;\n\t}\n\t\n\treflex savetosql{  // save data into SQLite\n\t\twrite \"begin\"+ name;\n\t\task DB_Accessor {\n\t\t\tdo insert params: PARAMS into: \"buildings\"\n\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\n\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\n\t\t}\n\t    write \"finish \"+ name;\n\t}\t\n\t\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}    \n\nexperiment default_expr type: gui {\n\toutput {\n\t\t\n\t\tdisplay GlobalView {\n\t\t\tspecies buildings aspect: default;\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Database-Usage-Agents-to-Database-in-SQLite.md"},"Database-Usage-Connection-Test.md":{"title":" SQLConnection","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n# SQLConnection\n\n\n_Author : thaitruongminh_\n\nHow to create a connection to a database in GAMA\n\n\nCode of the model : \n\n```\nmodel test_connection\n\nglobal {\n\tmap<string, string> SQLSERVER <- ['host'::'localhost', 'dbtype'::'sqlserver', 'database'::'', 'port'::'1433', 'user'::'sa', 'passwd'::'tmt'];\n\tmap<string, string> MySQL <- ['host'::'localhost', 'dbtype'::'MySQL', 'database'::'', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\n\tmap<string, string> ORACLE <- ['host'::'localhost', 'dbtype'::'Oracle', 'database'::'', 'port'::'1433', 'user'::'sa', 'passwd'::'tmt'];\n\tmap<string, string> POSTGRES <- ['host'::'localhost', 'dbtype'::'Postgres', 'database'::'bgaudou', 'port'::'5432', 'user'::'bgaudou', 'passwd'::''];\n\tmap<string, string> SQLITE <- ['dbtype'::'sqlite', 'database'::'../../includes/meteo.db'];\n\tinit {\n\t\tcreate DB_connection_tester;\n\t}\n\n}\n\nspecies DB_connection_tester skills: [SQLSKILL] {\n\tinit {\n\t\twrite \"Current Time \" + self timeStamp [];\n\t\twrite \"Connection to SQLSERVER is \" + self testConnection [params::SQLSERVER];\n\t\twrite \"Connection to MySQL is \" + self testConnection [params::MySQL];\n\t\twrite \"Connection to SQLITE is \" + self testConnection [params::SQLITE];\n\t\twrite \"Connection to ORACLE is \" + self testConnection [params::ORACLE];\n\t\twrite \"Connection to POSTGRESQL is \" + self testConnection [params::POSTGRES];\n\t}\n\n}\n\nexperiment default_expr type: gui {\n}  \n```\n","url":"wiki/Database-Usage-Connection-Test.md"},"Database-Usage-Create-Agents-and-Insert-in-MySQL.md":{"title":"  create_agents_Insert_result_MySQL","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  create_agents_Insert_result_MySQL\n\n\n_Author : Benoit Gaudou_\n\nThis model illustrates the use of the MySQL DBMS to: \n\n *     - create agents from a database\n \n *     - store every cycle some results into a database\n \n \n *  Note: this model could be used with any DBMS just by changing the PARAMS variable.\n \n \n *  NOTE: YOU SHOULD HAVE ALREADY CREATED YOUR DATABASE (meteo_DB here) AND IMPORTED THE FILE (../../includes/meteo_DB_dump.sql)\n *        IN ORDER THAT THE MODEL CAN RUN PROPERLY.\n\n\nCode of the model : \n\n```\nmodel create_agents_Insert_result_MySQL \n\nglobal {\n\tstring res_DB <- '`result_DB`';\n\tmap<string, string> PARAMS <- ['host'::'localhost', 'dbtype'::'MySQL', 'database'::'meteo_DB', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\n\tstring SQLquery_idPoint <- \"SELECT `idPointgrille`, AVG(`RRmm`) AS RR, AVG(`Tmin`) AS Tmin, AVG(`Tmax`) AS Tmax, AVG(`Rglot`) AS Rglot, AVG(`ETPmm`) AS ETPmm\n    \t\t\tFROM meteo_table GROUP BY `idPointgrille`\";\n\tinit {\n\t\tcreate DB_accessor;\n\t\task DB_accessor {\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE `result_DB` (\n\t\t\t\t\t\t\t\t\t\t  `idPoint` varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,\n\t\t\t\t\t\t\t\t\t\t  `valRnd` float NOT NULL DEFAULT '0',\n\t\t\t\t\t\t\t\t\t\t  `cycle` int(16) NOT NULL DEFAULT '0'\n\t\t\t\t\t\t\t\t\t\t) ENGINE=InnoDB DEFAULT CHARSET=utf8;\";\n\t\t}\n\n\t\tcreate idPoint from: list(first(DB_accessor) select [params::PARAMS, select::SQLquery_idPoint]) with:\n\t\t[name:: \"idPointgrille\", RRmm::float(\"RR\"), Tmin::float(\"Tmin\"), Tmax::float(\"Tmax\"), Rglot::float(\"Rglot\"), ETPmm::float(\"ETPmm\")];\n\t}\n\n\treflex endSimu when: (cycle = 10) {\n\t\task DB_accessor {\n\t\t\twrite \"Data: \" + (self select [params::PARAMS, select::\"select * FROM \" + res_DB]);\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"DROP TABLE \" + res_DB;\n\t\t}\n\n\t\twrite \"DROP the result table\";\n\t\tdo halt; \n\t}\n\n}\n\nspecies idPoint {\n\tfloat RRmm;\n\tfloat Tmin;\n\tfloat Tmax;\n\tfloat Rglot;\n\tfloat ETPmm;\n\tfloat valRnd;\n\treflex compute_new_random_value {\n\t\tvalRnd <- float(rnd(RRmm + Tmin + Tmax + Rglot + ETPmm));\n\t}\n\n\treflex store_valRnd {\n\t\twrite \" \" + self + \" inserts value \" + valRnd;\n\t\task (first(DB_accessor)) {\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO \" + res_DB + \" VALUES(?, ?, ?);\" values: [myself.name, myself.valRnd, cycle];\n\t\t}\n\n\t\twrite \" \" + self + \" inserts value \" + valRnd;\n\t}\n\n}\n\nspecies DB_accessor skills: [SQLSKILL] {\n\tlist listRes <- [];\n\tinit {\n\t// Test of the connection to the database\n\t\tif (not (self testConnection [params::PARAMS])) {\n\t\t\twrite \"Connection impossible\";\n\t\t\task (world) {\n\t\t\t\tdo halt;\n\t\t\t}\n\n\t\t} else {\n\t\t\twrite \"Connection Database OK.\";\n\t\t}\n\n\t\twrite \"\" + list(self select [params::PARAMS, select::\"SELECT * FROM meteo_table\"]);\n\t\twrite \"\" + list(self select [params::PARAMS, select::SQLquery_idPoint]);\n\t}\n\n}\n\nexperiment createInsertMySQL type: gui {\n}\n   \n```\n","url":"wiki/Database-Usage-Create-Agents-and-Insert-in-MySQL.md"},"Database-Usage-Create-Spatial-Table-in-MSSQL.md":{"title":"  CreateBuildingTableMSSQL","content":"[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  CreateBuildingTableMSSQL\n\n\n_Author : Truong Minh Thai_\n\nThis model shows how to create a database and a table in MSSQL using GAMA\n \n\nCode of the model : \n\n```\nmodel CreateBuildingTable_MSSQL\n\n\nglobal\n{\n\tmap<string, string> PARAMS <- ['host'::'127.0.0.1', 'dbtype'::'sqlserver', 'database'::'', 'port'::'1433', 'user'::'sa', 'passwd'::'tmt'];\n\tinit\n\t{\n\t\tcreate dummy;\n\t\task dummy\n\t\t{\n\t\t\tif (self testConnection [params::PARAMS])\n\t\t\t{\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE DATABASE spatial_DB\";\n\t\t\t\twrite \"spatial_BD database was created \";\n\t\t\t\tremove  \"database\" from: PARAMS;\n\t\t\t\tput \"spatial_DB\" key: \"database\" in: PARAMS;\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds\" + \"( \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"bounds table was created \";\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" + \"( \" + \" name VARCHAR(255), \" + \" type VARCHAR(255), \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"buildings table was created \";\n\t\t\t} else\n\t\t\t{\n\t\t\t\twrite \"Connection to MySQL can not be established \";\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nspecies dummy skills: [SQLSKILL]\n{\n}\n\nexperiment default_expr type: gui\n{\n}\n```\n","url":"wiki/Database-Usage-Create-Spatial-Table-in-MSSQL.md"},"Database-Usage-Create-Spatial-Table-in-MySQL.md":{"title":"  CreateBuildingTableMySQL","content":"[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  CreateBuildingTableMySQL\n\n\n_Author : Truong Minh Thai_\n\nThis model shows how to create a database and a table in MySQL using GAMA\n \n\nCode of the model : \n\n```\nmodel CreateBuildingTableMySQL\n\n\nglobal\n{\n\tmap<string, string> PARAMS <- ['host'::'localhost', 'dbtype'::'MySQL', 'database'::'', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\n\tinit\n\t{\n\t\tcreate test_species number: 1;\n\t\task test_species\n\t\t{\n\t\t\tif (self testConnection [params::PARAMS])\n\t\t\t{\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE DATABASE spatial_DB_GAMA\";\n\t\t\t\twrite \"spatial_BD_GAMA database was created \";\n\t\t\t\tremove \"database\" from: PARAMS;\n\t\t\t\tput \"spatial_DB_GAMA\" key: \"database\" in: PARAMS;\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds\" + \"( \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"bounds table was created \";\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" + \"( \" + \" name VARCHAR(255), \" + \" type VARCHAR(255), \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"buildings table was created \";\n\t\t\t} else\n\t\t\t{\n\t\t\t\twrite \"Connection to MySQL can not be established \";\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nspecies test_species skills: [SQLSKILL]\n{\n}\n\nexperiment default_expr type: gui\n{\n}\n```\n","url":"wiki/Database-Usage-Create-Spatial-Table-in-MySQL.md"},"Database-Usage-Create-Spatial-Table-in-PostGIS.md":{"title":"  CreateBuildingTablePostGIS","content":"[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  CreateBuildingTablePostGIS\n\n\n_Author : Truong Minh Thai_\n\nThis model shows how to create a database and a table in PostGIS using GAMA\n \n\nCode of the model : \n\n```\nmodel CreateBuildingTablePostGIS\n\n\nglobal\n{\n\tmap<string, string> PARAMS <- ['host'::'localhost', 'dbtype'::'Postgres', 'database'::'', 'port'::'5433', 'user'::'postgres', 'passwd'::'tmt'];\n\tinit\n\t{\n\t\tcreate dummy;\n\t\task dummy\n\t\t{\n\t\t\tif (self testConnection [params::PARAMS])\n\t\t\t{\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE DATABASE spatial_db with TEMPLATE = template_postgis;\";\n\t\t\t\twrite \"spatial_BD database was created \";\n\t\t\t\tremove \"database\" from: PARAMS;\n\t\t\t\tput \"spatial_db\" key: \"database\" in: PARAMS;\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds\" + \"( \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"bounds table was created \";\n\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" + \"( \" + \" name character varying(255), \" + \" type character varying(255), \" + \" geom GEOMETRY \" + \")\";\n\t\t\t\twrite \"buildings table was created \";\n\t\t\t} else\n\t\t\t{\n\t\t\t\twrite \"Connection to MySQL can not be established \";\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nspecies dummy skills: [SQLSKILL]\n{\n}\n\nexperiment default_expr type: gui\n{\n}\n```\n","url":"wiki/Database-Usage-Create-Spatial-Table-in-PostGIS.md"},"Database-Usage-Create-Spatial-Table-in-SQLite.md":{"title":"  CreateBuildingTableSQLite","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  CreateBuildingTableSQLite\n\n\n_Author : Truong Minh Thai_\n\nThis model shows how to create a database and a table in SQLite using GAMA\n \n\nCode of the model : \n\n```\n\nmodel SQLite_selectNUpdate\n  \nglobal {\n\tmap PARAMS <- ['dbtype'::'sqlite','database'::'../../includes/spatialite.db'];\n\n\tinit {\n\t\tcreate dummy ;\n\t\task (dummy)\t\n\t\t{ \n\t\t\tdo  executeUpdate params: PARAMS \n\t\t\t\t\tupdateComm: \"DROP TABLE bounds; \" ;\n \t\t\tdo  executeUpdate params: PARAMS \n \t\t\t\t\tupdateComm: \"DROP TABLE buildings; \" ;\n  \n \t\t\twrite \"dropped tables!\";\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds \" +\n                   \"(id INTEGER PRIMARY KEY, \" +\n\t\t\t\t   \" geom BLOB NOT NULL); \"  ;\n \t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" +\n                   \"(id INTEGER PRIMARY KEY, \" +\n                   \" name TEXT NOT NULL,\" +\n                   \" type TEXT NOT NULL,\" +\n                   \" geom BLOB NOT NULL); \"  ;\n\n\t\t}\n\t}\n}  \n\nspecies dummy skills: [SQLSKILL] { } \n\nexperiment default_expr type:gui {\n\n}     \n```\n","url":"wiki/Database-Usage-Create-Spatial-Table-in-SQLite.md"},"Database-Usage-Simple-Species-MySQL.md":{"title":"  Simple Species MySql","content":"[//]: # (keyword|concept_database)\n#  Simple Species MySql\n\n\n_Author : Truong Minh Thai_\n\n This model illustrates the use of the AgentDB species (instead of the SQLSKILL), and in particular following actions:\n\n *    - testConection\n \n *    - isConnected\n \n *    - close \n \n *    - executeUpdate\n \n *    - insert\n \n *    - select\n \n *    - getParameter \n \n \n *  This model does SQl query commands:\n \n * - Create table \n \n * - Insert data\n \n * - Select data\n \n * - Delete data\n \n * - Drop table \n \n \n *  NOTE: YOU SHOULD HAVE ALREADY CREATED YOUR DATABASE (meteo_DB here) AND IMPORTED THE FILE (../../includes/meteo_DB_dump.sql)\n *        IN ORDER THAT THE MODEL CAN RUN PROPERLY.\n\n\nCode of the model : \n\n```\nmodel simpleSQL_DBSpecies_MySQL\n\nglobal {\n\tmap<string, string> PARAMS <- ['host'::'localhost', 'dbtype'::'MySQL', 'database'::'meteo_DB', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\n\tinit {\n\t\tcreate DB_Accessor number: 1 {\n\t\t\tif (self testConnection (params::PARAMS) = false) {\n\t\t\t\twrite \"Impossible connection\";\n\t\t\t} else {\n\t\t\t\twrite \"Connection of \" + self;\n\t\t\t\tdo connect params: PARAMS;\n\t\t\t}\n\n\t\t}\n\n\t\tif (first(DB_Accessor) isConnected [] = false) {\n\t\t\twrite \"No connection.\";\n\t\t\task (AgentDB) {\n\t\t\t\tdo close;\n\t\t\t}\n\n\t\t\tdo halt;\n\t\t} else {\n\t\t\twrite \"\" + first(DB_Accessor) getParameter ();\n\t\t}\n\n\t\task (DB_Accessor) {\n\t\t\tdo executeUpdate updateComm: \"CREATE TABLE registration\" + \"(id INTEGER PRIMARY KEY, \" + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \" + \" age INTEGER);\";\n\t\t\twrite \"REGISTRATION table has been created.\";\n\t\t\tdo executeUpdate updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\";\n\t\t\tdo executeUpdate updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" values: [101, 'Mr', 'Mme', 45];\n\t\t\tdo insert into: \"registration\" values: [102, 'Mahnaz', 'Fatma', 25];\n\t\t\tdo insert into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [103, 'Zaid tim', 'Kha'];\n\t\t\tdo insert into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [104, 'Bill', 'Clark'];\n\t\t\twrite \"Five records have been inserted.\";\n\t\t\twrite \"Click on <<Step>> button to view selected data\";\n\t\t}\n\n\t}\n\n}\n\nspecies DB_Accessor parent: AgentDB {\n\treflex select {\n\t\tlist<list> t <- list<list> (self select (select::\"SELECT * FROM registration\"));\n\t\twrite \"Select before updated \" + t;\n\t}\n\n\treflex update {\n\t\tdo executeUpdate updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\";\n\t\tdo executeUpdate updateComm: \"DELETE FROM registration where id=103 \";\n\t\tlist<list> t <- list<list> (self select (select::\"SELECT * FROM registration\"));\n\t\twrite \"Select after updated \" + t;\n\t}\n\n\treflex drop {\n\t\tdo executeUpdate updateComm: \"DROP TABLE registration\";\n\t\twrite \"Registration table has been dropped.\";\n\t}\n\n}\n\nexperiment simple_SQL_exp type: gui {\n}     \n```\n","url":"wiki/Database-Usage-Simple-Species-MySQL.md"},"Database-Usage-Simple-SQL-Command-in-SQLite.md":{"title":"  Simple SQL Command in SQLIte","content":"[//]: # (keyword|skill_SQLSKILL)\n[//]: # (keyword|concept_database)\n#  Simple SQL Command in SQLIte\n\n\n_Author : Truong Minh Thai_\n\n This model does SQl query commands:\n\n * - Create table \n \n * - Insert data\n \n * - Select data\n \n * - Delete data\n \n * - Drop table \n \n \n *  Note: the file emptyFile.db is only ... an empty file.\n\n\nCode of the model : \n\n```\nmodel SQLite_selectNUpdate\n\nglobal {\n\tmap<string, string> PARAMS <- ['dbtype'::'sqlite', 'database'::'../../includes/emptyFile.db'];\n\tinit {\n\t\tcreate DB_Accessor;\n\n\t\t// Test of the connection to the database\n\t\tif (first(DB_Accessor) testConnection [params::PARAMS] = false) {\n\t\t\twrite \"Connection impossible\";\n\t\t\tdo halt;\n\t\t}\n\n\t\task (DB_Accessor) {\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE registration\" + \"(id INTEGER PRIMARY KEY, \" + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \" + \" age INTEGER);\";\n\t\t\twrite \"REGISTRATION table has been created.\";\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\";\n\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" values: [101, 'Mr', 'Mme', 45];\n\t\t\tdo insert params: PARAMS into: \"registration\" values: [102, 'Mahnaz', 'Fatma', 25];\n\t\t\tdo insert params: PARAMS into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [103, 'Zaid tim', 'Kha'];\n\t\t\tdo insert params: PARAMS into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [104, 'Bill', 'Clark'];\n\t\t\twrite \"Five records have been inserted.\";\n\t\t\twrite \"Click on <<Step>> button to view selected data\";\n\t\t}\n\n\t}\n\n}\n\nspecies DB_Accessor skills: [SQLSKILL] {\n\treflex select {\n\t\tlist<list> t <- list<list> (self select [params::PARAMS, select::\"SELECT * FROM registration\"]);\n\t\twrite \"Select before updated \" + t;\n\t}\n\n\treflex update {\n\t\tdo executeUpdate params: PARAMS updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\";\n\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM registration where id=103 \";\n\t\tlist<list> t <- list<list> (self select [params::PARAMS, select::\"SELECT * FROM registration\"]);\n\t\twrite \"Select after updated \" + t;\n\t}\n\n\treflex drop {\n\t\tdo executeUpdate params: PARAMS updateComm: \"DROP TABLE registration\";\n\t\twrite \"Registration table has been dropped.\";\n\t}\n\n}\n\nexperiment simple_SQL_exp type: gui {\n}     \n```\n","url":"wiki/Database-Usage-Simple-SQL-Command-in-SQLite.md"},"Date-and-Time-Date-type-and-real-dates.md":{"title":" Use of the Date variables","content":"[//]: # (keyword|operator_add_years)\n[//]: # (keyword|operator_add_months)\n[//]: # (keyword|operator_add_weeks)\n[//]: # (keyword|operator_add_days)\n[//]: # (keyword|operator_add_hours)\n[//]: # (keyword|operator_add_minutes)\n[//]: # (keyword|operator_add_seconds)\n[//]: # (keyword|operator_subtract_years)\n[//]: # (keyword|operator_subtract_months)\n[//]: # (keyword|operator_subtract_weeks)\n[//]: # (keyword|operator_subtract_days)\n[//]: # (keyword|operator_subtract_hours)\n[//]: # (keyword|operator_subtract_minutes)\n[//]: # (keyword|operator_subtract_seconds)\n[//]: # (keyword|concept_date)\n# Use of the Date variables\n\n\n_Author :  Patrick Taillandier_\n\nA model to show how to use date variables and more particularly the starting_date and current_date global variables.\n\n\nCode of the model : \n\n```\nmodel date_model \n\nglobal {\n\t\n\t//definition of the date of begining of the simulation - defining this date will allows to change the normal date management of the simulation by a more realistic one (using calendar) \n\tdate starting_date <- date([2011,1,2,1,1,30]);\n\t\n\t//be careful, when real dates are used, modelers should not use the #month and #year values that are not consistent with them\n\tfloat step <- 1#h;\n\t\t\n\tinit {\n\t\twrite \"starting_date: \" + starting_date;\n\t\t\n\t\t//there are several ways to define a date.\n\t\t//The simplest consists in using a list of int values: [year,month of the year,day of the month, hour of the day, minute of the hour, second of the minute]\n\t\tdate my_date <- date([2010,3,23,17,30,10]); //correspond the 23th of March 2010, at 17:30:10\n\t\t\n\t\t//It is also possible to define a date through a string:\n\t\tdate my_date2 <- date(\"2010-3-23T17:30:10+07:00\"); \n\t\twrite (my_date2);\n\t\n\t\t//it is possible to get the current date by using the \"now\" string:\n\t\tdate today <- date(\"now\"); \n\t\twrite (today);\n\t\t\n\t\twrite \"\\n ----------------------------------------------- \" ;\n\t\t\n\t\t//GAMA provides several operator to manipulate dates:\t\n\t\t\t\n\t\t//for instance, it is possible to compute the duration in seconds between 2 dates:\n\t\tfloat d <- starting_date - my_date;\n\t\twrite \"duration between \" + my_date + \" and \" + starting_date + \" : \" + d + \"s\";\n\t\t\n\t\twrite \"\\n ----------------------------------------------- \" ;\n\t\t\n\t\t//to add or subtract a duration (in secondes) to a date:\n\t\t write \"my_date2 + 10: \" + (my_date2 + 10);\n\t\t write \"my_date2 - 10: \" + (my_date2 - 10);\n\t\t \n\t\t write \"\\n ----------------------------------------------- \" ;\n\t\t \n\t\t \n\t\t //to add or subtract a duration (in years, months, weeks, days, hours, minutes,  secondes) to a date:\n\t\t  write \"my_date2 add_years 1: \" + (my_date2 add_years 1);\n\t\t  write \"my_date2 add_months 1: \" + (my_date2 add_months 1);\n\t\t  write \"my_date2 add_weeks 1: \" + (my_date2 add_weeks 1);\n\t\t  write \"my_date2 add_days 1: \" + (my_date2 add_days 1);\n\t\t  write \"my_date2 add_hours 1: \" + (my_date2 add_hours 1);\n\t\t  write \"my_date2 add_minutes 1: \" + (my_date2 add_minutes 1);\n\t\t  write \"my_date2 add_seconds 1: \" + (my_date2 add_seconds 1);\n\t\t  \n\t\t  write \"my_date2 subtract_years 1: \" + (my_date2 subtract_years 1);\n\t\t  write \"my_date2 subtract_months 1: \" + (my_date2 subtract_months 1);\n\t\t  write \"my_date2 subtract_weeks 1: \" + (my_date2 subtract_weeks 1);\n\t\t  write \"my_date2 subtract_days 1: \" + (my_date2 subtract_days 1);\n\t\t  write \"my_date2 subtract_hours 1: \" + (my_date2 subtract_hours 1);\n\t\t  write \"my_date2 subtract_minutes 1: \" + (my_date2 subtract_minutes 1);\n\t\t  write \"my_date2 subtract_seconds 1: \" + (my_date2 subtract_seconds 1);\n\t}\n\t\n\treflex info_date {\n\t\t//at each simulation step, the current_date is updated - its value can be seen in the top-left green info panel.\n\t\twrite \"current_date at cycle \" + cycle + \" : \" + current_date;\n\t}\n}\n\nexperiment main type: gui;\n```\n","url":"wiki/Date-and-Time-Date-type-and-real-dates.md"},"Date-and-Time-Simple-Time-definition.md":{"title":" Simple definition of time property in a model","content":"[//]: # (keyword|constant_#sec)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#d)\n[//]: # (keyword|constant_#month)\n[//]: # (keyword|constant_#year)\n[//]: # (keyword|concept_date)\n# Simple definition of time property in a model\n\n\n_Author : Patrick Taillandier_\n\nShow how the time is managed is GAMA.\n\n\nCode of the model : \n\n```\n\nmodel SimpleTimedefinition\n\nglobal {\n\t//redifitiion of the duration of one simulation step to 1 hour. By default the duration is one second.\n\tfloat step <- 1 #hour;\n\t\n\t\n\tinit {\n\t\t//GAMA provides different values for temporal unities - these values are given in seconds\n\t\twrite \"1#s: \" + 1#s;\n\t\twrite \"1#mn: \" + 1#mn;\n\t\twrite \"1#hour: \" + 1#hour;\n\t\twrite \"1#day: \" + 1#day;\n\t\twrite \"1#month: \" + 1#month;\n\t\twrite \"1#year: \" + 1#year;\n\t\t\n\t\t//Note that these values are constant: the value #month is always equal to 30 #day. \n\t}\n\treflex info_time {\n\t\twrite \"\\n-------------------------------------------\";\n\t\t//the global variable cycle gives the current step of the simulation\n\t\twrite \"cycle: \" + cycle;\n\t\t\n\t\t//the global variable time gives the current duration (in seconds) since the beginning of the simulation: time = cycle * step\n\t\t//The value of the time facet can be seen - in a date-time presentation - in the top-left green info panel (click on the number of cycle to see the time value).\n\t\t//When presenting the time value, a month is considered as being composed of 30 days. For a more realistic calendar, use the starting_date global value (see the Date type and Real dates model)\n\t\twrite \"time: \" + time;\n\t}\n}\n\nexperiment SimpleTimedefinition type: gui ;\n```\n","url":"wiki/Date-and-Time-Simple-Time-definition.md"},"Driving-Skill-OSM-Loading-Driving.md":{"title":" OSM Loading Driving","content":"[//]: # (keyword|operator_osm_file)\n[//]: # (keyword|operator_covers)\n[//]: # (keyword|operator_get)\n[//]: # (keyword|operator_in)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|statement_save)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_save_file)\n[//]: # (keyword|concept_osm)\n# OSM Loading Driving\n\n\n_Author : Patrick Taillandier_\n\nModel to show how to import OSM Files, using them to create agents for a road network, and saving the different agents in shapefiles. The first goal of this model is to prepare data for the driving skill models.\n\n\nCode of the model : \n\n```\n\n\nmodel OSMdata_to_shapefile \n \nglobal{\n\t//map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\n\tmap filtering <- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\",\"residential\", \"unclassified\"]]);\n\t\n\t//OSM file to load\n\tfile<geometry> osmfile <-  file<geometry>(osm_file(\"../includes/rouen.gz\", filtering))  ;\n\t\n\tgeometry shape <- envelope(osmfile);\n\tgraph the_graph; \n\tmap<point, intersection> nodes_map;\n\t\n\t\n\n\tinit {\n\t\twrite \"OSM file loaded: \" + length(osmfile) + \" geometries\";\n\t\t\n\t\t//from the OSM file, creation of the selected agents\n\t\tloop geom over: osmfile {\n\t\t\tif (shape covers geom) {\n\t\t\t\tstring highway_str <- string(geom get (\"highway\"));\n\t\t\t\tif (length(geom.points) = 1 ) {\n\t\t\t\t\tif ( highway_str != nil ) {\n\t\t\t\t\t\tstring crossing <- string(geom get (\"crossing\"));\n\t\t\t\t\t\tcreate intersection with: [shape ::geom, type:: highway_str, crossing::crossing] {\n\t\t\t\t\t\t\tnodes_map[location] <- self;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstring oneway <- string(geom get (\"oneway\"));\n\t\t\t\t\tfloat maxspeed_val <- float(geom get (\"maxspeed\"));\n\t\t\t\t\tstring lanes_str <- string(geom get (\"lanes\"));\n\t\t\t\t\tint lanes_val <- empty(lanes_str) ? 1 : ((length(lanes_str) > 1) ? int(first(lanes_str)) : int(lanes_str));\n\t\t\t\t\tcreate road with: [shape ::geom, type:: highway_str, oneway::oneway, maxspeed::maxspeed_val, lanes::lanes_val] {\n\t\t\t\t\t\tif lanes < 1 {lanes <- 1;} //default value for the lanes attribute\n\t\t\t\t\t\tif maxspeed = 0 {maxspeed <- 50.0;} //default value for the maxspeed attribute\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\twrite \"Road and node agents created\";\n\t\t\n\t\task road {\n\t\t\tpoint ptF <- first(shape.points);\n\t\t\tif (not(ptF in nodes_map)) {\n\t\t\t\tcreate intersection with:[location::ptF] {\n\t\t\t\t\tnodes_map[location] <- self;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tpoint ptL <- last(shape.points);\n\t\t\tif (not(ptL in nodes_map)) {\n\t\t\t\tcreate intersection with:[location::ptL] {\n\t\t\t\t\tnodes_map[location] <- self;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\twrite \"Supplementary node agents created\";\n\t\task intersection {\n\t\t\tif (empty (road overlapping (self))) {\n\t\t\t\tdo die;\n\t\t\t}\n\t\t}\n\t\t\n\t\twrite \"node agents filtered\";\n\t\t\n\t\t//Save all the road agents inside the file with the path written, using the with: facet to make a link between attributes and columns of the resulting shapefiles. \n\t\tsave road type:\"shp\" to:\"../includes/roads.shp\" with:[lanes::\"lanes\",maxspeed::\"maxspeed\", oneway::\"oneway\"] ;\n\t\tsave intersection type:\"shp\" to:\"../includes/nodes.shp\" with:[type::\"type\", crossing::\"crossing\"] ;\n\t\twrite \"road and node shapefile saved\";\n\t}\n}\n\t\n\nspecies road{\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\tstring type;\n\tstring oneway;\n\tfloat maxspeed;\n\tint lanes;\n\taspect base_ligne {\n\t\tdraw shape color: color; \n\t}\n\t\n} \n\t\nspecies intersection {\n\tstring type;\n\tstring crossing;\n\taspect base { \n\t\tdraw square(3) color: #red ;\n\t}\n} \n\t\n\nexperiment fromOSMtoShapefiles type: gui {\n\toutput {\n\t\tdisplay map type: opengl {\n\t\t\tgraphics \"world\" {\n\t\t\t\tdraw world.shape.contour;\n\t\t\t}\n\t\t\tspecies road aspect: base_ligne  refresh: false  ;\n\t\t\tspecies intersection aspect: base   refresh: false ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Driving-Skill-OSM-Loading-Driving.md"},"Driving-Skill-Road-Traffic-advanced.md":{"title":" Complex Road Network ","content":"[//]: # (keyword|operator_direction_to)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_in)\n[//]: # (keyword|operator_box)\n[//]: # (keyword|operator_sin)\n[//]: # (keyword|operator_triangle)\n[//]: # (keyword|operator_polyline)\n[//]: # (keyword|operator_reverse)\n[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|operator_as_driving_graph)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|statement_switch)\n[//]: # (keyword|statement_match)\n[//]: # (keyword|skill_skill_road_node)\n[//]: # (keyword|skill_skill_road)\n[//]: # (keyword|skill_advanced_driving)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_transport)\n# Complex Road Network \n\n\n_Author : Patrick Taillandier_\n\nModel to show how to use the driving skill to represent the traffic on a road network generated thanks to shapefiles, with intersections and traffic lights going from red to green to let people move or stop. Two experiments are presented : experiment_2D to display the model in 2D and which better display the orientation of roads and experiment_3D to display the model in 3D.\n\n\nCode of the model : \n\n```\n\nmodel RoadTrafficComplex\n \nglobal {   \n\tbool simple_data <- false;\n\t\n\t//Check if we use simple data or more complex roads\n\tfile shape_file_roads  <- simple_data ? file(\"../includes/RoadCircleLanes.shp\"): file(\"../includes/ManhattanRoads.shp\") ;\n\tfile shape_file_nodes  <- simple_data ? file(\"../includes/NodeCircleLanes.shp\") : file(\"../includes/ManhattanNodes.shp\");\n\tfile shape_file_bounds <- simple_data ? file(\"../includes/BoundsLaneRoad.shp\") :file(\"../includes/ManhattanRoads.shp\");\n\tgeometry shape <- envelope(shape_file_bounds) + 50.0;\n\t\n\tgraph road_network;  \n\tint nb_people <- simple_data ? 20 : 500;\n\t \n\tinit {  \n\t\t//create the intersection and check if there are traffic lights or not by looking the values inside the type column of the shapefile and linking\n\t\t// this column to the attribute is_traffic_signal. \n\t\tcreate intersection from: shape_file_nodes with:[is_traffic_signal::(read(\"type\") = \"traffic_signals\")];\n\t\t\n\t\t//create road agents using the shapefile and using the oneway column to check the orientation of the roads if there are directed\n\t\tcreate road from: shape_file_roads with:[lanes::int(read(\"lanes\")), oneway::string(read(\"oneway\"))] {\n\t\t\tgeom_display <- shape + (2.5 * lanes);\n\t\t\tmaxspeed <- (lanes = 1 ? 30.0 : (lanes = 2 ? 50.0 : 70.0)) °km/°h;\n\t\t\tswitch oneway {\n\t\t\t\tmatch \"no\" {\n\t\t\t\t\tcreate road {\n\t\t\t\t\t\tlanes <- max([1, int (myself.lanes / 2.0)]);\n\t\t\t\t\t\tshape <- polyline(reverse(myself.shape.points));\n\t\t\t\t\t\tmaxspeed <- myself.maxspeed;\n\t\t\t\t\t\tgeom_display  <- myself.geom_display;\n\t\t\t\t\t\tlinked_road <- myself;\n\t\t\t\t\t\tmyself.linked_road <- self;\n\t\t\t\t\t}\n\t\t\t\t\tlanes <- int(lanes /2.0 + 0.5);\n\t\t\t\t}\n\t\t\t\tmatch \"-1\" {\n\t\t\t\t\tshape <- polyline(reverse(shape.points));\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\n\t\tmap general_speed_map <- road as_map (each::(each.shape.perimeter / each.maxspeed));\n\t\t\n\t\t//creation of the road network using the road and intersection agents\n\t\troad_network <-  (as_driving_graph(road, intersection))  with_weights general_speed_map;\n\t\t\n\t\t//initialize the traffic light\n\t\task intersection {\n\t\t\tdo initialize;\n\t\t}\n\t\t\n\t\tcreate people number: nb_people { \n\t\t\tmax_speed <- 160 °km/°h;\n\t\t\tvehicle_length <- 5.0 °m;\n\t\t\tright_side_driving <- true;\n\t\t\tproba_lane_change_up <- 0.1 + (rnd(500) / 500);\n\t\t\tproba_lane_change_down <- 0.5+ (rnd(500) / 500);\n\t\t\tlocation <- one_of(intersection where empty(each.stop)).location;\n\t\t\tsecurity_distance_coeff <- 5/9 * 3.6 * (1.5 - rnd(1000) / 1000);  \n\t\t\tproba_respect_priorities <- 1.0 - rnd(200/1000);\n\t\t\tproba_respect_stops <- [1.0];\n\t\t\tproba_block_node <- 0.0;\n\t\t\tproba_use_linked_road <- 0.0;\n\t\t\tmax_acceleration <- 5/3.6;\n\t\t\tspeed_coeff <- 1.2 - (rnd(400) / 1000);\n\t\t\tthreshold_stucked <-int ( (1 + rnd(5))°mn);\n\t\t\tproba_breakdown <- 0.00001;\n\t\t\t\n\t\t}\t\n\t}\n\t\n} \n\n//species that will represent the intersection node, it can be traffic lights or not, using the skill_road_node skill\nspecies intersection skills: [skill_road_node] {\n\tbool is_traffic_signal;\n\tlist<list> stop;\n\tint time_to_change <- 100;\n\tint counter <- rnd (time_to_change) ;\n\tlist<road> ways1;\n\tlist<road> ways2;\n\tbool is_green;\n\trgb color_fire;\n\t\n\taction initialize {\n\t\tif (is_traffic_signal) {\n\t\t\tdo compute_crossing;\n\t\t\tstop<< [];\n\t\t\tif (flip(0.5)) {\n\t\t\t\tdo to_green;\n\t\t\t} else {\n\t\t\t\tdo to_red;\n\t\t\t}\t\n\t\t}\n\t}\n\t\n\taction compute_crossing{\n\t\tif  (length(roads_in) >= 2) {\n\t\t\troad rd0 <- road(roads_in[0]);\n\t\t\tlist<point> pts <- rd0.shape.points;\t\t\t\t\t\t\n\t\t\tfloat ref_angle <-  float( last(pts) direction_to rd0.location);\n\t\t\tloop rd over: roads_in {\n\t\t\t\tlist<point> pts2 <- road(rd).shape.points;\t\t\t\t\t\t\n\t\t\t\tfloat angle_dest <-  float( last(pts2) direction_to rd.location);\n\t\t\t\tfloat ang <- abs(angle_dest - ref_angle);\n\t\t\t\tif (ang > 45 and ang < 135) or  (ang > 225 and ang < 315) {\n\t\t\t\t\tways2<< road(rd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tloop rd over: roads_in {\n\t\t\tif not(rd in ways2) {\n\t\t\t\tways1 << road(rd);\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction to_green {\n\t\tstop[0] <- ways2 ;\n\t\tcolor_fire <- #green;\n\t\tis_green <- true;\n\t}\n\t\n\taction to_red {\n\t\tstop[0] <- ways1;\n\t\tcolor_fire <- #red;\n\t\tis_green <- false;\n\t}\n\treflex dynamic_node when: is_traffic_signal  {\n\t\tcounter <- counter + 1;\n\t\tif (counter >= time_to_change) { \n\t\t\tcounter <- 0;\n\t\t\tif is_green {do to_red;}\n\t\t\telse {do to_green;}\n\t\t} \n\t}\n\t\n\taspect base {\n\t\tif (is_traffic_signal) {\t\n\t\t\tdraw circle(5) color: color_fire;\n\t\t}\n\t}\n\t\n\taspect base3D {\n\t\tif (is_traffic_signal) {\t\n\t\t\tdraw box(1,1,10) color:#black;\n\t\t\tdraw sphere(5) at: {location.x,location.y,12} color: color_fire;\n\t\t}\n\t}\n}\n\n\n//species that will represent the roads, it can be directed or not and uses the skill skill_road\nspecies road skills: [skill_road] { \n\tgeometry geom_display;\n\tstring oneway;\n\taspect base {    \n\t\tdraw shape color: #gray end_arrow: 10;\n\t} \n\taspect base3D {    \n\t\tdraw geom_display color: #gray ;\n\t} \n}\n\n//People species that will move on the graph of roads to a target and using the skill advanced_driving\nspecies people skills: [advanced_driving] { \n\trgb color <- rgb(rnd(255), rnd(255), rnd(255)) ;\n\tint counter_stucked <- 0;\n\tint threshold_stucked;\n\tbool breakdown <- false;\n\tfloat proba_breakdown ;\n\tintersection target;\n\t\n\treflex breakdown when: flip(proba_breakdown){\n\t\tbreakdown <- true;\n\t\tmax_speed <- 1 °km/°h;\n\t}\n\t\n\treflex time_to_go when: final_target = nil {\n\t\ttarget <- one_of(intersection where not each.is_traffic_signal);\n\t\tcurrent_path <- compute_path(graph: road_network, target: target );\n\t\tif (current_path = nil ) {\n\t\t\tfinal_target <- nil;\n\t\t}\n\t}\n\treflex move when: current_path != nil and final_target != nil {\n\t\tdo drive;\n\t\tif real_speed < 5°km/°h {\n\t\t\tcounter_stucked<- counter_stucked + 1;\n\t\t\tif (counter_stucked mod threshold_stucked = 0) {\n\t\t\t\tproba_use_linked_road <- min([1.0,proba_use_linked_road + 0.1]);\n\t\t\t}\n\t\t} else {\n\t\t\tcounter_stucked<- 0;\n\t\t\tproba_use_linked_road <- 0.0;\n\t\t}\n\t}\n\n\taspect base { \n\t\tdraw breakdown ? square(15) : triangle(15) color: color rotate:heading + 90;\n\t} \n\taspect base3D {\n\t\tpoint loc <- calcul_loc();\n\t\tdraw box(vehicle_length, 1,1) at: loc rotate:  heading color: color;\n\t\t\n\t\tdraw triangle(0.5) depth: 1.5 at: loc rotate:  heading + 90 color: color;\n\t\t\n\t\tif (breakdown) {\n\t\t\tdraw circle(2) at: loc color: #red;\n\t\t}\n\t} \n\t\n\tpoint calcul_loc {\n\t\tif (current_road = nil) {\n\t\t\treturn location;\n\t\t} else {\n\t\t\tfloat val <- (road(current_road).lanes - current_lane) + 0.5;\n\t\t\tval <- on_linked_road ? val * - 1 : val;\n\t\t\tif (val = 0) {\n\t\t\t\treturn location; \n\t\t\t} else {\n\t\t\t\treturn (location + {cos(heading + 90) * val, sin(heading + 90) * val});\n\t\t\t}\n\t\t}\n\t}\n\t\n} \n\nexperiment experiment_2D type: gui {\n\tparameter \"if true, simple data (simple track), if false complex one (Manhattan):\" var: simple_data category: \"GIS\" ;\n\toutput {\n\t\tdisplay city_display {\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies intersection aspect: base;\n\t\t\tspecies people aspect: base;\n\t\t}\n\t}\n}\n\nexperiment experiment_3D type: gui {\n\tparameter \"if true, simple data (simple track), if false complex one (Manhattan):\" var: simple_data category: \"GIS\" ;\n\toutput {\n\t\tdisplay carte_principale type: opengl {\n\t\t\tspecies road aspect: base3D refresh: true;\n\t\t\tspecies intersection aspect: base3D;\n\t\t\tspecies people aspect: base3D ; \n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Driving-Skill-Road-Traffic-advanced.md"},"Driving-Skill-Road-Traffic-simple-(City).md":{"title":" Simple Road Network ","content":"[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|operator_copy)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_max_of)\n[//]: # (keyword|statement_user_command)\n[//]: # (keyword|statement_switch)\n[//]: # (keyword|statement_match)\n[//]: # (keyword|skill_driving)\n[//]: # (keyword|constant_#magenta)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_transport)\n# Simple Road Network \n\n\n_Author : Patrick Taillandier_\n\nModel using shapefiles to create buildings and a road graph, with people going from their living place to their work place depending on the hour. The traffic jam is also taken into account to slow the people agents when they are too much on the same road. The experiment shows a display of the city, with people agents, buildings and roads, a display of the traffic jam occuring on the roads, and a chart display showing two charts : one for the traffic jam coefficients, and an other for the objectives of the people agents.\n\n\nCode of the model : \n\n```\n  \nmodel RoadTrafficCity\n \n   \nglobal {   \n\t\n\t//Shapefiles for the buildings, the roads and the bounds of the environment\n\tfile shape_file_roads parameter: \"Shapefile for the roads:\" category: \"GIS\" <- file(\"../includes/ManhattanRoads.shp\") ;\n\tfile shape_file_bounds parameter: \"Shapefile for the bounds:\" category: \"GIS\" <- file(\"../includes/ManhattanBounds.shp\") ;\n\tfile shape_file_buildings parameter: \"Shapefile for the buildings:\" category: \"GIS\" <- file(\"../includes/ManhattanBuildings.shp\") ;\n\tgeometry shape <- envelope(shape_file_bounds);\n\t\n\t//Stock the number of times agents reached their goal (their house or work place)\n\tint nbGoalsAchived <- 0;\n\t\n\t//represent the day time for the agent to inform them to go work or home\n\tint day_time update: cycle mod 144 ;\n\t\n\t//Variables to manage the minimal and maximal time to start working\n\tint min_work_start <- 36;\n\tint max_work_start <- 60;\n\t\n\t//Number of people created\n\tint nb_people <- 500;\n\t\n\t//Variables to manage the minimal and maximal time to go home\n\tint min_work_end <- 84; \n\tint max_work_end <- 132; \n\t\n\t//Manage the speed allowed in the model for the people agents\n\tfloat min_speed <- 50.0;\n\tfloat max_speed <- 100.0; \n\t\n\t//Graph of the road network\n\tgraph the_graph;\n\t\n\t \n\tinit {  \n\t\t\n\t\t//creation of the agents of road and building species using the shapefile and linking the \n\t\tcreate road from: shape_file_roads with:[nbLanes::int(read(\"lanes\"))];\n\t\tcreate building from: shape_file_buildings;\n\t\t\n\t\t//Increase the shape of roads according to the number of lanes it has\n\t\task road as list {\n\t\t\tvisu_geom <- shape + (2 * nbLanes);\t\n\t\t}\n\t\t//Initliazation of the graph with the road species\n\t\tthe_graph <-  (as_edge_graph(road));\n\t\t\n\t\t//Initialization of nb_people agents of people species\n\t\t// and definition of their living and working places\n\t\tcreate people number: nb_people { \n\t\t\tliving_space <- 3.0;\n\t\t\ttolerance <- 0.1;\n\t\t\tlanes_attribute <- \"nbLanes\";\n\t\t\tobstacle_species <- [species(self)]; \n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(building) ;\n\t\t\tworking_place <- one_of(building) ;\n\t\t\tlocation <- living_place.location; \n\t\t}   \n\t}\n\t\n\t//Update of the graph every 10 Cycles to take into account the traffic jam of the road in the weights of the graph\n\treflex update_graph when:every(10){\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.shape.perimeter * each.coeff_traffic));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n\t\n} \n\t\nspecies road  { \n\tint nbLanes;\n\tint indexDirection; \n\tbool blocked <- false;\n\trgb color <- #black;\n\tfloat coeff_traffic <- 1.0 update: 1 + (float(length(people at_distance 1.0)) / shape.perimeter * 200 / nbLanes);\n\tgeometry visu_geom;\n\t\n\taspect base { \n\t\tdraw shape color: #black ;\n\t} \n\t\n\t\n\t//Command that the user can execute to remove or add a road\t\n\tuser_command \"Remove a road\" action: remove;\n\tuser_command \"Add a road\" action: add;\n\t\t \n\taction remove {\n\t\tblocked <- true;\n\t\tthe_graph <-  (as_edge_graph(road where (!each.blocked))) ;\n\t\tmap<road,float> weights_map <- road as_map (each:: each.coeff_traffic);\n\t\tthe_graph <- the_graph  with_weights weights_map;\n\t\tcolor <- #magenta;\n\t}\n\t\t\n\taction add {\n\t\tblocked <- false;\n\t\tthe_graph <-  (as_edge_graph(road where (!each.blocked)));\n\t\tmap<road,float> weights_map <- road as_map (each:: each.coeff_traffic);\n\t\tthe_graph <- the_graph  with_weights weights_map;\n\t\tcolor <- #black;\n\t}\n\t\t\n\taspect road_width {  \n\t\tdraw visu_geom color: color ;\n\t}\n\t\n\taspect traffic_jam {  \n\t\tif (coeff_traffic > 0.025) {\n\t\t\tdraw shape + (coeff_traffic / 4.0) color: #red ;\n\t\t}\n\t} \t\t\n}\n\t\nspecies building  { \n\trgb color <- #gray;\n\taspect base { \n\t\tdraw shape color: color ;\n\t}\n}\n\t\nspecies people skills: [driving]{ \n\tfloat speed; \n\trgb color <- rgb([rnd(255),rnd(255),rnd(255)]) ;\n\tpoint targetBis <- nil ; \n\tpoint previousLoc <- nil;\n\tbool normalMove <- true;\n\tfloat evadeDist <- 500.0;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\t//Reflex to make the agent move while it had a target and normalMove equals true\n\treflex move when: the_target != nil and normalMove{\n\t\tpreviousLoc <- copy(location);\n\t\tdo goto_driving target: the_target on: the_graph speed: speed ; \n\t\tswitch location { \n\t\t\tmatch the_target {\n\t\t\t\tthe_target <- nil;\n\t\t\t\tnbGoalsAchived <- nbGoalsAchived +1;\n\t\t\t}\n\t\t\tmatch previousLoc {\n\t\t\t\ttargetBis <- last((one_of(road where (each distance_to self < evadeDist)).shape).points);\n\t\t\t\tnormalMove <- false;\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\t//Reflex to make the agent move when it is not normal moving \n\treflex EvadeMove when: !(normalMove){\n\t\tpreviousLoc <- copy(location);\n\t\tdo goto_driving target: targetBis on: the_graph speed: speed ; \n\t\tswitch location { \n\t\t\tmatch targetBis {\n\t\t\t\tnormalMove <- true;\n\t\t\t}\n\t\t\tmatch previousLoc {\n\t\t\t\ttargetBis <- last((one_of(road where (each distance_to self < evadeDist)).shape).points);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//Reflex to make the agent go to its working place when it's time to go work\n\treflex time_to_work when: day_time = start_work {\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\n\t//Reflex to make the agent go to its living place when it's time to go home\n\treflex time_to_go_home when: day_time = end_work {\n\t\tobjective <- \"go home\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t}  \n\t\n\taspect base {\n\t\tdraw circle(20) color: color;\n\t}\n}\n\nexperiment traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" ;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" ;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" ;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" ;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" ;\n\t\n\toutput {\n\t\tdisplay city_display {\n\t\t\tspecies road aspect: road_width ;\n\t\t\tspecies building aspect: base;\n\t\t\tspecies people aspect: base;\n\t\t}\n\t\tdisplay traffic_jam_display {\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies road aspect: traffic_jam ;\n\t\t}\n\t\tdisplay chart_display refresh: every(10) {\n\t\t\tchart \"Traffic jam\" type: series size: {0.9, 0.4} position: {0.05, 0.05} {\n\t\t\t\tdata \"Mean road traffic coefficient\" value: mean (road collect each.coeff_traffic) style: line color: #green ;\n\t\t\t\tdata \"Max road traffic coefficient\" value: road max_of (each.coeff_traffic) style: line color: #red ;\n\t\t\t}\n\t\t\tchart \"People Objectif\" type: pie style: exploded size: {0.9, 0.4} position: {0.05, 0.55} {\n\t\t\t\tdata \"Working\" value: length ((people as list) where (each.objective=\"working\")) color: #green ;\n\t\t\t\tdata \"Staying home\" value: length ((people as list) where (each.objective=\"go home\")) color: #blue ;\n\t\t\t}\n\t\t}\n\t\tmonitor \"Number of goals achieved\" value: nbGoalsAchived ;\n\t}\n}\n\n\n\n```\n","url":"wiki/Driving-Skill-Road-Traffic-simple-(City).md"},"Driving-Skill-Road-Traffic-simple-(Simple-track).md":{"title":" Easy Road Network ","content":"[//]: # (keyword|operator_with_min_of)\n[//]: # (keyword|operator_select)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|statement_switch)\n[//]: # (keyword|statement_match)\n[//]: # (keyword|skill_driving)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_transport)\n# Easy Road Network \n\n\n_Author : Patrick Taillandier_\n\nModel using shapefiles to create roads using shapefiles with people driving on these roads. The model take into account the number of lanes of the roads.\n\n\nCode of the model : \n\n```\n  \n \nmodel RoadTrafficSimple \n  \nglobal {  \n\tfile shape_file_roads  <- file(\"../includes/RoadCircleLanes.shp\") ;\n\tfile shape_file_bounds <- file(\"../includes/BoundsLaneRoad.shp\") ;\n\tgeometry shape <- envelope(shape_file_bounds);\n\t\n\tgraph the_graph;  \n\tlist roadsList of: road ; \n\t\t\n\t\n\tinit {  \n\t\tcreate road from: shape_file_roads with: [nbLanes::int(read(\"lanes\"))] {\n\t\t\tgeom_visu <- shape + nbLanes;\n\t\t}\n\t\tthe_graph <- as_edge_graph(road);\n\t}   \n\t\n\treflex createPeople when: cycle mod 20 = 0 and cycle < 400{\n\t\troadsList <- (road as list);  \n\t\tcreate people number: 1 { \n\t\t\tspeed <-  (2.0 + 2 * length(people as list)) ;\n\t\t\tcurrentRoad <- first (roadsList);\n\t\t\tsource <- first((currentRoad.shape).points);\n\t\t\tlocation <- source; \n\t\t\ttarget <- last((currentRoad.shape).points);\n\t\t\tliving_space <- 10.0;\n\t\t\ttolerance <- 0.1;\n\t\t\tlanes_attribute <- \"nbLanes\";\n\t\t\tobstacle_species <- [species(self)]; \n\t\t}  \n\t}   \n} \n\t\nspecies road  { \n\tint nbLanes; \n\tgeometry geom_visu;\n\taspect base {    \n\t\tdraw geom_visu color: #black ;\n\t} \n}\n\nspecies people skills: [driving]{ \n\tfloat speed; \n\trgb color <- rgb(rnd(255),rnd(255),rnd(255)) ; \n\tpoint target <- nil ; \n\tpoint source <- nil;\n\troad currentRoad <- nil;\n\treflex move when: target != nil {\n\t\tdo goto_driving target: target on: the_graph speed: speed ; \n\t\tswitch target { \n\t\t\tmatch location {\n\t\t\t\tcurrentRoad <- (roadsList select (each != currentRoad)) with_min_of (each distance_to self);\n\t\t\t\tsource <- location;\n\t\t\t\tlist<point> rls <- (currentRoad.shape).points;\n\t\t\t\ttarget <- first (rls) = source ? last(rls):first(rls);\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment Simple type: gui {\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\t\n\toutput {\n\t\tdisplay city_display {\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base;\n\t\t}\n\t}\n}\n\n\n\n\n```\n","url":"wiki/Driving-Skill-Road-Traffic-simple-(Simple-track).md"},"Graphs-3D-Graph.md":{"title":" 3D Graph","content":"[//]: # (keyword|operator_cube)\n[//]: # (keyword|operator_as_distance_graph)\n[//]: # (keyword|operator_degree_of)\n[//]: # (keyword|operator_^)\n[//]: # (keyword|operator_hsb)\n[//]: # (keyword|skill_moving3D)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_skill)\n# 3D Graph\n\n\n_Author : Arnaud Grignard_\n\nModel using a 3D Graph and updating it at each step according to the location and the degree of each sphere. An arc is created between two adjacent spheres. Two different experiments are proposed : one with a dynamic size for the spheres according to their degree, one simpler with no update of the size.\n\n\nCode of the model : \n\n```\n  \n\nmodel graph3D\n\nglobal {\n\tint number_of_agents parameter: 'Number of Agents' min: 1 <- 200 category: 'Initialization';\n\tint width_and_height_of_environment parameter: 'Dimensions' min: 100 <- 500 category: 'Initialization';\n\t\n\t//Distance to know if a sphere is adjacent or not with an other\n\tint distance parameter: 'distance ' min: 1 <- 100;\n\t\n\t\n\tint degreeMax <- 1;\n\tgeometry shape <- cube(width_and_height_of_environment);\n\t\n\t\n\tgraph my_graph;\n\tinit {\n\t\t\n\t\t//creation of the node agent ie the spheres with a random location in the environment\n\t\tcreate node_agent number: number_of_agents {\n\t\t\tlocation <- { rnd(width_and_height_of_environment), rnd(width_and_height_of_environment), rnd(width_and_height_of_environment) };\n\t\t}\n\t\t\n\t\tdo degreeMax_computation;\n\t\t\n\t\task node_agent {\n\t\t\tdo compute_degree;\n\t\t}\n\t}\n\t\n\treflex updateDegreeMax {\n\t\tdo degreeMax_computation;\n\t}\n\n\taction degreeMax_computation {\n\t\tmy_graph <- node_agent as_distance_graph(distance);\n\t\tdegreeMax <- 1;\n\t\task node_agent {\n\t\t\tif ((my_graph) degree_of (self) > degreeMax) {\n\t\t\t\tdegreeMax <- (my_graph) degree_of (self);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nspecies node_agent skills: [moving3D] {\n\tint degree;\n\tfloat radius;\n\trgb color ;\n\tfloat speed <- 5.0;\n\treflex move {\n\t\t//make the agent move randomly\n\t\tdo wander;\n\t\t//compute the degree of the agent\n\t\tdo compute_degree;\n\t}\n\t\n\t\n\taction compute_degree {\n\t\tdegree <- my_graph = nil ? 0 : (my_graph) degree_of (self);\n\t\tradius <- ((((degree + 1) ^ 1.4) / (degreeMax))) * 5;\n\t\tcolor <- hsb(0.66,degree / (degreeMax + 1), 0.5);\n\t}\n\n    aspect base {\n\t\tdraw sphere(10) color:°black;\n\t}\n\t\n\taspect dynamic {\n\t\tdraw sphere(radius) color: color;\n\t}\n\n}\n\nexperiment Display type: gui {\n\toutput {\n\t\tdisplay WanderingSphere type: opengl { \n\t\t\tspecies node_agent aspect: dynamic;\n\t\t\tgraphics \"edges\" {\n\t\t\t\t//Creation of the edges of adjacence\n\t\t\t\tif (my_graph != nil) {\n\t\t\t\t\tloop eg over: my_graph.edges {\n\t\t\t\t\t\tgeometry edge_geom <- geometry(eg);\n\t\t\t\t\t\tfloat val <- 255 * edge_geom.perimeter / distance; \n\t\t\t\t\t\tdraw line(edge_geom.points, 0.5)  color: rgb(val,val,val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nexperiment SimpleDisplay type: gui {\n\toutput {\n\t\tdisplay WanderingSphere type: opengl { \n\t\t\tspecies node_agent aspect: base;\n\t\t\tgraphics \"edges\" {\n\t\t\t\tif (my_graph != nil) {\n\t\t\t\t\tloop eg over: my_graph.edges {\n\t\t\t\t\t\tgeometry edge_geom <- geometry(eg);\n\t\t\t\t\t\tfloat val <- 255 * edge_geom.perimeter / distance; \n\t\t\t\t\t\tdraw line(edge_geom.points) color:°black;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Graphs-3D-Graph.md"},"Graphs-Classic-Graph-Generation.md":{"title":" Graph Generation","content":"[//]: # (keyword|operator_generate_barabasi_albert)\n[//]: # (keyword|operator_generate_watts_strogatz)\n[//]: # (keyword|operator_generate_complete_graph)\n[//]: # (keyword|statement_switch)\n[//]: # (keyword|statement_match)\n[//]: # (keyword|concept_graph)\n# Graph Generation\n\n\n_Author : Patrick Taillandier_\n\nModel which shows how to create three kind of graphs : a scale-free graph, a small-world graph, a complete graph and a complete graph with a radius.\n\n\nCode of the model : \n\n```\n\nmodel classicgraphgeneration\n\nglobal {\n\tgraph the_graph ;\n\tstring graph_type <- \"small-world\";\n\tint nb_nodes <- 500;\n\tfloat p <- 0.0;\n\tint k <- 4;\n\tint m <- 4;\n\tint radius <- 20;\n\t\n\tinit {\n\t\tswitch graph_type {\n\t\t\tmatch \"scale-free\" {\n\t\t\t\tthe_graph <- generate_barabasi_albert(node_agent, edge_agent, nb_nodes,m, true);\t\n\t\t\t}\n\t\t\tmatch \"small-world\" {\n\t\t\t\tthe_graph <- generate_watts_strogatz(node_agent, edge_agent, nb_nodes, p, k, true);\t\n\t\t\t}\n\t\t\tmatch \"complete\" {\n\t\t\t\tthe_graph <- generate_complete_graph(node_agent, edge_agent, nb_nodes,true);\t\n\t\t\t}\n\t\t\tmatch \"complete-with-radius\" {\n\t\t\t\tthe_graph <- generate_complete_graph(node_agent, edge_agent, nb_nodes, radius,true);\t\n\t\t\t}\t\t\n\t\t}\n\t\twrite the_graph;\n\t\twrite \"Edges : \"+length(the_graph.edges);\n\t\twrite \"Nodes : \"+length(the_graph.vertices);\n\t}\n\t\n}\n\nspecies edge_agent {\n\taspect default {\t\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies node_agent {\n\taspect default {\t\n\t\tdraw circle(1) color: #red;\n\t}\n}\n\nexperiment loadgraph type: gui {\n\tparameter \"Graph type\" var: graph_type among: [ \"scale-free\", \"small-world\", \"complete\"];\n\tparameter \"Number of nodes\" var: nb_nodes min: 5 ;\n\tparameter \"Probability to rewire an edge (beta)\" var: p min: 0.0 max: 1.0 category: \"small-world\";\n\tparameter \"Base degree of each node. k must be even\" var: k min: 2 max: 10 category: \"small-world\";\n\tparameter \"Number of edges added per novel node\" var: m min: 1 max: 10 category: \"scale-free\";\n\t\n\toutput {\n\t\tdisplay map type: opengl{\n\t\t\tspecies edge_agent ;\n\t\t\tspecies node_agent ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Graphs-Classic-Graph-Generation.md"},"Graphs-Graph-Building-From-Agents.md":{"title":" Graph Generation using Agents","content":"[//]: # (keyword|operator_as_distance_graph)\n[//]: # (keyword|operator_as_intersection_graph)\n[//]: # (keyword|statement_switch)\n[//]: # (keyword|statement_match)\n[//]: # (keyword|concept_graph)\n# Graph Generation using Agents\n\n\n_Author : Patrick Taillandier_\n\nModel which shows how to create a graph using agents of a species as vertices. Two kinds of generations are presented : one where the distance taken into account to link two vertices by an edge, an other where the intersections of two vertices joins these vertices by an edge. \n\n\nCode of the model : \n\n```\n\nmodel graphbuilding\n\nglobal {\n\tgraph<geometry, geometry> the_graph ;\n\tstring graph_builing_type <- \"distance\";\n\tfloat distance <- 20.0;\n\tfloat tolerance <- 0.0;\n\tinit {\n\t\tcreate dummy_agent number: 30; \n\t\tswitch graph_builing_type {\n\t\t\tmatch \"distance\" {\n\t\t\t\tthe_graph <- as_distance_graph(dummy_agent, distance);\t\n\t\t\t}\n\t\t\tmatch \"intersection\" {\n\t\t\t\tthe_graph <- as_intersection_graph(dummy_agent, tolerance);\t\n\t\t\t}\t\n\t\t}\n\t\twrite \"nb vertices: \" + length(the_graph.vertices);\n\t\twrite \"nb edges: \" + length(the_graph.edges);\n\t}\n\t\n}\n\nspecies dummy_agent {\n\tgeometry shape <- square (5);\n\taspect default {\t\n\t\tdraw shape color: #red;\n\t}\n}\n\nexperiment loadgraph type: gui {\n\tparameter \"Method to build the graph\" var: graph_builing_type among: [ \"distance\", \"intersection\"];\n\tparameter \"Tolerance\" var: tolerance min: 0.0 max: 2.0 category: \"Intersection\";\n\tparameter \"Distance\" var: distance min: 1.0 max: 50.0 category: \"Distance\";\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy_agent ;\n\t\t\tgraphics \"the graph\" {\n\t\t\t\tloop edge over: the_graph.edges {\n\t\t\t\t\tdraw edge color: #blue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Graphs-Graph-Building-From-Agents.md"},"Graphs-Graph-Loading-Layout.md":{"title":" Graph from DGS File and Layout Changed","content":"[//]: # (keyword|operator_load_graph_from_file)\n[//]: # (keyword|operator_layout)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_dgs)\n# Graph from DGS File and Layout Changed\n\n\n_Author : Patrick Taillandier_\n\nModel which shows how to load a graph from a DGS File, and change is layout. \n\n\nCode of the model : \n\n```\n\nmodel graphloadinglayout\n\nglobal {\n\tgraph the_graph ;\n\tstring barabasi_file <- \"../includes/ProteinSimple.dgs\";\n\tgeometry shape <- rectangle(500,500);\n\tstring layout_type <- \"forcedirected\";\n\tint layout_time <- 1000;\n\t\n\t//The operator load_graph_from_file generates the graph from the file, and chose the vertices as agents of node_agent \n\t//species, and edges as edge_agent agents\n\tinit {\n\t\tthe_graph <- load_graph_from_file(barabasi_file, node_agent, edge_agent);\n\t}\n\t\n\t//In case the layout type is forcedirected or random, the reflex will change at each step the layout of the graph\n\treflex layout_graph {\n\t\tthe_graph <- layout(the_graph, layout_type, layout_time);\n\t}\n}\n\nspecies edge_agent {\n\taspect default {\t\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies node_agent {\n\taspect default {\t\n\t\tdraw circle(2) color: #red;\n\t}\n}\n\nexperiment loadgraph type: gui {\n\tparameter \"Layout type\" var: layout_type among: [ \"forcedirected\", \"random\", \"radialtree\", \"circle\"];\n\tparameter \"layout time\" var: layout_time min: 1 max: 100000;\n\toutput {\n\t\tdisplay map type: opengl{\n\t\t\tspecies edge_agent ;\n\t\t\tspecies node_agent ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Graphs-Graph-Loading-Layout.md"},"Graphs-Graph-Operators.md":{"title":" Graph Operators","content":"[//]: # (keyword|operator_as_distance_graph)\n[//]: # (keyword|operator_betweenness_centrality)\n[//]: # (keyword|operator_degree_of)\n[//]: # (keyword|operator_nb_cycles)\n[//]: # (keyword|operator_alpha_index)\n[//]: # (keyword|operator_beta_index)\n[//]: # (keyword|operator_gamma_index)\n[//]: # (keyword|operator_connectivity_index)\n[//]: # (keyword|operator_connected_components_of)\n[//]: # (keyword|operator_maximal_cliques_of)\n[//]: # (keyword|operator_biggest_cliques_of)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|concept_graph)\n# Graph Operators\n\n\n_Author : Patrick Taillandier_\n\nModel to show how to use the different existing operators for the graph species\n\n\nCode of the model : \n\n```\n\nmodel graphoperators\n\nglobal {\n\tgraph<geometry,geometry> the_graph;\n\tlist<list> cliques;\n\tinit {\n\t\tcreate people number: 50;\n\t\t\n\t\t//creation of the graph: all vertices that are at distance <= 20 are connected\n\t\tthe_graph <- as_distance_graph(people, 20);\n\t\t\n\t\t//compute the betweenness_centrality of each vertice\n\t\tmap<people,float> bc <- map<people, float>(betweenness_centrality(the_graph));\n\t\tfloat max_centrality <- max(bc.values);\n\t\tfloat min_centrality <- min(bc.values);\n\t\task people {\n\t\t\tcentrality <- (bc[self] - min_centrality) / (max_centrality - min_centrality);\n\t\t\tcentrality_color <- rgb(255, int(255 * (1 - centrality)), int(255 * (1 - centrality)));\n\t\t}\n\t\twrite \"mean vertice degree: \" + mean(the_graph.vertices collect (the_graph degree_of each));\n\t\twrite \"nb_cycles: \" + nb_cycles(the_graph);\n\t\twrite \"alpha_index: \" + alpha_index(the_graph);\n\t\twrite \"beta_index: \" + beta_index(the_graph);\n\t\twrite \"gamma_index: \" + gamma_index(the_graph);\n\t\twrite \"connectivity_index: \" + connectivity_index(the_graph);\n\t\twrite \"connected_components_of: \" + length(connected_components_of(the_graph));\n\t\t\n\t\twrite \"connected_components_of: \" + length(connected_components_of(the_graph));\n\t\t\n\t\twrite \"maximal_cliques_of:\" + (maximal_cliques_of(the_graph) collect (length(each)));\n\t\twrite \"biggest_cliques_of:\" + (biggest_cliques_of(the_graph) collect (length(each)));\n\t}\n}\n\nspecies people {\n\tfloat centrality;\n\trgb centrality_color;\n\taspect centrality{\n\t\tdraw circle(1) color: centrality_color;\n\t\t\n\t}\n}\n\nexperiment graphoperators type: gui {\n\t\n\toutput {\n\t\t\n\t\tdisplay map background:#lightgray{\n\t\t\tgraphics \"edges\" {\n\t\t\t\tloop edge over: the_graph.edges {\n\t\t\t\t\tdraw edge color: #black;\n\t\t\t\t}\n \t\t\t}\n \t\t\tspecies people aspect: centrality;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Graphs-Graph-Operators.md"},"Graphs-Hand-Made-Graph.md":{"title":" Hand Made Graph","content":"[//]: # (keyword|operator_edge)\n[//]: # (keyword|operator_node)\n[//]: # (keyword|operator_add_node)\n[//]: # (keyword|operator_add_edge)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_node)\n[//]: # (keyword|concept_edge)\n# Hand Made Graph\n\n\n_Author : Patrick Taillandier_\n\nModel to show how to build a graph from scratch using three ways : by putting a list of edges as parameter of as_edge_graph, by adding a node or an edge manually using facet to or by changing the graph itself after adding a node or an edge. The experiment has two displays : one for the first graph created from the list of edges, an other for the graph creating by adding the nodes and edges manually using add operator.\n\n\nCode of the model : \n\n```\n\n@no_warning\nmodel handMadeGraph\n\nglobal {\n\tgraph<geometry, geometry> the_graph1 ;\n\tgraph<geometry, geometry> the_graph2;\n\t\n\tinit {\n\t\tthe_graph1 <- as_edge_graph([edge({10,5}, {20,3}), edge({10,5}, {30,30}),edge({30,30}, {80,35}),edge({80,35}, {40,60}),edge({80,35}, {10,5}), node ({50,50})]);\t\n\t\t\n\t\tthe_graph2 <- graph<geometry, geometry>([]);\n\t\t//first way to add nodes and edges\n\t\tthe_graph2 << node({50,50}) ;\n\t\tthe_graph2 << edge({10,10},{90,50});\n\t\t\n\t\t//second way to add nodes and edges\n\t\tthe_graph2 <- the_graph2 add_node {10,40} ;\n\t\tthe_graph2 <- the_graph2 add_edge ({35,50}:: {50,50}) ;\n\t}\n\t\n}\n\nspecies edge_agent {\n\taspect default {\t\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies node_agent {\n\taspect default {\t\n\t\tdraw circle(1) color: #red;\n\t}\n}\n\nexperiment create_graph type: gui {\n\t\n\toutput {\n\t\tdisplay graph1 type: opengl{\n\t\t\tgraphics \"the graph 1\" {\n\t\t\t\tloop e over: the_graph1.edges {\n\t\t\t\t\tdraw e color: °blue; \n\t\t\t\t}\n\t\t\t\tloop n over: the_graph1.vertices {\n\t\t\t\t\tdraw circle(2) at: point(n) color: °blue; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplay graph2 type: opengl{\n\t\t\tgraphics \"the graph 2\" {\n\t\t\t\tloop e over: the_graph2.edges {\n\t\t\t\t\tdraw e color: °red; \n\t\t\t\t}\n\t\t\t\tloop n over: the_graph2.vertices {\n\t\t\t\t\tdraw circle(2) at: point(n) color: °red; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Graphs-Hand-Made-Graph.md"},"Graphs-Multigraph.md":{"title":" Multigraph","content":"[//]: # (keyword|operator_path_between)\n[//]: # (keyword|operator_node)\n[//]: # (keyword|operator_edge)\n[//]: # (keyword|operator_link)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_skill)\n# Multigraph\n\n\n_Author : Patrick Taillandier_\n\nThis model shows how to build a graph on which people agents will move with GIS Shapefile, but also to generate an other graph representing the friendship between the people agents, people agents trying to be closer spatially to each other\n\n\nCode of the model : \n\n```\n\nmodel multigraph\n\nglobal {\n\tfile shape_file_in <- file('../includes/road.shp') ;\n\tfile shape_file_bounds <- file('../includes/bounds.shp') ;\n\tgeometry shape <- envelope(shape_file_bounds);\n\t\n\t//spatial graph representing the road network\n\tgraph road_graph; \n\t\n\t//social graph (not spatial) representing the frienship links between people\n\tgraph friendship_graph <- graph([]);\n\t\n\tinit {\n\t\tcreate road from: shape_file_in;\n\t\t\n\t\t//creation of th road graph from the road agents\n\t\troad_graph <- as_edge_graph(road);\n\t\t\n\t\t//creation of 50 people agent, and add each people agent as a node in the friendship graph\n\t\tcreate people number: 50 {\n\t\t\tadd node(self) to: friendship_graph;\n\t\t}\n\t\t\n\t\t//creation of 50 friendship link between people agents\n\t\tloop times: 50 {\n\t\t\tpeople p1 <- one_of(people);\n\t\t\tpeople p2 <- one_of(list(people) - p1);\n\t\t\tcreate friendship_link  {\n\t\t\t\tadd edge (p1, p2, self) to: friendship_graph;\n\t\t\t\tshape <- link(p1,p2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies people skills: [moving]{\n\tpoint location <- any_location_in(one_of(road));\n\tpeople target_people <- one_of(people);\n\tpoint target <- target_people.location;\n\tfloat size <- 3.0;\n\t\n\t//action that make recompute the size of the agents as the distance between it and its target people in the friendship graph (the farthest, the biggest)\n\taction updateSize {\n\t\tpath friendship_path <- path_between(friendship_graph,self,target_people);\n\t\tif (friendship_path != nil) {\n\t\t\tsize <-max([2,length( friendship_path.edges)]) as float;\n\t\t}\n\t}\n\t\n\t//the agent moves toward its target, when reaching it, it chooses another target as the location of one of the people agent\n\treflex movement {\n\t\tif (location distance_to target < 5.0) {\n\t\t\ttarget_people <- one_of(people);\n\t\t\ttarget <- target_people.location;\n\t\t\tdo updateSize;\n\t\t}\n\t\tdo goto on:road_graph target:target speed:1 + rnd(2);\n\t}\n\taspect default {\n\t\tdraw circle(size) color: #red;\n\t}\t\n}\n\t\nspecies friendship_link {\n\t\n\taspect default {\n\t\tdraw shape color: #blue;\n\t}\n}\n\t\nspecies road  {\n\taspect default {\n\t\tdraw shape color:#black ;\n\t}\n} \n\n\nexperiment multigraph type: gui {\n\toutput {\n\t\tdisplay friendship type: opengl{\n\t\t\tspecies road ;\n\t\t\tspecies friendship_link ;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Graphs-Multigraph.md"},"Graphs-Shortest-paths.md":{"title":" ShortestPath","content":"[//]: # (keyword|operator_load_shortest_paths)\n[//]: # (keyword|operator_all_pairs_shortest_path)\n[//]: # (keyword|operator_path_between)\n[//]: # (keyword|operator_paths_between)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|statement_save)\n[//]: # (keyword|constant_#cyan)\n[//]: # (keyword|constant_#magenta)\n[//]: # (keyword|type_path)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|concept_shortest_path)\n[//]: # (keyword|concept_save_file)\n# ShortestPath\n\n\n_Author : Patrick Taillandier_\n\nThis model shows how get the shortest path from one point to another on a graph. The experiment proposes two displays : one to show the shortest path, an other to show the first k shortest paths. \n\n\nCode of the model : \n\n```\n\nmodel ShortestPath\n\nglobal {\n\tfile shape_file_in <- file('../includes/road.shp') ;\n\tfile shape_file_bounds <- file('../includes/bounds.shp') ;\n\tgeometry shape <- envelope(shape_file_bounds);\n\tgraph road_graph; \n\tpoint source;\n\tpoint target;\n\tpath shortest_path;\n\tlist<path> k_shortest_paths;\n\tint k <- 3; \n\tlist<rgb> colors <- [#red,#green,#blue,#pink,#cyan,#magenta,#yellow];\n\tbool save_shortest_paths <- false;\n\tbool load_shortest_paths <- false;\n\tstring shortest_paths_file <- \"../includes/shortest_paths.csv\";\n\t\n\tinit {\n\t\tcreate road from: shape_file_in;\n\t\troad_graph <- as_edge_graph(road);\n\t\t\n\t\t//computes all the shortest paths, puts them in a matrix, then saves the matrix in a file\n\t\tif save_shortest_paths {\n\t\t\tmatrix ssp <- all_pairs_shortest_path(road_graph);\n\t\t\twrite \"Matrix of all shortest paths: \" + ssp;\n\t\t\tsave ssp type:\"text\" to:shortest_paths_file;\n\t\t\t\n\t\t//loads the file of the shortest paths as a matrix and uses it to initialize all the shortest paths of the graph\n\t\t} else if load_shortest_paths {\n\t\t\troad_graph <- road_graph load_shortest_paths matrix(file(shortest_paths_file));\n\t\t}\n\t}\n\t\n\treflex compute_shortest_paths {\n\t\tsource <- point(one_of(road_graph.vertices));\n\t\ttarget <- point(one_of(road_graph.vertices));\n\t\tif (source != target) {\n\t\t\tshortest_path <- path_between (road_graph, source,target);\n\t\t\tk_shortest_paths <- list<path>(paths_between(road_graph,source::target,k));\t\n\t\t}\n\t}\n}\n\nspecies road  {\n\taspect base {\n\t\tdraw shape color: #black ;\n\t} \n}\n\nexperiment ShortestPath type: gui {\n\tparameter \"number of shortest paths (k)\" var: k min: 1 max: 7;\n\tparameter \"Computed all the shortest paths and save the results\" var: save_shortest_paths;\n\tparameter \"Load the shortest paths from the file\" var: load_shortest_paths;\n\t\n\toutput {\n\t\tdisplay map_shortest_path {\n\t\t\tspecies road aspect: base;\n\t\t\tgraphics \"shortest path\" {\n\t\t\t\tif (shortest_path != nil) {\n\t\t\t\t\tdraw circle(5) at: source color: #green;\n\t\t\t\t\tdraw circle(5) at: target color: #cyan;\n\t\t\t\t\tdraw (shortest_path.shape + 2.0) color: #magenta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplay map_k_shortest_paths {\n\t\t\tspecies road aspect: base;\n\t\t\tgraphics \"k shortest paths\" {\n\t\t\t\tif (shortest_path != nil) {\n\t\t\t\t\tdraw circle(5) at: source color: #green;\n\t\t\t\t\tdraw circle(5) at: target color: #cyan;\n\t\t\t\t\tloop i from: 0 to: length(k_shortest_paths) - 1{\n\t\t\t\t\t\tdraw ((k_shortest_paths[i]).shape + 2.0) color: colors[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Graphs-Shortest-paths.md"},"Init-Action-Init-Action.md":{"title":" InitAction","content":"[//]: # (keyword|operator_user_input)\n# InitAction\n\n\n_Author : Alexis Drogoul_\n\n This simple example shows how to use the _init_ callback action to build a simulation with some parameters, without declaring them as parameters\n\n\nCode of the model : \n\n```\n\nmodel InitAction\n\nglobal {\n\tint agent_number <- 100;\n\trgb agent_color <- #red;\n\t\n\tinit {\n\t\tcreate my_agents number: agent_number;\n\t}\n}\n\nspecies my_agents {\n\taspect default {\n\t\tdraw square(5) color: agent_color;\n\t}\n}\n\nexperiment InitAction type: gui {\n\t\n\taction _init_ {\n\t\tmap<string, int> params <- user_input([\"Number of agents\"::100, \"Color\"::#red, \"2D\"::true]);\n\t\tcreate InitAction_model with: [agent_number::params[\"Number of agents\"], agent_color::rgb(params[\"Color\"])];\n\t}\n\t\n\toutput {\n\t\tdisplay Simple {\n\t\t\tspecies my_agents;\n\t\t}\n\t}\n\t\n}\n\n```\n","url":"wiki/Init-Action-Init-Action.md"},"Map-comparison-Raster-Map-Comparison.md":{"title":" Raster Map Comparison","content":"[//]: # (keyword|operator_in)\n[//]: # (keyword|operator_as_matrix)\n[//]: # (keyword|operator_kappa)\n[//]: # (keyword|operator_kappa_sim)\n[//]: # (keyword|operator_fuzzy_kappa)\n[//]: # (keyword|operator_fuzzy_kappa_sim)\n[//]: # (keyword|operator_percent_absolute_deviation)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|statement_using)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_comparison)\n[//]: # (keyword|concept_raster)\n[//]: # (keyword|concept_statistic)\n# Raster Map Comparison\n\n\n_Author : Patrick Taillandier_\n\nThis model shows how to use different comparators to know the accuracy of a prediction model. Four comparators are used :\n- kappa, comparing the map observed and the map simulation ; kappa simulation comparing the initial map, the map observed and the map simulation;\n- fuzzy kappa, comparing the map observed and the map simulation but being more permissive by using fuzzy logic;\n- fuzzy kappa simulation, comparing the map observed, the map simulation and the map initial but being more permissive by using fuzzy logic\n\n\nCode of the model : \n\n```\n\nmodel mapcomparison\n\nglobal {\n\tlist<string> categories <- [\"type 1\", \"type 2\", \"type 3\", \"type 4\"];\n\tmap<string,rgb> color_cat <- [\"type 1\"::#blue, \"type 2\"::#green, \"type 3\"::#yellow, \"type 4\"::#red];\n\tmatrix<float> fuzzy_categories;\n\tmatrix<float> fuzzy_transitions;\n\tlist<float> nb_per_cat_obs;\n\tlist<float> nb_per_cat_sim;\n\t \n\tinit {\n\t\t//Initialize randomly the category of each cell\n\t\task shuffle(cell) {\n\t\t\tstring neigh_cat <-one_of(neighbours).cat_observed;\n\t\t\tcat_init <- neigh_cat in categories ? neigh_cat : one_of(categories);\n\t\t\tcolor_init <- color_cat[cat_init];\n\t\t}\n\t\t\n\t\t//Initialize the category observed and the cat attributes of the cells according to probability : \n\t\t// 60% of cases, the category observed will be the same than the category initialized\n\t\t//60% of cases, the category will be the same than the category observed\n\t\task cell {\n\t\t\tcat_observed <- flip(0.6) ?  cat_init : one_of(categories);\n\t\t\tcat <- flip(0.6) ?  cat_observed : one_of(categories);\n\t\t\tcolor <- color_cat[cat];\n\t\t\tcolor_obs <- color_cat[cat_observed];\n\t\t}\n\t\tfuzzy_categories <- 0.0 as_matrix {length(categories),length(categories)};\n\t\tloop i from: 0 to: length(categories) - 1 {\n\t\t\tfuzzy_categories[i,i] <- 1.0;\n\t\t}\n\t\tfuzzy_transitions <- 0.0 as_matrix {length(categories)*length(categories),length(categories)*length(categories)};\n\t\tloop i from: 0 to: (length(categories) * length(categories)) - 1 {\n\t\t\tfuzzy_transitions[i,i] <- 1.0;\t\n\t\t}\n\t\tlist<float> similarity_per_agents ;\n\t\twrite \"kappa(map observed, map simulation, categories): \" + kappa( cell collect (each.cat_observed),cell collect (each.cat),categories);\n\t\twrite \"kappa simulation(map init, map observed, map simulation,categories): \" + kappa_sim( cell collect (each.cat_init), cell collect (each.cat_observed),cell collect (each.cat),categories);\n\t\tusing topology(cell) {\n\t\t\twrite \"fuzzy kappa(map observed, map simulation,categories): \" + fuzzy_kappa(list(cell), cell collect (each.cat_observed),cell collect (each.cat), similarity_per_agents,categories,fuzzy_categories, 10);\n\t\t\twrite \"fuzzy kappa sim(map init, map observed, map simulation,categories): \" + fuzzy_kappa_sim(list(cell), cell collect (each.cat_init), cell collect (each.cat_observed),cell collect (each.cat), similarity_per_agents,categories,fuzzy_transitions, 10);\n\t\t}\n\t\tloop i from: 0 to: length(cell) - 1 {\n\t\t\tint val <- int(255 * similarity_per_agents[i]);\n\t\t\task cell[i] {color_fuzzy <- rgb(val, val, val);}\n\t\t\t\n\t\t}\n\t\tloop c over: categories {\n\t\t\tnb_per_cat_obs << cell count (each.cat_observed = c);\n\t\t\tnb_per_cat_sim << cell count (each.cat = c); \n\t\t}\n\t\twrite \"percent_absolute_deviation : \" + percent_absolute_deviation(nb_per_cat_obs,nb_per_cat_sim) + \"%\";\n\t\t\n\t}\n\t\n}\n\ngrid cell width: 50 height: 50 {\n\tstring cat_init;\n\tstring cat_observed;\n\tstring cat ;\n\trgb color;\n\trgb color_init;\n\trgb color_obs;\n\trgb color_fuzzy <- #white;\n\tlist<cell> neighbours <- self neighbors_at 1;\n\t\n\taspect fuzzy_sim {\n\t\tdraw shape color:color_fuzzy border: color_fuzzy;\n\t}\n\taspect init {\n\t\tdraw shape color:color_init border: color_init;\n\t}\n\taspect observed {\n\t\tdraw shape color:color_obs border: color_obs;\n\t}\n}\n\nexperiment mapcomparison type: gui {\n\toutput {\n\t\tdisplay map_sim type: opengl{\n\t\t\tgrid cell;\n\t\t}\n\t\tdisplay map_observed type: opengl{\n\t\t\tspecies cell aspect: observed refresh: false;\n\t\t}\n\t\tdisplay map_init type: opengl{\n\t\t\tspecies cell aspect: init refresh: false;\n\t\t}\n\t\tdisplay map_fuzzy type: opengl{\n\t\t\tspecies cell aspect: fuzzy_sim ;\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Map-comparison-Raster-Map-Comparison.md"},"Map-comparison-Vector-Map-Comparison.md":{"title":" Vector Map Comparison","content":"[//]: # (keyword|operator_in)\n[//]: # (keyword|operator_as_matrix)\n[//]: # (keyword|operator_kappa)\n[//]: # (keyword|operator_kappa_sim)\n[//]: # (keyword|operator_fuzzy_kappa)\n[//]: # (keyword|operator_fuzzy_kappa_sim)\n[//]: # (keyword|operator_sum)\n[//]: # (keyword|operator_percent_absolute_deviation)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_comparison)\n[//]: # (keyword|concept_statistic)\n# Vector Map Comparison\n\n\n_Author : Patrick Taillandier_\n\nThis model shows how to use different comparators to know the accuracy of a prediction model. Four comparators are used :\n- kappa, comparing the map observed and the map simulation ; kappa simulation comparing the initial map, the map observed and the map simulation;\n- fuzzy kappa, comparing the map observed and the map simulation but being more permissive by using fuzzy logic;\n- fuzzy kappa simulation, comparing the map observed, the map simulation and the map initial but being more permissive by using fuzzy logic\nFor each comparator, two comparisons are made : one without taking into account the weights of an area, just computing with each area having the same importance, and an other using weights related to the area of the region\n\n\nCode of the model : \n\n```\n\nmodel mapcomparison\n\nglobal {\n\tlist<string> categories ;\n\tmap<string,rgb> color_cat ;\n\tmatrix<float> fuzzy_categories;\n\tmatrix<float> fuzzy_transitions;\n\tlist<float> nb_per_cat_obs;\n\tlist<float> nb_per_cat_sim;\n\tfile data <- file(\"../includes/CLC00_06.shp\");\n\t\n\tgeometry shape <- envelope(data);\n\t \n\tinit {\n\t\tcreate areaclc from: data with: [init_cover::string(read(\"CODE_00\")),obs_cover::string(read(\"CODE_06\"))] ;\n\t\task areaclc {\n\t\t\tif (not (init_cover in categories)) {categories << init_cover; }\n\t\t\tif (not (obs_cover in categories)) {categories << obs_cover;}\n\t\t\t\n\t\t}\n\t\tloop cat over: categories {\n\t\t\tcolor_cat[cat] <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t}\n\t\task areaclc {\n\t\t\tsim_cover <- flip(0.7) ? obs_cover : one_of (categories);\n\t\t}\n\t\t\n\t\tfuzzy_categories <- 0.0 as_matrix {length(categories),length(categories)};\n\t\tloop i from: 0 to: length(categories) - 1 {\n\t\t\tfuzzy_categories[i,i] <- 1.0;\n\t\t}\n\t\tfuzzy_transitions <- 0.0 as_matrix {length(categories)*length(categories),length(categories)*length(categories)};\n\t\tloop i from: 0 to: (length(categories) * length(categories)) - 1 {\n\t\t\tfuzzy_transitions[i,i] <- 1.0;\t\n\t\t}\n\t\tlist<float> similarity_per_agents ;\n\t\twrite \"kappa(map observed, map simulation, categories): \" + kappa( areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories);\n\t\twrite \"kappa(map observed, map simulation,categories, weights): \" + kappa( areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories,areaclc collect (each.shape.area));\n\t\t\n\t\twrite \"kappa simulation(map init, map observed, map simulation, categories): \" + kappa_sim( areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories);\n\t\twrite \"kappa simulation(map init, map observed, map simulation, categories, weights): \" + kappa_sim( areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories,areaclc collect (each.shape.area));\n\t\t\n\t\twrite \"fuzzy kappa(map observed, map simulation,categories): \" + fuzzy_kappa(areaclc, areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_categories, 3000);\n\t\twrite \"fuzzy kappa(map observed, map simulation,categories,weights): \" + fuzzy_kappa(areaclc, areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_categories, 3000,areaclc collect (each.shape.area));\n\t\t\n\t\twrite \"fuzzy kappa sim(map init, map observed, map simulation,categories): \" + fuzzy_kappa_sim(areaclc, areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_transitions, 3000);\n\t\twrite \"fuzzy kappa sim(map init, map observed, map simulation,categories,weights): \" + fuzzy_kappa_sim(areaclc, areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_transitions, 3000,areaclc collect (each.shape.area));\n\t\t\n\t\tloop i from: 0 to: length(areaclc) - 1 {\n\t\t\tint val <- int(255 * similarity_per_agents[i]);\n\t\t\task areaclc[i] {color_fuzzy <- rgb(val, val, val);}\n\t\t\t\n\t\t}\n\t\tloop c over: categories {\n\t\t\tlist<areaclc> area_c <- areaclc where (each.obs_cover = c);\n\t\t\tlist<float> area_shape_c <- area_c collect (each.shape.area);\n\t\t\tnb_per_cat_obs << sum(area_shape_c );\n\t\t\tnb_per_cat_sim << sum((areaclc where (each.sim_cover = c)) collect (each.shape.area)); \n\t\t}\n\t\twrite \"percent_absolute_deviation : \" + percent_absolute_deviation(nb_per_cat_obs,nb_per_cat_sim) + \"%\";\n\t\t\n\t}\n\t\n}\n \nspecies areaclc {\n\tstring init_cover;\n\tstring obs_cover;\n\tstring sim_cover;\n\trgb color_fuzzy;\n\t\n\taspect init {\n\t\tdraw shape color: color_cat[init_cover];\n\t}\n\taspect simulation {\n\t\tdraw shape color: color_cat[sim_cover];\n\t}\n\taspect observed {\n\t\tdraw shape color: color_cat[obs_cover];\n\t}\n\taspect fuzzy_sim {\n\t\tdraw shape color: color_fuzzy;\n\t}\n}\n\n\nexperiment mapcomparison type: gui {\n\toutput {\n\t\tdisplay map_sim type: opengl{\n\t\t\tspecies areaclc aspect: simulation;\n\t\t}\n\t\tdisplay map_observed type: opengl{\n\t\t\tspecies areaclc aspect: observed refresh: false;\n\t\t}\n\t\tdisplay map_init type: opengl{\n\t\t\tspecies areaclc aspect: init refresh: false;\n\t\t}\n\t\tdisplay map_fuzzy type: opengl background: #pink{\n\t\t\tspecies areaclc aspect: fuzzy_sim ;\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Map-comparison-Vector-Map-Comparison.md"},"Multi-Level-Usage-Balls,-Groups-and-Clouds.md":{"title":" Balls, Groups and Clouds Multilevel Architecture","content":"[//]: # (keyword|operator_towards)\n[//]: # (keyword|operator_sin)\n[//]: # (keyword|operator_at_location)\n[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|operator_buffer)\n[//]: # (keyword|operator_polygon)\n[//]: # (keyword|operator_in)\n[//]: # (keyword|operator_direction_to)\n[//]: # (keyword|operator_species_of)\n[//]: # (keyword|operator_convex_hull)\n[//]: # (keyword|operator_overlaps)\n[//]: # (keyword|operator_dead)\n[//]: # (keyword|operator_of_generic_species)\n[//]: # (keyword|operator_simple_clustering_by_distance)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_enter)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_migrate)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|concept_multi_level)\n[//]: # (keyword|concept_agent_movement)\n# Balls, Groups and Clouds Multilevel Architecture\n\n\n_Author : _\n\nThis model shows how to use multi-level architecture to group agents, and regroup groups. The operators capture is used to capture an agent by a group and change its species as a species contained by the group and defined in the group species section. The operator release is used to release contained agents and change them into an other species. The experiment shows ball moving randomly, and following other balls. When they are close to each other, they generate a group of balls with its own behavior. A group of group agents generate a cloud in the same way. When the number of balls contained inside the group is too high, the group disappears and releases all its balls repulsively. \n\n\nCode of the model : \n\n```\n\nmodel balls_groups_clouds\n\nglobal { \n\t// Parameters\n\tbool create_group <- true; \n\tbool create_cloud <- false; \n\t\n\t// Environment\n\tpoint environment_bounds <- {500, 500}; \n\tgeometry shape <- rectangle(environment_bounds) ;\t\t\n\t\n\t//Define a inner environment smaller inside the environment\n\tint inner_bounds_x <- (int((environment_bounds.x) / 20))  ;\n\tint inner_bounds_y <- (int((environment_bounds.y) / 20))  ;\n\tint xmin <- inner_bounds_x ;\n\tint ymin <- inner_bounds_y ;       \n\tint xmax <- int((environment_bounds.x) - inner_bounds_x) ;\n\tint ymax <- int((environment_bounds.y) - inner_bounds_y) ;\n\t\n\tfloat MAX_DISTANCE <- environment_bounds.x + environment_bounds.y  ;\n\t\n\t//Global variables for ball agents\n\trgb ball_color <- #green; \n\trgb chaos_ball_color <- #red;\n\tfloat ball_size <- float(3);  \n\tfloat ball_speed <- float(1);\n\tfloat chaos_ball_speed <- 8 * ball_speed;  \n\tint ball_number <- 200 min: 2 max: 1000;  \n\tgeometry ball_shape <- circle (ball_size) ;\n\tfloat ball_separation <- 6 * ball_size; \n\t\n\t//Global variables for group agents\n\tint group_creation_distance <- int(ball_separation + 1);\n\tint min_group_member <- 3;\n\tint group_base_speed <- (int(ball_speed * 1.5));\n\tint base_perception_range <- int (environment_bounds.x / 100) min: 1 ;  \n\tint creation_frequency <- 3;\n\tint update_frequency <- 3;\n\tint merge_frequency <- 3;\n\tfloat merge_possibility <- 0.3;\n\t\n\t//Global variables for Clouds Agents\n\tint cloud_creation_distance <- 30 const: true;\n\tint min_cloud_member <- 3 const: true;\n\tint cloud_speed <- 3 const: true;\n\tint cloud_perception_range <- base_perception_range const: true ; \n\t\n\tinit {\n\t\tcreate ball number: ball_number ;\n\t\tcreate group_agents_viewer;\n\t\tcreate cloud_agents_viewer;\n\t}\n\t\n\t//The simulation will try to create group at each frequence cycle\n\treflex create_groups when: ( create_group and ((cycle mod creation_frequency) = 0) ) {\n\t\t//create a list from all balls following the nearest ball\n\t\tlist<ball> free_balls <- ball where ((each.state) = 'follow_nearest_ball') ;\n\n\t\tif (length (free_balls) > 1) {\n\t\t\t//Clustering of the balls according to their distance with at least a minimal number of balls in a group\n\t\t\tlist<list<ball>> satisfying_ball_groups <- (free_balls simple_clustering_by_distance group_creation_distance) where ( (length (each)) > min_group_member ) ;\n\t\t\t\n\t\t\t\n\t\t\tloop one_group over: satisfying_ball_groups {\n\t\t\t\tcreate group returns: new_groups;\n\t\t\t\t\n\t\t\t\t//Capture by the new groups created of the different balls present in the list one_group\n\t\t\t\task (new_groups at 0) as: group {\n\t\t\t\t\tcapture one_group as: ball_in_group; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//The simulation will try to create clouds at each frequence cycle\n\treflex create_clouds when: (create_cloud and ((cycle mod creation_frequency) = 0) ) {\n\t\t//A cloud can be created only using group with a number of balls inside greater than 5% of the total ball number\n\t\tlist<group> candidate_groups <- group where (length(each.members) > (0.05 * ball_number) );\n\t\t\n\t\t//A cloud can be created also only using group which aren't too far away \n\t\tlist<list<group>> satisfying_groups <- (candidate_groups simple_clustering_by_distance cloud_creation_distance) where (length(each) >= min_cloud_member);\n\t\t\n\t\t//Creation of the different clouds using the groups satisfying both conditions\n\t\tloop one_group over: satisfying_groups {\n\t\t\tcreate cloud returns: rets;\t\t\t\n\t\t\tcloud newCloud <- rets at 0; \n\t\t\task newCloud as: cloud {\n\t\t\t\tcapture one_group as: group_delegation;\n\t\t\t}\n\n\t\t\tloop gd over: (newCloud.members) {\n\t\t\t\task gd as group_delegation {\n\t\t\t\t\tmigrate ball_in_group target: ball_in_cloud;\n\t\t\t\t}\n\t\t\t} \n\t\t\t\n\t\t\tnewCloud.color <- ((group_delegation(one_of(newCloud.members))).color).darker;\n\t\t}\n\t}\n}\n\t//Base species with just the skills moving and all built-in variables and operators derivated from it\n\tspecies base skills: [moving] ;\n\t\n\t//Species with a specified type of control architecture, here the final state machine FSM\n\tspecies ball parent: base control: fsm  { \n\t\t\n\t\tfloat speed <- ball_speed; \n\t\trgb color <- ball_color;\n\t\tint beginning_chaos_time; \n\t\tint time_in_chaos_state;\n\t\t\n\t\t//create the ball in a certain way to not make balls intersect each other\n\t\tinit {\n\t\t\tbool continue_loop <- true ; \n\t\t\tloop while: continue_loop {\n\t\t\t\tpoint tmp_location <- {(rnd (xmax - xmin)) + xmin, (rnd (ymax - ymin)) + ymin} ;\n\t\t\t\tgeometry potential_geom <- ball_shape at_location tmp_location ; \n\t\t\t\t\n\t\t\t\tif ( empty ( ball where  ( each intersects potential_geom ) ) )  {\n\t\t\t\t\tlocation <- tmp_location ;\n\t\t\t\t\tcontinue_loop <- false ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Action used to separate the balls and make them repulsive for the other balls of the group\n\t\taction separation (list<ball> nearby_balls) {\n\t\t\tfloat repulsive_dx <- 0.0 ;\n\t\t\tfloat repulsive_dy <- 0.0 ;\n\t\t\tloop nb over: nearby_balls { \n\t\t\t\tfloat repulsive_distance <- ball_separation - ( location distance_to ( nb).location ) ;\n\t\t\t\tint repulsive_direction <- ((nb).location) towards (location) ;\n\t\t\t\trepulsive_dx <- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;\n\t\t\t\trepulsive_dy <- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;\n\t\t\t}\n\t\t\tlocation <- location + {repulsive_dx, repulsive_dy} ;\n\t\t}\n\t\t\n\t\tbool in_bounds (point a_point) {\n\t\t\treturn ( !(a_point.x < xmin) and !(a_point.x > xmax) and !(a_point.y < ymin) and !(a_point.y > ymax) ) ;\n\t\t}\n\t\t \n\t\t//State that will make the agent follows the closest ball if it is not in the chaos state anymore\n\t\tstate follow_nearest_ball initial: true {\n\t\t\tenter {   \n\t\t\t\tcolor <- ball_color ;\n\t\t\t\tspeed <- ball_speed ;\n\t\t\t}\n\t\t\tlist<ball> free_balls <- (list (ball) - self) where ((each.state) = 'follow_nearest_ball') ;\n\t\t\tball nearest_free_ball <- free_balls closest_to self;\n\t\t\tif nearest_free_ball != nil {\n\t\t\t\theading <- self towards (nearest_free_ball) ; \n\t\t\t\tfloat step_distance <- speed * step ;\n\t\t\t\tfloat step_x <- step_distance * (cos (heading)) ;\n\t\t\t\tfloat step_y <- step_distance * (sin (heading)) ; \n\t\t\t\tpoint tmp_location <- location + {step_x, step_y} ;\n\t\t\t\tif (self in_bounds (tmp_location) ) {\n\t\t\t\t\tlocation <- tmp_location ;\n\t\t\t\t\tdo separation (((ball overlapping (shape + ball_separation)) - self));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Make the ball move randomly during a certain time\n\t\tstate chaos {\n\t\t\tenter {\n\t\t\t\tbeginning_chaos_time <- int(time) ;\n\t\t\t\ttime_in_chaos_state <- 10 + (rnd(10)) ;\n\t\t\t\tcolor <- chaos_ball_color ;\n\t\t\t\tspeed <- chaos_ball_speed ;\n\t\t\t\theading <- rnd(359) ;\n\t\t\t}\n\t\t\t\n\t\t\tfloat step_distance <- speed * step ;\n\t\t\tfloat step_x <- step_distance * (cos (heading)) ;\n\t\t\tfloat step_y <- step_distance * (sin (heading)) ;\n\t\t\tpoint tmp_location <- location + {step_x, step_y} ;\n\t\t\tif (self in_bounds (tmp_location)) {\n\t\t\t\tlocation <- tmp_location ;\n\t\t\t\tdo separation (nearby_balls: (ball overlapping (shape + ball_separation)) - self);\n\t\t\t}\n\t\t\t\n\t\t\ttransition to: follow_nearest_ball when: time > (beginning_chaos_time + time_in_chaos_state) ;\n\t\t}\n\t\t\n\t\taspect default {\n\t\t\tdraw ball_shape color: color size: ball_size at:self.location;\n\t\t}\n\t}\n\t\n\t//Species representing the group of balls\n\tspecies group parent: base { \n\t\t\n\t\trgb color <- rgb ([ rnd(255), rnd(255), rnd(255) ]) ;\n\t\tgeometry shape <- polygon (ball_in_group) buffer  10 ;\n\t\tfloat speed update: float(group_base_speed) ;\n\t\t\n\t\t//Parameter to capture the balls contains in the perception range\n\t\tfloat perception_range update: float(base_perception_range + (rnd(5))) ;\n\t\t\n\t\tball nearest_free_ball update: ( ball where ( (each.state = 'follow_nearest_ball') ) ) closest_to self ;\n\t\tgroup nearest_smaller_group update: ( ( (group as list) - self ) where ( (length (each.members)) < (length (members)) ) ) closest_to self ;\n\t\tbase target update: (self get_nearer_target []) depends_on: [nearest_free_ball, nearest_smaller_group] ;\n\t\t \n\t\t//Function to return the closest ball or small group of balls that the agent could capture\n\t\tbase get_nearer_target {\n\t\t\tif  (nearest_free_ball = nil) and (nearest_smaller_group = nil) {\n\t\t\t\treturn nil ;\n\t\t\t}\n\t\t\t\n\t\t\tfloat distance_to_ball <- (nearest_free_ball != nil) ? (self distance_to nearest_free_ball) : MAX_DISTANCE ;\n\t\t\tfloat distance_to_group <- (nearest_smaller_group != nil) ? (self distance_to nearest_smaller_group) : MAX_DISTANCE ;\n\t\t\tif (distance_to_ball < distance_to_group) {\n\t\t\t\treturn nearest_free_ball ;\n\t\t\t}\n\t\t\t \n\t\t\treturn nearest_smaller_group ;\n\t\t}\n\t\t\n\t\t//Action to use when the group of balls explode\n\t\taction separate_components {\n\t\t\tloop com over: (list (ball_in_group)) {\n\t\t\t\tlist<ball_in_group> nearby_balls <-  ((ball_in_group overlapping (com.shape + ball_separation)) - com) where (each in members) ;\n\t\t\t\tfloat repulsive_dx <- 0.0 ;\n\t\t\t\tfloat repulsive_dy <- 0.0 ;\n\t\t\t\tloop nb over: nearby_balls { \n\t\t\t\t\tfloat repulsive_distance <- ball_separation - ( (ball_in_group (com)).location distance_to nb.location ) ;\n\t\t\t\t\tint repulsive_direction <- (nb.location) direction_to ((ball_in_group (com)).location) ;\n\t\t\t\t\trepulsive_dx <- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;\n\t\t\t\t\trepulsive_dy <- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t(ball_in_group (com)).location <- (ball_in_group (com)).location + {repulsive_dx, repulsive_dy} ;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Species that will represent the balls captured by the group agent\n\t\tspecies ball_in_group parent: ball topology: topology((world).shape)  {\n\t\t\t\n\t\t\tfloat my_age <- 1.0 update: my_age + 0.01;\n\t\t\t \n\t\t\tstate follow_nearest_ball initial: true { }\n\t\t\t\n\t\t\tstate chaos { }\n\t\t\t\n\t\t\taspect default {\n\t\t\t\tdraw circle(my_age) color: ((host as group).color).darker ;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Reflex to capture all the balls close to the group agent\n\t\treflex capture_nearby_free_balls when: (cycle mod update_frequency) = 0 {\n\t\t\tlist<ball> nearby_free_balls <- (ball overlapping (shape + perception_range)) where (each.state = 'follow_nearest_ball');\n\t\t\tif !(empty (nearby_free_balls)) {\n\t\t\t\tcapture nearby_free_balls as: ball_in_group;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Action to do when the group is disaggregated\n\t\taction disaggregate {\n\t\t\trelease members as: ball in: world {\n\t\t\t\t state <- 'chaos' ;\n\t\t\t}\n\t\t\t\n\t\t\tdo die ;\n\t\t}\n\t\t\n\t\t//Reflex to merge the group close to the agent when the cycle is in the frequency of merging\n\t\treflex merge_nearby_groups when: (cycle mod merge_frequency) = 0 {\n\t\t\tif ( (target != nil) and ((species_of (target)) = group) ) {\n\t\t\t\tlist<group> nearby_groups <- (group overlapping (shape + perception_range)) - self ;\n\t\t\t\t\n\t\t\t\tif target in nearby_groups {\n\t\t\t\t\tif (rnd(10)) < (merge_possibility * 10) {\n\t\t\t\t\t\tlist<ball_in_group> target_coms <- list<ball_in_group>(target.members) ;\n\t\t\t\t\t\tlist<ball> released_balls ;\n\t\t\t\t\t\task target {\n\t\t\t\t\t\t\trelease target_coms as: ball in: world returns: released_coms;\n\t\t\t\t\t\t\treleased_balls <- list(released_coms);\n\t\t\t\t\t\t\tdo die ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcapture released_balls as: ball_in_group; \n\t\t\t\t\t}\n\t\t\t\telse { ask target as group {do disaggregate ;} }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Reflex to chase a target agent \n\t\treflex chase_target when: (target != nil) {\n\t\t\tint direction_to_nearest_ball <- (self towards (target)) ;\n\t\t\tfloat step_distance <- speed * step ;\n\t\t\tfloat dx <- step_distance * (cos (direction_to_nearest_ball)) ;\n\t\t\tfloat dy <- step_distance * (sin (direction_to_nearest_ball)) ;\n\t\t\tgeometry envelope <- shape.envelope ;\n\t\t\tpoint topleft_point <- (envelope.points) at 0 ;\n\t\t\tpoint bottomright_point <- (envelope.points) at 0 ;\n\t\t\t\n\t\t\tloop p over: envelope.points {\n\t\t\t\tif ( (p.x <= topleft_point.x) and (p.y <= topleft_point.y) ) {\n\t\t\t\t\ttopleft_point <- p ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( (p.x >= bottomright_point.x) and (p.y >= bottomright_point.y) ) {\n\t\t\t\t\tbottomright_point <- p ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ( (dx + topleft_point.x) < 0 ) {\n\t\t\t\tfloat tmp_dx <- dx + topleft_point.x ;\n\t\t\t\tdx <- dx - tmp_dx ;\n\t\t\t} else {\n\t\t\t\tif (dx + bottomright_point.x) > (environment_bounds.x) {\n\t\t\t\t\tfloat tmp_dx <- (dx + bottomright_point.x) - environment_bounds.x ;\n\t\t\t\t\tdx <- dx - tmp_dx ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (dy + topleft_point.y) < 0 {\n\t\t\t\tfloat tmp_dy <- dy + topleft_point.y ;\n\t\t\t\tdy <- dy - tmp_dy ;\n\t\t\t} else {\n\t\t\t\tif (dy + topleft_point.y) > (environment_bounds.y) {\n\t\t\t\t\tfloat tmp_dy <- (dy + bottomright_point.y) - (environment_bounds.y) ;\n\t\t\t\t\tdy <- dy - tmp_dy ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tloop com over: (list (ball_in_group)) {\n\t\t\t\t(ball_in_group (com)).location <- (ball_in_group (com)).location + {dx, dy} ;\n\t\t\t}\n\t\t\t\n\t\t\tshape <- convex_hull((polygon ((list (ball_in_group)) collect (ball_in_group (each)).location)) + 2.0) ;\n\t\t}\n\t\t//Reflex to disaggregate the group if it is too important ie the number of balls is greater than 80% of the total ball number\n\t\treflex self_disaggregate {\n\t\t\tif ( ( length (members) ) > ( 0.8 * (ball_number) ) ) {\n\t\t\t\tdo disaggregate ;\n\t\t\t}\n\t\t}\n\t\t\n\t\taspect default {\n\t\t\tdraw shape color: color;\n\t\t}\n\t}\n\t\n\t//Species cloud that will be created by an agglomeration of groups.\n\tspecies cloud parent: base {\n\t\tgeometry shape <- convex_hull(polygon(members collect (((group_delegation(each)).shape).location))) update: convex_hull(polygon(members collect (((group_delegation(each)).shape).location)));\n\n\t\trgb color;\n\t\t\n\t\t//Species contained in the cloud to represent the groups captured by the cloud agent\n\t\tspecies group_delegation parent: group topology: (topology(world.shape)) {\n\t\t\tgeometry shape <- convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer 10 update: convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer  10 ;\n\n\t\t\treflex capture_nearby_free_balls when: false {\n\t\t\t}\n\t\t\t\n\t\t\treflex merge_nearby_groups when: false {\n\t\t\t}\n\t\t\t\n\t\t\treflex chase_target when: false {\n\t\t\t}\n\t\t\t\n\t\t\treflex self_disaggregate {\n\t\t\t}\n\t\t\t\n\t\t\taction move2 (float with_heading, float with_speed) {\n\n\t\t\t\tloop m over: members {\n\t\t\t\t\task m as ball_in_cloud {\n\t\t\t\t\t\tdo move2 (with_heading,with_speed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tspecies ball_in_cloud parent: ball_in_group topology: (world.shape) as topology control: fsm {\n\t\t\t\t\n\t\t\t\taction move2 (float with_heading, float with_speed) {\n\t\t\t\t\tfloat dx <- cos(with_heading) * with_speed;\n\t\t\t\t\tfloat dy <- sin(with_heading) * with_speed;\n\t\t\t\t\tlocation <- { ( (location.x) + dx ), ( (location.y) + dy )};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\taspect default {}\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tgroup target_group;\n\t\n\t\t//The cloud try to look for small groups to capture them\n\t\treflex chase_group {\n\t\t\tif ( (target_group = nil) or (dead(target_group)) ) {\n\t\t\t\ttarget_group <- one_of(group);\n\t\t\t}\n\t\t\t\n\t\t\tif (target_group != nil) {\n\t\t\t\tint direction_target <- self towards(target_group);\n\t\t\t\t\n\t\t\t\tloop m over: members {\n\t\t\t\t\task m as group_delegation {\n\t\t\t\t\t\tdo move2 with: [ with_heading :: float(direction_target), with_speed :: float(cloud_speed) ];\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Operator to know if a cloud can capture a group overlapping the cloud agent. \n\t\tbool can_capture (group a_group) {\n\t\t\t\n\t\t\tif (shape overlaps a_group.shape) { return true; }\n\t\t\t\n\t\t\tloop gd over: members {\n\t\t\t\tif ( (a_group.shape) overlaps ( ( group_delegation(gd)).shape ) ) { return true; }\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t//Reflex to capture group\n\t\treflex capture_group {\n\t\t\tif ( (target_group != nil) and !(dead(target_group)) ) {\n\t\t\t\tif (self can_capture [ a_group :: target_group]) {\n\n\t\t\t\t\tcapture target_group as: group_delegation returns: gds;\n\t\n\t\t\t\t\task (gds at 0) as: group_delegation {\n\t\t\t\t\t\tmigrate ball_in_group target: ball_in_cloud;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Reflex to disaggregate the clouds when they are no more group to capture\n\t\treflex disaggregate when: (empty(list(group))) {\n\t\t\tloop m over: members {\n\t\t\t\task group_delegation(m) as: group_delegation {\n\t\t\t\t\tmigrate ball_in_cloud target: ball_in_group;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\trelease members as: group in: world returns: r_groups;\n\t\t\t\n\t\t\tloop rg over: r_groups {\n\t\t\t\task rg as: group { do disaggregate; }\n\t\t\t}\n\t\t\t\n\t\t\tdo die; \n\t\t}\n\t \t \n\t\taspect default {\n\t\t\tdraw shape color: color empty: true;\n\t\t\tdraw (name + ' with ' + (string(length(members))) + ' groups.') size: 15 color: color  at: {location.x - 65, location.y};\n\t\t}\n\t}\n\t\n\tspecies group_agents_viewer  { \n\t\taspect default {\n\t\t\tdraw ('Number of groups: ' + (string (length (world.agents of_generic_species group)))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #blue size: 40  ;\n\t\t}\n\t}\n\n\tspecies cloud_agents_viewer  { \n\t\taspect default {\n\t\t\tdraw ('Number of clouds: ' + (string (length (list(cloud))))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #green size: 40 ;\n\t\t}\n\t} \n\n\nexperiment group_experiment type: gui {\n\tparameter 'Create groups?' var: create_group <- true;\n\tparameter 'Create clouds?' var: create_cloud <- false;\n\t\t\n\toutput {\n\t\tdisplay 'Standard display' {\n\t\t\tspecies ball aspect: default transparency: 0.5 ;\n\t\t\t\n\t\t\tspecies group aspect: default transparency: 0.5 {\n\t\t\t\tspecies ball_in_group;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay 'Ball display' {\n\t\t\tspecies ball;\n\t\t}\n\t\t\n\t\tdisplay 'Group display' {\n\t\t\tspecies group;\n\t\t\tspecies group_agents_viewer;\n\t\t}\n\t}\n}\n\nexperiment cloud_experiment type: gui {\n\n\tparameter 'Create groups?' var: create_group <- true;\n\tparameter 'Create clouds?' var: create_cloud <- true;\n\t\t\n\toutput {\n\t\tdisplay 'Standard display' {\n\t\t\tspecies ball aspect: default transparency: 0.5 ;\n\t\t\t\n\t\t\tspecies group aspect: default transparency: 0.5 {\n\t\t\t\tspecies ball_in_group;\n\t\t\t}\n\t\t\t\n\t\t\tspecies cloud aspect: default {\n\t\t\t\tspecies group_delegation transparency: 0.9 {\n\t\t\t\t\tspecies ball_in_cloud;\n\t\t\t\t\tspecies ball_in_group;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay 'Ball display' {\n\t\t\tspecies ball;\n\t\t}\n\t\t\n\t\tdisplay 'Group display' {\n\t\t\tspecies group;\n\t\t\tspecies group_agents_viewer;\n\t\t}\n\n\t\tdisplay 'Cloud display' {\n\t\t\tspecies cloud;\n\t\t}\n\t\t\n\t\tmonitor \"Balls\" value: length(ball);\n\t\tmonitor \"Groups\" value: length(group);\n\t\tmonitor \"Clouds\" value: length(cloud);\n\t}\n}\n\n```\n","url":"wiki/Multi-Level-Usage-Balls,-Groups-and-Clouds.md"},"Multi-Level-Usage-Corridor-(Hybrid-vs-ABM).md":{"title":" Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model","content":"[//]: # (keyword|operator_at_location)\n[//]: # (keyword|operator_towards)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|concept_multi_level)\n[//]: # (keyword|concept_agent_movement)\n# Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model\n\n\n_Author : _\n\nThis model shows how to use multi-level architecture. Two corridors are presented : one which can capture the pedestrians going through it and computing for them the time before releasing them at the end of the corridor, and an other doing nothing, letting the pedestrians moving by themselves in the corridor. \n\n\nCode of the model : \n\n```\n\nmodel pedestrian_corridor_Hybrid_vs_ABM\n\nglobal \n{\n\t\n\t//Parameters of the environment\n\tint environment_width <- 200 const: true;\n\tint environment_height <- 200 const: true;\n\tgeometry shape <- rectangle(environment_width, environment_height);\t\n\t\n\t\n\t//Parameters of the pedestrian agents\n\trgb pedestrian_green <- #green;\n\t\n\tfloat pedestrian_size <- 1.0;\n\tgeometry pedestrian_shape <- circle (pedestrian_size) ;\n\tfloat pedestrian_speed <- 2.0;\n \n \t//Parameters of the corridors\n\trgb corridor_color <- rgb ('blue');\n\tint corridor_width <- 160 depends_on: [environment_width];\n\tint corridor_height <- (int(environment_height * 0.05));\n\n\tpoint corridor_location_0 <- {environment_width / 2, environment_height / 4};\n\tgeometry corridor_shape_0 <- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_0) ;\n\n\tpoint corridor_location_1 <- {environment_width / 2, environment_height * 0.75};\n\tgeometry corridor_shape_1 <- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_1) ;\n\n\t//Parameters of pedestrian generation\n\tint new_pedestian_generate_frequency <- 8;\n\tpoint pedestrian_source_0 <- {0, corridor_location_0.y} ;\n\tpoint pedestrian_source_1 <- {0, corridor_location_1.y} ;\n\t \n\t \n\t \n\tinit \n\t{\n\t\tcreate corridor number: 2 returns: new_corridors;\n\t\t\n\t\task (new_corridors at 0) \n\t\t{\n\t\t\tdo init_corridor corridor_shape: corridor_shape_0 is_hybrid: false;\n\t\t}\n\n\t\task (new_corridors at 1) \n\t\t{\n\t\t\tdo init_corridor corridor_shape: corridor_shape_1 is_hybrid: true; \n\t\t}\n\t}\n\n\t//Generation of pedestrians according to the frequency of generation : one for each corridor\n\treflex generate_pedestrians when: ( (cycle mod new_pedestian_generate_frequency) = 0 ) \n\t{ \n\t\tcreate pedestrian number: 2 returns: new_pedestrians;\n\t\t\n\t\task (new_pedestrians at 0) \n\t\t{\n\t\t\tdo init_location loc: pedestrian_source_0;\n\t\t}\n\t\t\n\t\task (new_pedestrians at 1) \n\t\t{\n\t\t\tdo init_location loc: pedestrian_source_1;\n\t\t}\n\t}\t\n}\n\n\n//Species for the pedestrians which can move\nspecies pedestrian skills: [moving] {\n\tgeometry shape <- circle(pedestrian_size);\n\trgb color;\n\tcorridor last_corridor;\n\tpoint target_location;\n\tfloat speed <- pedestrian_speed;\n\t\n\t//Initialisation of the target location according to its generation location\n\taction init_location (point loc) {\n\t\tlocation <- loc;\n\t\ttarget_location <- {environment_width, location.y};\n\t\theading <- self towards (target_location);\n\t}\n\n\t//Reflex to move the agent to its target location and make it die once it reached its target\n\treflex move_left \n\t{\n\t\tdo move heading: (self) towards (target_location); \n\t\t\n\t\tif ( (target_location.x - location.x) <= speed ) \n\t\t{\n\t\t\tdo die;\n\t\t}\n\t}\n\t \n\taspect default \n\t{\n\t\tdraw shape color: color;\n\t}\n}\n\n//Species for the corridor which can capture pedestrians\nspecies corridor  {\n\tbool capture_pedestrians;\n\t\n\t\n\taction init_corridor (geometry corridor_shape, bool is_hybrid) \n\t{\n\t\tshape <- corridor_shape;\n\t\tcapture_pedestrians <- is_hybrid;\n\t}\n\n\tfloat max_speed <- pedestrian_speed;\n\tfloat macro_length min: 0.0 <- float(corridor_width); // the length of macro_patch\n\t\n\t//Species to model the pedestrian captured by the corridor\n\tspecies captured_pedestrian parent: pedestrian schedules: [] \n\t{\n\t\tfloat released_time;  \n\t\t\n\t\taspect default { }\n\t}\n\t\n\tinit \n\t{ \n\t\tcreate corridor_info_drawer number: 1 with: [target :: self];\n\t}\n\t//Reflex to capture the pedestrians overlapping the corridor ie entering the corridor \n\treflex aggregate when: capture_pedestrians \n\t{\n\t\tlist<pedestrian> tobe_captured_pedestrians <- (pedestrian overlapping shape) where ( (each.last_corridor != self) and ((each.location).x < (self.location).x) ) ; \n\t\t\n\t\tif !(empty (tobe_captured_pedestrians)) \n\t\t{\n\t\t\tcapture tobe_captured_pedestrians as: captured_pedestrian returns: cps { \n\t\t\t\tlast_corridor <- myself;\n\t\t\t}\n\t\t\tif !(empty (cps)) \n\t\t\t{\n\t\t\t\t\t//Computation of the time when the pedestrians captured will be released according to the speed\n\t\t\t\t\t// and the time they should make to pass the corridor if they move by themselves\n\t\t\t\t\tfloat group_outgoing_time <- time + (corridor_width / (pedestrian_speed) ); \n\t\t\t\t\tloop cp over: cps \n\t\t\t\t\t{\n\t\t\t\t\t\t\tcp.released_time <- group_outgoing_time;\n\t \t\t\t\t}\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\t\n\t//Reflex to release the pedestrians when we consider they were enough time inside the corridor \n\treflex disaggregate  \n\t{\n\t\tlist tobe_released_pedestrians <- members where (time >= (captured_pedestrian (each)).released_time);\n\t\t\n\t\tif !(empty (tobe_released_pedestrians)) \n\t\t{\n\t\t\t\n\t\t\trelease tobe_released_pedestrians as: pedestrian in: world returns: released_pedestrians;\n\t\t\t\n\t\t\tloop rp over: released_pedestrians \n\t\t\t{\n\t\t\t\trp.speed <- pedestrian_speed;\n\t\t\t\trp.location <- {((environment_width / 2) + (corridor_width / 2)), ((corridor_shape_1).location).y};\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\taspect default \n\t{\n\t\tdraw shape color: corridor_color;\n\t}\n}\n \nspecies corridor_info_drawer \n{\n\tcorridor target;\n\t\n\taspect base \n\t{\n\t\tif target.capture_pedestrians \n\t\t{\n\t\t\tdraw 'Hybrid model (coupling: ABM and Mathematical Model)' color: #blue size: 7 at: {(target.location).x - 90, (target.location).y - 10};\n\t\t\tdraw  'Aggregated agents: ' + string(length(target.members)) color: #black size: 7 at: {(target.location).x - 30, (target.location).y + 2};\n\t\t} \n\t\telse \n\t\t{\n\t\t\tdraw 'Agent-Based Model (ABM)' color: #blue size: 7 at: {(target.location).x - 40, (target.location).y - 10};\n\t\t}\n\t}\n}\n\nexperiment default_experiment type: gui \n{\n\toutput \n\t{\n\t\tdisplay default_display \n\t\t{\n\t\t\tspecies pedestrian;\n\t\t\tspecies corridor transparency: 0.8;\n\t\t\tspecies corridor_info_drawer aspect: base;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Multi-Level-Usage-Corridor-(Hybrid-vs-ABM).md"},"Multi-Level-Usage-Corridor.md":{"title":" Corridor Multi-Level Architecture","content":"[//]: # (keyword|operator_at_location)\n[//]: # (keyword|operator_towards)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|constant_#pixels)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_multi_level)\n[//]: # (keyword|concept_agent_movement)\n# Corridor Multi-Level Architecture\n\n\n_Author : _\n\nThis model shows how to use multi-level architecture. A corridor can capture pedestrians going from left to right side if they are inside the corridor. This will result in changing their species from pedestrian to captured_pedestrian which will not be displayed. Once they pass enought time to consider they reach the exit of the corridor, they will be released by the corridor agent as pedestrians, letting them been displayed and going to their target. \n\n\nCode of the model : \n\n```\n\nmodel corridor\n\nglobal {\t\n\t//Capture pedestrians parameter to define if wall will capture pedestrians\n\tbool capture_pedestrians <- false parameter: 'Capture pedestrians?';\n\t\n\tint environment_size init: 2000;\n\tpoint environment_bounds init: {environment_size, environment_size} ;\n\tgeometry shape <- rectangle(environment_bounds) ;\t\t\n\t\n\t//Pedestrians parameters\n\tfloat pedestrian_size init: 1.0;\n\tgeometry pedestrian_shape <- circle (pedestrian_size);\n\trgb pedestrian_color <- #green; \n\tfloat pedestrian_speed <- 2.0;\n\t\n\t\n\t//Wall parameters\n\trgb corridor_wall_color <- #black;\n\tint corridor_wall_width <- int(environment_size / 2);\n\tint corridor_wall_height <- 200;\n\tgeometry corridor_wall_0_shape <- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / 2, corridor_wall_height / 2};\n\tgeometry corridor_wall_1_shape <- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / 2, environment_size - (corridor_wall_height / 2)};\n\t\n\t//Corridor parameters\n\trgb corridor_color <- #blue;\n\tint corridor_width <- int(environment_size / 2) ;\n\tint corridor_height <- environment_size ;\n\tpoint corridor_location <- {environment_size / 2, environment_size / 2} ;\n\tgeometry corridor_shape <- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location) - (corridor_wall_0_shape + corridor_wall_1_shape);\n\tint corridor_left_bounds <- (int(corridor_location.x - (corridor_width / 2))) ;\n\tint corridor_right_bounds <- (int(corridor_location.x + (corridor_width / 2))) ;\n\t\n\t//Generation of new pedestrians parameters\n\tint new_pedestrian_rate <- 10;\n\tint new_pedestian_generate_frequency <- 1;\n\tint new_pedestrian_y_distance <- int(environment_size / new_pedestrian_rate);\n\t\n\tlist<pedestrian> pedestrians  update: list(pedestrian); \n\tfloat start_time <- machine_time;\n\t\n\tinit {\n\t\tcreate corridor;\n\t\t \n\t\tcreate corridor_wall number: 2 returns: corridor_walls; \n\t\t(corridor_walls at 0).shape <- corridor_wall_0_shape;\n\t\t(corridor_walls at 1).shape <- corridor_wall_1_shape;\n\t\t\n\t}\n\t\n\t//Reflex to generate new pedestrians according to the frequency generation parameter\n\treflex generate_pedestrians when: ((cycle mod new_pedestian_generate_frequency) = 0) {\n\t\tcreate pedestrian number: new_pedestrian_rate returns: new_pedestrians; \n\t\t\n\t\tint loop_times <- 0;\n\t\tloop p over: new_pedestrians {\n\t\t\tint y_coor <- rnd (new_pedestrian_y_distance);\n\t\t\task p as: pedestrian {\n\t\t\t\tdo init_location loc: { 0, (loop_times * new_pedestrian_y_distance) + y_coor };\n\t\t\t}\n\t\t\tloop_times <- loop_times + 1;\n\t\t}\n\t}\n\n} \n\n//Species pedestrian which will move from one side of the experiments to another and destroy itself once the other side is reached\nspecies pedestrian skills: [moving] topology: ( topology (shape - (corridor_wall_0_shape + corridor_wall_1_shape)) ){\n\tgeometry shape <-  circle (pedestrian_size);\n\tpoint initial_location;\n\tpoint target_location;\n\tint heading;\n\tfloat speed <- 2.0;\n\t\n\taction init_location (point loc) {\n\t\tlocation <- loc;\n\t\tinitial_location <- loc;\n\t\ttarget_location <- {environment_size, loc.y};\n\t\theading <- (self) towards (target_location);\n\t}\n\t\n\t//Reflex to make the agent move to its target_location\n\treflex move_left {\n\t\tint update_heading <- (self) towards (target_location);\n\t\t\n\t\tpoint current_location <- location;\n\t\t\n\t\tdo move heading: update_heading ;\n\t\t\n\t\t//Conditions to know if the agent doesn't move, in this case we take care if it is bcause of the walls \n\t\tif (current_location = location) {\n\t\t\tif ( (location.y <= corridor_wall_height) or (location.y >= environment_size - corridor_wall_height) ) {\n\t\t\t\tdo move heading: self towards {(environment_size / 2) - (corridor_width / 2), environment_size / 2}; \n\t\t\t} else {\n\t\t\t\tdo move heading: self towards {environment_size / 2, environment_size / 2}; \n\t\t\t}\n\t\t}\n\t\t\n\t\tif( (target_location.x - location.x) <= speed ) { \n\t\t\tdo die;\n\t\t}\n\t}\n\t \n\taspect my_aspect {\n\t\tdraw shape color: pedestrian_color;\n\t}\n}\n\n//Species which represents the corridor\nspecies corridor  {\n\tgeometry shape <- corridor_shape;\n\t\n\t//Subspecies for the multi-level architectures : captured pedestrians in this case\n\tspecies captured_pedestrian parent: pedestrian schedules: [] {\n\t\tfloat released_time;\n\t\t\n\t\taspect my_aspect { }\n\t}\n\t\n\tinit {\n\t\tcreate corridor_info_drawer number: 1 with: [target :: self];\n\t}\n\t\n\t//Reflex to capture pedestrians if the parameter is checked\n\treflex aggregate when: capture_pedestrians {\n\t\t//List to get all the pedestrians inside the corridor\n\t\tlist<pedestrian> tobe_captured_pedestrians <- (pedestrian overlapping shape);\n\t\t\n\t\t//If we have pedestrians inside the corridor, we capture them\n\t\tif !(empty (tobe_captured_pedestrians)) {\n\t\t\tcapture tobe_captured_pedestrians as: captured_pedestrian returns: cps;\n\t\t\t\n\t\t\t//We update the time during which a pedestrian is captured according to the time the pedestrian\n\t\t\t// should need to pass through the corridor if it wasn't captured\n\t\t\tloop cp over: cps {\n\t\t\t\tcp.released_time <- time + ( ( corridor_width - ( (((cp).location).x) - ((environment_size / 2) - (corridor_width / 2)) ) ) / pedestrian_speed) ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//Reflex to release pedestrians which have already passed enough time in the corridor\n\t// which means if they weren't captured by the corridor, they would have finish passing through it\n\treflex disaggregate  {\n\t\tlist tobe_released_pedestrians <- members where (time >= (captured_pedestrian (each)).released_time);\n\t\tif !(empty (tobe_released_pedestrians)) {\n\t\t\trelease tobe_released_pedestrians as: pedestrian in: world {\n\t\t\t\tlocation <- {((environment_size / 2) + (corridor_width / 2)) + (2 * pedestrian_size), (location).y};\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect my_aspect {\n\t\tdraw shape color: corridor_color;\n\t}\n}\n\nspecies corridor_wall {\n\tinit {\n\t\tcreate corridor_wall_info_drawer number: 1 with: [target :: self];\n\t}\n\t\n\taspect  my_aspect {\n\t\tdraw shape color: corridor_wall_color;\n\t}\n}\n\nspecies corridor_info_drawer {\n\tcorridor target;\n\t\n\taspect my_aspect {\n\t\tdraw  'Captured pedestrians: ' + (string (length (target.members))) color: rgb ('blue') size: 12°px at: {(target.location).x - 480, (target.location).y};\n\t\tdraw  'Pedestrians: ' + (string (length (list (pedestrian)))) color: rgb ('blue') size: 12°px at: {(target.location).x - 135, (target.location).y + 100};\n\t}\n}\n\nspecies corridor_wall_info_drawer {\n\tcorridor_wall target;\n\t\n\tinit {\n\t\tlocation <- target.location;\n\t}\n\t\n\taspect my_aspect { \n\t\tdraw 'WALL' color: rgb ('green') size: 15°px at: {(location).x - 40, (location).y};\n\t}\n}\n\n\nexperiment corridor_expr type: gui{\n\toutput {\n\t\tdisplay defaut_display {\n\t\t\tspecies pedestrian;\n\t\t\t\n\t\t\tspecies corridor aspect: my_aspect transparency: 0.8 {\n\t\t\t\tspecies captured_pedestrian;\n\t\t\t}\n\t\t\t\n\t\t\tspecies corridor_wall aspect: my_aspect transparency: 0.7;\n\t\t\tspecies corridor_info_drawer aspect: my_aspect;\n\t\t\tspecies corridor_wall_info_drawer aspect: my_aspect;\n\t\t}\n\n\t\tdisplay Execution_Time refresh: every(25) {\n\t\t\tchart 'Simulation step length' type: series background: #white {\n\t\t\t\tdata 'simulation_step_length_in_mili_second' value: machine_time - start_time color: (rgb ('green'));\n\t\t\t}\n\t\t}\n\t \t\n\t\tdisplay Captured_Pedestrians refresh: every(25){\n\t\t\tchart 'Captured Pedestrian' type: series background: #white {\n\t\t\t\tdata 'captured_pedestrians' value: length ( ((list (corridor)) at 0).members ) color: rgb ('blue');\n\t\t\t\tdata 'pedestrians' value: length (list (pedestrian)) color: rgb ('white');  \n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Multi-Level-Usage-Corridor.md"},"Multi-Level-Usage-Predators,-Preys-and-Shelters.md":{"title":" Multi-Level Architecture with Preys and Predators","content":"[//]: # (keyword|operator_of_species)\n[//]: # (keyword|operator_agents_overlapping)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_towards)\n[//]: # (keyword|operator_dead)\n[//]: # (keyword|operator_at_location)\n[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_enter)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|concept_multi_level)\n[//]: # (keyword|concept_agent_movement)\n# Multi-Level Architecture with Preys and Predators\n\n\n_Author : _\n\nThis model shows how to use multi-level architecture. In this model, prey and predators agents move randomly in the environment. When a prey agent perceive a predator, it flees trying to go to the closest shelters while the predator agent chases it. The shelters capture the prey agents fleeing, changing them into prey_in_shelter species, that predator can't chase during a certain time. They are released after that time in an invisible state so that they can wander in the  environment without being chase by the predator, but also, for a certain time.\n\n\nCode of the model : \n\n```\n\nmodel preys_predators_shelters\n\nglobal { \n\t//Parameters for the prey species\n\trgb prey_color <- #green const: true;\n\tfloat prey_perception <- 20.0;\n\tfloat prey_size <- 2.0 const: true;\n\tfloat prey_speed <- 1.0;\n\trgb prey_flee_color <- #orange;\n\tfloat prey_invisible_speed <- 3 * prey_speed;\n\trgb prey_invisible_color <- #black;  \n\tint prey_in_shelter_max_time min: 1 init: 200;\n\tint prey_invisible_max_time min: 1 max: 100 init: 70; \n\tint number_of_preys min: 1 max: 1000 init: 100;\n\t\n\t//Parameters for the predator species\n\trgb predator_color <- #red const: true;\n\tfloat predator_perception <- 3.0;\n\tfloat predator_size <- 4.0;\n\tfloat predator_speed <- 1.0;\n\tint number_of_predators min: 1 max: 100 init: 30; \n\tgeometry shape <- square(400);\n\t\n\trgb predator_in_shelter_color <- #yellow const: true;\n\t \n\t//Parameters for the shelter species\n\trgb shelter_color <- #blue const: true; \n\tfloat shelter_speed <- 1.5 const: true;\n\tgeometry shelter_shape <- square (50.0);\n\tint number_of_shelter <- 2 const: true;\n\t\n\t\n\tinit {\n\t\tcreate prey number: number_of_preys;\n\t\tcreate predator number: number_of_predators; \n\t\tcreate shelter number: number_of_shelter returns: shelters;\n\t\t(shelters at 0).shape <- shelter_shape at_location {150, 250};\n\t\t(shelters at 1).shape <- shelter_shape at_location {350, 250};\n\t}\n}\n//Species prey which can move using the skill moving and its operators\nspecies prey skills: [moving] control: fsm {\n\tgeometry shape <- square (prey_size);\n\trgb color <- prey_color;\n\t\n\t//List of all predators inside the perception of the prey\n\tlist nearby_predators update: (agents_overlapping (shape + prey_perception)) of_species predator depends_on: shape;\n\tint invisible_time min: 1 <- int(time);\n\n\tshelter nearest_shelter;\t\t\n\n\t//State to make the prey move randomly when there isn't any predator, if so, change the state to flee\n\tstate move_around initial: true {\n\t\tenter {\n\t\t\tspeed <- prey_speed;\n\t\t\tcolor <- prey_color;\n\t\t}\n\t\tdo wander; \n\t\t\n\t\ttransition to: flee_predator when: !(empty (nearby_predators)); \n\t}\n\t\n\t//State to make the prey move to the closest shelter to flee from the predator, if no predator are perceived, change the state to move aroung\n\tstate flee_predator {\n\t\tenter {\n\t\t\tcolor <- prey_flee_color;\n\t\t\tnearest_shelter <- first ( (list (shelter)) sort_by ( each distance_to (self)) );\n\t\t}\n\t\tif !(empty (nearby_predators)) { do move heading: (self) towards (nearest_shelter) speed: prey_speed;}\n\t\t\n\t\ttransition to: move_around when: (empty (nearby_predators));\n\t}\n\t//State to make the prey invisible during a certain time when it is released by the shelters\n\tstate invisible {\n\t\tenter {\n\t\t\tspeed <- prey_invisible_speed;\n\t\t\tcolor <- prey_invisible_color;\n\t\t\tinvisible_time <- int(time);\n\t\t\theading <- rnd (359) ;\n\t\t}\n\t\tdo move; \n\t\ttransition to: move_around when: ( (time - invisible_time) > prey_invisible_max_time );\n\t}\n\t\n\taspect default {\n\t\tdraw  shape color: color;\n\t}\n}\n\n//Species predator which can move using the skill moving\nspecies predator skills: [moving] schedules: shuffle (list (predator)) {\n\tgeometry shape <- square (predator_size);\n\tprey target_prey update: self choose_target_prey [];\n\t\n\t//Change the target prey according to the prey who aren't fleeing if it doesn't have any yet\n\taction choose_target_prey type: prey {\n\t\tif ( (target_prey = nil) or (dead (target_prey) ) ) {\n\t\t\treturn one_of ( (list (prey)) where (each.state = 'move_around') );\n\t\t}\n\t\t\n\t\treturn target_prey;\n\t}\n\t//Reflex to move randomly when no prey are perceived\n\treflex move_around when: (target_prey = nil) { do wander speed: predator_speed; }\n\t\n\t//Reflex to make the predator chase a prey\n\treflex chase_prey when: (target_prey != nil) { do move heading: self towards target_prey speed: predator_speed;}\n\t\n\taspect default {\n\t\tdraw shape color: predator_color;\n\t} \n} \n\n//Species shelter that will capture prey agents\nspecies shelter skills: [moving]  frequency: 2 {\n\tgeometry shape <- (square (50.0)) at_location {250, 250};\n\t\n\t//List of all preys which are being chased and inside the shelter but not captured yet\n\tlist<prey> chased_preys update: (prey) where ( (each.shape intersects shape) and (each.state = 'flee_predator') );\n\t\n\treflex move_around {\n\t\t//do wander speed: shelter_speed; \n\t}\n\t \n\t//Capture all the chased preys inside the shelter and change their species to prey_in_shelter\n\treflex capture_chased_preys when: !(empty (chased_preys)) { \n\t\tcapture chased_preys as: prey_in_shelter {\n\t\t\tstate <- 'in_shelter'; \n\t\t\tshape <- ( triangle (4.0) ) at_location location;\n\t\t}\n\t}\n\t\n\t//Release all the prey_in_shelter after a certain time and change their state to invisible after making their species returned to prey\n\treflex release_member_preys {\n\t\tlist<prey_in_shelter> to_be_released <- (prey_in_shelter) where ( (time - each.in_shelter_time) > prey_in_shelter_max_time );\n\t\t \n\t\trelease to_be_released in: world as: prey { \n\t\t\tstate <- 'invisible';\n\t\t\tshape <-  at_location (square (prey_size), self.location);   \n\t\t}\n\t} \n\t\n\t//Subspecies prey_in_shelter that will represent the prey agents captured by the shelter\n\tspecies prey_in_shelter parent: prey frequency: 2 schedules: ( ( int ( (length (prey_in_shelter)) / 2 ) ) among (list (prey_in_shelter)) ) {\n\t\tint in_shelter_time <- int(time);\n\t\t\n\t\tstate in_shelter {\n\t\t\tdo wander speed: shelter_speed;\n\t\t}\n\t\t\n\t\taspect default {\n\t\t\tdraw  shape color: predator_in_shelter_color;\n\t\t} \n\t}\n\t\n\taspect default {\n\t\tdraw shape color: shelter_color;\n\t\tdraw 'Members: ' + (string (length ((members)))) color: rgb ('white') size: 6 at: {(location).x - 20, (location).y};\n\t}\n}\n\nexperiment default_experiment type: gui {\n\toutput {\n\t\tdisplay default_display type: opengl{\n\t\t\tspecies prey aspect: default;\n\t\t\tspecies predator transparency: 0.5 aspect: default;\n\t\t\tspecies shelter transparency: 0.5 aspect: default { \n\t\t\t\tspecies prey_in_shelter aspect: default;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Multi-Level-Usage-Predators,-Preys-and-Shelters.md"},"Multi-simulation-Multi-simulation.md":{"title":" Multi Simulation","content":"[//]: # (keyword|operator_font)\n[//]: # (keyword|statement_overlay)\n[//]: # (keyword|constant_#pixels)\n[//]: # (keyword|constant_#bold)\n[//]: # (keyword|concept_multi_simulation)\n# Multi Simulation\n\n\n_Author : Patrick Taillandier_\n\nModel to show how to use multi-simulation, i.e. to run several times the same GUI experiment with potentially different parameter sets \n\n\nCode of the model : \n\n```\n\nmodel multi_simulation\n\nglobal {\n\t//definition of three global variables of which the initial values will be used by the first simulation \n\tint nb_agents <- 10;\n\tfloat agent_speed <- 1.0;\n\trgb agent_color <- #green;\n\t\n\t\n\tinit {\n\t\tcreate dummy number: nb_agents;\n\t}\n}\n\n//definition a simple species that just move randomly at a given speed\nspecies dummy skills: [moving]{\n\trgb color <- #green;\n\treflex move {\n\t\tdo wander speed: agent_speed;\n\t}\n\taspect default {\n\t\tdraw circle(2) color: agent_color border: #black;\n\t}\n}\n\nexperiment main type: gui {\n\t//definition of a minimal duration for each cycle. As the model is very simple, it can run too fast to observe the results, so we slow it down.\n\tfloat minimum_cycle_duration <- 0.1;\n\t\n\t//we define a init block to create new simulations\n\tinit {\n\t\t//we create a second simulation (the first simulation is always created by default) with the given parameters\n\t\tcreate simulation with: [nb_agents:: 5, agent_speed:: 3.0, agent_color:: #red];\n\t\t\n\t}\n\toutput {\n\t\tdisplay map {\n\t\t\t//we use an overlay to display the speed of the agents in the simulation\n\t\t\toverlay \"Overlay\" position: { 5, 5 } size: { 180 #px, 30 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n               draw \"agent_speed: \" + agent_speed color: # white font: font(\"SansSerif\", 20, #bold) at: { 10°px, 20°px };\n            }\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Multi-simulation-Multi-simulation.md"},"Multicriteria-decision-Multicriteria.md":{"title":" Multicriteria","content":"[//]: # (keyword|operator_^)\n[//]: # (keyword|operator_weighted_means_DM)\n[//]: # (keyword|operator_promethee_DM)\n[//]: # (keyword|operator_electre_DM)\n[//]: # (keyword|operator_evidence_theory_DM)\n[//]: # (keyword|operator_copy)\n[//]: # (keyword|concept_multi_criteria)\n# Multicriteria\n\n\n_Author : Patrick Taillandier_\n\nThis model show how to use different methods of multicriteria analysis to look for the best house. Four methods are used : the Weighted_Means method , the Electre method , the Promethee method  an the Evidence Theory method. Each method uses different criteria with different weights according to the methods used. \n\n\nCode of the model : \n\n```\n\nmodel multicriteria\n\nglobal {\n\tfloat weight_standing <- 1.0;\n\tfloat weight_price <- 1.0;\n\tfloat weight_distance <- 1.0;\n\tfloat weight_area <- 1.0;\n\tfloat p_standing <- 0.5;\n\tfloat p_price <- 0.5;\n\tfloat p_distance <- 0.5;\n\tfloat p_area <- 0.5;\n\tfloat q_standing <- 0.0;\n\tfloat q_price <- 0.0;\n\tfloat q_distance <- 0.0;\n\tfloat q_area <- 0.0;\n\tfloat v_standing <- 1.0;\n\tfloat v_price <- 1.0;\n\tfloat v_distance <- 1.0;\n\tfloat v_area <- 1.0;\n\tfloat s_standing <- 1.0;\n\tfloat s_price <- 1.0;\n\tfloat s_distance <- 1.0;\n\tfloat s_area <- 1.0;\n\tfloat s1_standing <- 0.0;\n\tfloat s1_price <- 0.0;\n\tfloat s1_distance <- 0.0;\n\tfloat s1_area <- 0.0;\n\tfloat s2_standing <- 1.0;\n\tfloat s2_price <- 1.0;\n\tfloat s2_distance <- 1.0;\n\tfloat s2_area <- 1.0;\n\tfloat v1p_standing <- 0.0;\n\tfloat v1p_price <- 0.0;\n\tfloat v1p_distance <- 0.0;\n\tfloat v1p_area <- 0.0;\n\tfloat v2p_standing <- 1.0;\n\tfloat v2p_price <- 1.0;\n\tfloat v2p_distance <- 1.0;\n\tfloat v2p_area <- 1.0;\n\tfloat v1c_standing <- 0.0;\n\tfloat v1c_price <- 0.0;\n\tfloat v1c_distance <- 0.0;\n\tfloat v1c_area <- 0.0;\n\tfloat v2c_standing <- 0.0;\n\tfloat v2c_price <- 0.0;\n\tfloat v2c_distance <- 0.0;\n\tfloat v2c_area <- 0.0;\n\t\n\t//Lists that will store the different criteria to use for each method linked with their weights\n\tlist criteria_WM <- [[\"name\"::\"standing\", \"weight\" :: weight_standing],[\"name\"::\"price\", \"weight\" :: weight_price],[\"name\"::\"distance\", \"weight\" ::weight_distance],[\"name\"::\"area\", \"weight\" :: weight_area]]; \n\tlist criteria_Electre <- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"v\"::v_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"v\"::v_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"v\"::v_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"v\"::v_area,  \"maximize\" :: true]]; \n\tlist criteria_Promethee <- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"s\"::s_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"s\"::s_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"s\"::s_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"s\"::s_area,  \"maximize\" :: true]];  \n\tlist criteria_ET <- [[\"name\"::\"standing\", \"s1\"::s1_standing, \"s2\"::s2_standing, \"v1p\"::v1p_standing, \"v2p\"::v2p_standing, \"v1c\"::v1c_standing, \"v2c\"::v2c_standing,\"maximize\" :: true],[\"name\"::\"price\", \"s1\"::s1_price, \"s2\"::s2_price, \"v1p\"::v1p_price, \"v2p\"::v2p_price, \"v1c\"::v1c_price, \"v2c\"::v2c_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"s1\"::s1_distance, \"s2\"::s2_distance, \"v1p\"::v1p_distance, \"v2p\"::v2p_distance, \"v1c\"::v1c_distance, \"v2c\"::v2c_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"s1\"::s1_area, \"s2\"::s2_area, \"v1p\"::v1p_area, \"v2p\"::v2p_area, \"v1c\"::v1c_area, \"v2c\"::v2c_area, \"maximize\" :: true]];\n\t\n\t\n\tinit {\n\t\tcreate people;\n\t\tgeometry free_space <- copy(shape);\n\t\tfree_space <- free_space - 10;\n\t\tcreate house number: 15 {\n\t\t\tlocation <- any_location_in (free_space);\n\t\t\tfree_space <- free_space - (shape + 10);\n\t\t}\n\t}\n\t\n\treflex reset_selected {\n\t\task house {\n\t\t\tis_selected_WM <- false;\n\t\t\tis_selected_electre <- false;\n\t\t\tis_selected_promethee <- false;\n\t\t\tis_selected_ET <- false;\n\t\t}\n\t\tcriteria_WM <- [[\"name\"::\"standing\", \"weight\" :: weight_standing],[\"name\"::\"price\", \"weight\" :: weight_price],[\"name\"::\"distance\", \"weight\" ::weight_distance],[\"name\"::\"area\", \"weight\" :: weight_area]]; \n\t\tcriteria_Electre <- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"v\"::v_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"v\"::v_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"v\"::v_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"v\"::v_area,  \"maximize\" :: true]]; \n\t\tcriteria_Promethee <- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"s\"::s_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"s\"::s_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"s\"::s_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"s\"::s_area,  \"maximize\" :: true]]; \n\t\tcriteria_ET <- [[\"name\"::\"standing\", \"s1\"::s1_standing, \"s2\"::s2_standing, \"v1p\"::v1p_standing, \"v2p\"::v2p_standing, \"v1c\"::v1c_standing, \"v2c\"::v2c_standing,\"maximize\" :: true],[\"name\"::\"price\", \"s1\"::s1_price, \"s2\"::s2_price, \"v1p\"::v1p_price, \"v2p\"::v2p_price, \"v1c\"::v1c_price, \"v2c\"::v2c_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"s1\"::s1_distance, \"s2\"::s2_distance, \"v1p\"::v1p_distance, \"v2p\"::v2p_distance, \"v1c\"::v1c_distance, \"v2c\"::v2c_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"s1\"::s1_area, \"s2\"::s2_area, \"v1p\"::v1p_area, \"v2p\"::v2p_area, \"v1c\"::v1c_area, \"v2c\"::v2c_area, \"maximize\" :: true]];\n\t}\n\t\n}\n\t\n\nspecies people  {\n\taspect default {\n\t\tdraw sphere(2) color: °red;\n\t}\n\t\n\treflex choose_house_weighted_means {\n\t\tlist<list> cands <- houses_eval();\n\t\tint choice <- weighted_means_DM(cands, criteria_WM);\n\t\tif (choice >= 0) {\n\t\t\task (house at choice) {is_selected_WM <- true;}\n\t\t}\n\t}\n\t\n\treflex choose_house_promethee {\n\t\tlist<list> cands <- houses_eval();\n\t\tint choice <- promethee_DM(cands, criteria_Promethee);\n\t\tif (choice >= 0) {\n\t\t\task (house at choice) {is_selected_promethee <- true;}\n\t\t}\n\t}\n\treflex choose_house_electre {\n\t\tlist<list> cands <- houses_eval();\n\t\tint choice <- electre_DM(cands, criteria_Electre, 0.7);\n\t\tif (choice >= 0) {\n\t\t\task (house at choice) {is_selected_electre <- true;}\n\t\t}\n\t}\n\treflex choose_house_evidence_theory {\n\t\tlist<list> cands <- houses_eval();\n\t\tint choice <- evidence_theory_DM(cands, criteria_ET, true);\n\t\tif (choice >= 0) {\n\t\t\task (house at choice) {is_selected_ET <- true;}\n\t\t}\n\t}\n\t\n\tlist<list> houses_eval {\n\t\tlist<list> candidates;\n\t\tloop bat over: house {\n\t\t\tlist<float> cand;\n\t\t\tadd bat.standing / 5 to: cand;\n\t\t\tadd ((500000 - bat.price) / 500000) to: cand;\n\t\t\tadd ((100 - (self distance_to bat)) / 100) to: cand;\n\t\t\tadd (bat.shape.area / 15^2) to: cand;\n\t\t\tadd cand to: candidates;\n\t\t}\n\t\treturn candidates;\n\t}\n\t\n}\n\nspecies house {\n\tbool is_selected_WM <- false;\n\tbool is_selected_electre <- false;\n\tbool is_selected_promethee <- false;\n\tbool is_selected_ET <- false;\n\tgeometry shape <- square(5 + rnd(10));\n\tfloat price <- 100000.0 + rnd (400000);\n\tint standing <- rnd(5);\n\trgb color <- rgb(255 * (1 - standing/5.0),255 * (1 - standing/5.0),255);\n\tfloat height <- price / 50000;\n\taspect weighted_means {\n\t\tif (is_selected_WM) {\n\t\t\tdraw shape + 2.0 color: °red;\n\t\t}\n\t\tdraw shape color: color depth: height;\n\t}\n\taspect electre_means {\n\t\tif (is_selected_electre) {\n\t\t\tdraw shape + 2.0 color: °red;\n\t\t}\n\t\tdraw shape color: color depth: height;\n\t}\n\taspect promethee_means {\n\t\tif (is_selected_promethee) {\n\t\t\tdraw shape + 2.0 color: °red;\n\t\t}\n\t\tdraw shape color: color depth: height;\n\t}\n\taspect evidence_theory_means {\n\t\tif (is_selected_ET) {\n\t\t\tdraw shape + 2.0 color: °red;\n\t\t}\n\t\tdraw shape color: color depth: height;\n\t}\n}\n\n\nexperiment multicriteria type: gui {\n\tparameter \"weight of the standing criterion\" var:weight_standing category: \"Weight\";\n\tparameter \"weight of the price criterion\" var:weight_price category: \"Weight\";\n\tparameter \"weight of the distance criterion\" var:weight_distance category: \"Weight\";\n\tparameter \"weight of the area criterion\" var:weight_area category: \"Weight\";\n\tparameter \"preference threshold of the standing criterion\" var:p_standing category: \"Preference\";\n\tparameter \"preference threshold of the price criterion\" var:p_price category: \"Preference\";\n\tparameter \"preference threshold of the distance criterion\" var:p_distance category: \"Preference\";\n\tparameter \"preference threshold of the area criterion\" var:p_area category: \"Preference\";\n\tparameter \"indifference threshold of the standing criterion\" var:q_standing category: \"Indifference\";\n\tparameter \"indifference threshold of the price criterion\" var:q_price category: \"Indifference\";\n\tparameter \"indifference threshold of the distance criterion\" var:q_distance category: \"Indifference\";\n\tparameter \"indifference threshold of the area criterion\" var:q_area category: \"Indifference\";\n\tparameter \"veto threshold of the standing criterion\" var:v_standing category: \"Veto\";\n\tparameter \"veto threshold of the price criterion\" var:v_price category: \"Veto\";\n\tparameter \"veto threshold of the distance criterion\" var:v_distance category: \"Veto\";\n\tparameter \"veto threshold of the area criterion\" var:v_area category: \"Veto\";\n\tparameter \"max prefence value of the standing criterion\" var:v_standing category: \"Max preference value\";\n\tparameter \"max prefence value of the price criterion\" var:v_price category: \"Max preference value\";\n\tparameter \"max prefence value of the distance criterion\" var:v_distance category: \"Max preference value\";\n\tparameter \"max prefence value of the area criterion\" var:v_area category: \"Max preference value\";\n\tparameter \"min criterion threshold of the standing criterion\" var:s1_standing category: \"Evidence Theory\";\n\tparameter \"min criterion threshold of the price criterion\" var:s1_price category: \"Evidence Theory\";\n\tparameter \"min criterion threshold of the distance criterion\" var:s1_distance category: \"Evidence Theory\";\n\tparameter \"min criterion threshold of the area criterion\" var:s1_area category: \"Evidence Theory\";\n\tparameter \"max criterion threshold of the standing criterion\" var:s2_standing category: \"Evidence Theory\";\n\tparameter \"max criterion threshold of the price criterion\" var:s2_price category: \"Evidence Theory\";\n\tparameter \"max criterion threshold of the distance criterion\" var:s2_distance category: \"Evidence Theory\";\n\tparameter \"max criterion threshold of the area criterion\" var:s2_area category:\"Evidence Theory\";\n\tparameter \"min preference of the standing criterion\" var:v1p_standing category: \"Evidence Theory\";\n\tparameter \"min preference of the price criterion\" var:v1p_price category: \"Evidence Theory\";\n\tparameter \"min preference of the distance criterion\" var:v1p_distance category: \"Evidence Theory\";\n\tparameter \"min preference of the area criterion\" var:v1p_area category: \"Evidence Theory\";\n\tparameter \"max preference of the standing criterion\" var:v2p_standing category: \"Evidence Theory\";\n\tparameter \"max preference of the price criterion\" var:v2p_price category: \"Evidence Theory\";\n\tparameter \"max preference of the distance criterion\" var:v2p_distance category: \"Evidence Theory\";\n\tparameter \"max preference of the area criterion\" var:v2p_area category: \"Evidence Theory\";\n\tparameter \"min rejection of the standing criterion\" var:v1c_standing category: \"Evidence Theory\";\n\tparameter \"min rejection of the price criterion\" var:v1c_price category: \"Evidence Theory\";\n\tparameter \"min rejection of the distance criterion\" var:v1c_distance category: \"Evidence Theory\";\n\tparameter \"min rejection of the area criterion\" var:v1c_area category: \"Evidence Theory\";\n\tparameter \"max rejection of the standing criterion\" var:v2c_standing category: \"Evidence Theory\";\n\tparameter \"max rejection of the price criterion\" var:v2c_price category: \"Evidence Theory\";\n\tparameter \"max rejection of the distance criterion\" var:v2c_distance category: \"Evidence Theory\";\n\tparameter \"max rejection of the area criterion\" var:v2c_area category: \"Evidence Theory\";\n\toutput {\n\t\tdisplay Map_Weighted_Means type: opengl{\n\t\t\tspecies house aspect: weighted_means;\n\t\t\tspecies people;\n\t\t}\n\t\tdisplay Map_Electre type: opengl{\n\t\t\tspecies house aspect: electre_means;\n\t\t\tspecies people;\n\t\t}\n\t\tdisplay Map_Promethee type: opengl{\n\t\t\tspecies house aspect: promethee_means;\n\t\t\tspecies people;\n\t\t}\n\t\tdisplay Map_Evidence_theory type: opengl{\n\t\t\tspecies house aspect: evidence_theory_means;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Multicriteria-decision-Multicriteria.md"},"Overlay-Overlay.md":{"title":" Overlay","content":"[//]: # (keyword|operator_font)\n[//]: # (keyword|statement_overlay)\n[//]: # (keyword|constant_#pixels)\n[//]: # (keyword|constant_#bold)\n[//]: # (keyword|concept_overlay)\n[//]: # (keyword|concept_display)\n[//]: # (keyword|concept_graphic)\n# Overlay\n\n\n_Author : Alexis Drogoul and Patrick Taillandier_\n\nModel to show how to use overlay layers in a display\n\n\nCode of the model : \n\n```\n\nmodel Overlay\n\nglobal\n{\n\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n//define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t//each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map \n        {\n        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay \"Overlay\" position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"SansSerif\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            //then we display the grid\n\t\t\tgrid cell lines: #black;\n        }\n\n    }\n}\n```\n","url":"wiki/Overlay-Overlay.md"},"Save-statement-Save_to_asc.md":{"title":" Save to Ascii","content":"[//]: # (keyword|statement_save)\n[//]: # (keyword|concept_save_file)\n[//]: # (keyword|concept_asc)\n# Save to Ascii\n\n\n_Author : Patrick Taillandier_\n\nThis is a model that shows how to save a grid inside a ASCII File to reuse it later or to keep it.\n\n\nCode of the model : \n\n```\n\nmodel SavetoAsc\n\nglobal {\n\tinit {\t\n\t\t//save grid \"grid_value\" attribute into the asc file.\n\t\tsave cell to:\"../results/grid.asc\" type:\"asc\";\n\t}\n}\n\n//Grid that will be saved in the ASC File\ngrid cell width: 50 height: 50 {\n\tfloat grid_value <- self distance_to world.location;\n\trgb color <- rgb(255 * (1 - grid_value / 50), 0,0);\n}\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tgrid cell lines: #black;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Save-statement-Save_to_asc.md"},"Save-statement-Save_to_CSV.md":{"title":" Save to CSV","content":"[//]: # (keyword|statement_save)\n[//]: # (keyword|concept_save_file)\n[//]: # (keyword|concept_csv)\n# Save to CSV\n\n\n_Author : Patrick Taillandier_\n\nThis is a model that shows how to save agents inside a CSV File to reuse it later or to keep it.\n\n\nCode of the model : \n\n```\nmodel SavetoCSV\n\nglobal {\n\tinit {\n\t\t//Create all the agents\n\t\tcreate bug number: 50;\n\t}\n\t//Save the agents bug when the cycle is equals to 100\n\treflex save_bug_attribute when: cycle = 100{\n\t\task bug {\n\t\t\t// save the values of the variables name, speed and size to the csv file\n\t\t\tsave [name,speed, size] to: \"../results/bug.csv\" type:\"csv\";\n\t\t}\n\t\t//Pause the model as the data are saved\n\t\tdo pause;\n\t}\n}\n\n//Species that will be saved\nspecies bug skills:[moving]{\n\tfloat size <- 1.0 + rnd(4) min: 1.0 max: 5.0;\n\tfloat speed <- 1.0 + rnd(4.0);\n\t\n\treflex update_size {\n\t\tint nb_neigh <- length(bug at_distance 20.0);\n\t\tif (nb_neigh > 5) {\n\t\t\tsize <- size + 1;\n\t\t} else {\n\t\t\tsize <- size - 1;\n\t\t}\n\t} \t\n\treflex move {\n\t\tdo wander;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(size) color: #red;\n\t}\n}\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies bug;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Save-statement-Save_to_CSV.md"},"Save-statement-Save_to_shapefile.md":{"title":" Save to Shapefile","content":"[//]: # (keyword|operator_copy)\n[//]: # (keyword|statement_save)\n[//]: # (keyword|concept_save_file)\n[//]: # (keyword|concept_shapefile)\n# Save to Shapefile\n\n\n_Author : Patrick Taillandier_\n\nThis is a model that shows how to save agents inside a Shapefile to reuse it later or to keep it.\n\n\nCode of the model : \n\n```\n\nmodel Savetoshapefile\n\nglobal {\n\tinit {\n\t\tgeometry free_space <- copy(shape);\n\t\t\n\t\t//creation of the building agents that will be saved\n\t\tcreate building number: 50 {\n\t\t\tshape <- square(5.0);\n\t\t\tlocation <- any_location_in (free_space - 5.0);\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t//save building geometry into the shapefile: add the attribute TYPE which value is set by the type variable of the building agent\n\t\tsave building to:\"../results/buildings.shp\" type:\"shp\" with:[type::\"TYPE\"];\n\t}\n}\n\n//species that represent the building agents that will be saved\nspecies building {\n\tstring type <- flip(0.8) ? \"residential\" : \"industrial\";\n\taspect default {\n\t\tdraw shape color: type = \"residential\" ? #gray : #pink;\n\t}\n}\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies building;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Save-statement-Save_to_shapefile.md"},"Save-statement-Save_to_text.md":{"title":" Save to Text","content":"[//]: # (keyword|statement_save)\n[//]: # (keyword|concept_save_file)\n[//]: # (keyword|concept_txt)\n# Save to Text\n\n\n_Author : Patrick Taillandier_\n\nThis is a model that shows how to save agents inside a text file to reuse it later or to keep it.\n\n\nCode of the model : \n\n```\n\n\nmodel SavetoText\n\nglobal {\n\tinit {\n\t\t//Create the agents that will be saved in the text file.\n\t\tcreate bug number: 50;\n\t}\n\t\n\t//Reflex saving the agents every 10 steps. \n\treflex save_data when: every(10){\n\t\t//save the following text into the given text file. Note that each time the save statement is used, a new line is added at the end of the file.\n\t\tsave (\"cycle:\" + cycle + \", mean size: \" + mean(bug collect each.size)) to: \"../results/data.txt\";\n\t}\n\t//Reflex that will pause the simulation when the number of cycles reach 100.\n\treflex end_simulation when: cycle = 100 {\n\t\tdo pause;\n\t}\n}\n\n//Species bug that will be saved using the skill moving\nspecies bug skills:[moving]{\n\tfloat size <- 1.0 + rnd(4) min: 1.0 max: 5.0;\n\tfloat speed <- 1.0 + rnd(4.0);\n\t\n\t//At each step, the size of the agent is update according to the number of bugs close to the agent\n\treflex update_size {\n\t\tint nb_neigh <- length(bug at_distance 20.0);\n\t\tif (nb_neigh > 5) {\n\t\t\tsize <- size + 1;\n\t\t} else {\n\t\t\tsize <- size - 1;\n\t\t}\n\t} \t\n\t\n\t//Make the agent move randomly\n\treflex move {\n\t\tdo wander;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(size) color: #red;\n\t}\n}\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies bug;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Save-statement-Save_to_text.md"},"Spatial-Operators-Geometry-discretization.md":{"title":" Discretization of Topology","content":"[//]: # (keyword|operator_to_squares)\n[//]: # (keyword|operator_to_rectangles)\n[//]: # (keyword|operator_triangulate)\n[//]: # (keyword|operator_points_on)\n[//]: # (keyword|operator_voronoi)\n[//]: # (keyword|concept_topology)\n[//]: # (keyword|concept_spatial_computation)\n[//]: # (keyword|concept_spatial_transformation)\n# Discretization of Topology\n\n\n_Author : Patrick Taillandier_\n\nA model which shows how to use the different convert topologies operators : to_square, to_rectangle, points_on, triangulate, voronoi.\n\n\nCode of the model : \n\n```\n\nmodel discretization\n\nglobal \n{\n\t//Geometry that will be used for each display : a circle\n\tgeometry init_geom <- circle (35);\n}\n\nexperiment main type: gui {\n\toutput {\n\t\t//Display that will show a circle converted in squares\n\t\tdisplay decretization_squares {\n\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into squares of 5.0 \n\t\t\t\tloop g over: to_squares(init_geom, 5.0) {\n\t\t\t\t\tdraw g color: °red;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in squares overlapping the shape\n\t\tdisplay squares_overlapping {\n\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\n\t\t\tgraphics \"squares\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into rectangles of 5.0 and keep the squares going out of the borders of the circle but still overlapping it\n\t\t\t\tloop g over: to_squares(init_geom,5.0, true) {\n\t\t\t\t\tdraw g color: °red;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in squares inside the shape\n\t\tdisplay squares_inside {\n\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\n\t\t\tgraphics \"squares\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into squares of 5.0 and remove the squares going out of the borders of the circle\n\t\t\t\tloop g over: to_squares(init_geom, 5.0, false) {\n\t\t\t\t\tdraw g color: °red;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in rectangles with a size of 10.0 and 5.0\n\t\tdisplay decretization_rectangles {\n\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\tloop g over: to_rectangles(init_geom, {10.0,5.0}) {\n\t\t\t\t\tdraw g color: °red;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in rectangles forming a grid of 15 cols and 20 rows\n\t\tdisplay decretization_rectangles_grid {\n\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\tloop g over: to_rectangles(init_geom, 15,20) {\n\t\t\t\t\tdraw g color: °red;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in rectangles overlapping the shape\n\t\tdisplay rectangles_overlapping {\n\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\n\t\t\tgraphics \"rectangles\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into rectangles of 5.0 and keep the rectangles going out of the borders of the circle but still overlapping it\n\t\t\t\tloop g over:  to_rectangles(init_geom, {10.0,5.0}, true){\n\t\t\t\t\tdraw g color: °red;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t//Display that will show a circle converted in rectangles inside the shape\n\t\tdisplay rectangles_inside {\n\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\n\t\t\tgraphics \"rectangles\" transparency: 0.5{\n\t\t\t\t//Convert the initial circle into rectangles of 5.0 and remove the rectanges going out of the borders of the circle\n\t\t\t\tloop g over: to_rectangles(init_geom, {10.0,5.0}, false) {\n\t\t\t\t\tdraw g color: °red;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t\n\t\t//Display that will show a circle triangulated\n\t\tdisplay triangles {\n\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\n\t\t\tgraphics \"triangles\" transparency: 0.5{\n\t\t\t\tloop g over: triangulate(init_geom) {\n\t\t\t\t\tdraw g color: °red;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\t\n\t\t//Display that will show a circle with points on its perimeter every 10.0\n\t\tdisplay points_on_contours {\n\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\tloop g over: points_on(init_geom,10.0) {\n\t\t\t\t\tdraw circle(2) at: g color: °red;\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t\n\t\tdisplay voronoi {\n\t\t\t//Creates a voronoi diagram from the points given and display them\n\t\t\tgraphics \"geoms\" transparency: 0.5{\n\t\t\t\tloop g over: voronoi([{10,10},{10,10},{80,80},{80,10},{10,80}, {40,40}]) {\n\t\t\t\t\tdraw g color: °red;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraphics \"points\" {\n\t\t\t\tloop pt over: [{10,10},{10,10},{80,80},{80,10},{10,80}, {40,40}] {\n\t\t\t\t\tdraw circle(2) at: pt color: °black;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n}\n```\n","url":"wiki/Spatial-Operators-Geometry-discretization.md"},"Spatial-Operators-Spatial-Operators-(Examples).md":{"title":" Spatial Operators","content":"[//]: # (keyword|operator_scaled_by)\n[//]: # (keyword|operator_rotated_by)\n[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_inter)\n[//]: # (keyword|operator_convex_hull)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_topology)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_spatial_computation)\n[//]: # (keyword|concept_spatial_transformation)\n# Spatial Operators\n\n\n_Author : Patrick Taillandier_\n\nA model which shows how to use spatial operators like rotated_by, scaled_by and convex_hull\n\n\nCode of the model : \n\n```\nmodel example_spatial_operators\n\nglobal {\n\t// Parameters for the shapefiles\n\tfile shape_file_name_init  <- file('../gis/init.shp') ;\n\tfile shape_file_name_background  <- file('../gis/background.shp');\n\t\n\t//Parameters for the agents\t\t\n\tfloat dying_size min: 100.0  <-10000.0 ; \n\tfloat crossover_size min: 100.0  <- 1000.0;\n\tfloat minimum_size min: 100.0 <- 500.0; \n\tint time_wthout_co min: 1 <- 7;\n\tfloat speed min: 1.0  <- 10.0; \n\tfloat crossover_rate min: 0.1  <- 0.95; \n\tfloat scaling_factor min: 1.001 <- 1.05;\n\tfloat angle_rotation_max min: 0.0 <- 45.0;\n\tint nb_partners_max min: 1  <- 1;\n\tint max_side_size min: 1 <- 5;  \n\tint background_size_side min: 20 max: 100 <- 80 ;\n\t\n\t// Environment\n\tgeometry shape <- envelope(shape_file_name_background);\n\t\n\n\treflex stop when: empty ( object ) {\n\t\tdo halt;\n  \t} \n\n}\n\nspecies object topology: topology(shape_file_name_init) {\n\trgb color <- rgb ( [ rnd ( 255 ) , rnd ( 255 ) , rnd ( 255 ) ]);\n\tpoint location_new_Ag <- nil;\n\trgb color_new_Ag <- nil;\n\tint nb_last_rep <- 0;\n\t\t\n\t//Reflex making the shape of the agent growing and rotate it randomly\n\treflex evolve {\n\t\tnb_last_rep <- nb_last_rep + 1;\n\t\tshape <- shape scaled_by scaling_factor;\n\t\tshape <- shape rotated_by ((rnd ( 100 * angle_rotation_max))/ 100.0);\t\t\n\t}\n\t\n\t//Make the agent move, kill it if is area is greater than the dying size or intersecting contours of the world\n\treflex move {\n\t\tlocation <- location + { speed * ( 1 - rnd ( 2 ) ) , speed * ( 1 - rnd ( 2 ) ) };\n\t\tif ( (shape.area > dying_size) or (shape intersects world.shape.contour)) {\n\t\t\tdo die; \n\t\t}\n\t\t\t\n\t}\n\t\n\t\n\t//Reflex to change the shape of the agent intersects an other agent and create a convex hull of the shape of the new agent resulting in the intersection of the shapes of the agent and an other one\n\treflex crossover when: ( shape.area > crossover_size ) and ( nb_last_rep > time_wthout_co ) { \n\t\tint nb_partners  <- 0;\n\t\tlist<object> list_people <- shuffle ( object );\n\t\tloop p over: list_people {\n\t\t\tif ( p != self ) and ( nb_partners <= nb_partners_max ) and (rnd ( 100 ) < ( crossover_rate * 100 ) ) and ( (p.shape).area > crossover_size ) and ( p . nb_last_rep > time_wthout_co ) and (shape intersects p.shape) {\n\t\t\t\tnb_partners <- nb_partners + 1;\n\t\t\t\tgeometry new_ag <- (shape inter p.shape);\n\t\t\t\tif ( new_ag != nil ) and ( new_ag.area > minimum_size ) {\n\t\t\t\t\tnb_last_rep <- 0;\n\t\t\t\t\task p {\n\t\t\t\t\t\tnb_last_rep <- 0;\n\t\t\t\t\t}\n\t\t\t\t\tcreate object  {\n\t\t\t\t\t\tcolor <- (myself.color + p.color) / 2;\n\t\t\t\t\t\tshape <-  convex_hull(new_ag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\taspect geometry {\n\t\tdraw shape color: color;\n\t}\n}\n\n\n\nexperiment example_spatial_operators type: gui {\n\tparameter 'Path of shapefile to load for the initial agent:' var: shape_file_name_init  category: 'GIS specific' ;\n\tparameter 'Path of shapefile to load for the background:' var: shape_file_name_background category: 'GIS specific';\n\tparameter 'Size (area) from which an agent dies:' var: dying_size min: 100.0  category: 'Population'; \n\tparameter 'Min size (area) for crossover:' var:crossover_size category: 'Population';\n\tparameter 'Minimum size (area) of a agent produced by a crossover:' var:minimum_size category: 'Population';\n\tparameter 'Number of steps without crossing-over for an agent:' var:time_wthout_co category: 'Population';\n\tparameter 'Agent deplacement speed:' var:speed category: 'Population' ; \n\tparameter 'Rate of crossover' var:crossover_rate category: 'Population'; \n\tparameter 'Scaling factor for agent geometry (at each step):' var:scaling_factor category: 'Population';\n\tparameter 'Max rotation angle for agent geometry (at each step):' var:angle_rotation_max category:'Population';\n\tparameter 'Max number of possible partners for crossing-overs (per step)' var:nb_partners_max category: 'Population' ;\n\tparameter 'Size max of the initiale side of an agent:' var:max_side_size category: 'Population'; \n\tparameter 'Size background side:' var: background_size_side category: 'Population' ;\n\n\toutput {\n\t\tdisplay space_display {\n\t\t\tgraphics \"background\" {\n\t\t\t\tdraw world.shape color: rgb ([ 255 , 240 , 240 ]);\n\t\t\t}\n\t\t\tspecies object aspect: geometry;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Spatial-Operators-Spatial-Operators-(Examples).md"},"Spatial-Operators-spatialinterpolation.md":{"title":" Spatial Interpolation","content":"[//]: # (keyword|operator_^)\n[//]: # (keyword|operator_IDW)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|concept_topology)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_spatial_computation)\n# Spatial Interpolation\n\n\n_Author : Patrick Taillandier_\n\nA model which shows how to use spatial interpolation\n\n\nCode of the model : \n\n```\n\nmodel spatialinterpolation\n\nglobal {\n\tmap<point, float> pts;\n\tfloat max_val; \n\tfloat min_val ; \n\t\n\t//power parameter\n\tint power <- 2;\n\t\n\t//cell properties\n\tint nb_rows <- 50;\n\tint nb_columns <- 50;\n\t\n\tinit {\n\t\t//creation of random point for demo puporse\n\t\tloop times: 50 {\n\t\t\tpoint pt <- any_location_in(world);\n\t\t\tpts[pt] <-pt.x ^2 + pt.y ^2;\n\t\t}\n\t\t\n\t\t//computation of the min and max values of the points (just use to define the color of the cells).\n\t\tmax_val <- max(pts.values);  \n\t\tmin_val <- min(pts.values); \n\t\t\n\t\t//computation of the value for each cell\n\t\tmap<cell_shape, float> results_shape <- map<cell_shape, float>(IDW(cell_shape, pts, power));\n\t\t\n\t\t//setting of the value and color of each cell\n\t\task cell_shape {\n\t\t\tval <- results_shape[self];\n\t\t\tfloat val_col <- 255 * (val - min_val) / (max_val - min_val);\n\t\t\tcolor <- rgb(val_col,0,0);\n\t\t}\n\t\t\n\t\t//same computation, but in this case, we consider only the centroid (location) of the cell for the computation of the distance\n\t\tmap<point, float> results_location <- map<point, float>(IDW(cell_location collect each.location, pts, power));\n\t\t\t\n\t\task cell_location {\n\t\t\tval <- results_location[self.location];\n\t\t\tfloat val_col <- 255 * (val - min_val) / (max_val - min_val);\n\t\t\tcolor <- rgb(val_col,0,0);\n\t\t}\n\t}\n}\n\n//cells where the distance is based on the shape of the cell (min distance between the rectangle and the points)\ngrid cell_shape width: nb_columns height: nb_rows {\n\tfloat val;\n}\n\n//cells where the distance is based on the centroid of the cell (distance between the centroid and the points)\ngrid cell_location width: nb_columns height: nb_rows {\n\tfloat val;\n}\n\n\nexperiment spatialinterpolation type: gui {\n\tparameter \"nb of columns\" var: nb_columns;\n\tparameter \"nb of rows\" var: nb_rows;\n\tparameter \"power parameter\" var: power;\n\toutput {\n\t\tdisplay map_shape {\n\t\t\tgrid cell_shape;\n\t\t\tgraphics \"points\" {\n\t\t\t\tloop pt over: pts.keys {\n\t\t\t\t\tfloat val <- pts[pt];\n\t\t\t\t\tfloat val_col <- 255 * (val - min_val) / (max_val - min_val);\n\t\t\t\t\tdraw circle(1) at: pt color: rgb(val_col,0,0) border: #white;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplay map_location {\n\t\t\tgrid cell_location;\n\t\t\tgraphics \"points\" {\n\t\t\t\tloop pt over: pts.keys {\n\t\t\t\t\tfloat val <- pts[pt];\n\t\t\t\t\tfloat val_col <- 255 * (val - min_val) / (max_val - min_val);\n\t\t\t\t\tdraw circle(1) at: pt color: rgb(val_col,0,0) border: #white;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Spatial-Operators-spatialinterpolation.md"},"Spatial-Operators-Topologies.md":{"title":" Spatial Operators","content":"[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|operator_of_species)\n[//]: # (keyword|operator_agents_at_distance)\n[//]: # (keyword|operator_simple_clustering_by_distance)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_hierarchical_clustering)\n[//]: # (keyword|operator_path_to)\n[//]: # (keyword|constant_#silver)\n[//]: # (keyword|constant_#grey)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_topology)\n[//]: # (keyword|concept_grid)\n# Spatial Operators\n\n\n_Author : Patrick Taillandier_\n\nA model which shows how to use spatial operator, allowing the user to change the parameter operator in the experiment to test the different operators and see the results\n\n\nCode of the model : \n\n```\n\nmodel gridfilter\n\nglobal {\n\tmap<string,map<dummy,rgb>> theDummies;\n\tmap<string,map<cell,rgb>> theCells;\n \tstring parameter_operator <-\"closest_to\" among:[\"closest_to\",\"at_distance\",\"neighbors_at\",\"distance_to\",\"path_to\",\"cluster_distance\",\"cluster_hierarchical\"];\n\tinit {\n\t\t\n\t\t//Create the agents\n\t\tdo create_dummy_agents;\n \n\n\t\t//Different actions to test the operators\n\t\tdo test_agents_at_distance;\n\t\tdo test_distance_to;\n\t\tdo test_neighbors_at;\n\t\tdo test_path_to;\n\t\tdo test_simple_clustering_by_distance;\n\t\tdo test_hierarchical_clustering;\n\t\tdo test_agent_closest_to; \t\n\t}  \n\t\n\taction test_agent_closest_to {\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\tadd [dummy(8)::#yellow] at:\"closest_to\" to:theDummies;\n\t\tadd #red at:dummy closest_to (dummy(8)) to:theDummies[\"closest_to\"];\n\t\t\n\t\t\n\t\tadd [cell(40)::#yellow] at:\"closest_to\" to:theCells;\n\t\tadd #red at:cell closest_to (cell(40)) to:theCells[\"closest_to\"];\n\t}\n\taction test_agents_at_distance {\n\t\t\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\task dummy(8)\n\t\t{\n\t\t\tadd [self::#yellow] at:\"at_distance\" to:theDummies;\n\t\t\tloop a_dummy over: agents_at_distance(30) of_species dummy\n\t\t\t{\t\n\t\t\t\tadd #red at:a_dummy to:theDummies[\"at_distance\"];\n\t\t\t}\n\t\t}\n\t\task cell(40)\n\t\t{\n\t\t\tadd [self::#yellow] at:\"at_distance\" to:theCells;\n\t\t\tloop a_cell over: agents_at_distance(10) of_species cell\n\t\t\t{\t\n\t\t\t\tadd #red at:a_cell to:theCells[\"at_distance\"];\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction test_neighbors_at {\n\t\t\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\t//The operator neighbors_at gives the same results that neighbors_of( an_agent, a_distance )\n\t\t\n\t\tadd [dummy(8)::#yellow] at:\"neighbors_at\" to:theDummies;\n\t\tloop a_dummy over: dummy(8) neighbors_at 30\n\t\t{\t\n\t\t\tadd #red at:a_dummy to:theDummies[\"neighbors_at\"];\n\t\t}\n\t\tadd [cell(40)::#yellow] at:\"neighbors_at\" to:theCells;\n\t\tloop a_cell over: cell(40) neighbors_at 20\n\t\t{\t\n\t\t\tadd #red at:a_cell to:theCells[\"neighbors_at\"];\n\t\t}\n\t}\n\t\n\taction test_distance_to {\n\t\t\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\t//The operator distance_to gives the same results that the operator topology distance_between[an_agent_A,an_agent_B]\n\t\tadd [dummy(8)::#yellow] at:\"distance_to\" to:theDummies;\n\t\tadd #red at:dummy(5) to:theDummies[\"distance_to\"];\n\t\t\n\t\tadd [cell(40)::#yellow] at:\"distance_to\" to:theCells;\n\t\tadd #red at:cell(27) to:theCells[\"distance_to\"];\n\t}\n\t\n\taction test_path_to {\n\t\t\n\t\t//It is possible to use the topology of the world (default), the graph or the grid\n\t\t//The operator distance_to gives the same results that the operator topology path_between[an_agent_A,an_agent_B]\n\t\tadd [dummy(8)::#yellow] at:\"path_to\" to:theDummies;\n\t\tadd #red at:dummy(9) to:theDummies[\"path_to\"];\n\t\t\n\t\tadd [cell(40)::#yellow] at:\"path_to\" to:theCells;\n\t\tadd #red at:cell(28) to:theCells[\"path_to\"];\n\t}\n\taction test_simple_clustering_by_distance \n\t{\n\t\t//Can be used for other topologies by adding using(topology(cell)) for example\n\t\t\n\t\tlist<list<dummy>> clusteredDummies <- list<list<dummy>>(dummy simple_clustering_by_distance 30);\n\t\tloop a_list over: clusteredDummies\n\t\t{\n\t\t\trgb colorList <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t\tloop a_dummy over: a_list\n\t\t\t{\n\t\t\t\tif(length(theDummies[\"cluster_distance\"])=0)\n\t\t\t\t{\n\t\t\t\t\tadd map<dummy,rgb>([a_dummy::colorList]) at:\"cluster_distance\" to:theDummies;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadd colorList at:a_dummy to:theDummies[\"cluster_distance\"];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taction test_hierarchical_clustering {\n\t\t//Can be used for other topologies by adding using(topology(cell)) for example\n\t\tlist<list<dummy>> clusteredDummies <- list<list<dummy>>(dummy hierarchical_clustering 10);\n\t\t\n\t\tloop a_list over: clusteredDummies\n\t\t{\n\t\t\trgb colorList <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t\tloop a_dummy over: a_list\n\t\t\t{\n\t\t\t\tif(length(theDummies[\"cluster_hierarchical\"])=0)\n\t\t\t\t{\n\t\t\t\t\tadd map<dummy,rgb>([a_dummy::colorList]) at:\"cluster_hierarchical\" to:theDummies;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadd colorList at:a_dummy to:theDummies[\"cluster_hierarchical\"];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taction create_dummy_agents {\n\t\tcreate dummy with: [location :: {5,5}];\n\t\tcreate dummy with: [location :: {8,9}];\n\t\tcreate dummy with: [location :: {14,6}];\n\t\tcreate dummy with: [location :: {35,55}];\n\t\tcreate dummy with: [location :: {25,75}];\n\t\tcreate dummy with: [location :: {56,80}];\n\t\tcreate dummy with: [location :: {10,70}];\n\t\tcreate dummy with: [location :: {80,8}];\n\t\tcreate dummy with: [location :: {34,78}];\n\t\tcreate dummy with: [location :: {67,32}];\n\t\tloop i from: 0 to: length(dummy) - 1 {\n\t\t\task dummy[i] {id <- string(i);}\n\t\t}\n\t}\n\t\n}\n\ngrid cell width: 10 height: 10 neighbors: 4{\n\trgb color <- #green;\n}\n\nspecies dummy {\n\tstring id;\n\taspect default {\n\t\tdraw circle(2) color: #yellow;\n\t\tdraw id size: 6 color: #black;\n\t}\n}\nexperiment topology_test type: gui {\n\t/** Insert here the definition of the input and output of the model */\n\tparameter \"Operator\" var: parameter_operator;\n\toutput {\n\t\t\n\t\tdisplay Continuous_Environment  \n\t\t{\n\t\t\tgraphics cell\n\t\t\t{\n\t\t\t\tloop a_key over: theCells[parameter_operator].pairs {\n\t\t\t\t\tdraw a_key.key at:a_key.key.location color: theCells[parameter_operator][a_key.key] ;\n\t\t\t\t}\n\t\t\t\tloop a_cell over: cell-theCells[parameter_operator].keys\n\t\t\t\t{\n\t\t\t\t\tdraw a_cell at:a_cell.location color: #green ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Display a line between the two chosen cell for the distance_to operator\n\t\t\t\tif(parameter_operator=\"distance_to\")\n\t\t\t\t{\n\t\t\t\t\tgeometry aLine <- line([theCells[parameter_operator].keys[0].location,theCells[parameter_operator].keys[1].location]) +1.2;\n\t\t\t\t\tdraw (aLine) color:#silver;\n\t\t\t\t\tdraw string(distance_to (theCells[parameter_operator].keys[0].location,theCells[parameter_operator].keys[1].location)) at:aLine.location size: 6 color: #silver;\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Display a path between the two chosen cell for the path_to operator\n\t\t\t\t\tif(parameter_operator=\"path_to\")\n\t\t\t\t\t{\n\t\t\t\t\t\t\tpath aPath <- theCells[parameter_operator].keys[0] path_to theCells[parameter_operator].keys[1].location;\n\t\t\t\t\t\t\tloop eg over: aPath.edges\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdraw (geometry(eg)+1.2) color:#silver;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraphics dummy\n\t\t\t{\n\t\t\t\tloop a_key over: theDummies[parameter_operator].pairs {\n\t\t\t\t\tdraw circle(2) at:a_key.key.location color: theDummies[parameter_operator][a_key.key] ;\n\t\t\t\t\tdraw a_key.key.id at:a_key.key.location size: 6 color: #black;\t\n\t\t\t\t}\n\t\t\t\tloop a_dummy over: dummy-theDummies[parameter_operator].keys\n\t\t\t\t{\n\t\t\t\t\tdraw circle(2) at:a_dummy.location color: #grey ;\n\t\t\t\t\tdraw a_dummy.id at:a_dummy.location size: 6 color: #black;\t\n\t\t\t\t}\n\t\t\t\t//Display a line between the two chosen dummies for the distance_to operator\n\t\t\t\tif(parameter_operator=\"distance_to\")\n\t\t\t\t{\n\t\t\t\t\tgeometry aLine <- line([theDummies[parameter_operator].keys[0].location,theDummies[parameter_operator].keys[1].location]) +1.2;\n\t\t\t\t\tdraw (aLine) color:#pink;\n\t\t\t\t\tdraw string(distance_to (theDummies[parameter_operator].keys[0].location,theDummies[parameter_operator].keys[1].location)) at:aLine.location size: 6 color: #pink;\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Display a path between the two chosen dummies for the path_to operator\n\t\t\t\t\tif(parameter_operator=\"path_to\")\n\t\t\t\t\t{\n\t\t\t\t\t\t\tpath aPath <- theDummies[parameter_operator].keys[0] path_to theDummies[parameter_operator].keys[1].location;\n\t\t\t\t\t\t\tloop eg over: aPath.edges\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdraw (geometry(eg)+1.2) color:#pink;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Spatial-Operators-Topologies.md"},"Statistics-Regression.md":{"title":" Regression","content":"[//]: # (keyword|operator_as_matrix)\n[//]: # (keyword|operator_build)\n[//]: # (keyword|operator_predict)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|type_regression)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_regression)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_statistic)\n# Regression\n\n\n_Author : Patrick Taillandier_\n\nA model which shows how to use the regression \n\n\nCode of the model : \n\n```\n\nmodel example_regression\n\nglobal {\n\t//Regression variable that will store the function\n\tregression location_fct;\n\tfloat x_val <- 50.0;\n\tfloat y_val <- 50.0;\n\t\n\tfloat val <- -1.0;\n\tinit {\n\t\tloop i from: 0 to: 18{\n\t\t\tif (i != 10) {\n\t\t\t\tcreate dummy with:[location::{i * 5 + 2 - rnd(4), i*5 + 2 - rnd(4), i*5 + 2 - rnd(4)}];\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//Reflex to compute the regression\n\treflex do_regression {\n\t\tmatrix<float> instances <- 0.0 as_matrix {3,length(dummy)};\n\t\tloop i from: 0 to: length(dummy) -1 {\n\t\t\tdummy ag <- dummy[i];\n\t\t\tinstances[1,i] <- ag.location.x;\n\t\t\tinstances[2,i] <- ag.location.y;\n\t\t\tinstances[0,i] <- ag.location.z;\n\t\t}\n\t\t//Compute the function of regression\n\t\tlocation_fct  <- build(instances);\n\t\twrite \"learnt function: \" + location_fct;\n\t\t\n\t\t//Predict the value using the function resulting before\n\t\tval <-  predict(location_fct, [x_val, y_val]);\n\t\twrite \"value : \" + val;\n\t}\n}\n\nspecies dummy {\n\taspect default {\n\t\tdraw sphere(2) color: #blue;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"Point to test, x value\" var: x_val ;\n\tparameter \"Point to test, y value\" var: y_val ;\n\toutput {\n\t\tdisplay map type: opengl {\n\t\t\tspecies dummy;\n\t\t\tgraphics \"new Point \" {\n\t\t\t\tif (location_fct != nil) {\n\t\t\t\t\tdraw sphere(2) color: #red at: {x_val,y_val,val};\n\t\t\t\t\t\n\t\t\t\t\t//Draw the function as a line\n\t\t\t\t\tdraw line([{100,100,predict(location_fct, [100,100])},{-10,-10,predict(location_fct, [-10,-10])}]) color: #black;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Statistics-Regression.md"},"Unit-Test-Basic-Example.md":{"title":" Example of Unit Test","content":"[//]: # (keyword|operator_any)\n[//]: # (keyword|operator_is)\n[//]: # (keyword|statement_setup)\n[//]: # (keyword|statement_test)\n[//]: # (keyword|statement_assert)\n[//]: # (keyword|concept_test)\n# Example of Unit Test\n\n\n_Author : Benoit Gaudou_\n\nA model which shows how to use the unit test to show the possible errors you have to go in the Views, Preferences, Simulation, in \"Errors\" Uncheck \"stop at the first error\", to show all the errors.\n\n\nCode of the model : \n\n```\n\nmodel test_unitTest_framework\n\nglobal {\n\tinit {\n\t\tcreate test_species number: 1;\n\t}\n}\n\n//Species to do the different unit tests\nspecies test_species {\n\tint a <- 0;\n\t\n\t//Setup a to 10 launched before each test\n\tsetup {\n\t\ta <- 10;\n\t\twrite \"SetUp : a = \" + a;\n\t}\n\n\t//First test executing comparison between numbers\n\ttest t1 {\n     \tassert 100 + 100 equals: 200;\n    \t\tassert 100 + 100 equals: 201;\n\t}\n\t\n\t//Second test executing comparison between list and type\n\ttest t2 {\n    \tassert any([1,2,3]) is_not: nil;\n    \tassert any([1,2,3]) is int;\n    \tassert any([1,2,3]) is_not: 5;\n    \tassert any([1,2,3]) is float;\n    \tassert any([1,2,3]) is string;\n\t}\n\n\t//test the incrementation of a\n\ttest incement_a {\n   \t\ta<- a + 10;\n    \t\twrite \"a: \" + a;\n\t}\n\t\n\t//Third test for lists\n\ttest t3 {\n \t\tlist<int> aa;\n\t \tassert aa[0] raises: \"error\";\n\t \tassert aa[0] raises: \"\";\n\t \tassert a raises: \"error\";\n\t}\n}\n\n\nexperiment new type: gui {}\n```\n","url":"wiki/Unit-Test-Basic-Example.md"},"Unit-Test-Two-Species-(Example).md":{"title":" Example of Unit Test","content":"[//]: # (keyword|statement_test)\n[//]: # (keyword|statement_assert)\n[//]: # (keyword|concept_test)\n# Example of Unit Test\n\n\n_Author : Benoit Gaudou_\n\nThe model creates 10 agents at initialization, kills one agent at each step. \n * With the assert we want to ensure that the test_species1 population always contains more than 5 agents. \n * After four steps the population is below 6 so Errors are raisen. You have to go in the Views, Preferences, Simulation, in \"Errors\" Uncheck \"stop at the first error\", to show all the errors.\n\n\nCode of the model : \n\n```\n\n\nmodel test_unitTest_framework\n\nglobal {\n\tinit {\n\t\t//Create agents : one to test the population of test_species1 and the test_species1 agents\n\t\tcreate test_species2 number: 1;\n\t\tcreate test_species1 number: 10;\n\t}\n\t//At each step, one of the agents of test_species1 dies\n\treflex one_should_die {\n\t\task one_of(test_species1){\n\t\t\tdo die;\n\t\t}\n\t}\n}\n\n\nspecies test_species2 {\n\t//The step is computed each step to test if there is still at least 5 agents of test_species1\n\ttest t1 {\n     \tassert (length(test_species1) > 5) equals: true;\n\t}\n}\n\nspecies test_species1 {\n}\n\n\nexperiment new type: gui {}\n```\n","url":"wiki/Unit-Test-Two-Species-(Example).md"},"User-Interaction-Event-Layer.md":{"title":" Event Feature","content":"[//]: # (keyword|statement_event)\n[//]: # (keyword|concept_gui)\n# Event Feature\n\n\n_Author : Arnaud Grignard & Patrick Taillandier_\n\nModel which shows how to use the event layer to trigger an action according to an event occuring in the display. The experiment has two displays : one for the changing color event, one for the changing shape event.\n\n\nCode of the model : \n\n```\nmodel event_layer_model\n\n\nglobal\n{\n\n//number of agents to create\n\tint nbAgent <- 500;\n\tinit\n\t{\n\n\t//creation of the agents\n\t\tcreate cell number: nbAgent\n\t\t{\n\t\t\tcolor <- °green;\n\t\t}\n\n\t}\n\n\t//Action to change the color of the agents, according to the point to know which agents we're in intersection with the point\n\taction change_color (point loc, list<cell> selected_agents)\n\t{\n\n\t//change the color of the agents\n\t\task selected_agents\n\t\t{\n\t\t\tcolor <- color = °green ? °pink : °green;\n\t\t}\n\n\t}\n\n\t//Action to change the shape of the agents, according to the point to know which agents we're in intersection with the point\n\taction change_shape (point loc, list<cell> selected_agents)\n\t{\n\t\task selected_agents\n\t\t{\n\n\t\t//change the bool attribute is_square to change the shape in the display\n\t\t\tis_square <- not (is_square);\n\t\t}\n\n\t}\n\n}\n\n//Species cells moving randomly\nspecies cell skills: [moving]\n{\n\trgb color;\n\tbool is_square <- false;\n\treflex mm\n\t{\n\t\tdo wander amplitude: 30;\n\t}\n\n\taspect default\n\t{\n\t\tdraw is_square ? square(2) : circle(1) color: color;\n\t}\n\n}\n\nexperiment Displays type: gui\n{\n\toutput\n\t{\n\t\tdisplay View_change_color\n\t\t{\n\t\t\tspecies cell aspect: default;\n\n\t\t\t//event, launches the action change_color if the event mouse_down (ie. the user clicks on the layer event) is triggered\n\t\t\tevent [mouse_down] action: change_color;\n\t\t}\n\n\t\tdisplay View_change_shape type: opengl\n\t\t{\n\t\t\tspecies cell;\n\n\t\t\t//event, launches the action change_shape if the event mouse_down (ie. the user clicks on the layer event) is triggered\n\t\t\tevent [mouse_down] action: change_shape;\n\t\t}\n\n\t}\n\n}\n\n```\n","url":"wiki/User-Interaction-Event-Layer.md"},"User-Interaction-Moving-Agents.md":{"title":" MovingAgents","content":"[//]: # (keyword|operator_at_location)\n[//]: # (keyword|operator_union)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_contains)\n[//]: # (keyword|operator_font)\n[//]: # (keyword|statement_event)\n[//]: # (keyword|constant_#burlywood)\n[//]: # (keyword|constant_#olive)\n[//]: # (keyword|constant_#bold)\n[//]: # (keyword|constant_#wheat)\n[//]: # (keyword|constant_#darkseagreen)\n[//]: # (keyword|constant_#firebrick)\n[//]: # (keyword|type_font)\n[//]: # (keyword|concept_gui)\n# MovingAgents\n\n\n_Author : drogoul_\n\nShows how to move agents using two event layers : \nClick to grab an group of agents, click again to drop them. Press the keys \"k\" to kill the agents in the selection, and \"d\" to duplicate them.\n\n\nCode of the model : \n\n```\nmodel MovingAgents\n\nglobal\n{\n\tlist<being> moved_agents ;\n\tgeometry shape <- square(1000);\n\tpoint target;\n\tgeometry zone <- circle(100);\n\tbool can_drop;\n\tinit\n\t{\n\t\tcreate being number: 100;\n\t}\n\n\taction kill (list<agent> selectedAgent, point mousePosition)\n\t{\n\t\task moved_agents\n\t\t{\n\t\t\tdo die;\n\t\t}\n\n\t\tmoved_agents <- list<being>([]);\n\t}\n\n\taction duplicate (list<agent> selectedAgent, point mousePosition)\n\t{\n\t\tgeometry available_space <- (zone at_location target) - (union(moved_agents) + 10);\n\t\tcreate being number: length(moved_agents) with: (location: any_location_in(available_space));\n\t}\n\n\taction click (list<agent> selectedAgent, point mousePosition)\n\t{\n\t\tif (empty(moved_agents))\n\t\t{\n\t\t\tlist<being> selected_agents <- being inside (zone at_location mousePosition);\n\t\t\tmoved_agents <- selected_agents;\n\t\t\task selected_agents\n\t\t\t{\n\t\t\t\tdifference <- mousePosition - location;\n\t\t\t\tcolor <- # olive;\n\t\t\t}\n\n\t\t} else if (can_drop)\n\t\t{\n\t\t\task moved_agents\n\t\t\t{\n\t\t\t\tcolor <- # burlywood;\n\t\t\t}\n\n\t\t\tmoved_agents <- list<being>([]);\n\t\t}\n\n\t}\n\n\taction move (list<agent> selectedAgent, point mousePosition)\n\t{\n\t\tcan_drop <- true;\n\t\ttarget <- mousePosition;\n\t\tlist<being> other_agents <- (being inside (zone at_location mousePosition)) - moved_agents;\n\t\tgeometry occupied <- geometry(other_agents);\n\t\task moved_agents\n\t\t{\n\t\t\tlocation <- mousePosition - difference;\n\t\t\tif (occupied intersects self)\n\t\t\t{\n\t\t\t\tcolor <- # red;\n\t\t\t\tcan_drop <- false;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tcolor <- # olive;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nspecies being skills: [moving]\n{\n\tgeometry shape <- square(10);\n\tpoint difference <- { 0, 0 };\n\trgb color <- # burlywood;\n\treflex r\n\t{\n\t\tif (!(moved_agents contains self))\n\t\t{\n\t\t\tdo wander amplitude: 30;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw shape color: color at: location;\n\t}\n\n}\n\nexperiment \"Click and Move\" type: gui\n{\n\tfont regular <- font(\"Helvetica\", 14, # bold);\n\toutput\n\t{\n\t\tdisplay \"Click and Move [OPENGL]\" type: opengl\n\t\t{\n\t\t\tgraphics \"Empty target\" \n\t\t\t{\n\t\t\t\tif (empty(moved_agents))\n\t\t\t\t{\n\t\t\t\t\tdraw zone at: target empty: false border: false color: #wheat;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tspecies being;\n\t\t\tevent mouse_move action: move;\n\t\t\tevent mouse_up action: click;\n\t\t\tevent 'k' action: kill;\n\t\t\tevent 'c' action: duplicate;\n\t\t\tgraphics \"Full target\" \n\t\t\t{\n\t\t\t\tint size <- length(moved_agents);\n\t\t\t\tif (size > 0)\n\t\t\t\t{\n\t\t\t\t\trgb c1 <- rgb(#darkseagreen, 120);\n\t\t\t\t\trgb c2 <- rgb(#firebrick, 120);\n\t\t\t\t\tdraw zone at: target empty: false border: false color: (can_drop ? c1 : c2);\n\t\t\t\t\tdraw string(size) at: target + { -30, -30 } font: regular color: # white;\n\t\t\t\t\tdraw \"'k': kill\" at: target + { -30, 0 } font: regular color: # white;\n\t\t\t\t\tdraw \"'c': copy\" at: target + { -30, 30 } font: regular color: # white;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\t\n\t\tdisplay \"Click and Move [JAVA2D]\" type: java2D\n\t\t{\n\t\t\tgraphics \"Empty target\" \n\t\t\t{\n\t\t\t\tif (empty(moved_agents))\n\t\t\t\t{\n\t\t\t\t\tdraw zone at: target empty: false border: false color: #wheat;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tspecies being;\n\t\t\tevent mouse_move action: move;\n\t\t\tevent mouse_up action: click;\n\t\t\tevent 'k' action: kill;\n\t\t\tevent 'c' action: duplicate;\n\t\t\tgraphics \"Full target\" \n\t\t\t{\n\t\t\t\tint size <- length(moved_agents);\n\t\t\t\tif (size > 0)\n\t\t\t\t{\n\t\t\t\t\trgb c1 <- rgb(#darkseagreen, 120);\n\t\t\t\t\trgb c2 <- rgb(#firebrick, 120);\n\t\t\t\t\tdraw zone at: target empty: false border: false color: (can_drop ? c1 : c2);\n\t\t\t\t\tdraw string(size) at: target + { -30, -30 } font: regular color: # white;\n\t\t\t\t\tdraw \"'k': kill\" at: target + { -30, 0 } font: regular color: # white;\n\t\t\t\t\tdraw \"'c': copy\" at: target + { -30, 30 } font: regular color: # white;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\n}\n```\n","url":"wiki/User-Interaction-Moving-Agents.md"},"User-Interaction-User-Command.md":{"title":" User Command","content":"[//]: # (keyword|operator_user_input)\n[//]: # (keyword|statement_user_command)\n[//]: # (keyword|concept_gui)\n# User Command\n\n\n_Author : Patrick Taillandier_\n\nModel which shows how to use the user commands in order to create agents in the display. The user has two possibilities : create one agent, or create a number of agents, with the possibility to change their shape and a pink color. The user also has the possibility to change the color and the shapes of the agents.\n\n\nCode of the model : \n\n```\n\nmodel usercommand\n\nglobal {\n\t//Number of agent to initialise\n\tint nbAgent <- 1;\n\t\n\tinit {\n\t\t//Create the agent\n\t\tcreate cell number: nbAgent {\n\t\t\tcolor <-°green;\n\t\t}\n\t}\n\t\n\t//These commands are displayed in the world layer\n\t//User command to create an agent according to the location where the user right click\n\tuser_command \"Create an agent\" {\n   \t\tcreate cell number: nbAgent with: [location::user_location]  {\n   \t\t\tcolor <-°green;\n   \t\t} \n\t}\n\t//User command to create a given number of agents according\n\tuser_command \"Create agents\" {\n\t\t map input_values <- user_input([\"Number\" :: nbAgent, \"shape\" :: \"circle\"]);\n     \t create cell number: int(input_values at \"Number\") with: [color:: °pink, is_square:: string(input_values at \"shape\") = \"square\"];\n\t}\n\t\n}\n\n//Species that will be used\nspecies cell {\n\trgb color;\t\n\tbool is_square <- false; \n\t\n\t//These commands will be displayed in the cells layer, after right clicking on a agent\n\tuser_command \"change color\"action: change_color;\n\tuser_command \"change shape\" action: change_shape;\n\t\n\t//Action to change the color of the agent triggered by change color user command\n\taction change_color \n    {\n     color <- color = °green ? °pink : °green;\n    } \n\t//Action to change the shape of the agent triggered by change shape user command\n    action change_shape\n    {\n       is_square <- not (is_square);\n    }\n\taspect default {\n\t\tdraw is_square ? square(2): circle(1) color: color;\n\t}\n}\n\n\nexperiment Displays type: gui {\n\toutput {\n\t\tdisplay map { \n\t\t\tspecies cell;\n\t\t}\n\t}\n}\n```\n","url":"wiki/User-Interaction-User-Command.md"},"User-Interaction-User-Control-Architecture.md":{"title":" User Command","content":"[//]: # (keyword|architecture_user_only)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|statement_user_panel)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_user_command)\n[//]: # (keyword|statement_user_input)\n[//]: # (keyword|skill_user_only)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_architecture)\n# User Command\n\n\n_Author : Patrick Taillandier_\n\nModel which shows how to use the advanced user control, to create and kill agents. \n\n\nCode of the model : \n\n```\n\n\nmodel user_control\n\nglobal {\n\n\tint nbAgent <- 10;\n\tbool advanced_user_control <- false;\n\tinit {\n\t\tcreate cell number: nbAgent {\n\t\t\tcolor <-°green;\n\t\t}\n\t\tcreate user;\n\t}\n}\n\nspecies cell {\n\trgb color;\t\n\taspect default {\n\t\tdraw circle(1) color: color;\n\t}\n}\n\nspecies user control:user_only {\n   user_panel \"Default\" initial: true {\n      transition to: \"Basic Control\" when: every (10) and !advanced_user_control;\n      transition to: \"Advanced Control\" when: every(10) and advanced_user_control;\n   }\n   \n   user_panel \"Basic Control\" {\n      user_command \"Kill one cell\" {\n         ask (one_of(cell)){\n            do die;\n         }\n      }\n      user_command \"Create one cell\" {\n        create cell { \n\t\t\tcolor <-°green; \n\t\t}\n      } \n      transition to: \"Default\" when: true;                    \n   }\n   user_panel \"Advanced Control\" {\n      user_command \"Kill cells\" color: #red continue: true{\n        user_input \"Number\" returns: number type: int <- 10;\n        ask (number among list(cell)){\n           do die;\n        }\n      }\n      user_command \"Create cells\" color: #green {\n        user_input \"Number\" returns: number type: int <- 10;\n        create cell number: number ;\n      } \n      transition to: \"Default\" when: true;        \n   }\n}\n\n\nexperiment Displays type: gui {\n\tparameter \"advanced user control\" var: advanced_user_control <- false;\n\toutput { \n\t\tdisplay map { \n\t\t\tspecies cell;\n\t\t}\n\t}\n}\n```\n","url":"wiki/User-Interaction-User-Control-Architecture.md"},"Agent-movement.md":{"title":" Agent movement","content":"# Agent movement\n\nThis sub-section is composed of the following models :\n\n* [ Movement of an agent on different paths](references#AgentmovementFollowPath)\n\n* [ Follow Weighted Network](references#AgentmovementFollowWeightedNetwork(Agents))\n\n* [ Directed Graph Model](references#AgentmovementGotoDirectedGraph)\n\n* [ Movement on a Grid of Cells](references#AgentmovementGotoGrid)\n\n* [ Shortest Path Computation on a Graph](references#AgentmovementGotoNetwork)\n\n* [ Movement on a Graph created by Polygons](references#AgentmovementGotoPolygon)\n\n* [ Movement in 3D](references#AgentmovementMoving3D)\n\n","url":"wiki/Agent-movement.md"},"Batch.md":{"title":" Batch","content":"# Batch\n\nThis sub-section is composed of the following models :\n\n* [ Model using Batch mode](references#BatchBatch)\n\n","url":"wiki/Batch.md"},"Charts.md":{"title":" Charts","content":"# Charts\n\nThis sub-section is composed of the following models :\n\n* [Ant Foraging (Charts examples)](references#ChartsAntForaging(Chartsexamples))\n\n","url":"wiki/Charts.md"},"Clustering.md":{"title":" Clustering","content":"# Clustering\n\nThis sub-section is composed of the following models :\n\n* [ Clustering of agents by K Means and DBScan](references#ClusteringClustering)\n\n* [ Clustering of agents by their distance ](references#ClusteringSpatialClustering)\n\n","url":"wiki/Clustering.md"},"Co-model-Usage.md":{"title":" Co-model Usage","content":"# Co-model Usage\n\nThis sub-section is composed of the following models :\n\n* [comodel with mixed behaviors ](references#Co-modelUsagecomodel_mix_behaviors)\n\n* [comodel_with_the_coupling](references#Co-modelUsagecomodel_mutate_population)\n\n* [Simple syntax demonstration of Comodeling ](references#Co-modelUsagecomodel_simple)\n\n* [comodel_with_the_coupling](references#Co-modelUsagecomodel_with_the_coupling)\n\n","url":"wiki/Co-model-Usage.md"},"Color.md":{"title":" Color","content":"# Color\n\nThis sub-section is composed of the following models :\n\n* [Creating color and sort cubes by color](references#ColorBubbleSort3D)\n\n* [Color defined by choosing a Color Brewer](references#ColorColorBrewer)\n\n* [RGB color to XYZ position](references#ColorRGBtoXYZ)\n\n","url":"wiki/Color.md"},"Data-Importation.md":{"title":" Data Importation","content":"# Data Importation\n\nThis sub-section is composed of the following models :\n\n* [3D shapefile loading](references#DataImportation3DshapefileLoading)\n\n* [ESRI ASCII to grid model](references#DataImportationASCfileImport)\n\n* [Contour Lines Import](references#DataImportationContourLines)\n\n* [CSV to Agents Model](references#DataImportationCSVAgents)\n\n* [Convertion of CSV data to Matrix](references#DataImportationCSVFileLoading)\n\n* [DXF to Agents Model](references#DataImportationDXFAgents)\n\n* [GeoTIFF file to Grid of Cells ](references#DataImportationGEOTIFFfileImport)\n\n* [Shapefiles Import and Save](references#DataImportationGISExport)\n\n* [ASCII File to DEM Representation](references#DataImportationGridDEM)\n\n* [OBJ File to Geometry](references#DataImportationOBJfiledrawing)\n\n* [Complex Object Loading](references#DataImportationOBJfileloading)\n\n* [OSM file to Agents](references#DataImportationOSMLoading)\n\n* [Raster File in a Grid of cells](references#DataImportationRasterImageImport)\n\n* [Raster File and Shapefiles Import](references#DataImportationRasterImagesandshapefileImport)\n\n","url":"wiki/Data-Importation.md"},"Database-Usage.md":{"title":" Database Usage","content":"# Database Usage\n\nThis sub-section is composed of the following models :\n\n* [SQLConnection](references#DatabaseUsageConnectionTest)\n\n* [ create_agents_Insert_result_MySQL](references#DatabaseUsageCreateAgentsandInsertinMySQL)\n\n* [ Simple Species MySql](references#DatabaseUsageSimpleSpeciesMySQL)\n\n* [ Simple SQL Command in SQLIte](references#DatabaseUsageSimpleSQLCommandinSQLite)\n\n* [ Agents from Database in MSSQL](references#DatabaseUsageAgentsfromDatabaseinMSSQL)\n\n* [ Agents from Database in MySQL](references#DatabaseUsageAgentsfromDatabaseinMySQL)\n\n* [ Agents from Database in PostGIS](references#DatabaseUsageAgentsfromDatabaseinPostGIS)\n\n* [ Agents from Database in SQLite ](references#DatabaseUsageAgentsfromDatabaseinSQLite)\n\n* [ Agents from Database in SQLite QGIS](references#DatabaseUsageAgentsfromDatabaseinSQLite_QGis)\n\n* [ Agents to Database in MSSQL](references#DatabaseUsageAgentstoDatabaseinMSSQL)\n\n* [ Agents to Database in MySQL](references#DatabaseUsageAgentstoDatabaseinMySQL)\n\n* [ Agents to Database in PostGIS](references#DatabaseUsageAgentstoDatabaseinPostGIS)\n\n* [ Agents to Database in SQLite](references#DatabaseUsageAgentstoDatabaseinSQLite)\n\n* [ CreateBuildingTableMSSQL](references#DatabaseUsageCreateSpatialTableinMSSQL)\n\n* [ CreateBuildingTableMySQL](references#DatabaseUsageCreateSpatialTableinMySQL)\n\n* [ CreateBuildingTablePostGIS](references#DatabaseUsageCreateSpatialTableinPostGIS)\n\n* [ CreateBuildingTableSQLite](references#DatabaseUsageCreateSpatialTableinSQLite)\n\n","url":"wiki/Database-Usage.md"},"Date-and-Time.md":{"title":" Date and Time","content":"# Date and Time\n\nThis sub-section is composed of the following models :\n\n* [Use of the Date variables](references#DateandTimeDatetypeandrealdates)\n\n* [Simple definition of time property in a model](references#DateandTimeSimpleTimedefinition)\n\n","url":"wiki/Date-and-Time.md"},"Driving-Skill.md":{"title":" Driving Skill","content":"# Driving Skill\n\nThis sub-section is composed of the following models :\n\n* [OSM Loading Driving](references#DrivingSkillOSMLoadingDriving)\n\n* [Complex Road Network ](references#DrivingSkillRoadTrafficadvanced)\n\n* [Simple Road Network ](references#DrivingSkillRoadTrafficsimple(City))\n\n* [Easy Road Network ](references#DrivingSkillRoadTrafficsimple(Simpletrack))\n\n","url":"wiki/Driving-Skill.md"},"Graphs.md":{"title":" Graphs","content":"# Graphs\n\nThis sub-section is composed of the following models :\n\n* [3D Graph](references#Graphs3DGraph)\n\n* [Graph Generation](references#GraphsClassicGraphGeneration)\n\n* [Graph Generation using Agents](references#GraphsGraphBuildingFromAgents)\n\n* [Graph from DGS File and Layout Changed](references#GraphsGraphLoadingLayout)\n\n* [Graph Operators](references#GraphsGraphOperators)\n\n* [Hand Made Graph](references#GraphsHandMadeGraph)\n\n* [Multigraph](references#GraphsMultigraph)\n\n* [ShortestPath](references#GraphsShortestpaths)\n\n","url":"wiki/Graphs.md"},"Init-Action.md":{"title":" Init Action","content":"# Init Action\n\nThis sub-section is composed of the following models :\n\n* [InitAction](references#InitActionInitAction)\n\n","url":"wiki/Init-Action.md"},"Map-comparison.md":{"title":" Map comparison","content":"# Map comparison\n\nThis sub-section is composed of the following models :\n\n* [Raster Map Comparison](references#MapcomparisonRasterMapComparison)\n\n* [Vector Map Comparison](references#MapcomparisonVectorMapComparison)\n\n","url":"wiki/Map-comparison.md"},"Multi-Level-Usage.md":{"title":" Multi-Level Usage","content":"# Multi-Level Usage\n\nThis sub-section is composed of the following models :\n\n* [Balls, Groups and Clouds Multilevel Architecture](references#Multi-LevelUsageBalls,GroupsandClouds)\n\n* [Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model](references#Multi-LevelUsageCorridor(HybridvsABM))\n\n* [Corridor Multi-Level Architecture](references#Multi-LevelUsageCorridor)\n\n* [Multi-Level Architecture with Preys and Predators](references#Multi-LevelUsagePredators,PreysandShelters)\n\n","url":"wiki/Multi-Level-Usage.md"},"Multi-simulation.md":{"title":" Multi-simulation","content":"# Multi-simulation\n\nThis sub-section is composed of the following models :\n\n* [Multi Simulation](references#Multi-simulationMulti-simulation)\n\n","url":"wiki/Multi-simulation.md"},"Multicriteria-decision.md":{"title":" Multicriteria decision","content":"# Multicriteria decision\n\nThis sub-section is composed of the following models :\n\n* [Multicriteria](references#MulticriteriadecisionMulticriteria)\n\n","url":"wiki/Multicriteria-decision.md"},"Overlay.md":{"title":" Overlay","content":"# Overlay\n\nThis sub-section is composed of the following models :\n\n* [Overlay](references#OverlayOverlay)\n\n","url":"wiki/Overlay.md"},"Save-statement.md":{"title":" Save statement","content":"# Save statement\n\nThis sub-section is composed of the following models :\n\n* [Save to Ascii](references#SavestatementSave_to_asc)\n\n* [Save to CSV](references#SavestatementSave_to_CSV)\n\n* [Save to Shapefile](references#SavestatementSave_to_shapefile)\n\n* [Save to Text](references#SavestatementSave_to_text)\n\n","url":"wiki/Save-statement.md"},"Spatial-Operators.md":{"title":" Spatial Operators","content":"# Spatial Operators\n\nThis sub-section is composed of the following models :\n\n* [Discretization of Topology](references#SpatialOperatorsGeometrydiscretization)\n\n* [Spatial Operators](references#SpatialOperatorsSpatialOperators(Examples))\n\n* [Spatial Interpolation](references#SpatialOperatorsspatialinterpolation)\n\n* [Spatial Operators](references#SpatialOperatorsTopologies)\n\n","url":"wiki/Spatial-Operators.md"},"Statistics.md":{"title":" Statistics","content":"# Statistics\n\nThis sub-section is composed of the following models :\n\n* [Regression](references#StatisticsRegression)\n\n","url":"wiki/Statistics.md"},"Unit-Test.md":{"title":" Unit Test","content":"# Unit Test\n\nThis sub-section is composed of the following models :\n\n* [Example of Unit Test](references#UnitTestBasicExample)\n\n* [Example of Unit Test](references#UnitTestTwoSpecies(Example))\n\n","url":"wiki/Unit-Test.md"},"User-Interaction.md":{"title":" User Interaction","content":"# User Interaction\n\nThis sub-section is composed of the following models :\n\n* [Event Feature](references#UserInteractionEventLayer)\n\n* [MovingAgents](references#UserInteractionMovingAgents)\n\n* [User Command](references#UserInteractionUserCommand)\n\n* [User Command](references#UserInteractionUserControlArchitecture)\n\n","url":"wiki/User-Interaction.md"},"Syntax-models-Casting.md":{"title":" Casting Syntax","content":"[//]: # (keyword|operator_sample)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|statement_user_command)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|type_pair)\n[//]: # (keyword|concept_cast)\n# Casting Syntax\n\n\n_Author : A. Drogoul & P. Taillandier_\n\ndifferent ways of transforming objects and agents in GAML.\n\n\nCode of the model : \n\n```\n\nmodel Casting\n\nspecies to_int {\n\tinit {\n\t\twrite sample(int(1));\n\t\twrite sample(int(1.0));\n\t\twrite sample(int(\"1\"));\n\t\twrite sample(int(\"1.0\"));\n\t\twrite sample(int(°pink));\n\t\twrite sample(int(true));\n\t\twrite sample(int(self));\n\t\twrite sample(int([]));\n\t\twrite sample(int([0]));\n\t\twrite sample(int({0,0,0}));\n\t\twrite sample(int(0::0));\n\t\twrite sample(int([0::0]));\n\t\twrite sample(int(#AABBCC));\n\t\twrite sample(int(°meter));\t\t\t\t\n\t}\n}\n\n\nspecies to_float{\n\tinit {\n\t\twrite sample(float(1));\n\t\twrite sample(float(1.0));\n\t\twrite sample(float(\"1\"));\n\t\twrite sample(float(\"1.0\"));\n\t\twrite sample(float(°pink));\n\t\twrite sample(float(true));\n\t\twrite sample(float(self));\n\t\twrite sample(float([]));\n\t\twrite sample(float([0]));\n\t\twrite sample(float(0::0));\n\t\twrite sample(float([0::0]));\n\t\twrite sample(float({0,0,0}));\n\t\twrite sample(float(#AABBCC));\n\t\twrite sample(float(°meter));\t\t\t\t\n\t}\n}\n\n\nspecies to_string{\n\tinit {\n\t\twrite sample(string(1));\n\t\twrite sample(string(1.0));\n\t\twrite sample(string(\"1\"));\n\t\twrite sample(string(\"1.0\"));\n\t\twrite sample(string(°pink));\n\t\twrite sample(string(true));\n\t\twrite sample(string(self));\n\t\twrite sample(string([]));\n\t\twrite sample(string([0]));\n\t\twrite sample(string({0,0,0}));\n\t\twrite sample(string(#AABBCC));\n\t\twrite sample(string(°meter));\t\t\t\t\n\t}\n}\n\nspecies to_point{\n\tinit {\n\t\twrite sample(point(1));\n\t\twrite sample(point(1.0));\n\t\twrite sample(point(\"1\"));\n\t\twrite sample(point(\"1.0\"));\n\t\twrite sample(point(°pink));\n\t\twrite sample(point(true));\n\t\twrite sample(point(self));\n\t\twrite sample(point([]));\n\t\twrite sample(point([0]));\n\t\twrite sample(point(0::0));\n\t\twrite sample(point([0::0]));\n\t\twrite sample(point({0,0,0}));\n\t\twrite sample(point(#AABBCC));\n\t\twrite sample(point(°meter));\t\t\t\t\n\t}\n}\nspecies to_list{\n\tinit {\n\t\twrite sample(list(1));\n\t\twrite sample(list(1.0));\n\t\twrite sample(list(\"1\"));\n\t\twrite sample(list(\"1.0\"));\n\t\twrite sample(list(°pink));\n\t\twrite sample(list(true));\n\t\twrite sample(list(self));\n\t\twrite sample(list([]));\n\t\twrite sample(list([0]));\n\t\twrite sample(list(0::0));\n\t\twrite sample(list([0::0]));\t\n\t\twrite sample(list({0,0,0}));\n\t\twrite sample(list(#AABBCC));\n\t\twrite sample(list(°meter));\t\t\t\t\n\t}\n}\nspecies to_pair{\n\tinit {\n\t\twrite sample(pair(1));\n\t\twrite sample(pair(1.0));\n\t\twrite sample(pair(\"1\"));\n\t\twrite sample(pair(\"1.0\"));\n\t\twrite sample(pair(°pink));\n\t\twrite sample(pair(true));\n\t\twrite sample(pair(self));\n\t\twrite sample(pair([]));\n\t\twrite sample(pair([0]));\n\t\twrite sample(pair(0::0));\n\t\twrite sample(pair([0::0]));\n\t\twrite sample(pair({0,0,0}));\n\t\twrite sample(pair(#AABBCC));\n\t\twrite sample(pair(°meter));\t\t\t\t\n\t}\n}\nspecies to_map{\n\tinit {\n\t\twrite sample(map<float, int>(°meter));\n\t\twrite sample(map(1));\n\t\twrite sample(map(1.0));\n\t\twrite sample(map(\"1\"));\n\t\twrite sample(map(\"1.0\"));\n\t\twrite sample(map(°pink));\n\t\twrite sample(map(true));\n\t\twrite sample(map(self));\n\t\twrite sample(map([]));\n\t\twrite sample(map([0]));\n\t\twrite sample(map(0::0));\n\t\twrite sample(map([0::0]));\n\t\twrite sample(map({0,0,0}));\n\t\twrite sample(map(#AABBCC));\n\t\twrite sample(map<int,string>(1));\t\t\t\t\n\t}\n}\nexperiment Casting type: gui{\n\tuser_command \"to int\" {create to_int;}\n\tuser_command \"to float\" {create to_float;}\n\tuser_command \"to string\" {create to_string;}\n\tuser_command \"to point\" {create to_point;}\n\tuser_command \"to list\" {create to_list;}\n\tuser_command \"to pair\" {create to_pair;}\n\tuser_command \"to map\" {create to_map;}\n}\n```\n","url":"wiki/Syntax-models-Casting.md"},"Syntax-models-Lists.md":{"title":" Lists","content":"[//]: # (keyword|operator_list_with)\n[//]: # (keyword|operator_sample)\n[//]: # (keyword|operator_any)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|operator_contains)\n[//]: # (keyword|operator_contains_all)\n[//]: # (keyword|operator_contains_any)\n[//]: # (keyword|operator_reverse)\n[//]: # (keyword|operator_norm)\n[//]: # (keyword|operator_group_by)\n[//]: # (keyword|operator_even)\n[//]: # (keyword|operator_index_by)\n[//]: # (keyword|operator_index_of)\n[//]: # (keyword|operator_last_index_of)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_with_min_of)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_min_of)\n[//]: # (keyword|operator_max_of)\n[//]: # (keyword|operator_copy_between)\n[//]: # (keyword|operator_inter)\n[//]: # (keyword|operator_union)\n[//]: # (keyword|operator_interleave)\n[//]: # (keyword|operator_select)\n[//]: # (keyword|operator_remove_duplicates)\n[//]: # (keyword|statement_trace)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_user_command)\n[//]: # (keyword|concept_list)\n[//]: # (keyword|concept_loop)\n# Lists\n\n\n_Author : Alexis Drogoul_\n\nExamples of the syntax and various operators used to manipulate the 'list' data type. Read the comments and run the model to get a better idea on how to use lists in GAML. \n\n\nCode of the model : \n\n```\n\nmodel Lists\n\n/* Insert your model definition here */\n\nspecies declaring_list_attributes {\n\t\n\t/**\n\t * Declarations of list attributes\n\t */\n\t // The simplest declaration identifies empty_list as a list that can contain any type of objects. \n\t // Its default value will be [] (the empty list) if it is not initialized.\n\tlist empty_list;\n\t// To provide it with an initial value, use the '<-' (or 'init:') facet\n\tlist explicit_empty_list <- [];\n\t// lists can also be provided with a default size, in which case they are filled with the nil element\n\tlist list_of_size_10 <-[];// list_size(10); // => [nil,nil,nil,nil,nil,nil,nil,nil,nil,nil]\n\t// to fill them with a given initial value, use the 'list_with' operator\n\tlist list_of_size_10_with_0 <- list_with(10, 0); // => [0,0,0,0,0,0,0,0,0,0]\n\t\n\t// lists can be declared so that they only accept a given type of contents.\n\t// For instance, empty_list_of_int will only accept integer elements\n\tlist<int> empty_list_of_int ;\n\t\n\t// the value passed to 'list_with' is verified and casted to the contents type of the list if necessary\n\tlist<int> list_of_int_size_10_filled_with_string<- list<int>(list_with(10,'1')); // list_of_int_size_10_filled_with_string is filled with the casting of '1' to int, i.e. 1\n\tlist<string> list_of_string_size_10_filled_with_string <- list_with(10,'1'); // while list_of_string_size_10_filled_with_string is filled with the string '1'\n\t// the casting is also realized if the list is initialized with a value\n\tlist<int> list_of_int_with_init_of_string <- list<int>(['10', '20']); // => [10,20]\n\tlist<float> list_of_float_with_init_of_string <- list<float>(list_of_string_size_10_filled_with_string); // => [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]\n\t// When the casting is not obvious, the default value is used\n\tlist<float> list_of_float_with_impossible_casting <- list<float>(['A','B']); \n\t// lists can of course contain lists\n\tlist<list> list_of_lists <- list_with (5,[]);\n\t// untyped lists can contain heterogeneous objects\n\tlist untyped_list <- ['5',5,[5]];\n\t// the casting applies to all elements when a contents type is defined (note the default last value of 0)\n\tlist<int> recasted_list_with_int <- list<int>(untyped_list); //=> [5,5,0]\n\n\t\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== DECLARING LISTS ==\";\n\t\twrite \"\";\n\t\twrite sample(empty_list);\n\t\twrite sample(explicit_empty_list);\n\t\twrite sample(list_of_size_10);\n\t\twrite sample(list_of_size_10_with_0);\n\t\twrite sample(empty_list_of_int);\n\t\twrite sample(list_of_int_size_10_filled_with_string);\n\t\twrite sample(list_of_string_size_10_filled_with_string);\n\t\twrite sample(list_of_int_with_init_of_string);\n\t\twrite sample(list_of_float_with_init_of_string);\n\t\twrite sample(list_of_float_with_impossible_casting);\n\t\twrite sample(list_of_lists);\n\t\twrite sample(untyped_list);\n\t\twrite sample(recasted_list_with_int);\n\t\twrite \"\";\n\t\t// Declaring temporary variables of type list follows the same pattern\n\t\t// but there are fewer facets available (notably, \"size:\" or \"fill_with:\").\n\t\tlist<string> list_of_string <- ['A','B','C'];\n\t\t// lists are not always declared litterally and can be obtained from various elements\n\t\t// by using the casting 'list()' operator\n\t\t// for instance, list(species_name) will return a list of all the instances of species_name\n\t\tcreate test_species number:4;\n\t\tlist<test_species> my_agents <- list(test_species);\n\t\twrite sample(my_agents);\n\t\tlist<string> my_names <- my_agents collect each.name;\n\t\twrite sample(my_names);\n\t\t// 'create' can directly declare (and return) a list of the agents created. For instance:\n\t\tcreate test_species number: 5 returns: my_agents2;\n\t\twrite (sample(my_agents2));\n\t\t// Some special casting operations are applied to specific types, like points...\n\t\twrite sample(list(any(my_agents).location));\n\t\t// ... colors ...\n\t\twrite sample(list(°pink));\n\t\t// ... or strings\n\t\twrite sample(list(\"This is a string\"));\n\t\t\n \t}\n}\n\nspecies test_species{}\n\nspecies accessing_list_elements {\n\tlist<int> l1 <- [1,2,3,4,5,6,7,8,9,10];\n\tlist<string> l2 <- ['this','is','a','list', 'of','strings'];\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== ACCESSING LIST ELEMENTS ==\";\n\t\twrite \"\";\n\t\twrite sample(l1);\n\t\twrite sample(l2);\n\t\twrite sample(first(l1));\n\t\twrite sample(last(l1));\n\t\twrite sample(l1 at 1);\n\t\twrite sample(l1[1]);\n\t\twrite sample(length(l1));\n\t\twrite sample(mean(l1));\n\t\twrite sample(max(l1));\n\t\twrite sample(min(l1));\n\t\twrite sample(any(l1));\n\t\twrite sample(3 among l2);\n\t\twrite sample(l1 contains 1);\n\t\twrite sample(l1 contains_all [1,4,6, 14]);\n\t\twrite sample(l1 contains_any [1,23]);\n\t\twrite sample(reverse(l2));\n\t\twrite sample(l1 collect (each + 1));\n\t\twrite sample(l1 collect (norm({each, each, each})));\n\t\twrite sample(l1 where (each > 5));\n\t\twrite sample(l1 count (each > 5));\n\t\twrite sample(l1 group_by (even(each)));\n\t\twrite sample(l2 index_by (each + \"_index\"));\n\t\twrite sample(l1 index_of 100);\n\t\twrite sample(l2 last_index_of 'is');\n\t\twrite sample(l2 sort_by each);\n\t\twrite sample(l2 sort_by length(each));\n\t\twrite sample(l2 first_with (first(each)  = 'o'));\n\t\twrite sample(l2 where (length(each) = 2) );\n\t\twrite sample(l2 with_min_of (length(each)));\n\t\twrite sample(l2 with_max_of (length(each)));\n\t\twrite sample(l2 min_of (length(each)));\n\t\twrite sample(l2 max_of (length(each))); \n\t\twrite sample(copy_between(l2,1,3));\n\t\twrite sample(copy_between(l2, 1, length(l2) - 1));\n\t}\n}\n\nspecies combining_lists {\n\tlist<int> l1 <- [1,2,3,4,5,6,7,8,9,10];\n\tlist<int> l2 <- [1,3,5,7,9];\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== COMBINING LISTS ==\";\n\t\twrite \"\";\n\t\twrite sample(list<list<string>>([[1,2,3]]));\n\t\twrite sample(l1);\n\t\twrite sample(l2);\n\t\twrite sample(l1 + l2);\n\t\twrite sample(l1 - l2);\n\t\twrite sample(l1 inter l2);\n\t\twrite sample(l1 union l2);\n\t\twrite sample(interleave ([l1,l2]));\n\t\tlist<string> l3 <- list<string>(l1 + l2);\n\t\twrite \"list<string> l3 <- l1 + l2; \" + sample(l3);\n\t\twrite sample(l1 as list<float>);\n\t}\n}\n\nspecies modifying_lists {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== MODIFYING LISTS ==\";\n\t\twrite \"\";\n\t\ttrace {\n\t\t// Besides assigning a new value to a list, lists can be manipulated using\n\t\t// the \"add\", \"remove\" and \"put\" statements. \n\t\t// Let's define an empty list supposed to contain integer elements\n\t\tlist<int> l1;\n\t\t// and add some stuff to it using \"add\"\n\t\tadd 1 to: l1;\n\t\tadd 2 to: l1;\n\t\tadd 3 to: l1;\n\t\twrite sample(l1);\n\t\t// the same can be done with the compact syntax introduced in GAMA 1.6 for \"add\"\n\t\tl1 <+ 4;\n\t\tl1 <+ 5;\n\t\twrite sample(l1);\n\t\t// tired of writing lines of add ? The \"all:\" facet is here to serve:\n\t\tadd all: [6, 7, 8, 9] to: l1;\n\t\t// or, in a more compact way:\n\t\tl1 <<+ [10,11,12,13];\n\t\twrite sample(l1);\n\t\t// automatic casting applies to any element added to the list\n \t\tl1 <+ (int(\"14\"));\n\t\t// as well as any container of elements\n\t\tl1 <<+ (list<int>([\"15\", 16.0]));\n\t\twrite sample(l1);\n\t\t// elements are by default added to the end of the list\n\t\t// but they can be introduced at specific positions using the \"at:\" facet\n\t\tadd 0 to: l1 at: 0;\n\t\t// or\n\t\tl1[0] +<- 0;\n\t\t// what about replacing some elements once they have been added ?\n\t\t// \"put\" can be used for that purpose\n\t\tput -2 at: 0 in: l1;\n\t\t// or, more elegantly:\n\t\tl1[0] <- -2;\n\t\t// Trying to put an element outside the bounds of the list will yield an error\n\t\t// l1[20] <- 10; will return the error \"Index 20 out of bounds of l1\"\n\t\twrite sample(l1);\n\t\t// And what about replacing all the values with a new one ?\n\t\tl1[] <- 0;\n\t\twrite sample(l1);\n\t\t// Well, l1 is a bit boring now, isnt't it ?\n\t\t// Let's fill it again with fresh values\n\t\tloop i from: 0 to: length(l1) -1 {\n\t\t\tl1[i] <- rnd(3);\n\t\t}\n\t\twrite(sample(l1));\n\t\t// To remove values from it, the \"remove\" statement (and its compact forms) can be used\n\t\t// For instance, let's try to remove its first element\n\t\tremove first(l1) from: l1;\n\t\t// it can also be written\n\t\tl1 >- first(l1);\n\t\twrite(sample(l1));\n\t\t// To remove all occurrences of a specific element, \"all:\" (or \">>-\") can be used\n\t\t// For instance:\n\t\tl1 >>- 2;\n\t\tl1 >>- 1;\n\t\t// or, written using the long syntactic form\n\t\tremove all: 1 from: l1;\n\t\twrite sample(l1);\n\t\t// To remove all the elements present in a given container, the same syntax can be used\n\t\tl1 >>- [0,3];\n\t\twrite (\"After l1 >>- [0,3] : \" + sample( l1));\n\t\t// By all means, l1 should now be empty! Let's fill it again\n\t\tloop times: 20 {\n\t\t\tl1 <+ rnd(3);\n\t\t}\n\t\twrite(sample(l1));\n\t\t// It is also possible to remove an index rather than a value (this will remove the \n\t\t// value present at this index )\n\t\tl1[] >- 2;\n\t\twrite(\"After l1[] >- 2 : \" + sample(l1));\n\t\t// Removing several indexes can be written using a syntax similar to the one used\n\t\t// for removing values\n\t\tl1[] >>- [1,2,4];\n\t\twrite(\"After l1[] >>- [1,2,4] : \" + sample(l1));\n\t\t// Random things to try out\n\t\t// Using casting back and forth: all number now vary from 1000 to 31000\n\t\tl1 <- list<int>(l1 collect (string(each) + \"1000\"));\n\t\twrite sample(l1);\n\t\t// Removing elements based on a criteria\n\t\tl1 >>- l1 select (each > 20000);\n\t\t// Removing duplicates\n\t\tl1 <- remove_duplicates(l1);\n\t\t// Another way (see \"../Maps.gaml\")\n\t\tl1 <- map(l1).values; \n\t\twrite(sample(l1));\n\t}}\n\t\n}\n\nspecies looping_on_lists {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== LOOPING ON LISTS ==\";\n\t\twrite \"\";\n\t\t// Besides iterator operators (like \"collect\", \"where\", etc.), which provide \n\t\t// functional iterations (i.e. filters), one can loop over lists using the imperative\n\t\t// statement 'loop'\n\t\tlist<string> l1 <- list(\"This is a list of strings\");\n\t\twrite sample(l1);\n\t\tint i <- 0;\n\t\tlist l2 <- [];\n\t\t// Here, the value of 's' will be that of each element of the list\n\t\tloop s over: l1 {\n\t\t\ti <- i + 1;\n\t\t\tl2 << \"Word #\" + i + \": \" + s;\n\t\t}\n\t\twrite sample(l2);\n\t\t// 'loop' can also directly use an integer index (remember lists have a zero-based index)\n\t\tl2 <- [];\n\t\tloop i from: 0 to: length(l1) - 1 step:2 {\n\t\t\tl2 << l1[i];\n\t\t}\n\t\twrite sample(l2);\n\t\t// Finally, list containing agents can be the support of implicit loops in the 'ask' statement\n\t\tcreate test_species number: 5 returns: my_agents;\n\t\tl2 <- [];\n\t\task my_agents{\n\t\t\t// attributes of each agent can be directly accessed\n\t\t\tl2 << name;\n\t\t}\n\t\twrite sample(l2);\n\t\t// ... which is formally equivalent to:\n\t\tl2 <- [];\n\t\tl2 <<+ my_agents collect each.name;\n\t\twrite sample(l2);\n\t\t// ... or, even simpler (since the casting of an agent to string returns its name)\n\t\tlist<string> l3 <- list<string>(my_agents);\n\t\twrite sample(l3);\n\t\t// Powerful filter expressions can be built by combining the various 'iterator' operators\n\t\tl3 <- list<string>(my_agents where even(int(each))) collect (\"Agent \" + each + \" has an even id\");\n\t\twrite sample(l3);\n\t}\n}\n\nexperiment Lists type: gui {\n\tuser_command \"Declaring lists\" {create declaring_list_attributes;}\n\tuser_command \"Accessing lists\" {create accessing_list_elements;}\n\tuser_command \"Combining lists\" {create combining_lists;}\n\tuser_command \"Modifying lists\" {create modifying_lists;}\n\tuser_command \"Looping on lists\" {create looping_on_lists;}\t\n}\n```\n","url":"wiki/Syntax-models-Lists.md"},"Syntax-models-Maps.md":{"title":" Maps","content":"[//]: # (keyword|operator_sample)\n[//]: # (keyword|operator_any)\n[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_index_by)\n[//]: # (keyword|operator_group_by)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|operator_contains)\n[//]: # (keyword|operator_contains_all)\n[//]: # (keyword|operator_contains_any)\n[//]: # (keyword|operator_reverse)\n[//]: # (keyword|operator_norm)\n[//]: # (keyword|operator_even)\n[//]: # (keyword|operator_index_of)\n[//]: # (keyword|operator_last_index_of)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_with_min_of)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_min_of)\n[//]: # (keyword|operator_max_of)\n[//]: # (keyword|operator_inter)\n[//]: # (keyword|operator_union)\n[//]: # (keyword|operator_select)\n[//]: # (keyword|statement_trace)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_user_command)\n[//]: # (keyword|concept_map)\n[//]: # (keyword|concept_loop)\n# Maps\n\n\n_Author : Alexis Drogoul_\n\nExamples of the syntax and various operators used to manipulate the 'map' data type. Read the comments and run the model to get a better idea on how to use maps in GAML. \n\n\nCode of the model : \n\n```\n\nmodel Maps\n\n/* Maps is a data structure consisting of a list of pair<key, value> where each key is unique */\n\nspecies declaring_map_attributes {\n\t\n\t/**\n\t * Declarations of map attributes\n\t */\n\t // The simplest declaration identifies empty_map as a map that can contain any type of objects. \n\t // Its default value will be [] (the empty list/map) if it is not initialized.\n\tmap empty_map;\n\t// To provide it with a literal initial value, use the '<-' (or 'init:') facet and pass a map\n\tmap explicit_empty_map <- [];\n\t// Or, more explicitely\n\tmap explicit_empty_map2 <- map([]);\n\t// Values can be declared litterally in this map, which is nothing more than a list of pair objects\n\tmap explicit_filled_map <- [\"First\"::1, \"Second\"::2];\n\t// If a map is initialized with a list that contains non-pair objects, the pairs element::element are added to the map\n\tmap map_initialized_with_list <- map<int, int>([1,2,3,4]);\n\t// maps can be declared so that they only accept a given type of keys and values\n\t// For instance, empty_map_of_int will accept string keys and integer values\n\tmap<string, int> empty_map_of_int;\n\t// The appropriate casting is realized if the map is initialized with a list of values\n\tmap<string, int> map_of_int_with_init_of_string <- map<string, int>(['10', '20']); // => ['10'::10,'20'::20]\n\t// or with another map\n\tmap<int, float> map_of_float_with_init_of_map <- map<int, float>(map_initialized_with_list); \n\t// When the casting is not obvious, the default values are used\n\t// Here, the list is first casted to return pairs, and they are casted to pair<string, float>\n\tmap<string, float> map_of_float_with_impossible_casting <- map<string, float>(['A','B']); \n\t// maps can of course contain maps\n\tmap<string, map> map_of_maps <- map<string, map>(['A'::[], 'B'::[]]);\n\t// untyped maps can contain heterogeneous objects\n\tmap untyped_map <- [10::'5','11'::5,[12]::[5]];\n\t// the casting applies to all elements when a key and contents type is defined\n\tmap<int, string> recasted_map_with_int_and_string <- map<int, string>(untyped_map); //=> [5,5,0]\n\n\t\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== DECLARING MAPS ==\";\n\t\twrite \"\";\n\t\twrite sample(empty_map);\n\t\twrite sample(explicit_empty_map);\n\t\twrite sample(empty_map_of_int);\n\t\twrite sample(explicit_filled_map);\n\t\twrite sample(map_initialized_with_list);\n\t\twrite sample(map_of_int_with_init_of_string);\n\t\twrite sample(map_of_float_with_init_of_map);\n\t\twrite sample(map_of_float_with_impossible_casting);\n\t\twrite sample(map_of_maps);\n\t\twrite sample(untyped_map);\n\t\twrite sample(recasted_map_with_int_and_string);\n\t\twrite \"\";\n\t\t// Declaring temporary variables of type map follows the same pattern\n\t\tmap<int,string> map_of_string <- [1::'A',2::'B',3::'C'];\n\t\t// maps are not always declared litterally and can be obtained from various elements\n\t\t// by using the casting 'map()' operator\n\t\t// for instance, map(species_name) will return a list of all the agents of species_name\n\t\t// using pairs of agent::agent. If the key is explicit, it is used in the casting:\n\t\tcreate test_species number:4;\n\t\tmap<string, test_species> my_agents <- map<string, test_species>(test_species);\n\t\twrite sample(my_agents);\n\t\t// Some special casting operations are applied to specific types, like agents (returns a copy of their attributes)\n\t\twrite sample(map(any(my_agents)));\n\t\t// The 'as_map(pair)' iterator operator also provides a way to build more complex maps\n\t\twrite sample(list(\"This is a string\") as_map (length(each)::each));\n\t\t// As well as \"group_by\" or \"index_by\"\n\t\twrite sample(my_agents index_by (each distance_to {0,0}));\n\t\twrite sample([1,2,3,4,5,6,7] group_by ((each mod 3) = 0));\n \t}\n}\n\nspecies test_species{}\n\nspecies accessing_map_elements {\n\tmap<int, int> l1 <- map<int, int>([1,2,3,4,5,6,7,8,9,10]);\n\tmap<int, string> l2 <- [1::'this',2::'is',3::'a',4::'list', 5::'of',6::'strings'];\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== ACCESSING MAPS ELEMENTS ==\";\n\t\twrite \"\";\n\t\twrite sample(l1);\n\t\twrite sample(l2);\n\t\twrite sample(first(l1));\n\t\twrite sample(last(l1));\n\t\twrite sample(l1 at 1);\n\t\twrite sample(l1[1]);\n\t\twrite sample(length(l1));\n\t\twrite sample(mean(l1));\n\t\twrite sample(max(l1));\n\t\twrite sample(min(l1));\n\t\twrite sample(any(l1));\n\t\twrite sample(3 among l1);\n\t\twrite sample(l1 contains 1);\n\t\twrite sample(l1 contains_all [1,4,6, 14]);\n\t\twrite sample(l1 contains_any [1,23]);\n\t\twrite sample(reverse(l2));\n\t\twrite sample(l1 collect (each + 1));\n\t\twrite sample(l1 collect (norm({each, each, each})));\n\t\twrite sample(l1 where (each > 5));\n\t\twrite sample(l1 count (each > 5));\n\t\twrite sample(l1 group_by (even(each)));\n\t\twrite sample(l2 index_by (each + \"_index\"));\n\t\twrite sample(l1 index_of 100);\n\t\twrite sample(l2 last_index_of 'is');\n\t\twrite sample(l2 sort_by each);\n\t\twrite sample(l2 sort_by length(each));\n\t\twrite sample(l2 first_with (first(each)  = 'o'));\n\t\twrite sample(l2 where (length(each) = 2) );\n\t\twrite sample(l2 with_min_of (length(each)));\n\t\twrite sample(l2 with_max_of (length(each)));\n\t\twrite sample(l2 min_of (length(each)));\n\t\twrite sample(l2 max_of (length(each)));\n\t}\n}\n\nspecies combining_maps {\n\tmap<int, int> l1 <- map<int, int>([1,2,3,4,5,6,7,8,9,10]);\n\tmap<int, int> l2 <- map<int, int>([1,3,5,7,9]);\n\tinit {\n\n\t\twrite \"\";\n\t\twrite \"== COMBINING MAPS ==\";\n\t\twrite \"\";\n\t\twrite sample(l1);\n\t\twrite sample(l2);\n\t\twrite sample(l1 + l2);\n\t\twrite sample(l1 - l2);\n\t\twrite sample(l1 inter l2);\n\t\twrite sample(l1 union l2);\n\t\tmap<string> l3 <- map<int, string>(l1 + l2);\n\t\twrite \"map<string> l3 <- l1 + l2; \" + sample(l3);\n\t}\n}\n\nspecies modifying_maps {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== MODIFYING MAPS ==\";\n\t\twrite \"\";\n\t\t// Besides assigning a new value to a map, maps can be manipulated using\n\t\t// the \"add\", \"remove\" and \"put\" statements. \n\t\t// Let's define an empty list supposed to contain integer keys and values\n\t\ttrace { map<int, int> m1 <- [0::0]; \n\t\t// and add some stuff to it using \"add\"\n\t\tadd 1::1 to: m1;\n\t\tadd 2::2 to: m1;\n\t\tadd 3::3 to: m1;\n\t\twrite sample(m1);\n\t\t// the same can be done with the compact syntax introduced in GAMA 1.6.1 for \"add\"\n\t\tm1 <+ 4::4;\n\t\tm1 <+ 5::5;\n\t\twrite sample(m1);\n\t\t// tired of writing lines of add ? The \"all:\" facet is here to serve:\n\t\tadd [6, 7, 8, 9] to: m1 all: true;\n\t\t// or, in a more compact way:\n\t\tm1 <<+ [10,11,12,13];\n\t\twrite sample(m1);\n\t\t// automatic casting applies to any element added to the map\n\t\tm1 <+ int(\"14\");\n\t\t// as well as any container of elements\n\t\tm1 <<+ map<int, int>([15::\"15\", 16::16.0]);\n\t\twrite sample(m1);\n\t\t// elements are by default added to the map while their keys are unique\n\t\t// So, what about replacing some elements once they have been added ?\n\t\t// \"put\" can be used for that purpose\n\t\tput -2 at: 0 in: m1;\n\t\t// or, more simply:\n\t\tm1[0] <- -3;\n\t\t// Trying to put an element outside the \"bounds\" of the map will of course not yield an error\n\t\t m1[20] <- 10; \n\t\twrite sample(m1);\n\t\t// And what about replacing all the values with a new one ?\n\t\tm1[] <- 0;\n\t\twrite(\"m1[] <- 0;\");\n\t\twrite sample(m1);\n\t\t// Well, m1 is a bit boring now, isnt't it ?\n\t\t// Let's fill it again with fresh values\n\t\tloop i over: m1.keys {\n\t\t\tm1[i] <- rnd(3);\n\t\t}\n\t\twrite(sample(m1));\n\t\t// To remove values from it, the \"remove\" statement (and its compact \">-\" form) can be used\n\t\t// WARNING: this form operation on the *values* of the map (i.e. it will remove the first pair\n\t\t// whose value = 0\n\t\tremove 0 from: m1;\n\t\t// it can also be written\n\t\tm1 >- 0;\n\t\twrite(sample(m1));\n\t\t// To remove all occurrences of pairs with a specific value, \"all:\" (or \">>-\") can be used\n\t\t// For instance:\n\t\tm1 >>- 2;\n\t\t// or, written using the long syntactic form\n\t\tremove 1 from: m1 all: true;\n\t\twrite sample(m1);\n\t\t// To remove keys instead, the same syntax can be used, but on the keys of the map (i.e. map[])\n\t\tm1[] >- 1; // This will remove the (unique) pair whose key = 1\n\t\t// The equivalent long syntax is\n\t\tremove key: 1 from: m1;\n\t\t// To remove a set of keys, the following syntax can be used\n\t\tm1[] >>- [2,3,4];\n \t\t// And to remove all the keys present in a given map (using the 'keys' attribute)\n\t\tm1[] >>- m1.keys;\n\t\twrite sample(m1);\n\t\t// By all means, m1 should now be empty! Let's fill it again\n\t\tint i <- 0;\n\t\tloop times: 20 {\n\t\t\ti <- i + 1;\n\t\t\tm1 <+ i::rnd(3);\n\t\t}\n\t\t// Random things to try out\n\t\t// Using the 'pairs' attribute: all number now vary from 1000 to 1003\n\t\tm1 <- m1.pairs as_map (each.key::((each.value) + 1000));\n\t\twrite sample(m1);\n\t\t// Removing values based on a criteria\n\t\tm1 >>- m1 select (each > 1001);\n\t\twrite(sample(m1));\n\t}\n\n\t}\n\t\n}\n\nspecies looping_on_maps {\n\tinit {\n\t\twrite \"\";\n\t\twrite \"== LOOPING ON MAPS ==\";\n\t\twrite \"\";\n\t\t// Besides iterator operators (like \"collect\", \"where\", etc.), which provide \n\t\t// functional iterations (i.e. filters), one can loop over maps using the imperative\n\t\t// statement 'loop'\n\t\tlist<string> strings <- list(\"This a list of string\");\n\t\twrite sample(strings);\n\t\tmap<string, string> l1 <- strings as_map (first(each)::each);\n\t\twrite sample(l1);\n\t\tint i <- 0;\n\t\tlist l2 <- [];\n\t\t// Here, the value of 's' will be that of each value of each pairs of the list\n\t\tloop s over: l1 { // equivalent to 'loop s over: l1.values'\n\t\t\ti <- i + 1;\n\t\t\tl2 << \"Word #\" + i + \": \" + s;\n\t\t}\n\t\twrite sample(l2);\n\t\t// To loop on the keys of l1, simply use its 'keys' attribute\n\t\tl2 <- [];\n\t\t i <- 0;\n\t\tloop s over: l1.keys{\n\t\t\ti <- i + 1;\n\t\t\tl2 << \"Key #\" + i + \": \" + s;\n\t\t}\n\t\twrite(sample(l2));\n\t\t// Looping on indexes allows to gain access to each element in turn\n\t\tl2 <- [];\n\t\tloop i over: l1.keys {\n\t\t\tl2 <+ l1[i];\n\t\t}\n\t\twrite sample(l2);\n\t\t// Finally, maps containing agents can be the support of implicit loops in the 'ask' statement\n\t\tcreate test_species number: 5 returns: my_agents;\n\t\tmap<int, test_species> map_of_agents <- map<int, test_species>(my_agents);\n\t\twrite(sample(map_of_agents));\n\t\tl2 <- [];\n\t\task map_of_agents{\n\t\t\t// attributes of each agent can be directly accessed\n\t\t\tl2 << name;\n\t\t}\n\t\twrite sample(l2);\n\t\t// Of course, this can be done more simply like this\n\t\tl2 <- map_of_agents collect each.name;\n\t\t}\n\t}\n\n\nexperiment Maps type: gui {\n\tuser_command \"Declaring maps\" {create declaring_map_attributes;}\n\tuser_command \"Accessing maps\" {create accessing_map_elements;}\n\tuser_command \"Combining maps\" {create combining_maps;}\n\tuser_command \"Modifying maps\" {create modifying_maps;}\n\tuser_command \"Looping on maps\" {create looping_on_maps;}\t\n}\n```\n","url":"wiki/Syntax-models-Maps.md"},"Syntax-models-Syntax-(1.6).md":{"title":" Syntax","content":"[//]: # (keyword|operator_list_with)\n[//]: # (keyword|operator_diff)\n[//]: # (keyword|operator_select)\n[//]: # (keyword|operator_any)\n[//]: # (keyword|operator_union)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|type_path)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#sec)\n[//]: # (keyword|constant_#pixels)\n[//]: # (keyword|concept_attribute)\n[//]: # (keyword|concept_ternary)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_action)\n[//]: # (keyword|concept_container)\n[//]: # (keyword|concept_list)\n# Syntax\n\n\n_Author : Alexis Drogoul_\n\nAn overview of the new syntactic constructs that have been introduced in GAMA 1.6\n\n\nCode of the model : \n\n```\n\n@no_warning\nmodel syntax\n\n/**\n * The global section can now sport skills and control, just like other agents. \n * The example below shows a potentially moving world that can be controlled by a finite state machine.\n */\nglobal skills: [moving] control: fsm {\n\n/**\n * EQUATIONS\n */ \n\tfloat x;\n\tfloat y;\n\tfloat t;\n\tequation eq {\n\t\tdiff(x, t) = x / 2;\n\t\tdiff(y, t) = x + y * 2;\n\t}\n\n\treflex solving {solve eq step: 1 method: rk4;}\n\n\t/** \n * ATTRIBUTES\n */\n\n// Attributes can be declared in different ways, ranging from \"classic\"...\n\tlist<int> a1 const: true <- [1, 2, 3] of: int;\n\tlist a2 <- [1, 2, 3] of: int;\n\t// ... to \"compact\" Java-like syntax.\n\tlist<int> a3 <- [1, 2, 3];\n\n\t// The declaration of a default size/value in containers is now working correctly\n\tlist<float> f <- list_with(2000,0.0);\n\n\t// Functions can be declared using the regular facet \"->\" / \"function:\" \n\tint b1 -> { 100 + length(a1) };\n\tint b2 function: { 100 + length(a1) };\n\t// ... or using a block (like a statement -- note the absence of semi-column at the end)\n\tint b3 {\n\t\t100 + length(a1)\n\t}\n\tstate first_state initial: true {\n\t//...\n\n\t}\n\tinit {\n\t\tcreate species0 number: 20;\n\t}\n\t\n\n\t/**\n\t * UNITS\n\t */\n// The usage of units is improved ( \"#\" being replaced by \"°\"), and they can be combined\n\tfloat c <- 10 °meter;\n\tfloat speed <- 10 °meter / °sec;\n\n\t// Attributes can (finally!) be named after unit names\n\tfloat meter <- 10.0;\n\n\t// Some mathematical constants have been introduced alongside units\n\tfloat pi_4 <- °pi / 4;\n\tfloat e <- °e;\n\n\t/**\n\t  * ACTIONS\n\t  */\n\t// Actions can also be declared in different ways. Classic:\n\taction dummy1 type: list of: int {\n\t\targ a type: int default: 100;\n\t\targ b type: float;\n\t\treturn [a, int(b)];\n\t}\n\t// Semi-classic (prefixed by the type)\n\tlist dummy2 of: int {\n\t\targ a type: int default: 100;\n\t\targ b type: float;\n\t\treturn [a, int(b)];\n\t}\n\t//Compact\n\tlist<int> dummy1 (int a <- 100, float b) {\n\t\treturn [a, int(b)];\n\t}\n\n\t// An action that returns nothing can still be called \"action\"\n\taction dummy_void {\n\t\twrite \"dummy_void\";\n\t}\n\n\t/**\n\t * DEALING WITH VARIABLES\n\t */\n\treflex variables {\n\n\t// Temporary variables can use the same syntax as attributes. The classic form:\n\t\t//let name: t1 type: int value: length(a1);\n\t\t// is equivalent to the more compact one:\n\t\tint t2 <- length(a1);\n\n\t\t// Assigning a value to variables is also sporting a new syntax \n\t\tset t2 value: 100;\n\t\t// ... can be replaced by \n\t\tset t2 <- 100;\n\t\t// ... or even by\n\t\tt2 <- 100;\n\n\t\t// Species can now act as direct containers of their agents..\n\t\tlist<species0> spec_with_location <- species0 select (each.location = { 0, 0 });\n\t\tspecies0 agent0 <- species0[10];\n\t\twrite string(agent0);\n\n\t\t// ...  and agents as direct containers of their attributes (mimicking the internal attributes map). This \"virtual map\" will now contain, in addition to the attributes, \n\t\t// all the variables loaded from CSV, SQL or shape files (some stored in the agent itself, others in the shape).\n\t\tagent0[\"departure\"] <- { 0, 0 };\n\t\twrite string(agent0);\n\n\t\t// Keys are not necessarily strings, by the way ! A warning is emitted in such cases, but it is just a warning.\n\t\tagent0[0] <- 0;\n\n\t\t// Accesses can be combined\n\t\tspecies0[10].name <- \"A new name\"; // which is equivalent to (spec at 10).name = \"A new name\";\n\n\t\t// Points can be used (with or without curly parentheses) to access agents in species\n\t\tspecies0 agent1 <- species0[10, 10]; // returns the agent closest to point {10,10} for a \"regular\" species\n\t\t// The behavior is a bit tweaked for grids, to allow for a \"natural\" access\n\t\tmy_grid cell0 <- my_grid[10, 10]; // Here, it is the cell at {10, 10} in the matrix of cells\n\n\t\t// Shapes also act as containers of CVS/Shapefile attributes (in case they are loaded without being attributed to an agent), as well as 3D properties (for the display).\n\t\tagent0.name <- string(agent0.shape[\"ID\"]);\n\t\tgeometry geom <- square(100);\n\t\tgeom[\"type\"] <- \"cube\";\n\t\t\n\t\t\n\t\t// All these attributes can be accessed using the casting of agents to map\n\t\twrite string(map(agent0));\n\n\t\t//This access can be used everywhere, easing the use of shape files (and data files in general)\n\t\tlist<geometry> shapes <- list<geometry>(file(\"something.shp\"));\n\n\t\t// If we suppose val1, val2, etc. are defined in the shape file\n\t\tfloat max <- min(shapes collect float(each[\"val1\"]));\n\n\t\t//To allow for an easier access in case the modeler only uses agents, agents' attributes can \"pass through\" towards their shape's attributes \n\t\t//(in case the same attribute has not been defined in the agent, of course)\n\t\tcreate species0 from: shapes;\n\t\tmax <- min(species0 collect float(each[\"val1\"])); // equivalent to each.shape[\"val1\"]. \n\t\t//This last sentence only works, however, for *reading* values.\n\t\tany(species0)[\"val1\"] <- 100; // will result in the creation of a new attribute in the agent (not in its shape)\n\t\tany(species0).shape[\"val1\"] <- 100; // will be correct in that case\n\n\t\t// Container variables have seen their usability clearly improved \n\t\tmap m <- map([]);\n\t\tlist<int> l <- [1, 2, 3, 4, 5];\n\n\t\t// Adding a value\n\t\tadd 1 to: l;\n\t\t// ... can now be written\n\t\tl <+ 1;\n\n\t\t// Removing a value\n\t\tremove 1 from: l;\n\t\tremove \"type\" from: geom;\n\n\t\t// ... can now be written\n\t\tl >- 1;\n\t\tgeom >- \"type\";\n\t\tany(species0)[] >- \"name\"; // removes the \"name\" attribute from a random agent. Can be dangerous in some cases... \n\n\t\t// Setting/putting a value\n\t\tput \"a\" at: 'key' in: m;\n\t\tput 1 at: 0 in: l;\n\t\t// ... can now be written\n\t\tm['key'] <- \"a\";\n\t\tl[0] <- 1;\n\t\tlist<list> ll <- [];\n\t\tll <+ []; // [[]]\n\t\tll[0] <+ 10; // [[10]]\n\n\t}\n\n\t// TODO Species can now be written within the \"global\" section (to enforce the idea that the top-level species are indeed contained in the world)\n\tspecies inside_global {\n\t}\n\n\t/**\n\t  * INVOCATION OF ACTIONS\n\t  */\n\treflex calling_actions {\n\t// IN IMPERATIVE MODE (i.e. in a statement)\n\t// The classic way\n\t\tdo dummy1 with: [a::10, b::100.0];\n\n\t\t// Another by distributing the arguments\n\t\tdo dummy1 a: 10 b: 100.0;\n\n\t\t// The new alternative one \n\t\tdo dummy1(a: 10, b: 100.0);\n\t\task any(species1) {\n\t\t\tdo goto(target: { 10, 10 }, speed: 100);\n\t\t}\n\t\t// ... which has been introduced to unify the functional/imperative use of actions.\n\n\t\t// And finally the new functional way, probably reserved to simple calls (as all the arguments must be passed).\n\t\tdo dummy1(10, 100.0);\n\n\t\t// IN FUNCTIONAL MODE (i.e. as part of expressions)\n\t\t// The \"classic\" way of calling actions. Note that in that case, dummy1 is used like a binary operator (callee on the left, argument map on the right)\n\t\tlist d1 <- self dummy1 [a::10, b::100.0];\n\n\t\t// First improvement, argument maps can now be simplified, which results in a functional syntax with named arguments\n\t\tlist d2 <- self dummy1 (b: 100.0); // a is not passed as it has a default value.\n\n\t\t// To improve the readability of this way of calling actions, the dotted notation is now allowed as well \n\t\tlist d3 <- self.dummy1(a: 100, b: 100.0);\n\t\tfloat s <- any(species1).compute_speed_using_an_action(max: 100);\n\n\t\t// Finally, the functional syntax is also introduced. In that case, all the arguments need to be passed as they are not named.\n\t\t// This unifies the way of calling operators and actions furthermore. \n\n\t\t// The action can be called as a n_ary operator, and in that case, the callee is implicitely the agent that executes the call\n\t\tlist d4 <- dummy1(10, 100.0);\n\n\t\t// And it can also be called using the \"dotted\" syntax, in which case the callee needs to be explicit (can be \"self\" of course)\n\t\tpath p <- world.move(100, 45, shape); // speed, heading, bounds\n\n\n\t\t/**\n \t \t *  As a summary, the syntaxes kept for future developments of models will likely be: \n \t \t */\n\n// CALLING WITH NAMED ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF\n\t\t// This method is convenient as it allows to pass only some arguments (if defaults are defined, which is implicitely the case in primitives), \n\t\t// but also to pass them in any order\n\t\tdo wander(speed: 100, amplitude: 10);\n\t\tpath p1 <- path(self.wander(amplitude: 10, speed: 100));\n\t\tpath p2 <- path(self wander (speed: 100, bounds: square(10)));\n\t\tpath p3 <- path(wander(speed: 100));\n\t\tpath p4 <- path(wander());\n\n\t\t// CALLING WITH COMPLETE ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF\n\t\t// This method is convenient as it follows the functional syntax of operators and then allows to declare \"quasi-operators\" in species, even to redefine existing ones.\n\t\tdo wander(100, 100, self.shape); // speed, amplitude, bounds as defined in primitive wander\n\t\tint d5 <- self.max(10, 100);\n\t\tint d6 <- self max (10, 100);\n\t\tint d7 <- max(10, 100);\n\t\tlist others <- filter(species1);\n\n\t\t// As a side note, the new syntax for arguments maps is not only usable in action calls, but also in create, for instance\n\t\tcreate species0 with: (location: { 100, 100 }, name: \"\");\n\t}\n\n\t// The ternary operator \"(condition) ? statement_if_condition_true : statement_if_condition_false\" can be used as follow :\n\tint max (int i, int j) {\n\t\treturn i > j ? i : j;\n\t}\n\n\tlist<agent> filter (container<agent> my_agents) {\n\t\treturn my_agents where (each.location = nil);\n\t}\n\n\t/**\n\t  * USE OF OPERATORS \n\t  */\n\treflex operators {\n\n\t// All the operators can now be written using a function-like form\n\t// It is true for unary operators (as before)\n\t\tbool a <- flip(0.4);\n\t\t// .. but also for binary ones (in addition to the classic way)\n\t\tint b <- div(100, 23) + 100 div 23;\n\t\tgeometry c1 <- union(square(1), circle(10));\n\t\t// The only exception to this rule is that of the built-in operators (like \"and\"/\"or\") and the ones whose names are not alphanumeric (like \"+\")\n\n\t\t// The big news is that operators are now allowed to be written using any number of parameters (not 1 or 2)\n\t\t// Here is an example with the \"between\" operator (written specially in Java to test this feature)\n\t\t// @operator(value = \"between\", can_be_const = true)\n\t\t// public static Boolean between(final Integer a, final Integer inf, final Integer sup) {\n\t\t//    \tif ( inf > sup ) { return false; }\n\t\t//\t\treturn a >= sup ? false : a > inf; \n\t\t// }\n\t\tbool e1 <- between(5, 1, 10);\n\t}\n\t/**\n\t  * DEFINITION OF ASPECTS\n\t  */\n\taspect default {\n\t// draw now accepts any kind of arguments and decides what to do based on the type of the argument\n\t\tdraw circle(1);\n\t\tdraw name;\n\t\tdraw file(\"image.jpg\");\n\n\t\t// special units (that take a value in the drawing scope) have been introduced to allow for a better control of the display\n\t\t// This statement will draw a circle of radius 10 pixels, whatever the level of zoom and size of the display\n\t\tdraw circle(10 °px);\n\t\tdraw \"Display dimensions: \" + °display_width + \" \" + °display_height;\n\t}\n\n}\n\n/** Species can \"mirror\" a list of agents (or another species). That is, their population is dynamically computed after the list or species mirrored.\n* Their instances, which are actually \"proxy\" agents, possess an attribute called \"target\" that points towards the agent they mirror. Very useful for building graphs, for instance.\n* The update of the population tries to preserve, as much as possible, the existing mapping (that is, proxy agents do not change targets if they do not die or disappear from the list) */\nspecies species0 {\n\tfloat speed <- float(rnd(1000));\n}\n\nspecies species1 mirrors: species0 skills: [moving] {\n\tpoint location update: target.location + { 10, 10 };\n\tfloat speed1 update: self compute_speed_using_an_action (); // No parameter as \"max\" is defaulted\n\tfloat speed2 update: compute_speed_using_a_functional_attribute;\n\tfloat compute_speed_using_a_functional_attribute {\n\t\tspeed of target\n\t}\n\tfloat compute_speed_using_an_action (int max <- 100) {\n\t\treturn min([max, int(speed of target)]);\n\t}\n\n\tinit {\n\t\twrite \"I am \" + self.name + \" and my target is \" + target.name;\n\t}\n\n}\n\ngrid my_grid width: 100 height: 100 {\n}\n\nexperiment exp1 type: gui {\n\toutput {\n\t\tdisplay Display type: opengl {\n\t\t// Layers include a new keyword, \"graphics\", that allows to draw arbitrary shapes using the syntax found in the aspects of species\n\t\t// The same capability will be soon added to species/agents layers (in order to define on-the-fly aspects without changing the species itself)\n\t\t\tgraphics 'G' {\n\t\t\t\tdraw sphere(10) at: { 50, 50 };\n\t\t\t\tif (true) {\n\t\t\t\t\tdraw \"true\";\n\t\t\t\t} else {\n\t\t\t\t\tdraw \"false\";\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Syntax-models-Syntax-(1.6).md"},"Syntax-models.md":{"title":" Syntax models","content":"# Syntax models\n\nThis sub-section is composed of the following models :\n\n* [Casting Syntax](references#SyntaxmodelsCasting)\n\n* [Lists](references#SyntaxmodelsLists)\n\n* [Maps](references#SyntaxmodelsMaps)\n\n* [Syntax](references#SyntaxmodelsSyntax(1.6))\n\n","url":"wiki/Syntax-models.md"},"Ants-(Foraging-and-Sorting)-Ant-Foraging-(Charts-examples).md":{"title":" Ant Foraging (Charts examples)","content":"[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|operator_min_of)\n[//]: # (keyword|operator_sort)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_contains)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|statement_datalist)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|constant_#violet)\n[//]: # (keyword|constant_#purple)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_chart)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_diffusion)\n# Ant Foraging (Charts examples)\n\n\n_Author : _\n\nToy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. In this model, the charts are particularly used.\n\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\Ants-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\Ants-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartHisto-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartHisto-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartHistoList-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartHistoList-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartHistoListList-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartHistoListList-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartPie-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartPie-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartPieList-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartPieList-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartScatter-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartScatter-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartScatterHistory-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartScatterHistory-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartScatterList-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartScatterList-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartSerie-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartSerie-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartSerieList-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartSerieList-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartSeriesListList-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\ChartSeriesListList-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\Cyclevalues-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\Cyclevalues-10.png)\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\Dispscaleoption-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Ants (Foraging and Sorting)\\Ants (Foraging and Sorting) Ant Foraging (Charts examples)\\Dispscaleoption-10.png)\n\nCode of the model : \n\n```\nmodel ants\n\nglobal {\n\t//Number of ants\n\tint ants_number <- 100 min: 1 max: 2000 ;\n\t//Evaporation value per cycle for the pheromons\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 ;\n\t//Diffusion rate for the pheromons\n\tfloat diffusion_rate <- 1.0 min: 0.0 max: 1.0 ;\n\tbool use_icons <- true ;\n\tbool display_state <- true;\n\t//Size of the grid\n\tint gridsize <- 75 ;\n\t//Center of the grid to put the location of the nest\n\tconst center type: point <- { (gridsize / 2),  (gridsize / 2)} ;\n\tconst types type: file <- (pgm_file('../images/environment75x75.pgm')) ;\n\tconst ant_shape_empty type: string <- '../icons/ant.png' ;\n\tconst ant_shape_full type: string <- '../icons/full_ant.png'  ;\n\tconst C00CC00 type: rgb <- rgb('#00CC00') ;    \n\tconst C009900 type: rgb <- rgb('#009900') ; \n\tconst C005500 type: rgb <- rgb('#005500') ; \n\tint food_gathered <- 0 ;   \n\tgeometry shape <- square(gridsize);\n\tinit{  \n\t\t//Ant are placed randomly in the nest\n\t\tcreate ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;\n\t}\n\t\n\t//Reflex to diffuse the road of pheromon on the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;\n   }\n\n}\n\n//Grid to discretize space for the food and the nest\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {\n\tbool multiagent <- true ;\n\tfloat road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\n\tint type <- int(types at {grid_x,grid_y}) ;\n\tbool isNestLocation <- (self distance_to center) < 4 ; \n\tbool isFoodLocation <- type = 2 ; \n\trgb color <- isNestLocation ? °violet:((food > 0)? °blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) update: isNestLocation ? °violet:((food > 0)? °blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) ;\n\tint food <- isFoodLocation ? 5 : 0 ;\n\tconst nest type: int <- 300 - int(self distance_to center) ;\n\t\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 2.0 ;\n\tant_grid place update: ant_grid (location ); \n\tstring im <- 'ant_shape_empty' ;\n\tbool hasFood <- false ;\n\treflex diffuse_road when:hasFood=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n   //Action to pick food\n\taction pick {\n\t\tim <- ant_shape_full ;\n\t\thasFood <- true ;\n\t\tplace.food <- place.food - 1 ;\n\t}\n\t//Action to drop food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1 ;\n\t\thasFood <- false ;\n\t\theading <- heading - 180 ;\n\t}\n\t//Action to chose the best place according to the possible food in the neighbour cells\n\taction choose_best_place type: ant_grid {\n\t\tlist<ant_grid> list_places <- place.neighbors ;\n\t\tif (list_places count (each.food > 0)) > 0  {\n\t\t\treturn (list_places first_with (each.food > 0)) ;\n\t\t} else {\n\t\t\t\tint min_nest  <-  (list_places min_of (each.nest)) ;\n\t\t\t\tlist_places <- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;\n\t\t\t\treturn last(list_places) ;\n\t\t\t}\n\t}\n\t\n\t//Initial state of the ant : wander until it finds food or find a road to follow\n\tstate wandering initial: true {\n\t\tdo wander amplitude:120 ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: followingRoad when: place.road > 0.05 ;\n\t}\n\t//State to carry food to the nest once the food is found\n\tstate carryingFood {\n\t\tdo goto target: center ;\n\t\ttransition to: wandering when: place.isNestLocation { \n\t\t\tdo drop ;\n\t\t}\n\t}\n\t//State to follow a road \n\tstate followingRoad {\n\t\tlocation <- (self choose_best_place []) as point ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: wandering when: (place.road < 0.05) ;\n\t}\n\taspect text {\n\t\tif use_icons {\n\t\t\tdraw  hasFood ? file(ant_shape_full) : file(ant_shape_empty) rotate: heading at: location size: {7,5} ;\n\t\t} else {\n\t\t\tdraw circle(1.0) empty: !hasFood color: rgb ('orange') ;\n\t\t}\n\t\tif display_state {\n\t\t\tdraw state at: location + {-3,1.5} color: °white size: 0.8 ;\n\t\t}\n\t}\n\taspect default {\n\t\tdraw circle(1.0) empty: !hasFood color: #orange ; \n\t}\n}\nexperiment Ant type: gui {\n\t//Parameters to play with  in the gui\n\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\n\tparameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\n\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\n\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\n\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\n\n\tlist<list<int>> nbants<-[[0]];\n\tlist<string> statesnames<-[\"\"];\n\tlist<string> categnames<-[\"empty\",\"carry\"];\n\tlist<list<int>> nbantsbydist<-[[0]];\n\tlist xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\n\tlist<list<int>> xyval<-[[1,1],[2,1],[3,2]];\n\t\n\t//Reflex to update the charts, belonging to the experiment bloc as it will not be used by other experiment which don't have the charts\n\treflex update_charts\n\t{\n\t\tnbants<-[];\n\t\tstatesnames<-[];\n\t\tcategnames<-[\"empty\",\"carry\"];\n\t\tnbantsbydist<-[];\n\t\tant x<-one_of(world.ant);\n\t\tloop x over:list(world.ant)\n\t\t{\n\t\t\tif !(statesnames contains (x.state))\n\t\t\t{\t\t\t\t\n\t\t\tadd [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;\n\t\t\tadd (x.state) to:statesnames;\t\t\t\t\n\t\t\tint d<-0;\n\t\t\tlist<int> nl<-[];\n\t\t\tloop d from:0 to:9\n\t\t\t\t{\n\t\t\tadd (list(ant) count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;\n\t\t\t\t}\n\t\t\tadd nl to:nbantsbydist;\n\t\t\t}\n//\t\t\tadd length((list(world.ant) collect (each.next_place distance_to each.location)) where (each=x)) to:nbants;\n\t\t}\n\t\t//write(\"nbants\"+nbants);\n\t\t//write(\"nbantsbydist\"+nbantsbydist);\n\t\t//write(\"states\"+statesnames);\t\t\n\t}\n\t//The different displays\n\toutput {\n\t\tdisplay Ants type: opengl {\n\t\t\tgrid ant_grid ;\n\t\t\tspecies ant aspect: text ;\n\t\t}\n\t\tdisplay ChartPie {\n\t\t\tchart \"DataPie\" type:pie\n\t\t\t{\n\t\t\t\tdata \"empty_ants\" value:(list(ant) count (!each.hasFood)) color:°red;\n\t\t\t\tdata \"carry_food_ants\" value:(list(ant) count (each.hasFood)) color:°green;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tdisplay ChartPieList {\n\t\t\tchart \"DataListPie\" type:pie style:exploded\n\t\t\t{\n\t\t\t\tdatalist [\"empty\",\"carry\"] value:[(list(ant) count (!each.hasFood)),(list(ant) count (each.hasFood))] color:[°red,°green];\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tdisplay ChartHisto {\n\t\t\tchart \"DataBar\" type:histogram\n\t\t\t{\n\t\t\t\tdata \"empty_ants\" value:(list(ant) count (!each.hasFood)) color:°red;\n\t\t\t\tdata \"carry_food_ants\" value:(list(ant) count (each.hasFood)) color:°green;\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tdisplay ChartHistoList {\n\t\t\tchart \"DataListBar\" type:histogram style:\"3d\"\n\t\t\t{\n\t\t\t\tdatalist [\"empty\",\"carry\"] value:[(list(ant) count (!each.hasFood)),(list(ant) count (each.hasFood))] color:[°red,°green];\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tdisplay ChartHistoListList {\n\t\t\tchart \"DataListListBar\" type:histogram\n\t\t\t{\n\t\t\t\tdatalist categoriesnames:categnames  value:nbants legend:statesnames inverse_series_categories :false style:stack;\n\t\t\t}\n\t\t}\n\t\tdisplay ChartSerie {\n\t\t\tchart \"DataSeries\" type:series\n\t\t\t{\n\t\t\t\tdata \"empty_ants\" value:float((list(ant) count (!each.hasFood))) color:°red;\n\t\t\t\tdata \"carry_food_ants\" value:float((list(ant) count (each.hasFood))) color:°green;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\n\t\tdisplay Dispscaleoption\n\t\t{\n\t\t\tchart \"simpleserieslist\" type:series  y_range:{-6.11, -4.11} x_tick_unit:0.5 y_tick_unit:0.05\n\t\t\t{\n\t\t\t\tdata value:[-5,-6,-8] legend:\"prems\" color:°blue marker_shape:marker_square fill:false;\n\t\t\t\tdata value:[-5.5,-4.11,-5.645] legend:\"sec\" color:°red marker_shape:marker_empty;\n\t\t\t\tdata value:[-7,-6,-4.654] legend:\"third\" color:°green marker_shape:marker_hor_ellipse fill:false;\n\t\t\t}\n\t\t}\n\t\tdisplay Cyclevalues\n\t\t{\n\t\t\tchart \"simplecyclelist\" type:xy x_tick_unit:0.5 y_tick_unit:0.5\n\t\t\t{\n\t\t\t\tdata value:{-5+cycle,-4} legend:\"prems\" color:°blue marker_shape:marker_square fill:false;\n\t\t\t\tdata value:{-5.5+cycle,-3.5} legend:\"sec\" color:°red marker_shape:marker_diamond;\n\t\t\t\tdata value:{-7+cycle,-4.654} legend:\"third\" color:°green marker_shape:marker_hor_ellipse fill:false;\n\t\t\t}\n\t\t}\n\t\t\tdisplay ChartSerieList {\n\t\t\tchart \"DataListSeries\" type:series\n\t\t\t{\n\t\t\t\tdatalist [\"food\",\"empty\"] value:[(list(ant) count (each.hasFood)),(list(ant) count (!each.hasFood))] color:[°purple,°black] style:area;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tdisplay ChartSeriesListList {\n\t\t\tchart \"DataListListSeries\" type:series\n\t\t\t{\n\t\t\t\tdatalist categoriesnames:categnames  value:nbants legend:statesnames inverse_series_categories :false style:line;\n\t\t\t}\n\t\t}\n\t\tdisplay ChartScatter {\n\t\t\tchart \"DataScatter\" type:scatter\n\t\t\t{\n\t\t\t\tdata \"empty_ants\" value:((list(ant) where (!each.hasFood)) collect each.location) color:°red line_visible:false;\n\t\t\t\tdata \"carry_food_ants\" value:((list(ant) where (each.hasFood)) collect each.location) color:°green line_visible:false;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tdisplay ChartScatterList {\n\t\t\tchart \"DataListScatter\" type:scatter\n\t\t\t{\n\t\t\t\tdatalist [\"empty\",\"carry\"] value:[((list(ant) where (!each.hasFood))  collect each.location),((list(ant) where (each.hasFood))  collect each.location)] color:[°red,°green] line_visible:false;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tdisplay ChartScatterHistory {\n\t\t\tchart \"DataListScatterHistory\" type:scatter\n\t\t\t{\n\t\t\t\tdatalist [\"empty\",\"carry\"] value:[mean((list(ant) where (!each.hasFood)) collect each.location),mean((list(ant) where (each.hasFood)) collect each.location)]\n\t\t\t\t\t color:[°red,°green] line_visible:true;\t\t\t\t\n\t\t\t}\n\t\t}\t\n\t\t}\n\t\n\t}\n\t\n//Experiment with only two display : the grid and the ants, and a chart\nexperiment AntOneDisp type: gui {\n\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\n\tparameter 'Evaporation of the signal unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\n\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\n\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\n\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\n\n\tlist<list<int>> nbants<-[[0]];\n\tlist<string> statesnames<-[\"\"];\n\tlist<string> categnames<-[\"empty\",\"carry\"];\n\tlist<list<int>> nbantsbydist<-[[0]];\n\tlist xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\n\tlist<list<int>> xyval<-[[1,1],[2,1],[3,2]];\n\n\treflex update_charts\n\t{\n\t\tant x<-one_of(world.ant);\n\t\tloop x over:list(world.ant)\n\t\t{\n\t\t\tif !(statesnames contains (x.state))\n\t\t\t{\t\t\t\t\n\t\t\tadd [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;\n\t\t\tadd (x.state) to:statesnames;\t\t\t\t\n\t\t\tint d<-0;\n\t\t\tlist<int> nl<-[];\n\t\t\tloop d from:0 to:9\n\t\t\t\t{\n\t\t\tadd (list(ant) count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;\n\t\t\t\t}\n\t\t\tadd nl to:nbantsbydist;\n\t\t\t}\n\t\t}\n\t\twrite(\"nbants\"+nbants);\n\t\twrite(\"nbantsbydist\"+nbantsbydist);\n\t\twrite(\"states\"+statesnames);\t\t\n\t}\n\toutput {\n\t\tdisplay Ants type: opengl {\n\t\t\tgrid ant_grid ;\n\t\t\tspecies ant aspect: text ;\n\t\t}\n\n\t\tdisplay ChartSerieList {\n\t\t\tchart \"DataListScatterHistory\" type:scatter\n\t\t\t{\n\t\t\t\tdatalist [\"empty\",\"carry\"] value:[mean((list(ant) where (!each.hasFood)) collect each.location),mean((list(ant) where (each.hasFood)) collect each.location)]\n\t\t\t\t\t color:[°red,°green] line_visible:true;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Charts-examples).md"},"Ants-(Foraging-and-Sorting)-Ant-Foraging-(Classic).md":{"title":" Ant Foraging (Classic)","content":"[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|operator_min_of)\n[//]: # (keyword|operator_sort)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_font)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|constant_#zoom)\n[//]: # (keyword|constant_#plain)\n[//]: # (keyword|constant_#sienna)\n[//]: # (keyword|constant_#brown)\n[//]: # (keyword|constant_#darkgoldenrod)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_diffusion)\n# Ant Foraging (Classic)\n\n\n_Author : _\n\nToy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. This model is considered as the classic one.\n\n\nCode of the model : \n\n```\nmodel ants\n\nglobal {\n\t//Number of ants\n\tint ants_number <- 100 min: 1 max: 2000 ;\n\t//Evaporation value per cycle\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 ;\n\t//Diffusion rate for the pheromon diffused among the grid\n\tfloat diffusion_rate <- 0.5 min: 0.0 max: 1.0 ;\n\tbool use_icons <- true ;\n\tbool display_state <- true;\n\t//Size of the grid\n\tint gridsize <- 75 ;\n\t//Center of the grid that will be used as a nest for the ants\n\tpoint center const: true <- { (gridsize / 2),  (gridsize / 2)} ;\n\tfile types const: true <- (pgm_file('../images/environment75x75.pgm')) ;\n\tstring ant_shape_empty const: true <- '../icons/ant.png' ;\n\tstring ant_shape_full const: true <- '../icons/full_ant.png'  ;\n\trgb C00CC00 const: true <- rgb('#00CC00') ;    \n\trgb C009900 const: true <- rgb('#009900') ; \n\trgb C005500 const: true <- rgb('#005500') ; \n\tint food_gathered <- 0 ;    \n\tgeometry shape <- square(gridsize);\n\tinit{  \n\t\t//Creation of the ants that will be placed randomly in the nest\n\t\tcreate ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;\n\t}\n\t//Reflex to diffuse the pheromon among the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;\n   }\n\n}\n\n//Grid that will be used to place the food in a discretized space\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {\n\tlist<ant_grid> neighbours <- self neighbors_at 1;\n\tfloat road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\n\tint type <- int(types at {grid_x,grid_y}) ;\n\tbool isNestLocation <- (self distance_to center) < 4 ;\n\tbool isFoodLocation <- type = 2 ; \n\trgb color <- isNestLocation ? °sienna:((food > 0)? °brown : ((road < 0.001)? #darkgoldenrod: ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) update: isNestLocation ? °sienna:((food > 0)? °brown : ((road < 0.001)?#darkgoldenrod : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) ;\n\tint food <- isFoodLocation ? 5 : 0 ;\n\tint nest const: true <- 300 - int(self distance_to center) ;\n\t\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 2.0 ;\n\tant_grid place update: ant_grid (location ); \n\tstring im <- 'ant_shape_empty' ;\n\tbool hasFood <- false ;\n\t//Reflex to allow the diffusion of the road of pheromon by putting pheromon inside a cell\n\treflex diffuse_road when:hasFood=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n   //Action to pick the food\n\taction pick {\n\t\tim <- ant_shape_full ;\n\t\thasFood <- true ;\n\t\tplace.food <- place.food - 1 ;\n\t}\n\t//Action to drop the food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1 ;  \n\t\thasFood <- false ;\n\t\theading <- heading - 180 ;\n\t}\n\t//Action to find the best cell in the neighbourhood of the ant\n\taction choose_best_place type: ant_grid {  \n\t\tlist<ant_grid> list_places <- place.neighbours ;\n\t\tif (list_places count (each.food > 0)) > 0  { \n\t\t\treturn (list_places first_with (each.food > 0)) ;\n\t\t} else {\n\t\t\t\tint min_nest  <-  (list_places min_of (each.nest)) ;\n\t\t\t\tlist_places <- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;\n\t\t\t\treturn last(list_places) ;\n\t\t\t}\n\t} \n\t//initial state of the ant that will make it wander until it finds food or a road\n\tstate wandering initial: true { \n\t\tdo wander amplitude:120 ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\t\n\t\t\t \n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: followingRoad when: place.road > 0.05 ; \n\t}\n\t//State to carry food to the nest once it has been found\n\tstate carryingFood {\n\t\tdo goto target: center ;\n\t\ttransition to: wandering when: place.isNestLocation { \n\t\t\tdo drop ;\n\t\t}\n\t}\n\t//State to follow a pheromon road once it has been found\n\tstate followingRoad {\n\t\tlocation <- (self choose_best_place()) as point ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: wandering when: (place.road < 0.05) ;\n\t}\n\taspect text {\n\t\tif use_icons {\n\t\t\tdraw  hasFood ? file(ant_shape_full) : file(ant_shape_empty) rotate: heading at: location size: {8,5} ;\n\t\t} else {\n\t\t\tdraw circle(1.0) empty: !hasFood color: rgb ('orange') ;\n\t\t}\n\t\tif display_state {\n\t\t\tdraw state at: location + {-3,1.5} color: °white font: font(\"Helvetica\", 14 * #zoom, #plain) perspective:true;\n\t\t}\n\t} \n\taspect default {\n\t\tdraw circle(1.0) empty: !hasFood color: #orange ; \n\t}           \n}\n\nexperiment Ant type: gui {\n\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\n\tparameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\n\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\n\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\n\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\n\toutput {\n\t\tdisplay Ants type: opengl  {\n\t\t\tgrid ant_grid ;\n\t\t\tspecies ant aspect: text ;\n\t\t}\n\t}\n}\n\n\n```\n","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Classic).md"},"Ants-(Foraging-and-Sorting)-Ant-Foraging-(Complex).md":{"title":" Ant Foraging (Complex)","content":"[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|operator_round)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_font)\n[//]: # (keyword|operator_distance_between)\n[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|statement_agents)\n[//]: # (keyword|statement_overlay)\n[//]: # (keyword|statement_inspect)\n[//]: # (keyword|statement_exhaustive)\n[//]: # (keyword|statement_permanent)\n[//]: # (keyword|statement_genetic)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|constant_#zoom)\n[//]: # (keyword|constant_#bold)\n[//]: # (keyword|constant_#plain)\n[//]: # (keyword|constant_#darkgray)\n[//]: # (keyword|constant_#pixels)\n[//]: # (keyword|constant_#darkgreen)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_batch)\n[//]: # (keyword|concept_diffusion)\n# Ant Foraging (Complex)\n\n\n_Author : _\n\nToy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. Two experiments are proposed to show how to use batch : Batch and Genetic.\n\n\nCode of the model : \n\n```\nmodel ants\n\nglobal {\n\t//Evaporation value per cycle\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 parameter: 'Evaporation of the signal (unit/cycle):' category: 'Signals';\n\t//Diffusion rate of the pheromon among the grid\n\tfloat diffusion_rate <- 1.0 min: 0.0 max: 1.0 parameter: 'Rate of diffusion of the signal (%/cycle):' category: 'Signals';\n\t//Size of the grid\n\tint gridsize <- 100 min: 30 parameter: 'Width and Height of the grid:' category: 'Environment and Population';\n\t//Number of ants\n\tint ants_number <- 200 min: 1 parameter: 'Number of ants:' category: 'Environment and Population';\n\t//Frequency of update of the grid\n\tint grid_frequency <- 1 min: 1 max: 100 parameter: 'Grid updates itself every:' category: 'Environment and Population';\n\t//Number of food places among the grid\n\tint number_of_food_places <- 5 min: 1 parameter: 'Number of food depots:' category: 'Environment and Population';\n\tfloat grid_transparency <- 1.0;\n\tfile ant_shape_empty const: true <- file('../icons/ant.png');\n\timage_file ant_shape_full const: true <- file('../icons/full_ant.png');\n\t//The center of the grid that will be considered as the nest location\n\tpoint center const: true <- { round(gridsize / 2), round(gridsize / 2) };\n\tint food_gathered <- 1;\n\tint food_placed <- 1;\n\trgb background const: true <- rgb(#99CC66);\n\trgb food_color const: true <- rgb(#312200);\n\trgb nest_color const: true <- rgb(#000000); \n\n\tgeometry shape <- square(gridsize);\n\tinit {\n\t\t//Creation of the food places placed randomly with a certain distance between each\n\t\tloop times: number_of_food_places {\n\t\t\tpoint loc <- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };\n\t\t\tlist<ant_grid> food_places <- (ant_grid where ((each distance_to loc) < 5));\n\t\t\task food_places {\n\t\t\t\tif food = 0 {\n\t\t\t\t\tfood <- 5;\n\t\t\t\t\tfood_placed <- food_placed + 5;\n\t\t\t\t\tcolor <- food_color;  \n\t\t\t\t}                                           \n\t\t\t}\n\t\t}\n\t\t//Creation of the ants that will be placed in the nest\n\t\tcreate ant number: ants_number with: (location: center);\n\t}\n\t//Reflex to diffuse the pheromon among the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:3 propagation: gradient method:convolution;\n   }\n  \n}\n\n//Grid used to discretize the space to place food\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 frequency: grid_frequency use_regular_agents: false use_individual_shapes: false{\n\tbool is_nest const: true <- (topology(ant_grid) distance_between [self, center]) < 4;\n\tfloat road <- 0.0 max: 240.0 update: (road <= evaporation_per_cycle) ? 0.0 : road - evaporation_per_cycle;\n\trgb color <- is_nest ? nest_color : ((food > 0) ? food_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food > 0) ?\n\tfood_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5)));\n\tint food <- 0;\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 1.0;\n\tbool has_food <- false;\n\t\n\t//Reflex to place a pheromon stock in the cell\n\treflex diffuse_road when:has_food=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n\t//Action to pick food\n\taction pick (int amount) {\n\t\thas_food <- true;\n\t\tant_grid place <- ant_grid(location);\n\t\tplace.food <- place.food - amount;\n\t}\n\t//Action to drop food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1;\n\t\thas_food <- false;\n\t\theading <- heading - 180;\n\t}\n\t//Action to find the best place in the neighborhood cells\n\tpoint choose_best_place {\n\t\tcontainer list_places <- ant_grid(location).neighbors;\n\t\tif (list_places count (each.food > 0)) > 0 {\n\t\t\treturn point(list_places first_with (each.food > 0));\n\t\t} else {\n\t\t\tlist_places <- (list_places where ((each.road > 0) and ((each distance_to center) > (self distance_to center)))) sort_by (each.road);\n\t\t\treturn point(last(list_places));\n\t\t}\n\n\t}\n\t//Reflex to drop food once the ant is in the nest\n\treflex drop when: has_food and (ant_grid(location)).is_nest {\n\t\tdo drop();\n\t}\n\t//Reflex to pick food when there is one at the same location\n\treflex pick when: !has_food and (ant_grid(location)).food > 0 {\n\t\tdo pick(1);\n\t}\n\t//Initial state to make the ant wander \n\tstate wandering initial: true {\n\t\tdo wander(amplitude: 90);\n\t\tfloat pr <- (ant_grid(location)).road;\n\t\ttransition to: carryingFood when: has_food;\n\t\ttransition to: followingRoad when: (pr > 0.05) and (pr < 4);\n\t}\n\t//State to carry food once it has been found\n\tstate carryingFood {\n\t\tdo goto(target: center);\n\t\ttransition to: wandering when: !has_food;\n\t}\n\t//State to follow a pheromon road if once has been found\n\tstate followingRoad {\n\t\tpoint next_place <- choose_best_place();\n\t\tfloat pr <- (ant_grid(location)).road;\n\t\tlocation <- next_place;\n\t\ttransition to: carryingFood when: has_food;\n\t\ttransition to: wandering when: (pr < 0.05) or (next_place = nil);\n\t}\n\n\taspect info {\n\t\tdraw circle(1) empty: !has_food color: #red;\n\t\tif (destination != nil) {\n\t\t\tdraw line([location + {0,0,0.5}, destination + {0,0,0.5}]) + 0.1 color: #white border: false;\n\t\t}\n\n\t\tdraw circle(4) empty: true color: #white;\n\t\tdraw string(self as int) color: #white font: font(\"Helvetica\", 12 * #zoom, #bold) at: my location - {1, 1, -0.5};\n\t\tdraw state color: #yellow  font: font(\"Helvetica\", 10 * #zoom, #plain) at: my location + { 1, 1, 0.5 } perspective: false;\n\t}\n\n\taspect icon {\n\t\tdraw ant_shape_empty size: {7,5} rotate: my heading + 1;\n\t}\n\n\taspect default {\n\t\tdraw square(1) empty: !has_food color: #blue rotate: my heading;\n\t}\n}\t\n//Simple experiment to display the ants\nexperiment Displays type: gui {\n\tpoint quadrant_size <- { 0.5, 0.5 };\n\tfloat inc <- 0.001;\n\tfloat pos <- 0.0;\n\treflex moving_quadrant {\n\t//pos <- pos + inc;\n\t\tif (pos > 0.5 or pos <= 0) {\n\t\t\tinc <- -inc;\n\t\t}\n\t\t\n\t}\n\n\toutput {\n\t\tdisplay Ants background: #white type: opengl {\n\t\t\timage '../images/soil.jpg' position: { pos, pos } size: quadrant_size;\n\t\t\tagents \"agents\" transparency: 0.5 position: { pos, pos } size: quadrant_size value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n\t\t\tspecies ant position: { pos, pos } size: quadrant_size aspect: icon;\n\t\t\tgrid ant_grid lines: #darkgray position: { 0.5, 0 } size: quadrant_size;\n\t\t\tspecies ant position: { 0.5, 0 } size: quadrant_size aspect: info;\n\t\t}\n\t}\n}\n//Complete experiment that will inspect all ants in a table\nexperiment Complete type: gui {\n\tparameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\n\tparameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\n\tparameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\n\n\t// Experimentator\n\n\tinit {\n\t\twrite \"Experimentator agent running \" + self;\n\t   ants_number <- 200;\n\t}\n\n\n\toutput {\n\t\tdisplay Ants2D type: java2D {\n\t\t\timage '../images/soil.jpg' position: { 0.05, 0.05 } size: { 0.9, 0.9 };\n\t\t\tagents \"agents\" transparency: 0.7 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest)) ;\n\t\t\tspecies ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;\n\t\t\toverlay \"Texts\" transparency: 0.3 background: rgb (99, 85, 66,255)  position: {10°px, 10°px} size: {250°px, 150°px} border: rgb (99, 85, 66,255) rounded: true{\n\t\t\t\tdraw ant_shape_full at: {60°px, 70°px} size: {140°px, 100°px} rotate: -60;\n\t\t\t\tdraw ('Food foraged: ' + (((food_placed = 0 ? 0 : food_gathered / food_placed) * 100) with_precision 2) + '%') at: {40°px,70°px} font:font(\"Arial\", 18, #bold) color: #white;\n\t\t\t\tdraw ('Carrying ants: ' + (((100 * ant count (each.has_food or each.state = \"followingRoad\")) / length(ant)) with_precision 2) + '%') at: {40°px, 100°px} font:font(\"Arial\", 18 , #bold) color: #white;\n\t\t\t}\n\t\t\t\t\t\n\t\t}\n\t\tinspect \"All ants\" type: table value: ant attributes: ['name', 'location', 'heading','state'];\n\t}\n}\n//Batch experiment to find the best way to maximize the food gathered using exhaustive method\nexperiment Batch type: batch repeat: 4 keep_seed: true until: (food_gathered = food_placed) or (time > 1000) {\n\tparameter 'Size of the grid:' var: gridsize init: 75 unit: 'width and height';\n\tparameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';\n\tparameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';\n\tparameter  'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;\n\tmethod exhaustive maximize: food_gathered;\n\n\t\n\tpermanent {\n\t\tdisplay Comparison background: #white {\n\t\t\tchart \"Food Gathered\" type: series {\n\t\t\t\t\tdata \"Min\" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;\n\t\t\t\t\tdata \"Max\" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Batch experiment to find the best way to maximize the food gathered using genetic method\nexperiment Genetic type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time > 1000) {\n\tparameter 'Size of the grid:' var: gridsize init: 75 unit: '(width and height)';\n\tparameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';\n\tparameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';\n\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;\n\tmethod genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;\n\t\n\t\tpermanent {\n\t\tdisplay Comparison background: #white {\n\t\t\tchart \"Food Gathered\" type: series {\n\t\t\t\t\tdata \"Min\" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;\n\t\t\t\t\tdata \"Max\" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Complex).md"},"Ants-(Foraging-and-Sorting)-Ant-Foraging-(Multi-Simulation).md":{"title":" Ant Foraging (Multi-Simulation)","content":"[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|operator_round)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_distance_between)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|statement_permanent)\n[//]: # (keyword|statement_agents)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_multi_simulation)\n[//]: # (keyword|concept_diffusion)\n# Ant Foraging (Multi-Simulation)\n\n\n_Author : _\n\nToy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. \n\n\nCode of the model : \n\n```\nmodel ants\n\nglobal {\n\t//Evaporation value per cycle of the pheromons\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 parameter: 'Evaporation of the signal (unit/cycle):' category: 'Signals';\n\t//Diffusion rate of the pheromons\n\tfloat diffusion_rate <- 1.0 min: 0.0 max: 1.0 parameter: 'Rate of diffusion of the signal (%/cycle):' category: 'Signals';\n\t//Size of the grid\n\tint gridsize <- 100 min: 30 parameter: 'Width and Height of the grid:' category: 'Environment and Population';\n\t//Number of ants that will be created\n\tint ants_number <- 50 min: 1 parameter: 'Number of ants:' category: 'Environment and Population';\n\t//Number of food places to create\n\tint number_of_food_places <- 5 min: 1 parameter: 'Number of food depots:' category: 'Environment and Population';\n\tfloat grid_transparency <- 1.0;\n\tfile ant_shape_empty const: true <- file('../icons/ant.png');\n\tstring ant_shape_full const: true <- '../icons/full_ant.png';\n\tpoint center const: true <- { round(gridsize / 2), round(gridsize / 2) };\n\tint food_gathered  <- 1;\n\tint food_placed  <- 1;\n\trgb background const: true <- rgb(#99CC66);\n\trgb food_color const: true <- rgb(#312200);\n\trgb nest_color const: true <- rgb(#000000); \n\n\tgeometry shape <- square(gridsize);\n\tinit {\n\t\t//Creation of the food places placed randomly with a certain distance between each\n\t\tloop times: number_of_food_places {\n\t\t\tpoint loc <- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };\n\t\t\tlist<ant_grid> food_places <- (ant_grid where ((each distance_to loc) < 5));\n\t\t\task food_places {\n\t\t\t\tif food = 0 {\n\t\t\t\t\tfood <- 5;\n\t\t\t\t\tfood_placed <- food_placed + 5;\n\t\t\t\t\tcolor <- food_color;  \n\t\t\t\t}                                           \n\t\t\t}\n\t\t}\n\t\t//Creation of the ants that will be placed in the nest\n\t\tcreate ant number: ants_number with: (location: center);\n\t\t//Write the index of the simulation\n\t\twrite \"Simulation \" + int(self) + \" created\";\n\t}\n\t//Reflex to diffuse the pheromon among the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;\n   }\n  \n\n  \n} \n\n//Grid used to discretize the space to place food\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 /*frequency: grid_frequency*/ use_regular_agents: false use_individual_shapes: false{\n\tbool is_nest const: true <- (topology(ant_grid) distance_between [self, center]) < 4;\n\tfloat road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\n\trgb color <- is_nest ? nest_color : ((food > 0) ? food_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food > 0) ?\n\tfood_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5)));\n\tint food <- 0;\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 1.0;\n\tbool has_food <- false;\n\t\n\t//Reflex to place a pheromon stock in the cell\n\treflex diffuse_road when:has_food=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n\t//Action to pick food\n\taction pick (int amount) {\n\t\thas_food <- true;\n\t\tant_grid place <- ant_grid(location);\n\t\tplace.food <- place.food - amount;\n\t}\n\t//Action to drop food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1;\n\t\thas_food <- false;\n\t\theading <- heading - 180;\n\t}\n\t//Action to find the best place in the neighborhood cells\t\n\tpoint choose_best_place {\n\t\tlist<ant_grid> list_places <- ant_grid(location).neighbors;\n\t\tif (list_places count (each.food > 0)) > 0 {\n\t\t\treturn point(list_places first_with (each.food > 0));\n\t\t} else {\n\t\t\tlist_places <- (list_places where ((each.road > 0) and ((each distance_to center) > (self distance_to center)))) sort_by (each.road);\n\t\t\treturn point(last(list_places));\n\t\t}\n\t}\n\t//Reflex to drop food once the ant is in the nest\t\n\treflex drop when: has_food and (ant_grid(location)).is_nest {\n\t\tdo drop();\n\t}\n\t//Reflex to pick food when there is one at the same location\n\treflex pick when: !has_food and (ant_grid(location)).food > 0 {\n\t\tdo pick(1);\n\t}\n\t//Initial state to make the ant wander \n\tstate wandering initial: true {\n\t\tdo wander(amplitude: 90);\n\t\tfloat pr <- (ant_grid(location)).road;\n\t\ttransition to: carryingFood when: has_food;\n\t\ttransition to: followingRoad when: (pr > 0.05) and (pr < 4);\n\t}\n\t//State to carry food once it has been found\n\tstate carryingFood {\n\t\tdo goto(target: center);\n\t\ttransition to: wandering when: !has_food;\n\t}\n\t//State to follow a pheromon road if once has been found\n\tstate followingRoad {\n\t\tpoint next_place <- choose_best_place();\n\t\tfloat pr <- (ant_grid(location)).road;\n\t\tlocation <- next_place;\n\t\ttransition to: carryingFood when: has_food;\n\t\ttransition to: wandering when: (pr < 0.05) or (next_place = nil);\n\t}\n\n\taspect icon {\n\t\tdraw ant_shape_empty size: {8,6} rotate: my heading + 1;\n\t}\n\n}\t\n\n\n\n\n//Experiment to show how to make multi simulations\nexperiment \"4 Simulations\" type: gui {\n\tparameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\n\tparameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\n\tparameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\n\n\t// We create three supplementary simulations using the species name 'ants_model' (automatically created from the name of the model + '_model')\n\n\tinit {\n\t\tcreate ants_model with: [ants_number::200,evaporation_rate::0.7,diffusion_rate::0.2];\n\t\tcreate ants_model with: [ants_number::50,evaporation_rate::0.05,diffusion_rate::0.8];\n\t\tcreate ants_model with: [ants_number::10,evaporation_rate::0.3,diffusion_rate::0.6];\n\t}\n\t\n\tpermanent {\n\t\tdisplay Comparison background: #white {\n\t\t\tchart \"Food Gathered\" type: series {\n\t\t\t\tloop s over: simulations {\n\t\t\t\t\tdata \"Food \" + int(s) value: s.food_gathered color: s.color marker: false style: line ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\toutput {\n\t\tdisplay Ants background: #white type: opengl{\n\t\t\timage '../images/soil.jpg' position: { 0.05, 0.05 } size: { 0.9, 0.9 };\n\t\t\tagents \"agents\" transparency: 0.5 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n\t\t\tspecies ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;\n\t\t}\n\t\n\t}\n}\n\n\n```\n","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Multi-Simulation).md"},"Ants-(Foraging-and-Sorting)-Ant-Foraging-(Simple).md":{"title":" Ant Foraging (Simple)","content":"[//]: # (keyword|operator_round)\n[//]: # (keyword|operator_min_of)\n[//]: # (keyword|operator_sort)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|statement_diffuse)\n[//]: # (keyword|statement_event)\n[//]: # (keyword|statement_exhaustive)\n[//]: # (keyword|statement_genetic)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_batch)\n[//]: # (keyword|concept_diffusion)\n# Ant Foraging (Simple)\n\n\n_Author : _\n\nToy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. This model is the simple one.\n\n\nCode of the model : \n\n```\nmodel ants\n\nglobal {\n\tint t <- 1;\n\t//Evaporation value per cycle of the pheromons\n\tfloat evaporation_per_cycle <- 5.0 min: 0.01 max: 240.0 ;\n\t//Diffusion rate of the pheromons\n\tfloat diffusion_rate const: true <- 1.0 min: 0.0 max: 1.0 ;\n\t//Size of the grid\n\tint gridsize const: true <- 75; \n\t//Number of ants to create\n\tint ants_number  <- 50 min: 1 max: 200 parameter: 'Number of Ants:';\n\t//Variable to keep information about the food remaining\n\tint food_remaining update: list ( ant_grid ) count ( each . food > 0) <- 10;\n\t//Center of the grid that will be considered as the nest of ants\n\tpoint center const: true <- { round ( gridsize / 2 ) , round ( gridsize / 2 ) };\n\tmatrix<int> types <- matrix<int> (pgm_file ( '../images/environment75x75_scarce.pgm' )); \n\t\n\tgeometry shape <- square(gridsize);\n\t\n\tinit {\n\t\t//Creation of the ants placed in the nest\n\t\tcreate ant number: ants_number with: [ location :: center ];\n\t} \n\t\n\t//Different actions triggered by an user interaction\n\taction press (point loc, list selected_agents)\n\t{\n\t\twrite(\"press \" + loc.x + \" \" + loc.y + \" \"+selected_agents);\n\t}\n\taction release (point loc, list selected_agents)\n\t{\n\t\twrite(\"release\");\n\t}\n\taction click  (point loc, list selected_agents)\n\t{\n\t\twrite(\"click\");\n\t}\n\taction click2   (point loc, list selected_agents)\n\t{\n\t\twrite(\"click2\");\n\t}\n\t//Reflex to diffuse the pheromons among the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;\n   }\n\n} \n//Grid used to discretize space to place food in cells\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 {\n\tbool isNestLocation  <- ( self distance_to center ) < 4;\n\tbool isFoodLocation <-  types[grid_x , grid_y] = 2;       \n\tlist<ant_grid> neighbours <- self neighbors_at 1;  \n\tfloat road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\n\trgb color <- rgb([ self.road > 15 ? 255 : ( isNestLocation ? 125 : 0 ) , self.road * 30 , self.road > 15 ? 255 : food * 50 ]) update: rgb([ self.road > 15 ? 255 : ( isNestLocation ? 125 : 0 ) ,self.road * 30 , self.road > 15 ? 255 : food * 50 ]); \n\tint food <- isFoodLocation ? 5 : 0; \n\tint nest const: true <- int(300 - ( self distance_to center ));\n}\n\n//Species ant that will move\nspecies ant skills: [ moving ] {     \n\trgb color <- #red;\n\tant_grid place function: {ant_grid ( location )};\n\tbool hasFood <- false; \n\tbool hasRoad <- false update: place . road > 0.05;\n\t\n\t//Reflex to diffuse pheromon on the cell once the agent has food\n\treflex diffuse_road when:hasFood=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n\t//Reflex to wander while the ant has no food\n\treflex wandering when: ( ! hasFood ) and ( ! hasRoad ) and ( place . food = 0) {\n\t\tdo wander amplitude: 120 speed: 1.0;\n\t}\n\t//Reflex to search food when the agent has no food nor pheromon road close\n\treflex looking when: ( ! hasFood ) and ( hasRoad ) and ( place . food = 0 ) { \n\t\tlist<ant_grid> list_places <- place . neighbours;\n\t\tant_grid goal <- list_places first_with ( each . food > 0 );\n\t\tif goal != nil {\n\t\t\tlocation <- goal.location ; \n\t\t} else {\n\t\t\tint min_nest <- ( list_places min_of ( each . nest ) );\n\t\t\tlist_places <- list_places sort ( ( each . nest = min_nest ) ? each . road : 0.0 ) ;\n\t\t\tlocation <- point ( last ( list_places ) ) ;\n\t\t}\n\t}\n\t//Reflex to take food\n\treflex taking when: ( ! hasFood ) and ( place . food > 0 ) { \n\t\thasFood <- true ;\n\t\tplace . food <- place . food - 1 ;\n\t}\n\t//Reflex to make the ant return to the nest once it has food\n\treflex homing when: ( hasFood ) and ( ! place . isNestLocation ) {\n\t\tdo goto target:center  speed:1.0;\n\t}\n\t//Reflex to drop food once the ant arrived at the nest\n\treflex dropping when: ( hasFood ) and ( place . isNestLocation ) {\n\t\thasFood <- false ;\n\t\theading <- heading - 180 ;\n\t}\n\taspect default {\n\t\tdraw circle(2.0) color: color;\n\t}\n\t\n}\n//Experiment simple to display ant and have user interaction\nexperiment Simple type:gui {\n\tparameter 'Evaporation:' var: evaporation_per_cycle;\n\tparameter 'Diffusion Rate:' var: diffusion_rate;\n\toutput { \n\t\tdisplay Ants refresh: every(2) { \n\t\t\tgrid ant_grid;\n\t\t\tspecies ant aspect: default;\n\t\t\tgraphics 'displayText' {\n\t\t\t\tdraw string ( food_remaining ) size: 24.0 at: { 20 , 20 } color: rgb ( 'white' );\n\t\t\t}\n\t\t\t//Event triggering the action passed in parameter\n\t\t\tevent mouse_down action:press;\n\t\t\tevent mouse_up action:release;\n\t\t}  \n\t\tdisplay Ants_2 refresh: every(2) { \n\t\t\tgrid ant_grid;\n\t\t\tgraphics 'displayText' {\n\t\t\t\tdraw string ( food_remaining ) size: 24.0 at: { 20 , 20 } color: rgb ( 'white' );\n\t\t\t}\n\t\t\tevent mouse_down action:press;\n\t\t\tevent mouse_up action:click2;\n\t\t}  \n\t}\n}\n\n// This experiment explores two parameters with an exhaustive strategy, \n// repeating each simulation two times, in order to find the best combination \n// of parameters to minimize the time taken by ants to gather all the food\nexperiment 'Exhaustive optimization' type: batch repeat: 2 keep_seed: true until: ( food_remaining = 0 ) or ( time > 400 ) {\n\tparameter 'Evaporation' var: evaporation_per_cycle among: [ 0.1 , 1.0 , 2.0 , 5.0 ,  10.0 ];\n\tparameter 'Diffusion rate' var: diffusion_rate min: 0.1 max: 1.0 step:\n\t0.3;\n\tmethod exhaustive minimize: time;\n}\n\n// This experiment simply explores two parameters with an exhaustive strategy, \n// repeating each simulation two times\nexperiment Repeated type: batch repeat: 2 keep_seed: true until: (\nfood_remaining = 0 ) or ( time > 400 ) {\n\tparameter 'Evaporation' var: evaporation_per_cycle among: [ 0.1 , 1.0 , 2.0 , 5.0 ,  10.0 ];\n\tparameter 'Diffusion rate' var: diffusion_rate min: 0.1 max: 1.0 step:0.3;\n}\n\n// This experiment explores two parameters with a GA strategy, \n// repeating each simulation two times, in order to find the best combination \n// of parameters to minimize the time taken by ants to gather all the food \nexperiment Genetic type: batch keep_seed: true repeat: 3 until: ( food_remaining\n= 0 ) or ( time > 400 ) {\n\tparameter 'Evaporation' var: evaporation_per_cycle min: 0.05 max: 10.0\n\tstep: 0.1;\n\tparameter 'Diffusion rate' var: diffusion_rate min: 0.0 max: 1.0 step:\n\t0.01;\n\tmethod genetic pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1\n\tnb_prelim_gen: 1 max_gen: 20 minimize: time;\n}\n```\n","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Simple).md"},"Ants-(Foraging-and-Sorting)-Ant-Sorting.md":{"title":" Ant Sorting","content":"[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|statement_state)\n[//]: # (keyword|statement_transition)\n[//]: # (keyword|statement_enter)\n[//]: # (keyword|skill_fsm)\n[//]: # (keyword|constant_#cyan)\n[//]: # (keyword|constant_#magenta)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_grid)\n# Ant Sorting\n\n\n_Author : _\n\nThis model is loosely based on the behavior of ants sorting different elements in their nest. A of mobile agents - the ants - is placed on a grid. The grid itself contains cells of different colors. Each step, the agents move randomly. If they enter a colored cell, they pick this color if its density in the neighbourhood is less than *number_of_objects_around*. If they have picked a color, they drop it on a black cell if they have encountered at least *number_of_objects_in_history* cells with the same color.\\n After a while, colors begin to be aggregated.\n\n\nCode of the model : \n\n```\n\nmodel ant_sort\n\nglobal  {\n\t// Parameters \n\tint number_of_different_colors <- 5 max: 9 ;\n\tint density_percent <- 30 min: 0 max: 99 ;\n\tint number_of_objects_in_history <- 3 min: 0 ;\n\tint number_of_objects_around  <- 5 min: 0 max: 8;\n\tint width_and_height_of_grid <- 128 max: 400 min: 10 ;  \n\tint ants <- 20 min: 1 ;\n\t\n\t//Action to kill all the ants\n\taction kill_all {\n\t\task ant {do die;}\n\t}\n\t\n\t//Action to create all the ants\n\taction create_all {\n\t\tcreate ant number: ants;\n\t}\n\n\trgb black <- #black  ;\t\n\tlist<rgb> colors const: true <- [#yellow,#red, #orange, #blue, #green,#cyan, #gray,#pink,#magenta] ;\n\t//Action to write the description of the model\n\taction description {\n\t\twrite \"\\n Description. \\n This model is loosely based on the behavior of ants sorting different elements in their nest. \\n A of mobile agents - the ants - is placed on a grid. The grid itself contains cells of different colors. Each step, the agents move randomly. If they enter a colored cell, they pick this color if its density in the neighbourhood is less than *number_of_objects_around*. If they have picked a color, they drop it on a black cell if they have encountered at least *number_of_objects_in_history* cells with the same color.\\n After a while, colors begin to be aggregated. \" ;\t\n\t}  \n\tinit { \n\t\tdo description ;\n\t\tdo create_all;\n\t} \n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [ moving ] control: fsm { \n\trgb color <- #white ; \n\tant_grid place -> {ant_grid (location)} ;\n\t\n\t//Reflex to make the ant wander\n\treflex wandering { \n\t\tdo wander amplitude: 120;\n\t}\n\t//Initial state that will change to full\n\tstate empty initial: true {\n\t\ttransition to: full when: (place.color != black) and ( (place.neighbors count (each.color = place.color)) < (rnd(number_of_objects_around))) {\n\t\t\tcolor <- place.color ;\n\t\t\tplace.color <- black ; \n\t\t}\n\t}\n\t//State full that will change to black if the place color is empty and drop the color inside it\n\tstate full {\n\t\tenter { \n\t\t\tint encountered <- 0; \n\t\t}\n\t\tif place.color = color { \n\t\t\tencountered <- encountered + 1 ;\n\t\t}\n\t\ttransition to: empty when: (place.color = black) and (encountered > number_of_objects_in_history) {\n\t\t\tplace.color <- color ;\n\t\t\tcolor <- black ;\n\t\t}\n\t}\n\taspect default {\n\t\tdraw file(\"../images/ant_normal.svg\") size:5 color: color rotate: heading - 90;\n\t\tdraw circle(5) empty: true color: color;\n\t}\n}\n//Grid that will use the density to determine the color\ngrid ant_grid width: width_and_height_of_grid height: width_and_height_of_grid neighbors: 8 use_regular_agents: false frequency: 0{\n\trgb color <- (rnd(100)) < density_percent ? (colors at rnd(number_of_different_colors - 1)) : #black ;\n}\n\n\n\t\nexperiment sort type: gui{\n\tparameter \"Number of colors:\" var: number_of_different_colors category: \"Environment\" ;\n\tparameter \"Density of colors:\" var: density_percent category: \"Environment\" ;\n\tparameter \"Number of similar colors in memory necessary to put down:\" var: number_of_objects_in_history category: \"Agents\" ;\n\tparameter \"Number of similar colors in perception necessary to pick up:\" var: number_of_objects_around category: \"Agents\" ;\n\tparameter \"Width and height of the grid:\" var: width_and_height_of_grid category: \"Environment\" ;\n\tparameter \"Number of agents:\" var: ants category: \"Agents\" ;\n\t\n\toutput {\n\t\tdisplay OpenGL type: opengl  {\n\t\t\tgrid ant_grid ;\n\t\t\tspecies ant transparency: 0.2 ;\n\t\t}\n\t}\n}\n\n\n```\n","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Sorting.md"},"Articles-Prima_model1.md":{"title":" Prima 1","content":"[//]: # (keyword|concept_skill)\n# Prima 1\n\n\n_Author : _\n\nThis model shows how to create agent and make them move randomly in the world. Some agents are infected, and others can gain the infection if they are in a certain range.\n\n\nCode of the model : \n\n```\n\nmodel SI_city\n\nglobal{\n\tgeometry shape<-envelope(square(500));\n\t\n\t//Creation of the people agents\n\tinit{\n\t\tcreate people number:1000;\n\t}\n}\n//People species with agents moving and can be infected\nspecies people skills:[moving]{\t\t\n\tfloat speed <- 5.0 + rnd(5);\n\tbool is_infected <- flip(0.01);\n\t//Make the agent wander at each step with a certain speed.\n\treflex move{\n\t\tdo wander;\n\t}\n\t//Infect the agent if it is not already infected, and according to the infected people in a range\n\treflex infect when: is_infected{\n\t\task people at_distance 10 {\n\t\t\tif flip(0.01) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\toutput {\n\t\tdisplay map  {\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-Prima_model1.md"},"Articles-Prima_model2.md":{"title":" Prima 2","content":"[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_shapefile)\n# Prima 2\n\n\n_Author : _\n\nThis model shows how to create agent and make them move randomly in the world. Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks to a shapefile. Roads are also created thanks to an other shapefile.\n\n\nCode of the model : \n\n```\nmodel model2 \n \nglobal {\n\t//Shapefile for the roads\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\t//Shapefile for the buildings\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\t//Definition of the shape as the bounds of the roads shapefile\n\tgeometry shape <- envelope(roads_shapefile);\n\tinit {\n\t\t//Creation of the road agents using the shapefile\n\t\tcreate roads from: roads_shapefile;\n\t\t//Creation of the building agents using the shapefile\n\t\tcreate buildings from: buildings_shapefile;\n\t\t//Creation of the people agent and place them in one of the building and chose a target in the building agents\n\t\tcreate people number:1000 {\n\t\t\tlocation <- any_location_in(one_of(buildings));\n\t\t\ttarget <- any_location_in(one_of(buildings));\n\t\t}\n\t}\n}\n\n//People species with agents moving and can be infected\nspecies people skills:[moving]{\t\t\n\tfloat speed <- 5.0 + rnd(5);\n\tbool is_infected <- flip(0.01);\n\tpoint target;\n\t//Make the agent wander at each step with a certain speed.\n\treflex move {\n\t\tdo wander;\n\t}\n\t//Infect the agent if it is not already infected, and according to the infected people in a range\n\treflex infect when: is_infected{\n\t\task people at_distance 10 {\n\t\t\tif flip(0.01) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies roads {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies buildings {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies roads aspect:geom;\n\t\t\tspecies buildings aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-Prima_model2.md"},"Articles-Prima_model3.md":{"title":" Prima 3","content":"[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n# Prima 3\n\n\n_Author : _\n\nThis model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph.\n\n\nCode of the model : \n\n```\nmodel model3 \n \nglobal {\n\t//Shapefile for the roads\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\t//Shapefile for the buildings\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\t//The bounds of the world are the same as the bounds of the roads shapefile\n\tgeometry shape <- envelope(roads_shapefile);\n\t//We need now a graph on which people will move\n\tgraph road_network;\n\tinit {\n\t\t//Create the roads using the shapefiles\n\t\tcreate roads from: roads_shapefile;\n\t\t//Create the graph using the road agents as edges of the graph\n\t\troad_network <- as_edge_graph(roads);\n\t\t//Create the buildings using the shapefiles\n\t\tcreate buildings from: buildings_shapefile;\n\t\t//Create the people agents and choose their location and target\n\t\tcreate people number:1000 {\n\t\t\tlocation <- any_location_in(one_of(buildings));\n\t\t\ttarget <- any_location_in(one_of(buildings));\n\t\t}\n\t}\n}\n//Species people that will move from a location to a target\nspecies people skills:[moving]{\t\t\n\tfloat speed <- 5.0 + rnd(5);\n\tbool is_infected <- flip(0.01);\n\tpoint target;\n\t//Reflex to make the agent move to a target\n\treflex move {\n\t\tdo goto target:target on: road_network;\n\t\t//Each time the agent is at the target's location, chose an other target\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in(one_of(buildings));\n\t\t}\n\t}\n\t//check if the agent is infected if it is not infected already and if there are infected people nearby\n\treflex infect when: is_infected{\n\t\task people at_distance 10 {\n\t\t\tif flip(0.01) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies roads {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies buildings {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies roads aspect:geom;\n\t\t\tspecies buildings aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-Prima_model3.md"},"Articles-Prima_model4.md":{"title":" Prima 4","content":"[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_3d)\n# Prima 4\n\n\n_Author : _\n\nThis model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph. The displayis now a 3D display.\n\n\nCode of the model : \n\n```\nmodel model4 \n\nglobal {\n\t//Shapefile for the roads\n\tfile roads_shapefile <- shape_file(\"../includes/road.shp\");\n\t//Shapefile for the buildings\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\t//The world bounds are now the shapefile roads 's boundss\n\tgeometry shape <- envelope(roads_shapefile);\n\t//The graph of roads on which people will move\n\tgraph road_network;\n\tinit {\n\t\t//Creation of the roads using the road shapefile\n\t\tcreate roads from: roads_shapefile;\n\t\t//Creation of the graph using roads as the edges of the graph\n\t\troad_network <- as_edge_graph(roads);\n\t\t//Creation of the buildings from the building shapefile\n\t\tcreate buildings from: buildings_shapefile;\n\t\t//Creation of the people agent, located in one of the building\n\t\tcreate people number:1000 {\n\t\t\tbuildings init_place <- one_of(buildings);\n\t\t\tlocation <- any_location_in(init_place) + {0,0, init_place.height};\n\t\t\ttarget <- any_location_in(one_of(buildings));\n\t\t}\n\t}\n}\n//Species people that will move from a location to a target and can be infected\nspecies people skills:[moving]{\t\t\n\tfloat speed <- 5.0 + rnd(5);\n\tbool is_infected <- flip(0.01);\n\tpoint target;\n\t\n\t//Reflex to move to the target on the graph of roads\n\treflex move {\n\t\tdo goto target:target on: road_network;\n\t\t//Once the target is reached, find an other target\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in(one_of(buildings));\n\t\t}\n\t}\n\t//Reflex to check if we are infected if we aren't already and infected people are nearby\n\treflex infect when: is_infected{\n\t\task people at_distance 10 {\n\t\t\tif flip(0.01) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw sphere(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies roads {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies buildings {\n\tfloat height <- 10.0+ rnd(10);\n\taspect geom {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\toutput {\n\t\t//Type opengl to display in 3D\n\t\tdisplay map type: opengl {\n\t\t\tspecies roads aspect:geom;\n\t\t\tspecies buildings aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-Prima_model4.md"},"Articles-Prima_model5.md":{"title":" Prima 5","content":"[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_of_species)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_multi_level)\n# Prima 5\n\n\n_Author : _\n\nThis model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph. The displayis now a 3D display. The model adds a new level as people going inside a building will be nowa new species belonging to the building and that will be manage by the building agent concerned\n\n\nCode of the model : \n\n```\nmodel model5 \n\nglobal {\n\t//Shapefile of the roads\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\t//Shapefile of the buildings\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\t//The bounds of the world are the bounds of the roads shapefile\n\tgeometry shape <- envelope(roads_shapefile);\n\t//The graph of road on which people agents will move\n\tgraph road_network;\n\tinit {\n\t\t//Creation of the roads using the road shapefile\n\t\tcreate roads from: roads_shapefile;\n\t\t//Creation of the graph using the road agents as edge\n\t\troad_network <- as_edge_graph(roads);\n\t\t//Creation of the building using the building shapefile\n\t\tcreate buildings from: buildings_shapefile;\n\t\t//Creation of the people that will be placed in a building randomly chosen\n\t\tcreate people number:1000 {\n\t\t\tbuildings init_place <- one_of(buildings);\n\t\t\tlocation <- any_location_in(init_place) + {0,0, init_place.height};\n\t\t\ttarget <- any_location_in(one_of(buildings));\n\t\t}\n\t}\n}\n//Species people that can be infected and will move from a location to a target\nspecies people skills:[moving]{\t\t\n\tfloat speed <- 5.0 + rnd(5);\n\tbool is_infected <- flip(0.01);\n\tpoint target;\n\t//Make the agent move to its target\n\treflex move {\n\t\tdo goto target:target on: road_network;\n\t\t//Change the target once it has been reached\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in(one_of(buildings));\n\t\t}\n\t}\n\t//Reflex to infect the people agent if it is not infected already and if there are infected people nearby\n\treflex infect when: is_infected{\n\t\task people at_distance 10 {\n\t\t\tif flip(0.01) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw sphere(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies roads {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n//Species buildings that will change the people agents inside it to people in building agent\n//Managing them once they have been captured, and releasing them once they reached a\n//leaving time\nspecies buildings {\n\tfloat height <- 10.0+ rnd(10);\n\tint nb_I -> {members count (people_in_building(each).is_infected)};\n\t\n\taspect geom {\n\t\tdraw shape color: empty(members) ? #gray : (nb_I/length(members) > 0.5 ? #red : #green) depth: height;\n\t}\n\t//Species people in building that will be managed by the building agents\n\tspecies people_in_building parent: people schedules: [] {\n\t\tint leaving_time;\n\t\taspect circle{}\n\t}\n\t//Reflex to capture the people entering inside the building, changing them in people in building species and puting a leaving time to know when lettiing\n\t// them out\n\treflex let_people_enter {\n\t\tlist<people> entering_people <- (people inside self);\n\t\tif !(empty (entering_people)) {\n\t\t\t//Change the species of the people captured from people species to people_in_building species\n\t\t\tcapture entering_people as: people_in_building returns: people_captured;\n\t\t\task people_captured {\n\t\t\t\tleaving_time <- int(time + 50 + rnd(50));\n\t\t\t}\n \t\t}\n\t}\n\t//Reflex to let the people_in_building agents go out if there leaving time is reached, releasing them in the world as people agent\n\treflex let_people_leave  {\n\t\tlist<people_in_building> leaving_people <- members of_species people_in_building where (time >= each.leaving_time);\n\t\tif !(empty (leaving_people)) {\n\t\t\trelease leaving_people as: people in: world;\n\t\t}\n\t}\n}\n\nexperiment main_experiment type:gui{\n\toutput {\n\t\tdisplay map type: opengl {\n\t\t\tspecies roads aspect:geom;\n\t\t\tspecies buildings aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-Prima_model5.md"},"Articles-Prima_model6.md":{"title":" Prima 5","content":"[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_diff)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_multi_level)\n[//]: # (keyword|concept_equation)\n# Prima 5\n\n\n_Author : _\n\nThis model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph. The displayis now a 3D display. The model adds a new level as people going inside a building will be nowa new species belonging to the building and that will be manage by the building agent concernedThe people_in_building agent will be infected inside a building respecting an ordinary differentialequation system.\n\n\nCode of the model : \n\n```\nmodel model6 \n\nglobal {\n\t//Shapefile of roads\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\t//Shapefile of buildings\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\t//Bounds of the world will be the bounds of the shapefile of roads\n\tgeometry shape <- envelope(roads_shapefile);\n\t//The graph of roads on which people agents will move\n\tgraph road_network;\n\t\n\t//The beta used for the ODE system\n\tfloat beta <- 0.4;\n\t\n\tinit {\n\t\t//Creation of the roads using the shapefile\n\t\tcreate roads from: roads_shapefile;\n\t\t//Creation of the graph using the road agents as edge\n\t\troad_network <- as_edge_graph(roads);\n\t\t//Creation of the buildings using the shapefile\n\t\tcreate buildings from: buildings_shapefile;\n\t\t//Creation of the people that will be placed in a building randomly chosen\n\t\tcreate people number:1000 {\n\t\t\tbuildings init_place <- one_of(buildings);\n\t\t\tlocation <- any_location_in(init_place) + {0,0, init_place.height};\n\t\t\ttarget <- any_location_in(one_of(buildings));\n\t\t}\n\t}\n}\n\n//Species people that can be infected and will move from a location to a target\nspecies people skills:[moving]{\t\t\n\tfloat speed <- 5.0 + rnd(5);\n\tbool is_infected <- flip(0.01);\n\tpoint target;\n\t//Reflex to make the agent move from its location to its target on the graph\n\treflex move {\n\t\tdo goto target:target on: road_network;\n\t\t//Change the target once it has been reached\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in(one_of(buildings));\n\t\t}\n\t}\n\t//Reflex to know if a non-infected agent is infected by the agents nearby\n\treflex infect when: is_infected{\n\t\task people at_distance 10 {\n\t\t\tif flip(0.01) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw sphere(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies roads {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\n//Species buildings that will change the people agents inside it to people in building agent\n//Managing them once they have been captured, and releasing them once they reached a\n//leaving time\nspecies buildings {\n\tfloat height <- 10.0+ rnd(10);\n\t//Variable to know the number of people infected inside the buildings\n\tint nb_I -> {members count (people_in_building(each).is_infected)};\n\t//Variable to know the number of people inside the building\n\tint nbInhabitants update: length(members);\n\t//List of all the people_in_building agents not infected\t\t\t\t\n\tlist<people_in_building> membersS update: list<people_in_building>(members) where (!each.is_infected);\n\t//List of all the people_in_building agents infected\t\t\t\t\n\tlist<people_in_building> membersI update: list<people_in_building>(members) where (each.is_infected);\n\tfloat t;\n\t//Float used in the ODE system representing the number of non infected agents    \n\tfloat S update: length(membersS) as float; \n\t//Float used in the ODE system representing the number of infected agents \n   \tfloat I update: length(membersI) as float;\n   \tfloat I_to_1 <- 0.0;\n   \tfloat h<-0.1;\n   \t\n\taspect geom {\n\t\tdraw shape color: empty(members) ? #gray : (nb_I/length(members) > 0.5 ? #red : #green) depth: height;\n\t}\n\t//Species people in building that will be managed by the building agents\n\tspecies people_in_building parent: people schedules: [] {\n\t\tint leaving_time;\n\t\taspect circle{}\n\t}\n\t//Reflex to capture the people entering inside the building, changing them in people in building species and puting a leaving time to know when lettiing\n\t// them out\n\treflex let_people_enter {\n\t\tlist<people> entering_people <- (people inside self);\n\t\tif !(empty (entering_people)) {\n\t\t\tcapture entering_people as: people_in_building returns: people_captured;\n\t\t\task people_captured {\n\t\t\t\tleaving_time <- int(time + 50 + rnd(50));\n\t\t\t}\n \t\t}\n\t}\n\t//Reflex to let the people_in_building agents go out if there leaving time is reached, releasing them in the world as people agent\n\treflex let_people_leave  {\n\t\tlist<people_in_building> leaving_people <- list<people_in_building>(members) where (time >= each.leaving_time);\n\t\tif !(empty (leaving_people)) {\n\t\t\trelease leaving_people as: people in: world;\n\t\t}\n\t}\n\t//ODE system to represent the infection among the building\n\tequation SIR{ \n\t\tdiff(S,t) = (- beta * S * I / nbInhabitants) ;\n\t\tdiff(I,t) = (  beta * S * I / nbInhabitants) ;\n\t}\n\t//Make the computation of the ODE System only when they are people inside\n\treflex epidemic when:(S>0 and I>0){ \t\n\t\tfloat I0 <- I;\n    \tsolve SIR method: \"rk4\" step: h ;\n    \tI_to_1 <- I_to_1 + (I - I0);\n    \tif(I_to_1 > 1) {\n    \t\task(membersS){\n    \t\t\tis_infected <- true;\n    \t\t\tmyself.I_to_1 <- myself.I_to_1 - 1;\n    \t\t}\n    \t}\n    }    \n}\n\nexperiment main_experiment type:gui{\n\toutput {\n\t\tdisplay map type: opengl {\n\t\t\tspecies roads aspect:geom;\n\t\t\tspecies buildings aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-Prima_model6.md"},"Articles-ville_1.md":{"title":" Ville 1","content":"[//]: # (keyword|operator_gauss)\n[//]: # (keyword|concept_gui)\n# Ville 1\n\n\n_Author : _\n\nThis is a simple model showing different circle with a color according to the income of the house.\n\n\nCode of the model : \n\n```\nmodel ville\n\nglobal {\n\tinit {\n\t\tcreate foyer number: 500;\n\t}\n}\n\nspecies batiment {\n\tstring type;\n\tint capacite;\n}\n\nspecies route {\n}\n\nspecies foyer {\n\tfloat revenu <- gauss(1500, 500);\n\tbool est_satisfait ;\n\tbatiment habitation;\n\tbatiment lieu_travail;\n\t\n\taspect revenu {\n\t\tint val <- int(255 * (revenu / 3000));\n\t\tdraw circle(5) color: rgb(255 - val, val, 0);\n\t}\n}\n\nexperiment ville type: gui { \n\toutput {\n\t\tdisplay carte_principale {\n\t\t\tspecies foyer aspect: revenu;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-ville_1.md"},"Articles-ville_2.md":{"title":" Ville 2","content":"[//]: # (keyword|operator_gauss)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_shapefile)\n# Ville 2\n\n\n_Author : _\n\nCreation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. \n\n\nCode of the model : \n\n```\n\nmodel ville\n\nglobal {\n\tfile shape_file_batiments <- file(\"../includes/batiments.shp\");\n\tfile shape_file_routes <- file(\"../includes/routes.shp\");\n\tgeometry shape <- envelope(shape_file_routes);\n\tinit {\n\t\tcreate route from: shape_file_routes;\n\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))];\n\t\tcreate foyer number: 500;\n\t}\n}\n\nspecies batiment {\n\tstring type;\n\tint capacite <- type = \"Industrial\" ? 0 : int(shape.area / 60.0);\n\taspect geometrie {\n\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray;\n\t}\n}\n\nspecies route {\n\taspect geometrie {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies foyer {\n\tfloat revenu <- gauss(1500, 500);\n\tbatiment habitation;\n\tbatiment lieu_travail;\n\t\n\taspect revenu {\n\t\tint val <- int(255 * (revenu / 3000));\n\t\tdraw circle(5) color: rgb(255 - val, val, 0);\n\t}\n}\n\nexperiment ville type: gui {\n\toutput {\n\t\tdisplay carte_principale {\n\t\t\tspecies batiment aspect: geometrie;\n\t\t\tspecies route aspect: geometrie;\n\t\t\tspecies foyer aspect: revenu;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-ville_2.md"},"Articles-ville_3.md":{"title":" Ville 3","content":"[//]: # (keyword|operator_gauss)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_shapefile)\n# Ville 3\n\n\n_Author : _\n\nCreation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income.\n\n\nCode of the model : \n\n```\nmodel ville\n\nglobal {\n\tfile shape_file_batiments <- file(\"../includes/batiments.shp\");\n\tfile shape_file_routes <- file(\"../includes/routes.shp\");\n\tgeometry shape <- envelope(shape_file_routes);\n\tinit \n\t{\n\t\tcreate route from: shape_file_routes;\n\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))];\n\t\tcreate foyer number: 500;\n\t}\n}\n\nspecies foyer {\n\tfloat revenu <- gauss(1500, 500);\n\tbool est_satisfait update: calculer_satisfaction();\n\tbatiment habitation;\n\tbatiment lieu_travail;\n\tinit {\n\t\tlieu_travail <- one_of(batiment where (each.type = \"Industrial\"));\n\t\thabitation <- choisir_batiment(); \n\t\tdo emmenager;\n\t}\n\tbool calculer_satisfaction {\n\t\tlist<foyer> voisins <- foyer at_distance 50.0;\n\t\tfloat revenu_moyen <- mean(voisins collect (each.revenu));\n\t\treturn empty(voisins) or (revenu_moyen > (revenu * 0.7) and revenu_moyen < (revenu / 0.7));\n\t}\n\taction emmenager {\n\t\thabitation.capacite <- habitation.capacite - 1;\n\t\tlocation <- any_location_in(habitation.shape);\n\t}\n\taction demenager {\n\t\thabitation.capacite <- habitation.capacite + 1;\n\t}\n\tbatiment choisir_batiment {\n\t\treturn one_of(batiment where (each.capacite >0));\n\t}\n\treflex demenagement when: !est_satisfait {\n\t\tdo demenager;\n\t\thabitation <- choisir_batiment();\n\t\tdo emmenager;\n\t}\n\taspect revenu {\n\t\tint val <- int(255 * (revenu / 3000));\n\t\tdraw circle(5) color: rgb(255 - val, val, 0);\n\t}\n}\nspecies batiment {\n\tstring type;\n\tint capacite <- type = \"Industrial\" ? 0 : int(shape.area / 70.0);\n\taspect geometrie {\n\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray;\n\t}\n\n}\nspecies route {\n\taspect geometrie {\n\t\tdraw shape color: #black;\n\t}\n\n}\nexperiment ville type: gui {\n\toutput {\n\t\tdisplay carte_principale {\n\t\t\tspecies batiment aspect: geometrie;\n\t\t\tspecies route aspect: geometrie;\n\t\t\tspecies foyer aspect: revenu;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-ville_3.md"},"Articles-ville_4.md":{"title":" Ville 4","content":"[//]: # (keyword|operator_gauss)\n[//]: # (keyword|operator_distance_between)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n# Ville 4\n\n\n_Author : _\n\nCreation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income, but also to their working place.\n\n\nCode of the model : \n\n```\nmodel ville\n\nglobal {\n\tfile shape_file_batiments <- file(\"../includes/batiments.shp\");\n\tfile shape_file_routes <- file(\"../includes/routes.shp\");\n\tgeometry shape <- envelope(shape_file_routes);\n\tgraph<point, route> reseau_route;\n\tinit {\n\t\tcreate route from: shape_file_routes;\n\t\treseau_route <- as_edge_graph(route);\n\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))];\n\t\tcreate foyer number: 500;\n\t}\n}\nspecies foyer {\n\tfloat revenu <- gauss(1500, 500);\n\tbool est_satisfait update: calculer_satisfaction();\n\tbatiment habitation;\n\tbatiment lieu_travail;\n\tinit {\n\t\tlieu_travail <- one_of(batiment where (each.type = \"Industrial\"));\n\t\thabitation <- choisir_batiment(); \n\t\tdo emmenager;\n\t}\n\tbool calculer_satisfaction {\n\t\tlist<foyer> voisins <- foyer at_distance 50.0;\n\t\tfloat revenu_moyen <- mean(voisins collect (each.revenu));\n\t\treturn empty(voisins) or (revenu_moyen > (revenu * 0.7) and revenu_moyen < (revenu / 0.7));\n\t}\n\taction emmenager {\n\t\thabitation.capacite <- habitation.capacite - 1;\n\t\tlocation <- any_location_in(habitation.shape);\n\t}\n\taction demenager {\n\t\thabitation.capacite <- habitation.capacite + 1;\n\t}\n\tbatiment choisir_batiment {\n\t\treturn one_of(batiment where ((each.capacite >0) and ( each.distances[lieu_travail]< 1000.0)));\n\t}\n\treflex demenagement when: !est_satisfait {\n\t\tdo demenager;\n\t\thabitation <- choisir_batiment();\n\t\tdo emmenager;\n\t}\n\taspect revenu {\n\t\tint val <- int(255 * (revenu / 3000));\n\t\tdraw circle(5) color: rgb(255 - val, val, 0);\n\t}\n}\nspecies batiment {\n\tstring type;\n\tint capacite <- type = \"Industrial\" ? 0 : int(shape.area / 70.0);\n\tmap<batiment,float> distances;\n\tinit {\n\t\tloop bat over: batiment where (each.type = \"Industrial\") {\n\t\t\tput (topology(reseau_route) distance_between [self,bat]) at: bat in: distances;\n\t\t}\n\t}\n\taspect geometrie {\n\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray;\n\t}\n}\nspecies route {\n\taspect geometrie {\n\t\tdraw shape color: #black;\n\t}\n}\nexperiment ville type: gui {\n\toutput {\n\t\tdisplay carte_principale {\n\t\t\tspecies batiment aspect: geometrie;\n\t\t\tspecies route aspect: geometrie;\n\t\t\tspecies foyer aspect: revenu;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-ville_4.md"},"Articles-ville_5.md":{"title":" Ville 5","content":"[//]: # (keyword|operator_gauss)\n[//]: # (keyword|operator_distance_between)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n# Ville 5\n\n\n_Author : _\n\nCreation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income, but also to their working place. This model add a new display showing the \"color\" of each building according to the mean income of its residents\n\n\nCode of the model : \n\n```\nmodel ville\n\nglobal {\n\tfile shape_file_batiments <- file(\"../includes/batiments.shp\");\n\tfile shape_file_routes <- file(\"../includes/routes.shp\");\n\tgeometry shape <- envelope(shape_file_routes);\n\tgraph<point, route> reseau_route;\n\t\n\tinit {\n\t\tcreate route from: shape_file_routes;\n\t\treseau_route <- as_edge_graph(route);\n\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))];\n\t\tcreate foyer number: 500;\n\t}\n} \n\nspecies foyer {\n\tfloat revenu <- gauss(1500, 500);\n\tbool est_satisfait update: calculer_satisfaction();\n\tbatiment habitation;\n\tbatiment lieu_travail;\n\tinit {\n\t\tlieu_travail <- one_of(batiment where (each.type = \"Industrial\"));\n\t\thabitation <- choisir_batiment(); \n\t\tdo emmenager;\n\t}\n\tbool calculer_satisfaction {\n\t\tlist<foyer> voisins <- foyer at_distance 50.0;\n\t\tfloat revenu_moyen <- mean(voisins collect (each.revenu));\n\t\treturn empty(voisins) or (revenu_moyen > (revenu * 0.7) and revenu_moyen < (revenu / 0.7));\n\t}\n\taction emmenager {\n\t\thabitation.capacite <- habitation.capacite - 1;\n\t\thabitation.foyers << self;\n\t\tlocation <- any_location_in(habitation.shape) + {0,0, habitation.hauteur};\n\t}\n\taction demenager {\n\t\thabitation.capacite <- habitation.capacite + 1;\n\t\tremove self from: habitation.foyers;\n\t}\n\tbatiment choisir_batiment {\n\t\treturn one_of(batiment where ((each.capacite >0) and ( each.distances[lieu_travail]< 1000.0)));\n\t}\n\treflex demenagement when: !est_satisfait {\n\t\tdo demenager;\n\t\thabitation <- choisir_batiment();\n\t\tdo emmenager;\n\t}\n\taspect revenu {\n\t\tint val <- int(255 * (revenu / 3000));\n\t\tdraw sphere(5) color: rgb(255 - val, val, 0);\n\t}\n}\nspecies batiment {\n\tstring type;\n\tint capacite <- type = \"Industrial\" ? 0 : int(shape.area / 70.0);\n\tmap<batiment,float> distances;\n\tint hauteur <- 5 + rnd(10);\n\tlist<foyer> foyers ;\n\tfloat revenu_moyen update: empty(foyer) ? 0.0 : mean (foyers collect each.revenu);\n\tinit {\n\t\tloop bat over: batiment where (each.type = \"Industrial\") {\n\t\t\tput (topology(reseau_route) distance_between [self,bat]) at: bat in: distances;\n\t\t}\n\t}\n\taspect geometrie {\n\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray depth: hauteur;\n\t}\n\taspect information_foyer {\n\t\tdraw shape color: type = \"Industrial\" ? #pink : (empty(foyers) ? #gray : rgb(int(255 * (1 - (revenu_moyen / 3000))), int(255 * (revenu_moyen / 3000)), 0)) depth: length(foyers);\n\t}\n}\nspecies route {\n\taspect geometrie {\n\t\tdraw shape color: #black;\n\t}\n}\nexperiment ville type: gui {\n\toutput {\n\t\tdisplay carte_principale type: java2D {\n\t\t\tspecies batiment aspect: geometrie;\n\t\t\tspecies route aspect: geometrie;\n\t\t\tspecies foyer aspect: revenu;\n\t\t}\n\t\tdisplay carte_batiment type: opengl {\n\t\t\tspecies batiment aspect: information_foyer;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-ville_5.md"},"Articles-ville_6.md":{"title":" Ville 6","content":"[//]: # (keyword|operator_gauss)\n[//]: # (keyword|operator_distance_between)\n[//]: # (keyword|operator_select)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_3d)\n# Ville 6\n\n\n_Author : _\n\nCreation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income, but also to their working place. This model add a new display showing the \"color\" of each building according to the mean income of its residents. The buildings also have a z location given thanks to a mnt file.\n\n\nCode of the model : \n\n```\nmodel ville\n\nglobal {\n\tfile shape_file_batiments <- file(\"../includes/batiments.shp\");\n\tfile shape_file_routes <- file(\"../includes/routes.shp\");\n\tfile mnt <- file(\"../includes/mnt.asc\");\n\tfile texture <- file('../includes/Texture.png');\n\tgeometry shape <- envelope(mnt);\n\tgraph<point, route> reseau_route;\n\tlist<batiment> industries;\n\t\n\tinit {\n\t\tcreate route from: shape_file_routes;\n\t\treseau_route <- as_edge_graph(route);\n\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))] {\n\t\t\tfloat z <- (mnt_cell(location)).grid_value;   \n\t\t\tlocation <- {location.x,location.y,z};\n\t\t}\n\t\tindustries <- batiment select (each.type = \"Industrial\");\n\t\tcreate foyer number: 500;\n\t}\n}\n\ngrid mnt_cell file: mnt;\n\nspecies foyer {\n\tfloat revenu <- gauss(1500, 500);\n\tbool est_satisfait update: calculer_satisfaction();\n\tbatiment habitation;\n\tbatiment lieu_travail;\n\tinit {\n\t\tlieu_travail <- one_of(batiment where (each.type = \"Industrial\"));\n\t\thabitation <- choisir_batiment(); \n\t\tdo emmenager;\n\t}\n\tbool calculer_satisfaction {\n\t\tlist<foyer> voisins <- foyer at_distance 50.0;\n\t\tfloat revenu_moyen <- mean(voisins collect (each.revenu));\n\t\treturn empty(voisins) or (revenu_moyen > (revenu * 0.7) and revenu_moyen < (revenu / 0.7));\n\t}\n\taction emmenager {\n\t\thabitation.capacite <- habitation.capacite - 1;\n\t\tlocation <- any_location_in(habitation.shape) + {0,0, (habitation.hauteur + habitation.location.z)};\n\t\thabitation.foyers << self;\n\t}\n\taction demenager {\n\t\thabitation.capacite <- habitation.capacite + 1;\n\t\tremove self from: habitation.foyers;\n\t}\n\tbatiment choisir_batiment {\n\t\tbatiment b  <- one_of(batiment where ((each.capacite >0) and ( each.distances[lieu_travail]< 1000.0)));\n\t\treturn b;\n\t}\n\treflex demenagement when: !est_satisfait {\n\t\tdo demenager;\n\t\thabitation <- choisir_batiment();\n\t\tdo emmenager;\n\t}\n\taspect revenu {\n\t\tint val <- int(255 * (revenu / 3000));\n\t\tdraw sphere(5) color: rgb(255 - val, val, 0);\n\t}\n}\nspecies batiment {\n\tstring type;\n\tint capacite <- type = \"Industrial\" ? 0 : int(shape.area / 70.0);\n\tmap<batiment,float> distances;\n\tint hauteur <- 5 + rnd(10);\n\tlist<foyer> foyers ;\n\tfloat revenu_moyen update: empty(foyer) ? 0.0 : mean (foyers collect each.revenu);\n\tinit {\n\t\tloop bat over: batiment where (each.type = \"Industrial\") {\n\t\t\tput (topology(reseau_route) distance_between [self,bat]) at: bat in: distances;\n\t\t}\n\t}\n\taspect geometrie {\n\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray depth: hauteur;\n\t}\n\taspect information_foyer {\n\t\tdraw shape color: type = \"Industrial\" ? #pink : (empty(foyers) ? #gray : rgb(int(255 * (1 - (revenu_moyen / 3000))), int(255 * (revenu_moyen / 3000)), 0)) depth: length(foyers);\n\t}\n}\nspecies route {\n\taspect geometrie {\n\t\tdraw shape color: #black at:{location.x,location.y,(mnt_cell(location)).grid_value};\n\t}\n}\nexperiment ville type: gui {\n\toutput {\n\t\tdisplay carte_principale type: opengl {\n\t\t\tgrid mnt_cell triangulation: true texture:texture elevation:true transparency: 0.3;\n\t\t\tspecies batiment aspect: geometrie;\n\t\t\tspecies route aspect: geometrie;\n\t\t\tspecies foyer aspect: revenu;\n\t\t}\n\t\tdisplay carte_batiment type: opengl {\n\t\t\tspecies batiment aspect: information_foyer;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Articles-ville_6.md"},"Boids-Boids-3D-Analysis.md":{"title":" Boids 3D Analysis","content":"[//]: # (keyword|operator_sin)\n[//]: # (keyword|operator_polygon)\n[//]: # (keyword|operator_dead)\n[//]: # (keyword|operator_triangle)\n[//]: # (keyword|operator_hsb)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_remove_duplicates)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_camera)\n[//]: # (keyword|concept_multi_level)\n# Boids 3D Analysis\n\n\n_Author : _\n\n This model shows the movement of boids following a goal, and creating without their own volonty, a flock . Four experiments are proposed : start is the 3D display of the boids like a real world, trajectory_analysis like the name means is about the analysis of the trajectory of the boids, Space Time Cube adds two display to see the movement of the boids using the time as the z-axis, and the last one represents the differents camera available in GAMA.\n\n\nCode of the model : \n\n```\nmodel boids \n\nglobal torus: torus_environment{ \n\t//Number of boids to represent\n\tint number_of_agents parameter: 'Number of agents' <- 10 min: 1 max: 1000000;\n\t//Number of obstacles to represent\n\tint number_of_obstacles parameter: 'Number of obstacles' <- 4 min: 0;\n\t//Size of the boids\n\tint boids_size parameter: 'Boids size' <- 20 min: 1;\n\t//Maximal speed allowed for the boids\n\tfloat maximal_speed parameter: 'Maximal speed' <- 15.0 min: 0.1 max: 15.0;\n\t//Speed radius\n\tfloat  radius_speed parameter: 'radius speed' <- 0.5 min: 0.1;\n\t//Cohesion factor of the boid group  in the range of a boid agent\n\tint cohesion_factor parameter: 'Cohesion Factor' <- 200;\n\t//Alignment factor used for the boid group in the range of a boid agent\n\tint alignment_factor parameter: 'Alignment Factor' <- 100; \n\t//Minimal distance to move\n\tfloat minimal_distance parameter: 'Minimal Distance' <- 10.0; \n\t//Maximal turn done by the boids\n\tint maximal_turn parameter: 'Maximal Turn' <- 90 min: 0 max: 359; \n\t\n\t//Parameters of the environment and the simulations\n\tint width_and_height_of_environment parameter: 'Width/Height of the Environment' <- 800;  \n\tbool torus_environment parameter: 'Toroidal Environment ?' <- false; \n\tbool apply_cohesion <- true parameter: 'Apply Cohesion ?';\n\tbool apply_alignment <- true parameter: 'Apply Alignment ?';   \n\tbool apply_separation <- true parameter: 'Apply Separation ?';   \n\tbool apply_goal <- true parameter: 'Follow Goal ?'; \n\tbool apply_avoid <- true parameter: 'Apply Avoidance ?';   \n\tbool apply_wind <- true parameter: 'Apply Wind ?';     \n\tbool moving_obstacles <- false parameter: 'Moving Obstacles ?';    \n\tint bounds <- int(width_and_height_of_environment / 20); \n\t//Wind vector \n\tpoint wind_vector <- {0,0} parameter: 'Direction of the wind';  \n\tint goal_duration <- 30 update: (goal_duration - 1); \n\t//Goal location\n\tpoint goal <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \n\tlist images of: image_file <- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \n\tstring file_path_to_ocean <- '../images/ocean.jpg';\n\tint xmin <- bounds;    \n\tint ymin <- bounds;  \n\tint xmax <- (width_and_height_of_environment - bounds);    \n\tint ymax <- (width_and_height_of_environment - bounds);   \n\tgeometry shape <- square(width_and_height_of_environment);\n\n\n\t// flock's parameter \n\tfloat two_boids_distance const: true init: 30.0;  \n\tint merging_distance const: true init: 30;\n\tbool create_flock  init: false;  \n\t\n\tinit {\n\t\t//Create the boids and place them randomlly\n\t\tcreate boids number: number_of_agents { \n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\n\t\t} \n\t\t \n\t\t //Create an obstacle and place it randomly\n\t\tcreate obstacle number: number_of_obstacles {\n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \n\t\t}\n\t\t//Create a goal and place it at the goal location\n\t\tcreate  boids_goal number: 1 {\n\t\t\tlocation <- goal;\n\t\t}\n\t\t\n\t\tcreate aggregatedboids;\n\t}\n\t\n\t//Reflex to create flock of boids considering the neighbours of each boids \n\t reflex create_flocks {\n\t \tif create_flock {\n\t \t\t//Create a map using a boid agent as a key and the list of all its neighbours as the value for the key\n\t \t\tmap<boids, list<boids>> potentialBoidsNeighboursMap;\n\t \t\t\n\t \t\t//Search all the boids within the two boids distance from a boid agent and put them in the map\n\t \t\tloop one_boids over: boids {\n\t \t\t\tlist<boids> free_neighbours <- boids overlapping (one_boids.shape + (two_boids_distance));\n\t \t\t\tremove one_boids from: free_neighbours;  \n\n\t \t\t\tif !(empty (free_neighbours)) {\n\t \t\t\t\tadd (one_boids::free_neighbours) to: potentialBoidsNeighboursMap;\n\t \t\t\t} \n\t \t\t}\n\t \t\t\n\t \t\t//Sorting of all the boids considered as key in the map by the length of their neighbours\n\t \t\tlist<boids> sorted_free_boids <- (potentialBoidsNeighboursMap.keys) sort_by (length (potentialBoidsNeighboursMap at each));\n\t \t\t//Removing of all the boids which has been considered as a key of the map, but  which are already included in a bigger list of neighbours by one of them neighbours\n\t \t\tloop one_boids over: sorted_free_boids {\n\t \t\t\tlist<boids> one_boids_neighbours <- potentialBoidsNeighboursMap at one_boids;\n\t \t\t\t\n\t \t\t\tif  (one_boids_neighbours != nil) {\n\t \t\t\t\tloop one_neighbour over: one_boids_neighbours {\n\t \t\t\t\t\tremove one_neighbour from: potentialBoidsNeighboursMap; \n\t \t\t\t\t}\n\t \t\t\t}\n\t \t\t}\n\t \t\t//Remove all the duplicates key of potentialBoidsNeighboursMap\n\t\t \tlist<boids> boids_neighbours <- (potentialBoidsNeighboursMap.keys);\n\t\t \tloop one_key over: boids_neighbours {\n\t\t \t\tput (remove_duplicates (( potentialBoidsNeighboursMap at (one_key)) + one_key)) at: one_key in: potentialBoidsNeighboursMap;\n\t\t \t}\n\t\t \t\n\t\t \t//Create a flock of boids considering the key of potentialBoidsNeighboursMap\n\t\t \tloop one_key over: (potentialBoidsNeighboursMap.keys) {\n\t\t \t\tlist<boids> micro_agents <- potentialBoidsNeighboursMap at one_key;\n\t\t \t\t\t\n\t\t \t\tif ( (length (micro_agents)) > 1 ) {\n\t\t \t\t\tcreate flock number: 1 with: [ color::rgb([rnd (255), rnd (255), rnd (255)]) ] { \n\t\t \t\t\t\tcapture micro_agents as: boids_delegation;\n\t\t \t\t\t}\n\t\t \t\t}\n\t\t \t} \n\t\t}\n\t}  \n}\n//Species boids_goal which represents the goal followed by the boids agent, using the skill moving\nspecies boids_goal skills: [moving] {\n\tfloat range const: true init: 20.0;\n\tint radius <-3;\n\t\n\t//Reflex to make the goal move in circle\n\treflex wander_in_circle{\n\t\t\n\t\tlocation <- {world.shape.width/2 + world.shape.width/2 * cos (time*radius_speed), world.shape.width/2 + world.shape.width/2 * sin (time*radius_speed)};\n\t\tgoal <- location;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(10) color: rgb ('red');\n\t\tdraw circle(40) color: rgb ('orange') size: 40 empty: true;\n\t}\n\t\n\taspect sphere{\n\t\tdraw sphere(10) color: rgb('white');\n\t}\n} \n\n//Species flock which represents the flock of boids agents, managing the boids agents captured\nspecies flock  \n{\n\t//Represent the cohesion index of the flock\n\tfloat cohesionIndex <- two_boids_distance update: (two_boids_distance + (length (members)));\n\trgb color <- rgb ([64, 64, 64]);\n \tgeometry shape update: !(empty (members)) ? ( (polygon (members collect (boids_delegation (each)).location )) + 2.0 ) : ( polygon ([ {rnd (width_and_height_of_environment), rnd (width_and_height_of_environment)} ]) );\n\t \n\t//Species that will represent the boids agents captured or inside a flock\n\tspecies boids_delegation parent: boids topology: topology(world.shape)  \n\t{\n\t\tlist<boids> others -> {( (boids_delegation overlapping (shape + range))) - self};\n \n \t\t//Action to compute the mass center of the flock\n\t\taction compute_mass_center type: point \n\t\t{\n\t\t\tloop o over: others \n\t\t\t{\n\t\t\t\tif  dead(o) \n\t\t\t\t{\n\t\t\t\t\tdo write message: 'in ' + name + ' agent with others contains death agents'; \n\t\t\t\t} \n\t\t\t}\n\t\t \n\t\t\treturn (length(others) > 0) ? (mean (others collect (each.location)) ) : location;\n\t\t}\n\n\t\treflex separation when: apply_separation {\n\t\t}\n\t\t\n\t\treflex alignment when: apply_alignment {\n\t\t}\n\t\t//Reflex to apply the cohesion on the boids agents\n\t\treflex cohesion when: apply_cohesion {\n\t\t\tpoint acc <- (self compute_mass_center []) - location;\n\t\t\tacc <- acc / cohesion_factor;\n\t\t\tvelocity <- velocity + acc;\n\t\t}\n\t\t\n\t\treflex avoid when: apply_avoid {\n\t\t}\t\t\n\t}\n\t//Reflex to capture boids agents and release captured boids agents\n\treflex capture_release_boids {\n\t\t list<boids_delegation> removed_components <- boids_delegation where ((each distance_to location) > cohesionIndex );\n\t\t if !(empty (removed_components)) {\n\t\t \trelease removed_components;\n\t\t }\n\t\t \n\t\t list<boids> added_components <- boids where ((each distance_to location) < cohesionIndex );\n\t\t if !(empty (added_components)) {\n\t\t \tcapture added_components as: boids_delegation;\n\t\t }\n\t}\n\t//Reflexe to kill the flock if the boids agents contained is lower than 2\n\treflex dispose when: ((length (members)) < 2) {\n\t\t release members;\n\t\t do die;\n\t}\n\t//Reflex to merge the flocks too close from each other\n\treflex merge_nearby_flocks {\n\t\tlist<flock> nearby_flocks<- (flock overlapping (shape +  merging_distance));\n\t\tif !(empty (nearby_flocks)) {\n\t\t \tnearby_flocks <- nearby_flocks sort_by (length (each.members));\n\t\t \tflock largest_flock <- nearby_flocks at ((length (nearby_flocks)) - 1);\n\t\t \t \n\t\t \tremove largest_flock from: nearby_flocks;\n\t\t \t \n\t\t \tlist<boids> added_components ;\n\t\t \tloop one_flock over: nearby_flocks {\n\t\t \t\trelease one_flock.members returns: released_boids; \n\t\t \t\t\n\t\t \t\tloop rb over: released_boids {\n\t\t \t\t\tadd boids(rb) to: added_components;\n\t\t \t\t}\n\t\t \t}\n\t\t \t\n\t\t \tif !(empty (added_components)) { \n\t\t \t\task largest_flock {\n\t\t \t\t\tcapture added_components as: boids_delegation;\n\t\t \t\t}\n\t\t \t} \n\t\t }\n\t}\n\t\n\taspect default {\n\t\tdraw shape color: color;\n\t}\n}\n\t\n//Species to represent the boids aggregated\nspecies aggregatedboids{\n\treflex updateLocation{\n\t  location <- mean (boids collect (each.location));\t\n\t}\n\taspect base{   \t\t\n\t\tdraw sphere(10) color: rgb('red');\n\t}\n}\n//Species to represent the boids agent using the skill moving\nspecies boids skills: [moving] {\n\t//Speed of the agent\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t//Range of movement for the neighbours\n\tfloat range <- minimal_distance * 2;\n\t//Velocity of the agent\n\tpoint velocity <- {0,0};\n\tfloat hue <- rnd(360) / 360;\n\t\n\t//List of the neighbours boids\n\tlist<boids> others update: ((boids overlapping (circle (range)))  - self);\n\t\n\t//Point of the mass center of the \"flock\" considered as the neighbours agents\n\tpoint mass_center update:  (length(others) > 0) ? (mean (others collect (each.location)) )  : location;\n\t\n\t//Reflex to do the separation of the agents with the other boids in the minimal distance\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0,0}; \n\t\tloop boid over: (boids overlapping (circle(minimal_distance)))  {\n\t\t\tacc <- acc - ((location of boid) - location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t\n\t//Reflex to do the alignement of the boids\n\treflex alignment when: apply_alignment {\n\t\tpoint acc <- mean (others collect (each.velocity)) - velocity;\n\t\tvelocity <- velocity + (acc / alignment_factor);\n\t}\n\t \n\t//Reflex to apply the cohesion using the mass center of the \"flock\"\n\treflex cohesion when: apply_cohesion {\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc / cohesion_factor;\n\t\tvelocity <- velocity + acc; \n\t}\n\t//Reflex to avoid the obstacles\n\treflex avoid when: apply_avoid {\n\t\tpoint acc <- {0,0};\n\t\tlist<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - ((location of obs) - my (location));\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t//action to represent the bounding of the movement of the boids\n\taction bounding {\n\t\tif  !(torus_environment) {\n\t\t\tif  (location.x) < xmin {\n\t\t\t\tvelocity <- velocity + {bounds,0};\n\t\t\t} else if (location.x) > xmax {\n\t\t\t\tvelocity <- velocity - {bounds,0};\n\t\t\t}\n\t\t\t\n\t\t\tif (location.y) < ymin {\n\t\t\t\tvelocity <- velocity + {0,bounds};\n\t\t\t} else if (location.y) > ymax {\n\t\t\t\tvelocity <- velocity - {0,bounds};\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//Reflex to follow the goal \n\treflex follow_goal when: apply_goal {\n\t\tvelocity <- velocity + ((goal - location) / cohesion_factor);\n\t}\n\t//Reflex to apply the wind vector\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t//action to move  \n\taction do_move {  \n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) -2, (rnd(4)) - 2}; \n\t\t}\n\t\tpoint old_location <- location; \n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location; \n\t}\n\t\n\t//Reflex to do the movement, calling both bounding and do_move actions\n\treflex movement {\n\t\tdo bounding;\n\t\tdo do_move;\n\t}\n\t\n\taspect basic{\n\t\tdraw triangle(boids_size) color:rgb('black');\n\t}\n\taspect image {\n\t\tdraw (images at (rnd(2))) size: boids_size rotate: heading color: rgb('black') ;\t\t\t    \n\t}\n\t\t\t\n\taspect dynamicColor{\n\t\trgb cc <- hsb (float(heading)/360.0,1.0,1.0);\n\t\tdraw triangle(20) size: 15 rotate: 90 + heading color: cc border:cc depth:5;\n\t\tdraw name;\n\t}\n} \n\n//Species which represents the obstacles using the skill moving\nspecies obstacle skills: [moving] {\n\tfloat speed <- 0.1;\t \n\taspect default {\n\t\tdraw triangle(20) color: rgb('yellow') depth:5;\n\t}\n}\n\n\n\nexperiment start type: gui {\n\toutput {\n\t\tdisplay RealBoids  type:opengl z_fighting:false {\n\t\t\timage 'background' file:file_path_to_ocean;\n\t\t\tspecies boids aspect: dynamicColor  position:{0,0,0.1} trace: 30;\n\t\t\tspecies boids_goal transparency:0.2 position:{0,0,0.1};\n\t\t\tspecies obstacle position:{0,0,0.1}; \t\t\n\t\t}\n\t}\n}\n\nexperiment trajectory_analysis type: gui {\n\toutput {\n\t\t\n\t\tdisplay RealBoids  type:opengl {\n\t\t\timage 'background' file:file_path_to_ocean;\n\t\t\tspecies boids aspect: dynamicColor transparency:0.5 position:{0,0,0.1};\n\t\t\tspecies boids aspect: image transparency:0.5 position:{0,0,0.11};\n\t\t\tspecies boids_goal transparency:0.2 position:{0,0,0.1};\n\t\t\tspecies obstacle position:{0,0,0.1}; \t\t\n\t\t}\n\t\t\t\t\n\t\tdisplay AggregatedBoidsTrajectory  type:opengl  {\n\t\t\timage 'background' file:file_path_to_ocean;\n\t\t\tspecies aggregatedboids  aspect: base trace:100 fading: true ;\n\t\t\tspecies boids_goal aspect:sphere;\t\t\n\t\t}\n\t} \n}\n\nexperiment SpaceTimeCube type: gui {\n\toutput {\n\t\tdisplay RealBoids  type:opengl {\n\t\t\timage 'background' file:file_path_to_ocean;\n\t\t\tspecies boids aspect: dynamicColor transparency:0.5 position:{0,0,0.1};\n\t\t\tspecies boids aspect: image transparency:0.5 position:{0,0,0.11};\n\t\t\tspecies boids_goal transparency:0.2 position:{0,0,0.1};\n\t\t\tspecies obstacle position:{0,0,0.1}; \t\t\n\t\t}\n\t\t\n\t\tdisplay SpaceTimeCubeAll  type:opengl {\n\t\t\timage 'background' file:file_path_to_ocean;\n\t\t\tspecies boids trace:true{\n\t\t\t    draw triangle(20) size: 15 rotate: 90 + heading color: hsb (float(heading)/360.0,1.0,1.0) border:hsb (float(heading)/360.0,1.0,1.0) depth:5 at: {location.x ,location.y,location.z+time};\t\n\t\t\t}\n\t\t\tspecies boids_goal trace:true{\n\t\t\t\tdraw sphere(10) color: rgb('yellow') at: {location.x ,location.y,location.z+time};\n\t\t\t}\t\n\t\t}\n\t\t\t\t\n\t\tdisplay SpaceTimeCubeAggregated  type:opengl {\n\t\t\timage 'background' file:file_path_to_ocean;\n\t\t\tspecies aggregatedboids trace:true{\n\t\t\t    draw sphere(10) color: rgb('red') at: {location.x ,location.y,location.z+time};\t\n\t\t\t}\n\t\t\tspecies boids_goal trace:true{\n\t\t\t\tdraw sphere(10) color: rgb('yellow') at: {location.x ,location.y,location.z+time};\n\t\t\t}\t\n\t\t}\n\t}\n}\n\nexperiment MultipleView type: gui {\n\toutput {\n\n\n\t\tdisplay RealBoids   type:opengl {\n\t\t\timage 'background' file:file_path_to_ocean;\n\t\t\tspecies boids aspect: image  transparency:0.5 position:{0,0,0.25};\n\t\t\tspecies boids_goal transparency:0.2 position:{0,0,0.25};\n\t\t\tspecies obstacle ;\n\t\t\tspecies boids  aspect: dynamicColor transparency:0.2 position:{0,0,0.24};\t\t\n\t\t}\n\t\t\n\t\tdisplay ThirdPersonn  type:opengl camera_interaction:false camera_pos:{int(first(boids).location.x),int(first(boids).location.y),250} \n\t\tcamera_look_pos:{int(first(boids).location.x),first(boids).location.y,0} \n\t\tcamera_up_vector:{0.0,-1.0,0.0} {\n\t\t\n\t\t\timage 'background' file:file_path_to_ocean;\n\t\t\tspecies obstacle;\n\t\t\tspecies boids  aspect: dynamicColor transparency:0.2 ;\n\t\t\tspecies boids_goal  transparency:0.2; \t\t\n\t\t}\n\t\t\n\t\t\t\n\t\tdisplay FirstPerson  type:opengl camera_interaction:false camera_pos:{int(first(boids).location.x),int(first(boids).location.y),10} \n\t\t\tcamera_look_pos:{cos(first(boids).heading)*first(boids).speed+int(first(boids).location.x),\n\t\t\tsin(first(boids).heading)*first(boids).speed+int(first(boids).location.y),10} \n\t\t\tcamera_up_vector:{0.0,0.0,1.0} {\t\n\t\t\timage 'background' file:file_path_to_ocean;\n\t\t\tspecies obstacle ;\n\t\t\tspecies boids  aspect: dynamicColor transparency:0.2 ;\n\t\t\tspecies boids_goal  transparency:0.2; \t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Boids-Boids-3D-Analysis.md"},"Boids-Boids-3D-Motion.md":{"title":" Boids 3D Motion","content":"[//]: # (keyword|operator_cube)\n[//]: # (keyword|skill_moving3D)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_3d)\n# Boids 3D Motion\n\n\n_Author : _\n\nThis model shows the movement of boids following a goal, and creating without their own volonty, a flock .  The goal agent and the boids will move within the 3D space.\n\n\nCode of the model : \n\n```\nmodel boids_3D \nglobal torus: torus_environment{ \n\t//Number of boids to create\n\tint number_of_agents parameter: 'Number of agents' <- 100 min: 1 max: 1000000;\n\t//Number of obstacles to create\n\tint number_of_obstacles parameter: 'Number of obstacles' <- 0 min: 0;\n\t//Size of the boids\n\tint boids_size parameter: 'Boids size' <- 50 min: 1;\n\t//Maximal speed of the boids\n\tfloat maximal_speed parameter: 'Maximal speed' <- 15.0 min: 0.1 max: 15.0;\n\t//Factor for the boids flock\n\tint cohesion_factor parameter: 'Cohesion Factor' <- 100; \n\tint alignment_factor parameter: 'Alignment Factor' <- 100; \n\tfloat minimal_distance parameter: 'Minimal Distance' <- 10.0; \n\t//MAximal angle of turn for the boids\n\tint maximal_turn parameter: 'Maximal Turn' <- 90 min: 0 max: 359; \n\t//environment parameters\n\tint width_and_height_of_environment parameter: 'Width/Height of the Environment' <- 800;  \n\tint z_max parameter: 'Z max of the Environment' <- 400;  \n\tbool torus_environment parameter: 'Toroidal Environment ?' <- false; \n\t//Experiment parameter\n\tbool apply_cohesion <- true parameter: 'Apply Cohesion ?';\n\tbool apply_alignment <- true parameter: 'Apply Alignment ?';   \n\tbool apply_separation <- true parameter: 'Apply Separation ?';   \n\tbool apply_goal <- true parameter: 'Follow Goal ?'; \n\tbool apply_wind <- true parameter: 'Apply Wind ?';     \n\t//Wind variable\n\tpoint wind_vector <- {0,0,0}  parameter: 'Direction of the wind';   \n\t//Duration of the goal\n\tint goal_duration <- 30 update: (goal_duration - 1); \n\t//Location of the goal\n\tpoint goal <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 ,(rnd(z_max - 2) + 1)}; \n\tlist images <- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \n\tgeometry shape <- cube(width_and_height_of_environment);\n\tinit {\n\t\t//Creation of the boids agents that will be placed randomly within the environment\n\t\tcreate boids number: number_of_agents { \n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 , (rnd(z_max - 2) + 1)};\n\t\t} \n\t\t//Creation of the goal\n\t\tcreate boids_goal {\n\t\t\tlocation <- goal;\n\t\t}\n\t}\n}\n\n//Species boids_goal that will represent the goal agent, using the skill moving\nspecies boids_goal skills: [moving3D] {\n\tfloat range init: 20.0;\n\t\n\t//Reflex to make the goal agent wander in a certain amplitude and a certain speed, \n\t//Respecting the minimal and maximal z values\n\treflex wander { \n\t\tdo  wander amplitude: 45 speed: 20; \n\t\tif (location.z) < 0 {\n\t\t\tlocation <- {location.x,location.y,0};\n\t\t} else if (location.z) > z_max {\n\t\t\tlocation <- {location.x,location.y,z_max};\n\t\t}\n\t\tgoal <- location;\n\t}\n\t\n\taspect default { \n\t\tdraw sphere(10) color: #red ;\n\t}\n} \n\n//Species boids that will represent the boids agents, using the skill moving\nspecies boids skills: [moving] {\n\t//Attribute for the speed of the boids\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t//Range of sensing of the boids\n\tfloat range <- minimal_distance * 2;\n\tpoint velocity <- {0,0, 0} ;\n\t\n\t//List of the others boids in the range distance of the agent\n\tlist others update: ((boids at_distance range)  - self);\n\t//Mass center of the \"flock\" represented as the other boids in the sensing range\n\tpoint mass_center update:  (length(others) > 0) ? (mean (others collect (each.location)) )  : location;\n\t\n\t//Reflex to apply separation\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0,0,0};\n\t\tloop boid over: (boids at_distance (minimal_distance))  {\n\t\t\tacc <- acc - ((location of boid) - location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t//Reflex to apply alignment\n\treflex alignment when: apply_alignment {\n\t\tpoint acc <- (length(others) > 0) ? (mean (others collect (each.velocity))) : {0.0,0.0,0.0};\n\t\tacc <- acc - velocity;\n\t\tvelocity <- velocity + (acc / alignment_factor);\n\t}\n\t//Reflex to apply cohesion\n\treflex cohesion when: apply_cohesion {\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc / cohesion_factor;\n\t\tvelocity <- velocity + acc; \n\t}\n\t//Action to make the agent location within the environment\n\taction bounding {\n\t\tif (location.z) < 0 {\n\t\t\tlocation <- {location.x,location.y,0};\n\t\t} else if (location.z) > z_max {\n\t\t\tlocation <- {location.x,location.y,z_max};\n\t\t}\n\t}\n\t//Reflex to make the agent follow the goal\n\treflex follow_goal when: apply_goal {\n\t\tvelocity <- velocity + ((goal - location) / cohesion_factor);\n\t}\n\t//Reflex to apply the wind by using the vector of wind\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t//Action to make the agent moving\n\taction do_move {  \n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) and (((velocity.z) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) -2, (rnd(4)) - 2,  ((rnd(4)) - 2)} ; \n\t\t}\n\t\tpoint old_location <- location;\n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location;\n\t}\n\t//Reflex to move the agent, calling both bounding and do_move action\n\treflex movement {\n\t\tdo bounding;\n\t\tdo do_move;\n\t}\n\t\n\taspect sphere {\n\t\tdraw sphere(10) color: #green;\n\t}\n\t\n\taspect image {\n\t\tdraw (images at (rnd(2))) size: boids_size rotate: heading color: #black ;      \n\t}\n}\n\n\nexperiment boids_3D type: gui {\n\t\n\t\n\toutput {\n\t\t\n\t\tdisplay Sky1 type:opengl  z_fighting:false{\n\t\t\timage 'background' file:'../images/ocean.jpg' ;\n\t\t\tspecies boids aspect: image;\n\t\t\tspecies boids_goal;\t\n\t\t}\n\t\t\n\n\t}\n}\n```\n","url":"wiki/Boids-Boids-3D-Motion.md"},"Boids-Boids-With-Flocks.md":{"title":" Boids With Flocks","content":"[//]: # (keyword|operator_copy)\n[//]: # (keyword|operator_triangle)\n[//]: # (keyword|operator_buffer)\n[//]: # (keyword|operator_polygon)\n[//]: # (keyword|operator_convex_hull)\n[//]: # (keyword|operator_solid)\n[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_towards)\n[//]: # (keyword|operator_sin)\n[//]: # (keyword|operator_simple_clustering_by_distance)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_event)\n[//]: # (keyword|constant_#lightblue)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_multi_level)\n[//]: # (keyword|concept_clustering)\n# Boids With Flocks\n\n\n_Author : _\n\nThis model shows the movement of boids following a goal, and creating without their own volonty, a flock . \n\n\nImported model : \n\n```\n\nmodel boids \nglobal torus: torus_environment{ \n\t//Number of boids that will be created\n\tint number_of_agents <- 50 min: 1 max: 1000000;\n\t//Number of obstacles for the boids movement to represent\n\tint number_of_obstacles <- 0 min: 0;\n\t//Maximal speed of the boids\n\tfloat maximal_speed <- 15.0 min: 0.1 max: 15.0;\n\t//Factors for the group of boids\n\tint cohesion_factor <- 200;\n\tint alignment_factor <- 100; \n\t//Variables for the movement of the boids\n\tfloat minimal_distance <- 10.0; \n\tint maximal_turn <- 45 min: 0 max: 359; \n\t\n\tint width_and_height_of_environment <- 1000;  \n\tbool torus_environment <- false; \n\tbool apply_cohesion <- true ;\n\tbool apply_alignment <- true ;\n\tbool apply_separation <- true;\n\tbool apply_avoid <- true;  \n\tbool apply_wind <- true;   \n\tbool moving_obstacles <- false;   \n\tint bounds <- int(width_and_height_of_environment / 20); \n\t//Vector for the wind\n\tpoint wind_vector <- {0,0}; \n\tlist images of: image_file <- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \n\tint xmin <- bounds;   \n\tint ymin <- bounds;  \n\tint xmax <- (width_and_height_of_environment - bounds);     \n\tint ymax <- (width_and_height_of_environment - bounds);   \n\t\n\t//Action to move the goal to the mouse location\n\taction move_goal(point mouse) {\n\t\task first(boids_goal) {\n\t\t\tdo goto target: mouse speed: 30;\n\t\t}\n\t}\n\t\n\tgeometry shape <- square(width_and_height_of_environment);\n\t\n\tinit { \n\t\t//Create the boids agents\n\t\tcreate boids number: number_of_agents { \n\t\t\t location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\n\t\t} \n\t\t//Create the obstacles agents\n\t\tcreate obstacle number: number_of_obstacles {\n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \n\t\t}\n\t\t//Create the goal that boids will follow\n\t\tcreate  boids_goal;\t\n\t}\t\n}\n\n//Species boids goal which represents the goal that will be followed by boids agents using the skill moving\nspecies boids_goal skills: [moving] {\n\tfloat range  <- 20.0;\n\t\n\t//If the mouse is not used, then the goal just wander\n\treflex wander {  \n\t\tdo  wander amplitude: 45 speed: 20;  \n\t}\n\t\n\taspect default {\n\t\tdraw circle(10) color: #red ;\n\t\tdraw circle(40) color: #orange empty: true;\n\t}\n} \n//Species boids which represents the boids agents whom follow the boid goal agents, using the skill moving\nspecies boids skills: [moving] {\n\t//Speed of the boids agents\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t//Range used to consider the group of the agent\n\tfloat range <- minimal_distance * 2;\n\tpoint velocity <- {0,0};\n\t\t\n\t//Reflex used when the separation is applied to change the velocity of the boid\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0,0};\n\t\task (boids overlapping (circle(minimal_distance)))  {\n\t\t\tacc <- acc - ((location) - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t\n\t//Reflex to align the boid with the other boids in the range\n\treflex alignment when: apply_alignment {\n\t\tlist others  <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint acc <- mean (others collect (each.velocity)) - velocity;\n\t\tvelocity <- velocity + (acc / alignment_factor);\n\t}\n\t \n\t//Reflex to apply the cohesion of the boids group in the range of the agent\n\treflex cohesion when: apply_cohesion {\n\t\tlist others <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint mass_center <- (length(others) > 0) ? mean (others collect (each.location)) : location;\n\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc / cohesion_factor; \n\t\tvelocity <- velocity + acc;   \n\t}\n\t\n\t//Reflex to avoid the obstacles\n\treflex avoid when: apply_avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - ((location of obs) - my (location));\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t\n\t//action to represent the bounding of the environment considering the velocity of the boid\n\taction bounding {\n\t\tif  !(torus_environment) {\n\t\t\tif  (location.x) < xmin {\n\t\t\t\tvelocity <- velocity + {bounds,0};\n\t\t\t} else if (location.x) > xmax {\n\t\t\t\tvelocity <- velocity - {bounds,0};\n\t\t\t}\n\t\t\t\n\t\t\tif (location.y) < ymin {\n\t\t\t\tvelocity <- velocity + {0,bounds};\n\t\t\t} else if (location.y) > ymax {\n\t\t\t\tvelocity <- velocity - {0,bounds};\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//Reflex to follow the goal \n\treflex follow_goal {\n\t\tvelocity <- velocity + ((first(boids_goal).location - location) / cohesion_factor);\n\t}\n\t//Reflex to apply the wind vector on the velocity\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t\n\t//Action to move the agent  \n\taction do_move {  \n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) -2, (rnd(4)) - 2};\n\t\t}\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location;\n\t}\n\t\n\t//Reflex to apply the movement by calling the do_move action\n\treflex movement {\n\t\tdo do_move;\n\t}\n\t\n\taspect image {\n\t\tdraw (images at (rnd(2))) size: {50,50} rotate: heading ;      \n\t}\n\taspect circle { \n\t\tdraw circle(15)  color: #red;\n\t}\n\t\n\taspect default { \n\t\tdraw circle(20) color: #lightblue empty: true;\n\t}\n} \n\n//Species obstacle that represents the obstacles avoided by the boids agents using the skill moving\nspecies obstacle skills: [moving] {\n\tfloat speed <- 2.0;\n\tgeometry shape <- triangle(15);\n\t\n\t//Reflex to move the obstacles if it is available\n\treflex move_obstacles when: moving_obstacles {\n\t\t//Will make the agent go to a boid with a 50% probability\n\t\tif flip(0.5)  \n\t\t{ \n\t\t\tdo goto target: one_of(boids);\n\t\t} \n\t\telse{ \n\t\t\tdo wander amplitude: 360;   \n\t\t}\n\t}\n\taspect default {\n\t\tdraw  triangle(20) color: #black ;\n\t}\n\n}\n\n\nexperiment boids_gui type: gui {\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var: number_of_obstacles;\n\tparameter 'Maximal speed' var: maximal_speed;\n\tparameter 'Cohesion Factor' var: cohesion_factor;\n\tparameter 'Alignment Factor' var: alignment_factor; \n\tparameter 'Minimal Distance'  var: minimal_distance; \n\tparameter 'Maximal Turn'  var: maximal_turn; \n\tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \n\tparameter 'Toroidal Environment ?'  var: torus_environment ; \n\tparameter 'Apply Cohesion ?' var: apply_cohesion ;\n\tparameter 'Apply Alignment ?' var: apply_alignment ;   \n\tparameter 'Apply Separation ?' var: apply_separation ;   \n\tparameter 'Apply Avoidance ?' var: apply_avoid ;   \n\tparameter 'Apply Wind ?' var: apply_wind ;     \n\tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \n\tparameter 'Direction of the wind' var: wind_vector ;  \n\t\n\t//Minimum duration of a step to better see the movements\n\tfloat minimum_cycle_duration <- 0.01;\n\n\toutput {\n\t\tdisplay Sky  background: #blue type: opengl { \n\t\t\timage '../images/sky.jpg' refresh: false;\n\t\t\tspecies boids aspect: image trace: 10 fading: true ;\n\t\t\tspecies boids_goal;\n\t\t\tspecies obstacle;\n\t\t\t//Event to call the action move_goal in global if the mouse move within the experiment\n\t\t\tevent mouse_move action: move_goal;\n\t\t}\n\n\t}\n}\n```\n\n\nCode of the model : \n\n```\nmodel boids_flock\n//Import the boids model\nimport \"Boids.gaml\"\nglobal {\n\t//Size of the boids\n\tfloat boids_size <- float(3);\n\t//Shape of the boids\n\tgeometry boids_shape <- circle(boids_size);\n\t//Separation between boids\n\tfloat boids_separation <- 4 * boids_size;\n\t//Distance to allow creation of the flock \n\tint flock_creation_distance <- int(boids_separation + 1);\n\t//Minimum number of member among a flock\n\tint min_group_member <- 3;\n\t//Frequency of update for the flock\n\tint update_frequency <- 10;\n\t//Frequency of merge for the flock\n\tint merge_frequency <- 10;\n\t//Allow the creation of flock\n\tbool create_flocks <- false;\n\t//Perception range of the boids\n\tint base_perception_range <- int(xmax / 100) min: 1;\n\t\n\tinit {\n\t\t//Creation of the different agents viewer\n\t\tcreate boids_agents_viewer;\n\t\tcreate flock_agents_viewer;\n\t\tcreate boids_in_flock_viewer;\n\t}\n\t//Reflex to create the flocks if it is available\n\treflex create_flocks when: create_flocks {\n\t\t\n\t\tif (length(boids) > 1) {\n\t\t\t//Clustering by distance of the boids to determine the satisfying boids groups\n\t\t\tlist<list<boids>> satisfying_boids_groups <- (boids.population simple_clustering_by_distance flock_creation_distance) where ((length(each)) > min_group_member);\n\t\t\tloop one_group over: satisfying_boids_groups {\n\t\t\t\t\n\t\t\t\tgeometry potential_flock_polygon <- convex_hull(solid(polygon(one_group collect boids(each).location)) + (base_perception_range + 5));\n\t\t\t\t//If there is no obstacle between the boids of a potential flock, then the flock is created and all the boids become boids in flock\n\t\t\t\tif (empty(obstacle overlapping potential_flock_polygon)) {\n\t\t\t\t\tcreate flock {\n\t\t\t\t\t\tcapture one_group as: boids_in_flock;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n//Species flock which represent the flock of boids, using the skill moving\nspecies flock skills: [moving] {\n\trgb color <- rgb(rnd(255), rnd(255), rnd(255));\n\tgeometry shape <- polygon(((boids_in_flock))) buffer 10;\n\t//Range of perception of the flock\n\tfloat perception_range <- float(base_perception_range + (rnd(5)));\n\t//Speed of the flock\n\tfloat speed update: mean(boids_in_flock collect each.speed);\n\t//Reflex to disaggregate the flock if there is a obstacle in the flock\n\treflex disaggregate {\n\t\tgeometry buffered_shape <- shape + perception_range;\n\t\tif !(empty(obstacle overlapping buffered_shape)) {\n\t\t\trelease members as: boids in: world;\n\t\t\tdo die;\n\t\t}\n\n\t}\n\t//Reflex to capture the boids nearby in the range of perception with an update_frequency\n\treflex capture_nearby_boids when: ((cycle mod update_frequency) = 0) {\n\t\tgeometry buffered_shape <- shape + perception_range;\n\t\tlist<boids> nearby_boids <- (boids overlapping buffered_shape);\n\t\tif (!(empty(nearby_boids))) {\n\t\t\tgeometry new_polygon <- convex_hull(solid(shape + polygon(nearby_boids collect (each.location))));\n\t\t\tif (empty(obstacle overlapping new_polygon)) {\n\t\t\t\tcapture nearby_boids as: boids_in_flock;\n\t\t\t}\n\n\t\t}\n\n\t}\n\t//Reflex to merge the intersecting flocks\n\treflex merge_nearby_flocks when: ((cycle mod merge_frequency) = 0) \n\t{\n\t\tloop f over: (flock) {\n\t\t\tif (f != self and (shape intersects f.shape)) {\n\t\t\t\tgeometry new_shape <- convex_hull(polygon(shape.points + f.shape.points));\n\t\t\t\tif empty(obstacle overlapping new_shape) {\n\t\t\t\t\tlist<boids> released_boids;\n\t\t\t\t\task f {\n\t\t\t\t\t\trelease members as: boids in: world returns: released_coms;\n\t\t\t\t\t\treleased_boids <- list(released_coms);\n\t\t\t\t\t\tdo die;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!empty(released_boids)) {\n\t\t\t\t\t\tcapture released_boids as: boids_in_flock;\n\t\t\t\t\t}\n\n\t\t\t\t\tshape <- convex_hull(polygon(members collect (boids_in_flock(each).location)));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\t//Reflex to make the flock follow the goal\n\treflex chase_goal {\n\t\tint direction_to_nearest_ball <- (self towards (first(boids_goal)));\n\t\tfloat step_distance <- speed * step;\n\t\tfloat dx <- step_distance * (cos(direction_to_nearest_ball));\n\t\tfloat dy <- step_distance * (sin(direction_to_nearest_ball));\n\t\tgeometry envelope <- shape.envelope;\n\t\tfloat min_y <- (envelope.points with_min_of (each.y)).y;\n\t\tfloat min_x <- (envelope.points with_min_of (each.x)).x;\n\t\tfloat max_x <- (envelope.points with_max_of (each.x)).x;\n\t\tfloat max_y <- (envelope.points with_max_of (each.y)).y;\n\t\tif (((dx + min_x) < xmin) and min_x > xmin) or (((dx + max_x) > xmax) and max_x < xmax) {\n\t\t\tdx <- 0.0;\n\t\t}\n\t\tif (((dy + min_y) < ymin) and min_y > ymin) or (((dy + max_y) > ymax) and max_y < ymax) {\n\t\t\tdy <- 0.0;\n\t\t}\n\t\t\n\t\tloop com over: boids_in_flock {\n\t\t\t(boids_in_flock(com)).location <- (boids_in_flock(com)).location + { dx, dy };\n\t\t}\n\n\t\tshape <- convex_hull(polygon(list(boids_in_flock) collect (each.location)));\n\t}\n\n\taspect default {\n\t\tdraw shape color: color;\n\t}\n\t//Species boids_in_flock which represents the boids agents captured by the flock\n\tspecies boids_in_flock parent: boids {\n\t\tfloat my_age <- 1.0 update: my_age + 0.01;\n\t\treflex separation when: apply_separation {\n\t\t}\n\n\t\treflex alignment when: apply_alignment {\n\t\t}\n\n\t\treflex cohesion when: apply_cohesion {\n\t\t}\n\n\t\treflex avoid when: apply_avoid {\n\t\t}\n\n\t\treflex follow_goal  {\n\t\t}\n\n\t\treflex wind when: apply_wind {\n\t\t}\n\n\t\taction do_move {\n\t\t}\n\n\t\treflex movement {\n\t\t\tdo do_move;\n\t\t}\n\n\t\taspect default {\n\t\t\tdraw circle(my_age) color: ((host as flock).color).darker;\n\t\t}\n\n\t}\n\n}\n//Species flock agents viewer which draw the flock information\nspecies flock_agents_viewer {\n\taspect default {\n\t\tdraw \"Flocks: \" + (string(length(list(flock)))) at: { width_and_height_of_environment - 810, (width_and_height_of_environment) - 5 } color: #blue size: 80 ;\n\t}\n\n}\n//Species boids agents viewer which draw the boids information\nspecies boids_agents_viewer {\n\taspect default {\n\t\tdraw \"Boids: \" + (string(length(list(boids)))) at: { width_and_height_of_environment - 810, (width_and_height_of_environment) - 165 } color: #blue size: 80 ;\n\t}\n\n}\n\n//Species boids_in_flock_viewer which draw the boids in flock information\nspecies boids_in_flock_viewer {\n\taspect default {\n\t\tdraw \"Boids in flocks: \" + (string(number_of_agents - (length(list(boids))))) at: { width_and_height_of_environment - 810, width_and_height_of_environment - 85 } color:\n\t\t#blue size: 80 ;\n\t}\n\n}\n\n\nexperiment boids_flocks type: gui {\n\tparameter \"Create flock?\" var: create_flocks <- true;\n\tparameter \"Number of boids\" var: number_of_agents <- 300;\n\tparameter \"Environment size\" var: width_and_height_of_environment <- 1600;\n\tparameter \"Moving obstacles?\" var: moving_obstacles <- true;\n\tparameter \"Torus environment?\" var: torus_environment <- false;\n\tparameter \"Number of obstacles\" var: number_of_obstacles <- 5;\n\toutput {\n\t\tdisplay default_display {\n\t\t\tspecies boids_goal;\n\t\t\tspecies boids aspect: image;\n\t\t\tspecies obstacle;\n\t\t\tspecies flock aspect: default transparency: 0.5 {\n\t\t\t\tspecies boids_in_flock aspect: default;\n\t\t\t}\n\n\t\t\tspecies flock_agents_viewer;\n\t\t\tspecies boids_agents_viewer;\n\t\t\tspecies boids_in_flock_viewer;\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Boids-Boids-With-Flocks.md"},"Boids-Boids.md":{"title":" Boids","content":"[//]: # (keyword|operator_copy)\n[//]: # (keyword|operator_triangle)\n[//]: # (keyword|statement_event)\n[//]: # (keyword|constant_#lightblue)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_skill)\n# Boids\n\n\n_Author : _\n\nThis model shows the movement of boids following a goal, and creating without their own volonty, a flock. The experiment proposes to display in a 3D view the different boids and allows the user to move the goal to see the behaviour of boids.\n\n\nCode of the model : \n\n```\n\nmodel boids \nglobal torus: torus_environment{ \n\t//Number of boids that will be created\n\tint number_of_agents <- 50 min: 1 max: 1000000;\n\t//Number of obstacles for the boids movement to represent\n\tint number_of_obstacles <- 0 min: 0;\n\t//Maximal speed of the boids\n\tfloat maximal_speed <- 15.0 min: 0.1 max: 15.0;\n\t//Factors for the group of boids\n\tint cohesion_factor <- 200;\n\tint alignment_factor <- 100; \n\t//Variables for the movement of the boids\n\tfloat minimal_distance <- 10.0; \n\tint maximal_turn <- 45 min: 0 max: 359; \n\t\n\tint width_and_height_of_environment <- 1000;  \n\tbool torus_environment <- false; \n\tbool apply_cohesion <- true ;\n\tbool apply_alignment <- true ;\n\tbool apply_separation <- true;\n\tbool apply_avoid <- true;  \n\tbool apply_wind <- true;   \n\tbool moving_obstacles <- false;   \n\tint bounds <- int(width_and_height_of_environment / 20); \n\t//Vector for the wind\n\tpoint wind_vector <- {0,0}; \n\tlist images of: image_file <- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \n\tint xmin <- bounds;   \n\tint ymin <- bounds;  \n\tint xmax <- (width_and_height_of_environment - bounds);     \n\tint ymax <- (width_and_height_of_environment - bounds);   \n\t\n\t//Action to move the goal to the mouse location\n\taction move_goal(point mouse) {\n\t\task first(boids_goal) {\n\t\t\tdo goto target: mouse speed: 30;\n\t\t}\n\t}\n\t\n\tgeometry shape <- square(width_and_height_of_environment);\n\t\n\tinit { \n\t\t//Create the boids agents\n\t\tcreate boids number: number_of_agents { \n\t\t\t location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\n\t\t} \n\t\t//Create the obstacles agents\n\t\tcreate obstacle number: number_of_obstacles {\n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \n\t\t}\n\t\t//Create the goal that boids will follow\n\t\tcreate  boids_goal;\t\n\t}\t\n}\n\n//Species boids goal which represents the goal that will be followed by boids agents using the skill moving\nspecies boids_goal skills: [moving] {\n\tfloat range  <- 20.0;\n\t\n\t//If the mouse is not used, then the goal just wander\n\treflex wander {  \n\t\tdo  wander amplitude: 45 speed: 20;  \n\t}\n\t\n\taspect default {\n\t\tdraw circle(10) color: #red ;\n\t\tdraw circle(40) color: #orange empty: true;\n\t}\n} \n//Species boids which represents the boids agents whom follow the boid goal agents, using the skill moving\nspecies boids skills: [moving] {\n\t//Speed of the boids agents\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t//Range used to consider the group of the agent\n\tfloat range <- minimal_distance * 2;\n\tpoint velocity <- {0,0};\n\t\t\n\t//Reflex used when the separation is applied to change the velocity of the boid\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0,0};\n\t\task (boids overlapping (circle(minimal_distance)))  {\n\t\t\tacc <- acc - ((location) - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t\n\t//Reflex to align the boid with the other boids in the range\n\treflex alignment when: apply_alignment {\n\t\tlist others  <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint acc <- mean (others collect (each.velocity)) - velocity;\n\t\tvelocity <- velocity + (acc / alignment_factor);\n\t}\n\t \n\t//Reflex to apply the cohesion of the boids group in the range of the agent\n\treflex cohesion when: apply_cohesion {\n\t\tlist others <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint mass_center <- (length(others) > 0) ? mean (others collect (each.location)) : location;\n\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc / cohesion_factor; \n\t\tvelocity <- velocity + acc;   \n\t}\n\t\n\t//Reflex to avoid the obstacles\n\treflex avoid when: apply_avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - ((location of obs) - my (location));\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t\n\t//action to represent the bounding of the environment considering the velocity of the boid\n\taction bounding {\n\t\tif  !(torus_environment) {\n\t\t\tif  (location.x) < xmin {\n\t\t\t\tvelocity <- velocity + {bounds,0};\n\t\t\t} else if (location.x) > xmax {\n\t\t\t\tvelocity <- velocity - {bounds,0};\n\t\t\t}\n\t\t\t\n\t\t\tif (location.y) < ymin {\n\t\t\t\tvelocity <- velocity + {0,bounds};\n\t\t\t} else if (location.y) > ymax {\n\t\t\t\tvelocity <- velocity - {0,bounds};\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//Reflex to follow the goal \n\treflex follow_goal {\n\t\tvelocity <- velocity + ((first(boids_goal).location - location) / cohesion_factor);\n\t}\n\t//Reflex to apply the wind vector on the velocity\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t\n\t//Action to move the agent  \n\taction do_move {  \n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) -2, (rnd(4)) - 2};\n\t\t}\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location;\n\t}\n\t\n\t//Reflex to apply the movement by calling the do_move action\n\treflex movement {\n\t\tdo do_move;\n\t}\n\t\n\taspect image {\n\t\tdraw (images at (rnd(2))) size: {50,50} rotate: heading ;      \n\t}\n\taspect circle { \n\t\tdraw circle(15)  color: #red;\n\t}\n\t\n\taspect default { \n\t\tdraw circle(20) color: #lightblue empty: true;\n\t}\n} \n\n//Species obstacle that represents the obstacles avoided by the boids agents using the skill moving\nspecies obstacle skills: [moving] {\n\tfloat speed <- 2.0;\n\tgeometry shape <- triangle(15);\n\t\n\t//Reflex to move the obstacles if it is available\n\treflex move_obstacles when: moving_obstacles {\n\t\t//Will make the agent go to a boid with a 50% probability\n\t\tif flip(0.5)  \n\t\t{ \n\t\t\tdo goto target: one_of(boids);\n\t\t} \n\t\telse{ \n\t\t\tdo wander amplitude: 360;   \n\t\t}\n\t}\n\taspect default {\n\t\tdraw  triangle(20) color: #black ;\n\t}\n\n}\n\n\nexperiment boids_gui type: gui {\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var: number_of_obstacles;\n\tparameter 'Maximal speed' var: maximal_speed;\n\tparameter 'Cohesion Factor' var: cohesion_factor;\n\tparameter 'Alignment Factor' var: alignment_factor; \n\tparameter 'Minimal Distance'  var: minimal_distance; \n\tparameter 'Maximal Turn'  var: maximal_turn; \n\tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \n\tparameter 'Toroidal Environment ?'  var: torus_environment ; \n\tparameter 'Apply Cohesion ?' var: apply_cohesion ;\n\tparameter 'Apply Alignment ?' var: apply_alignment ;   \n\tparameter 'Apply Separation ?' var: apply_separation ;   \n\tparameter 'Apply Avoidance ?' var: apply_avoid ;   \n\tparameter 'Apply Wind ?' var: apply_wind ;     \n\tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \n\tparameter 'Direction of the wind' var: wind_vector ;  \n\t\n\t//Minimum duration of a step to better see the movements\n\tfloat minimum_cycle_duration <- 0.01;\n\n\toutput {\n\t\tdisplay Sky  background: #blue type: opengl { \n\t\t\timage '../images/sky.jpg' refresh: false;\n\t\t\tspecies boids aspect: image trace: 10 fading: true ;\n\t\t\tspecies boids_goal;\n\t\t\tspecies obstacle;\n\t\t\t//Event to call the action move_goal in global if the mouse move within the experiment\n\t\t\tevent mouse_move action: move_goal;\n\t\t}\n\n\t}\n}\n```\n","url":"wiki/Boids-Boids.md"},"Circle-Circle.md":{"title":" Circle","content":"[//]: # (keyword|operator_towards)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_of_species)\n[//]: # (keyword|concept_skill)\n# Circle\n\n\n_Author : _\n\nThis model shows the movement of cells trying to do a circle shape with themselves considering the other cells. The second experiment shows a bigger circle using more cell agents.\n\n\nCode of the model : \n\n```\nmodel circle_model\n\nglobal { \n\t//Number of agents to create\n\tint number_of_agents min: 1 <- 50 ;\n\t//Radius of the circle that the cells will make\n\tint radius_of_circle min: 10 <- 1000 ;\n\t//Repulsion strength of one cell to the others\n\tint repulsion_strength min: 1 <- 5 ;\n\t//Size of the environment\n\tint width_and_height_of_environment min: 10 <- 3000 ; \n\t//Range of the agents\n\tint range_of_agents min: 1 <- 25 ;\n\t//Speed of the agents\n\tfloat speed_of_agents min: 0.1  <- 2.0 ; \n\t//Size of the agents\n\tint size_of_agents <- 100;\n\t//Center of the considered circle created by the cells\n\tpoint center const: true <- {width_and_height_of_environment/2,width_and_height_of_environment/2};\n\tgeometry shape <- square(width_and_height_of_environment);\n\tinit { \n\t\t//Creation of the cell agents\n\t\tcreate cell number: number_of_agents;\n\t}  \n}  \n  \n//Species cell which represents the cell agents, using the skill moving\nspecies cell skills: [moving] {  \n\t//Color of the cell, randomly chosen\n\trgb color const: true <- [100 + rnd (155),100 + rnd (155), 100 + rnd (155)] as rgb;\n\t//Size of the cell\n\tfloat size const: true <- float(size_of_agents);\n\t//Range of the cell\n\tfloat range const: true <- float(range_of_agents); \n\t//Speed of the cell\n\tfloat speed const: true <- speed_of_agents;   \n\t//Heading of the cell, the direction it 'watches'\n\tint heading <- rnd(359);\n\t\n\t//Reflex to make the cell agent fo to the center, calling the derivated action move\n\treflex go_to_center {\n\t\theading <- (((self distance_to center) > radius_of_circle) ? self towards center : (self towards center) - 180);\n\t\tdo move speed: speed; \n\t}\n\t//Reflex to flee of the other cells agents, which will help to design the circle shape\n\treflex flee_others {\n\t\tcell close <- one_of ( ( (self neighbors_at range) of_species cell) sort_by (self distance_to each) );\n\t\tif close != nil {\n\t\t\theading <- (self towards close) - 180;\n\t\t\tfloat dist <- self distance_to close;\n\t\t\tdo move speed: dist / repulsion_strength heading: heading;\n\t\t}\n\t}\n\t\n\taspect default { \n\t\tdraw circle(size)  color: color;\n\t}\n}\n\n\nexperiment main type: gui {\n\tparameter 'Number of Agents' var: number_of_agents;\n\tparameter 'Radius of Circle' var: radius_of_circle; \n\tparameter 'Strength of Repulsion' var: repulsion_strength; \n\tparameter 'Dimensions' var: width_and_height_of_environment;\n\tparameter 'Range of Agents' var: range_of_agents;\n\tparameter 'Speed of Agents' var: speed_of_agents ; \n\t\n\toutput {\n\t\tdisplay Circle {\n\t\t\tspecies cell;\n\t\t}\n\t}\n}\nexperiment main2 type: gui  {\n\tparameter \"Size of Agents\" var: size_of_agents <- 100;\n\tparameter 'Number of Agents' var: number_of_agents <- 300;\n\tparameter 'Radius of Circle' var: radius_of_circle min: 10 <- 15000;\n\tparameter 'Strength of Repulsion' var: repulsion_strength min: 1 <- 50;\n\tparameter 'Dimensions' var: width_and_height_of_environment  min: 10 <- 40000;\n\tparameter 'Range of Agents' var: range_of_agents min: 1 <- 250;\n\tparameter 'Speed of Agents' var: speed_of_agents min: 0.1 <- 100.0 ;\n\n\toutput {\n\t\tdisplay Circle  {\n\t\t\tspecies cell;\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Circle-Circle.md"},"Clock-Clock.md":{"title":" Clock","content":"[//]: # (keyword|constant_#msec)\n[//]: # (keyword|constant_#sec)\n# Clock\n\n\n_Author : JD _\n\nCode of the model : \n\n```\nmodel Clock\n\nglobal {\n\t//Background of the clock\n\tfile clock_normal     const: true <- image_file(\"../images/clock.png\");\n\t//Image for the big hand \n\tfile clock_big_hand   const: true <- image_file(\"../images/big_hand.png\");\n\t//Image for the small hand\n\tfile clock_small_hand const: true <- image_file(\"../images/small_hand.png\");\n\t//Image for the clock alarm\n\tfile clock_alarm \t  const: true <- image_file(\"../images/alarm_hand.png\");\n\t//Zoom to take in consideration the zoom in the display, to better write the cycle values\n\tint zoom <- 4 min:1 max:100;\n\t//Time value for a cycle\n\tfloat step<-360000.0#ms min: 1.0 max: 360000.0;\n\t\n\t//Alarm parameters\n\tint alarm_days <- 0 min:0 max:365;\n\tint alarm_hours <- 2 min:0 max:11;\n\tint alarm_minutes <- 0 min:0 max:59;\n\tint alarm_seconds <- 0 min:0 max:59;\n\tbool alarm_am <- true;\n\tint alarmCycle <-  int((alarm_seconds+alarm_minutes*60+alarm_hours*3600 + (alarm_am ? 0 : 3600*12) + alarm_days*3600*24) * 1000 / step);\n\t\n\t//Time elapsed since the beginning of the experiment\n\tint timeElapsed <- 0 update:  int(cycle * step);\n\tstring reflexType <-\"\";\n\tinit {\n\t\t//Creation of the clock\n\t\tcreate clock number: 1 {\n\t\t\tlocation <- {world.shape.width/5,world.shape.height/5};\n\t\t}\n\t}\n}\n//Species that will represent the clock\nspecies  clock { \n\t\tfloat nb_minutes<-0.0 update: ((timeElapsed mod 3600000#ms))/60000#ms; //Mod with 60 minutes or 1 hour, then divided by one minute value to get the number of minutes\n\t\tfloat nb_hours<-0.0 update:((timeElapsed mod 43200000#ms))/3600000#ms;\n\t\treflex update {\n\t\t\twrite string(nb_hours)+\" : \"+nb_minutes;\n\t\t\tif (cycle = alarmCycle) \n\t\t\t{\n\t\t\t\t write \"Time to leave\" ; \n\n\t\t\t\t // Uncomment the following statement to play the Alarm.mp3\n\t\t\t\t // But firstly, you need to go to \"Help -> Install New Software...\" to install the \"Audio\" feature (which is still in the experimental stage). \n\t\t\t\t//start_sound source:\"../includes/Alarm.mp3\" ;\n\t\t\t}\n\t\t}\n\t\taspect default {\n\t\t\tdraw string(\"#cycles: \" + cycle + \" cycles\")  size:zoom/2 font:\"times\" color:°black at:{world.shape.width/3,0};\n\t\t\tdraw clock_big_hand rotate: nb_minutes*(360/60)  + 90  size: {7 * zoom, 2}; //Modulo with the representation of a minute in ms and divided by 10000 to get the degree of rotation\n\t\t\tdraw clock_small_hand rotate: nb_hours*(360/12)  + 90  size:{5*zoom, 2} ;\t\t\t\n\t\t\tdraw clock_alarm rotate:      (alarmCycle/12000)  size: zoom/3 ; // Alarm time\n\t\t}\n \n}\n\nexperiment Display type: gui {\n\tfloat minimum_cycle_duration <- 0.1#s;\n\tparameter 'Zoom: ' var: zoom category: 'Init' ;\n\tparameter 'Milliseconds/cycle' var: step category: 'Init';\n\tparameter 'alarm Day' var: alarm_days;\n\tparameter 'alarm Hour' var: alarm_hours;\n\tparameter 'alarm Am' var: alarm_am;\n\tparameter 'alarm Minutes' var: alarm_minutes;\n\tparameter 'alarm Seconds' var: alarm_seconds;\n\toutput {\n\t\tdisplay ClockView type: opengl { \n\t\t\tgraphics \"c\" refresh: false {draw clock_normal size: 10*zoom at:{world.shape.width/5,world.shape.height/5} ;}\n\t\t\tspecies clock ;\n\t\t}\n\t}\n\n}\n\n```\n","url":"wiki/Clock-Clock.md"},"Co-model-Example-comodel_Flood_Evacuation.md":{"title":" Comodel of Flood and Evacuation model","content":"[//]: # (keyword|operator_max_of)\n[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|operator_copy)\n[//]: # (keyword|operator_closest_points_with)\n[//]: # (keyword|operator_pyramid)\n[//]: # (keyword|operator_simplification)\n[//]: # (keyword|operator_translated_by)\n[//]: # (keyword|operator_overlaps)\n[//]: # (keyword|operator_font)\n[//]: # (keyword|statement_user_command)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_agents)\n[//]: # (keyword|constant_#magenta)\n[//]: # (keyword|constant_#bold)\n[//]: # (keyword|concept_comodel)\n# Comodel of Flood and Evacuation model\n\n\n_Author : HUYNH Quang Nghi_\n\nCo-model example : couple the evacuation model with the flood model. Water win or human win?\n\n\nImported models : \n\n```\nmodel continuous_move \nglobal { \n\t//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/building.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(building_shapefile);\n\tint maximal_turn <- 90; //in degree\n\tint cohesion_factor <- 10;\n\t//Size of the people\n\tfloat people_size <- 2.0;\n\t//Space without buildings\n\tgeometry free_space;\n\t//Number of people agent\n\tint nb_people <- 500;\n\t//Point to evacuate\n\tpoint target_point <- {world.location.x, 0};\n\tinit { \n\t\t\n\t\tfree_space <- copy(shape);\n\t\t//Creation of the buildinds\n\t\tcreate building from: building_shapefile {\n\t\t\t//Creation of the free space by removing the shape of the different buildings existing\n\t\t\tfree_space <- free_space - (shape + people_size);\n\t\t}\n\t\t//Simplification of the free_space to remove sharp edges\n\t\tfree_space <- free_space simplification(1.0);\n\t\t//Creation of the people agents\n\t\tcreate people number: nb_people {\n\t\t\t//People agents are placed randomly among the free space\n\t\t\tlocation <- any_location_in(free_space);\n\t\t\ttarget_loc <-  target_point;\n\t\t} \t\t \t\n\t}\t\n}\n//Species which represent the building \nspecies building {\n\t//Height of the buildings\n\tfloat height <- 3.0 + rnd(5);\n\taspect default {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n//Species people which move to the evacuation point using the skill moving\nspecies people skills:[moving]{\n\t//Target point to evacuate\n\tpoint target_loc;\n\t//Speed of the agent\n\tfloat speed <- 0.5 + rnd(1000) / 1000;\n\t//Velocity of the agent\n\tpoint velocity <- {0,0};\n\t//Direction of the agent taking in consideration the maximal turn an agent is able to make\n\tint heading max: heading + maximal_turn min: heading - maximal_turn;\n\t\n\t//Size of the agent\n\tfloat size <- people_size;\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t\n\t//Reflex to kill the agent when it has evacuated the area\n\treflex end when: location distance_to target_loc <= 2 * people_size{\n\t\twrite name + \" is arrived\";\n\t\tdo die;\n\t}\n\t//Reflex to compute the velocity of the agent considering the cohesion factor\n\treflex follow_goal  {\n\t\tvelocity <- velocity + ((target_loc - location) / cohesion_factor);\n\t}\n\t//Reflex to apply separation when people are too close from each other\n\treflex separation {\n\t\tpoint acc <- {0,0};\n\t\task (people at_distance size)  {\n\t\t\tacc <- acc - (location - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t//Reflex to avoid the different obstacles\n\treflex avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<building> nearby_obstacles <- (building at_distance people_size);\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - (obs.location - location);\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t//Reflex to move the agent considering its location, target and velocity\n\treflex move {\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity ;\n\t\tif (not empty(building overlapping self )) {\n\t\t\tlocation <- point((location closest_points_with free_space)[1]);\n\t\t}\n\t\tvelocity <- location - old_location;\n\t}\t\n\taspect default {\n\t\tdraw pyramid(size) color: color;\n\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\n\toutput {\n\t\tdisplay map type: opengl {\n\t\t\tspecies building refresh: false;\n\t\t\tspecies people;\n\t\t\tgraphics \"exit\" refresh: false {\n\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n\n```\nmodel Evacuation_coupling\n\nimport \"../../../Toy Models/Evacuation/models/Continuous Move.gaml\"\nexperiment Evacuation_coupling_exp type: gui parent: main\n{\n\tpoint centroid <- { 0, 180 };\n\tlist<building> getBuilding\n\t{\n\t\treturn list(building);\n\t}\n\n\taction transform_environement\n\t{\n\t\tloop t over: list(building)\n\t\t{\n\t\t\tt.shape <- t.shape translated_by centroid;\n\t\t\tt.shape <- t.shape * 10;\n\t\t\tt.location <- t.location * 8;\n\t\t}\n\n\t\tloop t over: list(people)\n\t\t{\n\t\t\tt.speed <- 10.0;\n\t\t\tt.size <- 20.0;\n\t\t\tt.shape <- t.shape translated_by centroid;\n\t\t\tt.location <- t.location * 8;\n\t\t}\n\n\t\ttarget_point <- point(target_point translated_by centroid);\n\t}\n\n\tlist<people> getPeople\n\t{\n\t\treturn list(people);\n\t}\n\n\toutput\n\t{\n\t}\n\n}\n```\n\n\n```\n\nmodel hydro\n\nglobal {\n   //Shapefile for the river\n   file river_shapefile <- file(\"../includes/RedRiver.shp\");\n   //Shapefile for the dykes\n   file dykes_shapefile <- file(\"../includes/Dykes.shp\");\n   //Shapefile for the buildings\n   file buildings_shapefile <- file(\"../includes/Building.shp\");\n   \n   //Data elevation file\n   file dem_file <- file(\"../includes/mnt50.asc\");  \n   //Diffusion rate\n   float diffusion_rate <- 0.6;\n   //Height of the dykes\n   float dyke_height <- 15.0;\n   //Width of the dyke\n   float dyke_width <- 15.0;\n    \n   //Shape of the environment using the dem file\n   geometry shape <- envelope(dem_file);\n   \n   //List of the drain and river cells\n   list<cell> drain_cells;\n   list<cell> river_cells;\n   \n   \n  \n   float step <- 1°h;\n   \n   init {\n   \t //Initialization of the cells\n      do init_cells;\n     //Initialization of the water cells\n      do init_water;\n     //Initialization of the river cells\n     river_cells <- cell where (each.is_river);\n     //Initialization of the drain cells\n      drain_cells <- cell where (each.is_drain);\n     //Initialization of the obstacles (buildings and dykes)\n      do init_obstacles;\n      //Set the height of each cell\n      ask cell {\n         obstacle_height <- compute_highest_obstacle();\n         do update_color;\n      }\n   }\n   //Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\n   //action to initialize the water cells according to the river shape file and the drain\n   action init_water {\n      geometry river <- geometry(river_shapefile);\n      ask cell overlapping river {\n         water_height <- 10.0;\n         is_river <- true;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }\n   //initialization of the obstacles (the buildings and the dykes)\n   action init_obstacles{\n      create buildings from: buildings_shapefile  {\n         do update_cells;\n      }\n      create dyke from: dykes_shapefile;\n      ask dyke {\n          shape <-  shape + dyke_width;\n            do update_cells;\n      }\n   }\n   //Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- rnd(100)/100;\n      ask river_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   //Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask cell {already <- false;}\n      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {\n         do flow;\n      }\n   }\n   //Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell {\n         do update_color;\n      }\n   }\n   //Reflex for the drain cells to drain water\n   reflex draining {\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }\n   \n}\n//Species which represent the obstacle\n   species obstacle {\n   \t  //height of the obstacle\n      float height min: 0.0;\n      //Color of the obstacle\n      rgb color;\n      //Pressure of the water\n      float water_pressure update: compute_water_pressure();\n      \n      //List of cells concerned\n      list<cell> cells_concerned ;\n      //List of cells in the neighbourhood \n      list<cell> cells_neighbours;\n      \n      //Action to compute the water pressure\n      float compute_water_pressure {\n      \t//If the obstacle doesn't have height, then there will be no pressure\n         if (height = 0.0) {\n            return 0.0;\n         } else {\n         \t//The leve of the water is equals to the maximul level of water in the neighbours cells\n            float water_level <- cells_neighbours max_of (each.water_height);\n            //Return the water pressure as the minimal value between 1 and the water level divided by the height\n            return min([1.0,water_level / height]);\n         } \n      }\n      \n      //Action to update the cells\n      action update_cells {\n      \t//All the cells concerned by the obstacle are the ones overlapping the obstacle\n         cells_concerned <- (cell overlapping self);\n        \task cells_concerned {\n        \t//Add the obstacles to the obstacles of the cell\n            add myself to: obstacles;\n            water_height <- 0.0;\n         }\n         //Cells neighbours are all the neighbours cells of the cells concerned\n         cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);\n         //The height is now computed\n      \t do compute_height();\n         if (height > 0.0) {   \n         \t//We compute the water pressure again\n            water_pressure <- compute_water_pressure();\n         } else {water_pressure <- 0.0;}\n      }\n      action compute_height;\n      aspect geometry {\n         int val <- int( 255 * water_pressure);\n         color <- rgb(val,255-val,0);\n         draw shape color: color depth: height*5 border: color;\n      }\n   }\n   //Species buildings which is derivated from obstacle\n   species buildings parent: obstacle {\n   \t //The building has a height randomly chosed between 2 and 10\n      float height <- 2.0 + rnd(8);\n   }\n   //Species dyke which is derivated from obstacle\n   species dyke parent: obstacle{\n   \t\n       int counter_wp <- 0;\n       int breaking_threshold <- 24;\n      \n      //Action to represent the break of the dyke\n       action break{\n         ask cells_concerned {\n            do update_after_destruction(myself);\n         }\n         do die;\n      }\n      //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps\n      action compute_height\n       {\n      \t   height <- dyke_height - mean(cells_concerned collect (each.altitude));\n      \n      }\n      \n      //Reflex to break the dynamic of the water\n      reflex breaking_dynamic {\n      \tif (water_pressure = 1.0) {\n      \t\tcounter_wp <- counter_wp + 1;\n      \t\tif (counter_wp > breaking_threshold) {\n      \t\t\tdo break;\n      \t\t}\n      \t} else {\n      \t\tcounter_wp <- 0;\n      \t}\n      }\n      //user command which allows the possibility to destroy the dyke for the user\n      user_command \"Destroy dyke\" action: break; \n   }\n   //Grid cell to discretize space, initialized using the dem file\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false {\n      //Altitude of the cell\n      float altitude;\n      //Height of the water in the cell\n      float water_height <- 0.0 min: 0.0;\n      //Height of the cell\n      float height;\n      //List of the neighbour cells\n      list<cell> neighbour_cells ;\n      //Boolean to know if it is a drain cell\n      bool is_drain <- false;\n      //Boolean to know if it is a river cell\n      bool is_river <- false;\n      //List of all the obstacles overlapping the cell\n      list<obstacle> obstacles;\n      //Height of the obstacles\n      float obstacle_height <- 0.0;\n      bool already <- false;\n      \n      //Action to compute the highest obstacle among the obstacles\n      float compute_highest_obstacle {\n         if (empty(obstacles))\n         {\n            return 0.0; \n         } else {\n            return obstacles max_of(each.height);\n         }\n      }\n      //Action to flow the water \n      action flow {\n      \t//if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t//We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            //If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}\n               //The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               //If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      //Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n      //action to compute the destruction of the obstacle\n      action update_after_destruction(obstacle the_obstacle){\n         remove the_obstacle from: obstacles;\n         obstacle_height <- compute_highest_obstacle();\n      }\n       \n   }\n\n\nexperiment main_gui type: gui {\n   parameter \"Shapefile for the river\" var:river_shapefile category:\"Water data\";\n   parameter \"Shapefile for the dykes\" var:dykes_shapefile category:\"Obstacles\";\n   parameter \"Shapefile for the buildings\" var:buildings_shapefile category:\"Obstacles\";\n   parameter \"Height of the dykes\" var:dyke_height category:\"Obstacles\";\n   parameter \"Diffusion rate\" var:diffusion_rate category:\"Water dynamic\";\n   output { \n      display map type: opengl {\n         grid cell triangulation: true;\n         species buildings aspect: geometry;\n         species dyke aspect: geometry ;\n      }\n      display chart_display refresh: every(24) { \n         chart \"Pressure on Dykes\" type: series {\n            data \"Mean pressure on dykes \" value: mean(dyke collect (each.water_pressure)) style: line color: #magenta ;\n            data \"Rate of dykes with max pressure\" value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;\n            data \"Rate of dykes with high pressure\" value: (dyke count (each.water_pressure > 0.5))/ length(dyke) style: line color: #orange ;\n            data \"Rate of dykes with low pressure\" value: (dyke count (each.water_pressure < 0.25))/ length(dyke) style: line color: #green ;\n         }\n      }\n   }\n}\n```\n\n\n```\nmodel Flood_coupling\n\nimport \"../../../Toy Models/Flood Simulation/models/Hydrological Model.gaml\"\nexperiment Flood_coupling_exp type: gui parent: main_gui\n{\n\tpoint newSize <- { 0.07, 0.07 };\n\tcell getCellAt (geometry p)\n\t{\n\t\task simulation\n\t\t{\n\t\t\treturn cell closest_to p;\n\t\t}\n\n\t}\n\n\tlist<cell> getCell\n\t{\n\t\treturn list(cell) where (each.grid_value > 8.0);\n\t}\n\n\tlist<buildings> getBuildings\n\t{\n\t\treturn list(buildings);\n\t}\n\n\tlist<dyke> getDyke\n\t{\n\t\treturn list(dyke);\n\t}\n\n\toutput\n\t{\n\t}\n\n}\n```\n\n\nCode of the model : \n\n```\nmodel comodel_Flood_Evacuation\n\nimport \"Flood_coupling.gaml\" as myFlood\nimport \"Evacuation_coupling.gaml\" as myEvacuation\n\n\nglobal\n{\n\t//set the bound of environment\n\tgeometry shape <- envelope(file(\"../../../Toy Models/Flood Simulation/includes/mnt50.asc\"));\n\t//counting variable of casualty\n\tint casualty <- 0;\n\tinit\n\t{\n\t\t//create experiment from micro-model myFlood with corresponding parameters\n\t\tcreate myFlood.Flood_coupling_exp with:\n\t\t[buildings_shapefile::file(\"../../../Toy Models/Flood Simulation/includes/Building.shp\"), river_shapefile::file(\"../../../Toy Models/Flood Simulation/includes/RedRiver.shp\"), dykes_shapefile::file(\"../../../Toy Models/Flood Simulation/includes/Dykes.shp\"), dem_file::file(\"../../../Toy Models/Flood Simulation/includes/mnt50.asc\")];\n\t\t//create the Evacuation micro-model's experiment\n\t\tcreate myEvacuation.Evacuation_coupling_exp with: [nb_people::200, target_point::{ 0, 1580 }, building_shapefile::file(\"../../../Toy Models/Evacuation/includes/building.shp\")]\n\t\t{\n\t\t\t//transform the environment and the agents to new location (near the river)\n\t\t\tdo transform_environement;\n\t\t}\n\n\t}\n\n\treflex doing_cosimulation\n\t{\n\t\t//do a step of Flooding\n\t\task myFlood.Flood_coupling_exp collect each.simulation\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t//people evacate \n\t\task myEvacuation.Evacuation_coupling_exp collect each.simulation\n\t\t{\n\t\t\t//depending on the real plan of evacuation, we can test the speed of the evacuation with the speed of flooding by doing more or less simulation step  \n\t\t\tif (cycle mod 2 = 0)\n\t\t\t{\n\t\t\t\tdo _step_;\n\t\t\t}\n\n\t\t}\n\n\t\t//loop over the population\n\t\tloop thePeople over: first(myEvacuation.Evacuation_coupling_exp).getPeople()\n\t\t{\n\t\t\t//get the cell at people's location\n\t\t\tcell theWater <- cell(first(myFlood.Flood_coupling_exp).getCellAt(thePeople));\n\t\t\t//if the water levele is high than 8 meters and people is overlapped, tell him that he must dead\n\t\t\tif (theWater.grid_value > 8.0 and theWater overlaps thePeople)\n\t\t\t{\n\t\t\t\task thePeople\n\t\t\t\t{\n\t\t\t\t\tdo die;\n\t\t\t\t}\n\t\t\t\t//increase the counting variable\n\t\t\t\tcasualty <- casualty + 1;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment comodel_Flood_Evacuation_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay \"comodel_disp\"\n\t\t{\n\t\t\tagents \"building\" value: first(myEvacuation.Evacuation_coupling_exp).getBuilding();\n\t\t\tagents \"people\" value: first(myEvacuation.Evacuation_coupling_exp).getPeople();\n\t\t\tagents \"cell\" value: first(myFlood.Flood_coupling_exp).getCell();\n\t\t\tagents \"dyke\" value: first(myFlood.Flood_coupling_exp).getDyke();\n\t\t\tgraphics 'CasualtyView'\n\t\t\t{\n\t\t\t\tdraw ('Casualty: ' + casualty) at: { 0, 4000 } font: font(\"Arial\", 18, # bold) color: # red;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Co-model-Example-comodel_Flood_Evacuation.md"},"Co-model-Example-Comodel_SIR_Switch.md":{"title":" Comodel SIR Switch","content":"[//]: # (keyword|operator_diff)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|concept_comodel)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_equation)\n# Comodel SIR Switch\n\n\n_Author : HUYNH Quang Nghi_\n\nThis is a comodel that implement the dynamic of SIR_switch: it will use the EBM when the density of population is big and ABM when the density of population is low. It demonstrate the capability of using dynamically the legacy models.\nSIR_ABM_coupling is the coupling that manipulates the elements inside SIR_ABM model and proposes the function would be used from outside. SIR_ABM is a simple example of SIR that use the agents to represent the spreading of disease..\nSIR_EBM_coupling is the coupling that manipulates the elements inside SIR_EBM model and proposes the function would be used from outside. SIR_EBM is a simple example of ODE use into agents with the example of the SIR equation system.\n\n\nImported models : \n\n```\nmodel SIR_ABM \n\nglobal{\n\tgeometry shape<-envelope(square(100));\n\tfloat beta <- 0.5 ; \t \n\tfloat nu <- 0.001 ;\n\tfloat delta <- 0.01;\n\tinit{\n\t\tcreate Host number:495 ;\n\t\tcreate Host number:5{state<-1;}\n\t\t\n\t}\n}\n\nspecies Host skills:[moving]{\n\tint state<-0;\n\tlist<rgb> color<-[#green, #red, #yellow];\n\treflex moving{\n\t\tdo wander;\n\t}\n\n\n    \n    reflex become_infected when: state=1 {\n    \tlist n<- self neighbors_at(1);\n    \task n{    \t\t\n\t    \tif (flip(beta)) {\n\t\t\t\tstate<-1;    \n\t        }\n    \t}\n    }\n    \n    reflex become_immune when: (state=1 and flip(delta)) {\n    \tstate<-2;\n    }\n    \n            \n\taspect base{\n\t\tdraw circle(1) color: color[state];\n\t}\n}\nexperiment SIR_ABM_exp type:gui{\n\toutput {\n\t\tdisplay gridDisp{\n\t\t\tspecies Host aspect:base;\n\t\t}\n\t}\n}\n```\n\n\n```\nmodel SIR_ABM_coupling\n\nimport \"SIR_ABM.gaml\"\nexperiment SIR_ABM_coupling_exp type: gui parent: SIR_ABM_exp\n{\n\tint get_num_S\n\t{\n\t\treturn length(Host where (each.state = 0));\n\t}\n\n\tint get_num_I\n\t{\n\t\treturn length(Host where (each.state = 1));\n\t}\n\n\tint get_num_R\n\t{\n\t\treturn length(Host where (each.state = 2));\n\t}\n\n\taction set_num_S_I_R (int numS, int numI, int numR)\n\t{\n\t\tunknown call;\n\t\tcall <- set_num_S(numS);\n\t\tcall <- set_num_I(numI);\n\t\tcall <- set_num_R(numR);\n\t}\n\n\taction set_num_S (int num)\n\t{\n\t\task (Host where (each.state = 0))\n\t\t{\n\t\t\tdo die;\n\t\t}\n\n\t\tcreate Host number: num\n\t\t{\n\t\t\tstate <- 0;\n\t\t}\n\n\t}\n\n\taction set_num_I (int num)\n\t{\n\t\task (Host where (each.state = 1))\n\t\t{\n\t\t\tdo die;\n\t\t}\n\n\t\tcreate Host number: num\n\t\t{\n\t\t\tstate <- 1;\n\t\t}\n\n\t}\n\n\taction set_num_R (int num)\n\t{\n\t\task (Host where (each.state = 2))\n\t\t{\n\t\t\tdo die;\n\t\t}\n\n\t\tcreate Host number: num\n\t\t{\n\t\t\tstate <- 2;\n\t\t}\n\n\t}\n\n\toutput\n\t{\n\t}\n\n}\n```\n\n\n```\nmodel SIR_EBM\n\nglobal {\n\tinit{\n\t\tcreate agent_with_SIR_dynamic;\n\t} \n}\n\n\nspecies agent_with_SIR_dynamic {\n\tint N <- 495 ;\n\tint iInit <- 5;\t\t\n\n    float t;  \n\tfloat S <- N - float(iInit); \t      \n\tfloat I <- float(iInit); \n\tfloat R <- 0.0; \n\t\n\tfloat alpha <- 0.2;\n\tfloat beta <- 0.8; \n\n\tfloat h <- 0.01;\n   \n\tequation SIR{ \n\t\tdiff(S,t) = (- beta *   S * I / N);\n\t\tdiff(I,t) = (  beta*  S * I / N) - (alpha * I)  ;\n\t\tdiff(R,t) = (  alpha  *  I) ;\n\t}\n                \n    reflex solving {\n//    \twrite S;\n    \tsolve SIR method: \"rk4\" step: h;// cycle_length: 1/h ;\n    }    \n}\n\n\nexperiment SIR_EBM_exp type: gui {\n\toutput { \n\t\tdisplay display_charts {\n\t\t\tchart \"SIR_agent\" type: series background: #white {\n\t\t\t\tdata 'S' value: first(list(agent_with_SIR_dynamic)).S color: #green ;\t\t\t\t\n\t\t\t\tdata 'I' value: first(list(agent_with_SIR_dynamic)).I color: #red ;\n\t\t\t\tdata 'R' value: first(list(agent_with_SIR_dynamic)).R color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n```\nmodel SIR_EBM_coupling\n\nimport \"SIR_EBM.gaml\"\nexperiment SIR_EBM_coupling_exp type: gui parent: SIR_EBM_exp\n{\n\tint get_num_S\n\t{\n\t\treturn first(agent_with_SIR_dynamic).S;\n\t}\n\n\tint get_num_I\n\t{\n\t\treturn first(agent_with_SIR_dynamic).I;\n\t}\n\n\tint get_num_R\n\t{\n\t\treturn first(agent_with_SIR_dynamic).R;\n\t}\n\n\taction set_num_S_I_R (int numS, int numI, int numR)\n\t{\n\t\tunknown call;\n\t\tcall <- set_num_S(numS);\n\t\tcall <- set_num_I(numI);\n\t\tcall <- set_num_R(numR);\n\t}\n\n\taction set_num_S (int num)\n\t{\n\t\tfirst(agent_with_SIR_dynamic).S <- float(num);\n\t}\n\n\taction set_num_I (int num)\n\t{\n\t\tfirst(agent_with_SIR_dynamic).I <- float(num);\n\t}\n\n\taction set_num_R (int num)\n\t{\n\t\tfirst(agent_with_SIR_dynamic).R <- float(num);\n\t}\n\n\toutput\n\t{\n\t}\n\n}\n```\n\n\nCode of the model : \n\n```\nmodel Comodel_SIR_Switch\n\nimport \"Legacy_models/SIR_EBM_coupling.gaml\" as SIR_1\nimport \"Legacy_models/SIR_ABM_coupling.gaml\" as SIR_2\n\n\nglobal\n{\n\tgeometry shape <- envelope(square(100));\n\tint switch_threshold <- 120; // threshold for switching models\n\tint threshold_to_IBM <- 220; // threshold under which the model swith to IBM\n\tint threshold_to_Maths <- 20;\n\tinit\n\t{\n\t\tcreate SIR_1.SIR_EBM_coupling_exp;\n\t\tcreate SIR_2.SIR_ABM_coupling_exp;\n\t\tcreate Switch;\n\t}\n\n}\n\nspecies Switch\n{\n\tint S <- 495;\n\tint I <- 5;\n\tint R <- 0;\n\treflex request_from_micro_model\n\t{\n\t\t//if the size of S population and I population are bigger than a threshold, use the EBM\n\t\tif (S > threshold_to_Maths and I > threshold_to_Maths)\n\t\t{\n\t\t\task world\n\t\t\t{\n\t\t\t\tunknown call;\n\t\t\t\tcall <- first(SIR_1.SIR_EBM_coupling_exp).set_num_S_I_R(myself.S, myself.I, myself.R);\n\t\t\t\task first(SIR_1.SIR_EBM_coupling_exp).simulation\n\t\t\t\t{\n\t\t\t\t\tloop times: 5\n\t\t\t\t\t{\n\t\t\t\t\t\tdo _step_;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmyself.S <- first(SIR_1.SIR_EBM_coupling_exp).get_num_S();\n\t\t\t\tmyself.I <- first(SIR_1.SIR_EBM_coupling_exp).get_num_I();\n\t\t\t\tmyself.R <- first(SIR_1.SIR_EBM_coupling_exp).get_num_R();\n\t\t\t}\n\n\t\t}\n\t\t\n\t\t//if the size of S population or  I population are smaller  than a threshold, use the ABM\n\t\tif (I < threshold_to_IBM or S < threshold_to_IBM)\n\t\t{\n\t\t\task world\n\t\t\t{\n\t\t\t\tunknown call;\n\t\t\t\tcall <- first(SIR_2.SIR_ABM_coupling_exp).set_num_S_I_R(myself.S, myself.I, myself.R);\n\t\t\t\task first(SIR_2.SIR_ABM_coupling_exp).simulation\n\t\t\t\t{\n\t\t\t\t\tloop times: 1\n\t\t\t\t\t{\n\t\t\t\t\t\tdo _step_;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmyself.S <- first(SIR_2.SIR_ABM_coupling_exp).get_num_S();\n\t\t\t\tmyself.I <- first(SIR_2.SIR_ABM_coupling_exp).get_num_I();\n\t\t\t\tmyself.R <- first(SIR_2.SIR_ABM_coupling_exp).get_num_R();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taspect base\n\t{\n\t\tdraw square(100);\n\t}\n\n}\n\nexperiment Simple_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay co_SIR_chart\n\t\t{\n\t\t\tchart \"SIR_agent\" type: series background: # white\n\t\t\t{\n\t\t\t\tdata 'S' value: first(Switch).S color: # green;\n\t\t\t\tdata 'I' value: first(Switch).I color: # red;\n\t\t\t\tdata 'R' value: first(Switch).R color: # yellow;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Co-model-Example-Comodel_SIR_Switch.md"},"Co-model-Example-comodel_Urban_Traffic.md":{"title":" comodel Urban and Traffic model","content":"[//]: # (keyword|operator_rnd_color)\n[//]: # (keyword|operator_exp)\n[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|operator_max_of)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|operator_using)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|statement_using)\n[//]: # (keyword|statement_agents)\n[//]: # (keyword|constant_#sec)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|constant_#cyan)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_comodel)\n# comodel Urban and Traffic model\n\n\n_Author : HUYNH Quang Nghi_\n\nCo-model example : coupling urban growth model with the traffic model.\n\n\nImported models : \n\n```\n\nmodel raster3\n\n\nglobal\n{ \n\t//File for the ascii grid\n\tfile asc_grid <- grid_file(\"../includes/cantho_1999_v6.asc\");\n\t//Shapefile for the road\n\tfile road_shapefile <- shape_file(\"../includes/roads15_3.shp\");\n\t//Shapefile for the city\n\tfile city_center_shapefile <- shape_file(\"../includes/city center.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(asc_grid);\n\t//Graph of the roads\n\tgraph roads_network;\n\t\n\t// Dynamic list of the cells to consider at each cycle\n\tlist<plot> empty_plots <- plot where (each.grid_value = 0.0) update: shuffle(plot where (each.grid_value = 0.0));\n\t\n\tlist<rgb> plot_colors <- [ \n\t\t#lightgray, //empty\n\t\t#orange, // 1 built\n\t\t#blue // 2 River-lake\n\t];\n\t//Radius of density\n\tint density_radius <- 4;\n\t//Weight of density\n\tfloat weight_density <- 0.05;\n\t//Weight of the road distance\n\tfloat weight_road_dist <- 0.5;\n\t//Weight of the city center distance\n\tfloat weight_cc_dist <- 0.3;\n\t//Number of plot allowing to build a building\n\tint nb_plots_to_build <- 195;\n\n\tinit\n\t{\n\t\t//Creation of the roads using the shapefile of the road\n\t\tcreate roads from: road_shapefile;\n\t\t//Creation of the city center using the city center shapefile\n\t\tcreate city_center from: city_center_shapefile;\n\t\t//Creation of the graph of the road network\n\t\troads_network <- as_edge_graph(roads);\n\t\t\n\t\t//Each road has to compute its distance from the city center\n\t\task roads {\n\t\t\tdo compute_cc_dist;\n\t\t}\n\t\t//Compute the city distance for each plot\n\t\task empty_plots {\n\t\t\tdo compute_distances;\n\t\t}\n\t\t//Normalization of the distance\n\t\tdo normalize_distances;\n\t}\n\t//Action to normalize the distance\n\taction normalize_distances {\n\t\t//Maximum distance from the road of all the plots\n\t\tfloat max_road_dist <- empty_plots max_of each.dist_route;\n\t\t//Maximum distance from the city center for all the plots\n\t\tfloat max_cc_dist <- empty_plots max_of each.dist_cv;\n\t\t//Normalization of  each empty plot according to the maximal value of each attribute\n\t\task empty_plots {\n\t\t\tdist_cv <- 1 - dist_cv / max_cc_dist;\n\t\t\tdist_route <- 1 - dist_route / max_road_dist;\n\t\t}\n\t}\n\t\n\t\n\t//Reflex representing the global dynamic of the model\n\treflex dynamique_globale when: weight_density != 0 or weight_road_dist != 0 or weight_cc_dist != 0 {\n\t\t//Ask to each empty plot to compute its constructability\n\t\task empty_plots {\n\t\t\tconstructability <- compute_constructability();\n\t\t}\n\t\tlist<plot> ordered_plots <- empty_plots sort_by (each.constructability);\n\t\tordered_plots <- nb_plots_to_build last ordered_plots;\n\t\t//Build on each empty plot having the highest constructability\n\t\task ordered_plots\n\t\t{\n\t\t\tdo build;\n\t\t}\n\t}\t\n}\n//Species representing the city center\nspecies city_center {\n\taspect default {\n\t\tdraw circle(300) color: #cyan;\n\t}\t\n}\n//Species representing the roads\nspecies roads\n{\n\tfloat dist_cv;\n\t//Action to compute the city center distance for the road\n\taction compute_cc_dist {\n\t\tusing topology(roads_network)\n\t\t{\n\t\t\tdist_cv <- self distance_to first(city_center);\n\t\t}\n\t}\n\taspect default {\n\t\tdraw shape color: #black;\t\n\t}\n}\n//Grid species to represent the different building plots\ngrid plot file: asc_grid use_individual_shapes: false use_regular_agents: false neighbors: 4\n{\n\trgb color <- grid_value = -1 ? #white : plot_colors[int(grid_value)];\n\t//Distance from the road\n\tfloat dist_route <- 0.0;\n\t//Distance from the city center\n\tfloat dist_cv <- 0.0;\n\t//Constructability of the plot\n\tfloat constructability;\n\t\n\t//Action to compute all the distances for the cell\n\taction compute_distances\n\t{\n\t\troads route_pp <- roads closest_to self;\n\t\tdist_route <- (self distance_to route_pp) using topology(world);\n\t\tdist_cv <- dist_route + route_pp.dist_cv;\n\t}\n\t//Action to build on the cell\n\taction build\n\t{\n\t\tgrid_value <- 1.0;\n\t\tcolor <- plot_colors[1];\n\t}\n\t//Action to compute the constructability of the plot cell\n\tfloat compute_constructability\n\t{\n\t\t//Get all the neighbours plots\n\t\tlist<plot> voisins <- (self neighbors_at density_radius);\n\t\t//Compute the density of all the neighbours plots\n\t\tfloat densite <- (voisins count (each.grid_value = 1.0)) / length(voisins);\n\t\treturn (densite * weight_density + dist_route * weight_road_dist + dist_cv * weight_cc_dist) / (weight_density + weight_road_dist + weight_cc_dist);\n\t}\t\t\t\n}\n\nexperiment raster type: gui {\n \tparameter \"Weight of the density criteria\" var: weight_density;\n \tparameter \"Weight of the distance to roads criteria\" var: weight_road_dist;\n \tparameter \"Weight of the distance to city center criteria\" var: weight_cc_dist;\n \toutput {\n \t\tdisplay map type: opengl {\n\t\t\tgrid plot;\n\t\t\tspecies roads;\n\t\t\tspecies city_center;\n\t\t}\n\t}\n}\n\n```\n\n\n```\nmodel Urban_coupling\n\nimport \"../../../Toy Models/Urban Growth/models/raster model.gaml\"\nexperiment Urban_coupling_exp type: gui parent: raster\n{\n\tlist<plot> getPlot\n\t{\n\t\treturn list(plot);\n\t}\n\n}\n```\n\n\n```\n\nmodel traffic\n\nglobal {\n\t//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/buildings.shp\");\n\t//Shapefile of the roads\n\tfile road_shapefile <- file(\"../includes/roads.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(road_shapefile);\n\t//Step value\n\tfloat step <- 10 #s;\n\t//Graph of the road network\n\tgraph road_network;\n\t//Map containing all the weights for the road network graph\n\tmap<road,float> road_weights;\n\t\n\tinit {\n\t\t//Initialization of the building using the shapefile of buildings\n\t\tcreate building from: building_shapefile;\n\t\t//Initialization of the road using the shapefile of roads\n\t\tcreate road from: road_shapefile;\n\t\t\n\t\t//Creation of the people agents\n\t\tcreate people number: 1000{\n\t\t\t//People agents are located anywhere in one of the building\n\t\t\tlocation <- any_location_in(one_of(building));\n      \t}\n      \t//Weights of the road\n      \troad_weights <- road as_map (each::each.shape.perimeter);\n      \troad_network <- as_edge_graph(road);\n\t}\n\t//Reflex to update the speed of the roads according to the weights\n\treflex update_road_speed  {\n\t\troad_weights <- road as_map (each::each.shape.perimeter / each.speed_coeff);\n\t\troad_network <- road_network with_weights road_weights;\n\t}\n}\n//Species to represent the people using the skill moving\nspecies people skills: [moving]{\n\t//Target point of the agent\n\tpoint target;\n\t//Probability of leaving the building\n\tfloat leaving_proba <- 0.05; \n\t//Speed of the agent\n\tfloat speed <- 5 #km/#h;\n\trgb color <- rnd_color(255);\n\t//Reflex to leave the building to another building\n\treflex leave when: (target = nil) and (flip(leaving_proba)) {\n\t\ttarget <- any_location_in(one_of(building));\n\t}\n\t//Reflex to move to the target building moving on the road network\n\treflex move when: target != nil {\n\t\tdo goto target: target on: road_network recompute_path: false move_weights: road_weights;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t}\t\n\t}\n\t\n\taspect default {\n\t\tdraw circle(5) color: color;\n\t}\n}\n//Species to represent the buildings\nspecies building {\n\taspect default {\n\t\tdraw shape color: #gray;\n\t}\n}\n//Species to represent the roads\nspecies road {\n\t//Capacity of the road considering its perimeter\n\tfloat capacity <- 1 + shape.perimeter/30;\n\t//Number of people on the road\n\tint nb_people <- 0 update: length(people at_distance 1);\n\t//Speed coefficient computed using the number of people on the road and the capicity of the road\n\tfloat speed_coeff <- 1.0 update:  exp(-nb_people/capacity) min: 0.1;\n\t\n\taspect default {\n\t\tdraw (shape + 3 * speed_coeff) color: #red;\n\t}\n}\nexperiment trafic type: gui {\n\tfloat minimum_cycle_duration <- 0.01;\n\toutput {\n\t\tdisplay carte type: opengl{\n\t\t\tspecies building refresh: false;\n\t\t\tspecies road ;\n\t\t\tspecies people ;\n\t\t}\n\t}\n}\n```\n\n\n```\nmodel Traffic_coupling\n\nimport \"../../../Toy Models/Traffic/models/Simple traffic model.gaml\"\nexperiment Traffic_coupling_exp type: gui parent: trafic\n{\n\tlist<building> getBuilding\n\t{\n\t\treturn list(building);\n\t}\n\n\tlist<people> getPeople\n\t{\n\t\treturn list(people);\n\t}\n\n\tlist<road> getRoad\n\t{\n\t\treturn list(road);\n\t}\n\n}\n```\n\n\nCode of the model : \n\n```\nmodel comodel_Urban_Traffic\n\nimport \"Traffic_coupling.gaml\" as myTraffic\nimport \"Urban_coupling.gaml\" as myUrban\n\n\nglobal\n{\n\t//set the bound of the world\n\tgeometry shape <- envelope(shape_file(\"../../../Toy Models/Traffic/includes/roads.shp\"));\n\tinit\n\t{\n\t\t//create Traffic micro-model's experiment\n\t\tcreate myTraffic.Traffic_coupling_exp with:\n\t\t[building_shapefile::file(\"../../../Toy Models/Traffic/includes/buildings.shp\"), road_shapefile::file(\"../../../Toy Models/Traffic/includes/roads.shp\")];\n\t\t//create Urban micro-model;s experiment\n\t\tcreate myUrban.Urban_coupling_exp with:\n\t\t[asc_grid::grid_file(\"../../../Toy Models/Urban Growth/includes/cantho_1999_v6.asc\"), road_shapefile::shape_file(\"../../../Toy Models/Urban Growth/includes/roads15_3.shp\"), city_center_shapefile::shape_file(\"../../../Toy Models/Urban Growth/includes/city center.shp\")];\n\t}\n\n\treflex simulate_micro_models\n\t{\n\t\t//ask simulation of micro-model step one\n\t\task myTraffic.Traffic_coupling_exp collect each.simulation\n\t\t{\n\t\t\tdo _step_;\n\t\t}\n\n\t\t// tell the urban to grow up every 200 step\n\t\task myUrban.Urban_coupling_exp collect each.simulation\n\t\t{\n\t\t\tif (cycle mod 200 = 0)\n\t\t\t{\n\t\t\t\tdo _step_;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment comodel_Urban_Traffic_exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay \"comodel_disp\"\n\t\t{\n\t\t\tagents \"Plotgrid\" value: first(myUrban.Urban_coupling_exp).getPlot() size: { 0.037, 0.052 };\n\t\t\tagents \"building\" value: first(myTraffic.Traffic_coupling_exp).getBuilding();\n\t\t\tagents \"people\" value: first(myTraffic.Traffic_coupling_exp).getPeople();\n\t\t\tagents \"road\" value: first(myTraffic.Traffic_coupling_exp).getRoad();\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Co-model-Example-comodel_Urban_Traffic.md"},"Co-model-Example-comodelBoidsVoronoi.md":{"title":" Comodel of Boids and Voronoi","content":"[//]: # (keyword|operator_copy)\n[//]: # (keyword|operator_triangle)\n[//]: # (keyword|operator_using)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|statement_event)\n[//]: # (keyword|statement_agents)\n[//]: # (keyword|constant_#lightblue)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_comodel)\n# Comodel of Boids and Voronoi\n\n\n_Author : HUYNH Quang Nghi_\n\nCo-model example : Voronoi applied on Boids.\n\n\nImported models : \n\n```\n\nmodel voronoi\n \nglobal {\n\t// Parameters \n\t//Number of points\n\tint num_points <- 4 min: 1 max: 1000;\n\t//Size of the environment\n\tint env_width <- 100 min: 10 max: 400;\n\tint env_height <- 100 min: 10 max: 400;\n\t\n\t// Environment\n\tgeometry shape <- rectangle(env_width, env_height);\n\t\n\tinit { \n\t\twrite 'This model shows how Voronoi-like shapes can be drawn on a regular surface. A set of mobile agents is placed on a grid. Each agent possesses an attribute called *inside_color*. Each step, the agents move randomly and the grid cells paint themselves using the *inside_color* of the nearest agent. Dynamical boundaries then appear on the screen without any further calculations.';\n\t\t//Creation of all the points\n\t\tcreate center number: num_points ;  \n\t}   \n} \n//Grid for the voronoi clustering\ngrid cell width: env_width height: env_height neighbors: 8 use_regular_agents: false {\n\t// Note: since GAMA 1.7, the topology needs to be specified for this computation to use continuous distances\n\tcenter closest_center <- nil update: (center closest_to self.location) using topology(world);\n\trgb color <- #white update: (closest_center).color;\n}\n//Species representing the center of a Voronoi point\nspecies center skills: [moving] { \n\trgb color <- rgb([rnd (255),rnd (255),rnd (255)]); \n\t//Make the center of the cluster wander in the environment       \n\treflex wander {\n\t\tdo wander amplitude: 90;\n\t}  \n\taspect base {\n\t\tdraw square(1.0) color: color;\n\t}\n}\n\n\nexperiment voronoi type: gui{ \n\tparameter 'Number of points:' var: num_points;\n\tparameter 'Width of the environment:' var: env_width;\n\tparameter 'Height of the environment:' var: env_height;\n\t\n\toutput {\n\t\tdisplay Voronoi type: opengl {\n\t\t\tgrid cell  ;\n\t\t\tspecies center aspect: base ;\n\t\t}\n\t}\t\n}\n```\n\n\n```\nmodel Voronoi_coupling\n\nimport \"../../../Toy Models/Voronoi/Voronoi.gaml\"\n\n\nexperiment Voronoi_coupling_exp type:gui  parent:voronoi{\n\t\n\tlist<center> getCenter{\n\t\treturn list(center);\n\t}\n\tlist<cell> getCell{\n\t\treturn list(cell);\n\t}\n\t\n\t\n\toutput{\n\t}\n}\n```\n\n\n```\n\nmodel boids \nglobal torus: torus_environment{ \n\t//Number of boids that will be created\n\tint number_of_agents <- 50 min: 1 max: 1000000;\n\t//Number of obstacles for the boids movement to represent\n\tint number_of_obstacles <- 0 min: 0;\n\t//Maximal speed of the boids\n\tfloat maximal_speed <- 15.0 min: 0.1 max: 15.0;\n\t//Factors for the group of boids\n\tint cohesion_factor <- 200;\n\tint alignment_factor <- 100; \n\t//Variables for the movement of the boids\n\tfloat minimal_distance <- 10.0; \n\tint maximal_turn <- 45 min: 0 max: 359; \n\t\n\tint width_and_height_of_environment <- 1000;  \n\tbool torus_environment <- false; \n\tbool apply_cohesion <- true ;\n\tbool apply_alignment <- true ;\n\tbool apply_separation <- true;\n\tbool apply_avoid <- true;  \n\tbool apply_wind <- true;   \n\tbool moving_obstacles <- false;   \n\tint bounds <- int(width_and_height_of_environment / 20); \n\t//Vector for the wind\n\tpoint wind_vector <- {0,0}; \n\tlist images of: image_file <- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \n\tint xmin <- bounds;   \n\tint ymin <- bounds;  \n\tint xmax <- (width_and_height_of_environment - bounds);     \n\tint ymax <- (width_and_height_of_environment - bounds);   \n\t\n\t//Action to move the goal to the mouse location\n\taction move_goal(point mouse) {\n\t\task first(boids_goal) {\n\t\t\tdo goto target: mouse speed: 30;\n\t\t}\n\t}\n\t\n\tgeometry shape <- square(width_and_height_of_environment);\n\t\n\tinit { \n\t\t//Create the boids agents\n\t\tcreate boids number: number_of_agents { \n\t\t\t location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\n\t\t} \n\t\t//Create the obstacles agents\n\t\tcreate obstacle number: number_of_obstacles {\n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \n\t\t}\n\t\t//Create the goal that boids will follow\n\t\tcreate  boids_goal;\t\n\t}\t\n}\n\n//Species boids goal which represents the goal that will be followed by boids agents using the skill moving\nspecies boids_goal skills: [moving] {\n\tfloat range  <- 20.0;\n\t\n\t//If the mouse is not used, then the goal just wander\n\treflex wander {  \n\t\tdo  wander amplitude: 45 speed: 20;  \n\t}\n\t\n\taspect default {\n\t\tdraw circle(10) color: #red ;\n\t\tdraw circle(40) color: #orange empty: true;\n\t}\n} \n//Species boids which represents the boids agents whom follow the boid goal agents, using the skill moving\nspecies boids skills: [moving] {\n\t//Speed of the boids agents\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t//Range used to consider the group of the agent\n\tfloat range <- minimal_distance * 2;\n\tpoint velocity <- {0,0};\n\t\t\n\t//Reflex used when the separation is applied to change the velocity of the boid\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0,0};\n\t\task (boids overlapping (circle(minimal_distance)))  {\n\t\t\tacc <- acc - ((location) - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t\n\t//Reflex to align the boid with the other boids in the range\n\treflex alignment when: apply_alignment {\n\t\tlist others  <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint acc <- mean (others collect (each.velocity)) - velocity;\n\t\tvelocity <- velocity + (acc / alignment_factor);\n\t}\n\t \n\t//Reflex to apply the cohesion of the boids group in the range of the agent\n\treflex cohesion when: apply_cohesion {\n\t\tlist others <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint mass_center <- (length(others) > 0) ? mean (others collect (each.location)) : location;\n\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc / cohesion_factor; \n\t\tvelocity <- velocity + acc;   \n\t}\n\t\n\t//Reflex to avoid the obstacles\n\treflex avoid when: apply_avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - ((location of obs) - my (location));\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t\n\t//action to represent the bounding of the environment considering the velocity of the boid\n\taction bounding {\n\t\tif  !(torus_environment) {\n\t\t\tif  (location.x) < xmin {\n\t\t\t\tvelocity <- velocity + {bounds,0};\n\t\t\t} else if (location.x) > xmax {\n\t\t\t\tvelocity <- velocity - {bounds,0};\n\t\t\t}\n\t\t\t\n\t\t\tif (location.y) < ymin {\n\t\t\t\tvelocity <- velocity + {0,bounds};\n\t\t\t} else if (location.y) > ymax {\n\t\t\t\tvelocity <- velocity - {0,bounds};\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//Reflex to follow the goal \n\treflex follow_goal {\n\t\tvelocity <- velocity + ((first(boids_goal).location - location) / cohesion_factor);\n\t}\n\t//Reflex to apply the wind vector on the velocity\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t\n\t//Action to move the agent  \n\taction do_move {  \n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) -2, (rnd(4)) - 2};\n\t\t}\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location;\n\t}\n\t\n\t//Reflex to apply the movement by calling the do_move action\n\treflex movement {\n\t\tdo do_move;\n\t}\n\t\n\taspect image {\n\t\tdraw (images at (rnd(2))) size: {50,50} rotate: heading ;      \n\t}\n\taspect circle { \n\t\tdraw circle(15)  color: #red;\n\t}\n\t\n\taspect default { \n\t\tdraw circle(20) color: #lightblue empty: true;\n\t}\n} \n\n//Species obstacle that represents the obstacles avoided by the boids agents using the skill moving\nspecies obstacle skills: [moving] {\n\tfloat speed <- 2.0;\n\tgeometry shape <- triangle(15);\n\t\n\t//Reflex to move the obstacles if it is available\n\treflex move_obstacles when: moving_obstacles {\n\t\t//Will make the agent go to a boid with a 50% probability\n\t\tif flip(0.5)  \n\t\t{ \n\t\t\tdo goto target: one_of(boids);\n\t\t} \n\t\telse{ \n\t\t\tdo wander amplitude: 360;   \n\t\t}\n\t}\n\taspect default {\n\t\tdraw  triangle(20) color: #black ;\n\t}\n\n}\n\n\nexperiment boids_gui type: gui {\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var: number_of_obstacles;\n\tparameter 'Maximal speed' var: maximal_speed;\n\tparameter 'Cohesion Factor' var: cohesion_factor;\n\tparameter 'Alignment Factor' var: alignment_factor; \n\tparameter 'Minimal Distance'  var: minimal_distance; \n\tparameter 'Maximal Turn'  var: maximal_turn; \n\tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \n\tparameter 'Toroidal Environment ?'  var: torus_environment ; \n\tparameter 'Apply Cohesion ?' var: apply_cohesion ;\n\tparameter 'Apply Alignment ?' var: apply_alignment ;   \n\tparameter 'Apply Separation ?' var: apply_separation ;   \n\tparameter 'Apply Avoidance ?' var: apply_avoid ;   \n\tparameter 'Apply Wind ?' var: apply_wind ;     \n\tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \n\tparameter 'Direction of the wind' var: wind_vector ;  \n\t\n\t//Minimum duration of a step to better see the movements\n\tfloat minimum_cycle_duration <- 0.01;\n\n\toutput {\n\t\tdisplay Sky  background: #blue type: opengl { \n\t\t\timage '../images/sky.jpg' refresh: false;\n\t\t\tspecies boids aspect: image trace: 10 fading: true ;\n\t\t\tspecies boids_goal;\n\t\t\tspecies obstacle;\n\t\t\t//Event to call the action move_goal in global if the mouse move within the experiment\n\t\t\tevent mouse_move action: move_goal;\n\t\t}\n\n\t}\n}\n```\n\n\n```\nmodel Boids_coupling\n\nimport \"../../../Toy Models/Boids/models/Boids.gaml\"\n\n\nexperiment Boids_coupling_exp type:gui  parent:boids_gui{\n\t\n\tlist<boids_goal> getBoids_goal{\n\t\treturn list(boids_goal);\n\t}\n\t\n\tlist<boids> getBoids{\n\t\treturn list(boids);\n\t}\n\t\n\t\n\toutput{\n\t}\n}\n```\n\n\nCode of the model : \n\n```\nmodel comodelBoidsVoronoi\nimport \"Boids_coupling.gaml\" as myBoids\nimport \"Voronoi_coupling.gaml\" as myVoronoi\n\n\nglobal\n{\n\t// set the bound of the environment\n\tgeometry shape <- envelope(100);\n\t\n\tinit\n\t{\t\n\t\t//create experiment from micro-model myBoids\n\t\tcreate myBoids.Boids_coupling_exp with: [shape::square(0.5), width_and_height_of_environment::100, number_of_agents::100];\n\t\t//create experiment form micro-model myVoronoi\n\t\tcreate myVoronoi.Voronoi_coupling_exp with:[num_points::100, env_width::100, env_height::100];\n\t}\n\n\treflex simulate_micro_models\n\t{\n\t\t//tell myBoids to step a cycle\n\t\task (myBoids.Boids_coupling_exp collect each.simulation){ do _step_;}\n\t\t//get all boids's location into a list\n\t\tlist<point> theLocations<-(myBoids.Boids_coupling_exp accumulate each.getBoids()) collect each.location;\n\t\t//myVoronoi do a step with the location of their agent from the location list above \n\t\task (myVoronoi.Voronoi_coupling_exp collect each.simulation){ ask center{location<-theLocations at (int(self)); }do _step_;}\n\t}\n\n}\n\nexperiment comodel_Boids_Voronoi_Exp type: gui\n{\n\toutput\n\t{\n\t\tdisplay \"comodel_disp\" \n\t\t{\n\t\t\tagents \"cell\" value: (myVoronoi.Voronoi_coupling_exp accumulate each.getCell());\n\t\t\t\n\t\t\tagents \"boids_goal\" value: (myBoids.Boids_coupling_exp accumulate each.getBoids_goal()) {draw circle(5) color:#red;}\n\t\t\t\n\t\t\tagents \"boids\" value: (myBoids.Boids_coupling_exp accumulate each.getBoids()) {draw circle(1) color:#blue;}\n\t\t\t\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Co-model-Example-comodelBoidsVoronoi.md"},"Epidemiology-SIR-(ABM-vs-EBM).md":{"title":" comparison_ABM_EBM_SIR","content":"[//]: # (keyword|operator_^)\n[//]: # (keyword|operator_of_species)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_grid)\n# comparison_ABM_EBM_SIR\n\n\n_Author : Benoit Gaudou _\n\nComparison between an agent-based and an equation-based model of the SIR model. The ABM use a grid to place the agents, and each cell will be the location of an agent, while the EBM is only using a ODE System and no geographical representation.\n\n\nCode of the model : \n\n```\nmodel comparison_ABM_EBM_SIR\n\nglobal {\n\t//Number of susceptible individuals\n\tint number_S <- 499; \n\t//Number of infectious individuals\n\tint number_I <- 1; \n\t//Number of Resistant individuals\n\tint number_R <- 0; \n\t//Beta parameter used for the infection of susceptible individuals\n\tfloat beta <- 0.1; \n\t//Gamma parameter used for the resistance gained by the infectious individuals\n\tfloat gamma <- 0.01;\n\t//Size of the neighbours\n\tint neighbours_size <- 2;\n\t//Total number of individuals\n\tint N <- number_S + number_I + number_R;\n\t//Number of hosts (for ABM)\n\tint nb_hosts <- number_S + number_I + number_R update: length(Host);\n\t//Number of infected hosts (for ABM)\n\tint nb_infected <- number_I update:  Host count (each.is_infected);\n\tfloat hKR4 <- 0.7;\n\tgeometry shape <- square(50);\n\tinit {\n\t\t//Create the number of hosts susceptibles\n\t\tcreate Host number: number_S {\n\t\t\tis_susceptible <- true;\n\t\t\tis_infected <- false;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- #green;\n\t\t}\n\t\t//Create the number of hosts infectious\n\t\tcreate Host number: number_I {\n\t\t\tis_susceptible <- false;\n\t\t\tis_infected <- true;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- #red;\n\t\t}\n\t\t//Create the node agent for the SIR ODE System\n\t\tcreate node_agent number: 1 {\n\t\t\tS <- float(number_S);\n\t\t\tI <- float(number_I);\n\t\t\tR <- float(number_R);\n\t\t}\n\t}\n\n}\n//Grid that will be used to discretize space\ngrid sir_grid width: 50 height: 50 {\n\t\trgb color <- #black;\n\t\tlist<sir_grid> neighbours <- (self neighbors_at neighbours_size) of_species sir_grid;\n\t}\n\t\n//Species host which represents the host of the disease\nspecies Host {\n\t\n\t//Different booleans to know in which state is the host\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\t\n\t//Color of the host\n\trgb color <- #green;\n\t\n\t//Location of the agent among the grid\n\tsir_grid myPlace;\n\t//Count of neighbors infected \n    int ngb_infected_number function: {self neighbors_at(neighbours_size) count(each.is_infected)};\n\t\n\tinit {\n\t\t//The location is chosen randomly\n\t\tmyPlace <- one_of(sir_grid);\n\t\tlocation <- myPlace.location;\n\t}\n\t//Reflex to move the agent in the neighbours cells\n\treflex basic_move {\n\t\tmyPlace <- one_of(myPlace.neighbours);\n\t\tlocation <- myPlace.location;\n\t}\n\t//Reflex to pass the agent to the state infected \n\treflex become_infected when: is_susceptible {\n\t\t\t//Probability of being infected according to the number of infected among the neighbours\n    \t\tif (flip(1 - (1 - beta)  ^ ngb_infected_number)) {\n        \t\tis_susceptible <-  false;\n\t            \tis_infected <-  true;\n\t            \tis_immune <-  false;\n\t            \tcolor <-  #red;       \t\t\t\n\t\t\t}    \t\t\t\t\n\t}\n\t//Reflex to pass the agent to the state immune\n\treflex become_immune when: (is_infected and flip(gamma)) {\n\t\tis_susceptible <- false;\n\t\tis_infected <- false;\n\t\tis_immune <- true;\n\t\tcolor <- #blue;\n\t} \n\t\n\taspect basic {\n\t\tdraw circle(1) color: color;\n\t}\n\n}\n//Species node agent that will represent the SIR Ordinary differential equations system\nspecies node_agent {\n\tfloat t;\n\tfloat I;\n\tfloat S;\n\tfloat R;\n\tequation eqSIR type: SIR vars: [S, I, R, t] params: [N, beta, gamma];\n\treflex solving {solve eqSIR method: rk4 step: 1;}\n\t\n}\n\nexperiment Simulation_ABM_EBM type: gui {\n\tparameter 'Number of Susceptible' type: int var: number_S <- 495 category: \"Initial population\";\n\tparameter 'Number of Infected' type: int var: number_I <- 5 category: \"Initial population\";\n\tparameter 'Number of Removed' type: int var: number_R <- 0 category: \"Initial population\";\n\tparameter 'Beta (S->I)' type: float var: beta <- 0.1 category: \"Parameters\";\n\tparameter 'Gamma (I->R)' type: float var: gamma <- 0.01 category: \"Parameters\";\n\tparameter 'Size of the neighbours' type: int var: neighbours_size <- 1 min: 1 max: 5 category: \"Infection\";\n\toutput {\n\t\tdisplay sir_display { \n\t\t\tgrid sir_grid lines: #black;\n\t\t\tspecies Host aspect: basic;\t\n\t\t}\n\t\tdisplay ABM { \n\t\t\tchart 'Susceptible' type: series background: #lightgray style: exploded {\n\t\t\t\tdata 'susceptible' value: (Host as list) count (each.is_susceptible) color: #green;\n\t\t\t\tdata 'infected' value: (Host as list) count (each.is_infected) color: #red;\n\t\t\t\tdata 'immune' value: (Host as list) count (each.is_immune) color: #blue;\n\t\t\t}\n\t\t}\n\t\tdisplay EBM { \n\t\t\tchart \"SIR\" type: series background: #white {\n\t\t\t\tdata 'S' value: first(node_agent).S color: #green;\n\t\t\t\tdata 'I' value: first(node_agent).I color: #red;\n\t\t\t\tdata 'R' value: first(node_agent).R color: #blue;\n\t\t\t}\n\t\t}\n\t\tdisplay ABM_EBM  { \n\t\t\tchart 'Susceptible' type: series background: #lightgray style: exploded {\n\t\t\t\tdata 'susceptible' value: (Host as list) count (each.is_susceptible) color: #green-50;\n\t\t\t\tdata 'infected' value: (Host as list) count (each.is_infected) color: #red-50;\n\t\t\t\tdata 'immune' value: (Host as list) count (each.is_immune) color: #blue-50;\n\t\t\t\tdata 'S' value: first(node_agent).S color: #green+50;\n\t\t\t\tdata 'I' value: first(node_agent).I color: #red+50;\n\t\t\t\tdata 'R' value: first(node_agent).R color: #blue+50;\n\t\t\t}\n\t\t}\n\t}\n\n}\n```\n","url":"wiki/Epidemiology-SIR-(ABM-vs-EBM).md"},"Epidemiology-SIR-(Built-In).md":{"title":" simple_ODE_SIR_Predefined","content":"[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_equation)\n# simple_ODE_SIR_Predefined\n\n\n_Author : hqnghi _\n\nA simple example of ODE use into agents with the example of the SIR equation system.\n\n\nCode of the model : \n\n```\n \nmodel simple_ODE_SIR_Predefined\n\nglobal {\n\tinit {\n\t\tcreate predefined_ODE_SIR_agent number: 1;\n\t}\n}\n\n//Species which represent the Ordinary Differential Equations System \nspecies predefined_ODE_SIR_agent {\n\t//Variable to represent the discrete time for integration\n\tfloat t;\n \t//Total Population \n   \tint N <- 500;\n   \t//Number of infected\n\tfloat I <- 1.0; \n\t//Number of susceptible\n\tfloat S <- N - I; \n\t//Number of recovered\n\tfloat R <- 0.0; \n\n\t//Rate of transmission success for each infected\n  \tfloat beta <- 0.4;\n  \t//Rate of passing to resistant\n   \tfloat gamma <- 0.01; \n   \t\t\n   \tfloat h <- 0.1;\n\n\t// Parameters must follow exact order S, I, R, t  and N,beta,gamma\t\t\n\tequation eqSIR type:SIR vars: [S,I,R,t] params: [N,beta,gamma] ;\n\n\treflex solving {solve eqSIR method:rk4 step:h ;}//cycle_length:int(1/h);}\n}\n\n\nexperiment mysimulation type: gui {\n\toutput {\t\n\t\tdisplay display_charts {\n\t\t\tchart 'SIR_agent' type: series background: #lightgray {\n\t\t\t\tdata \"S\" value: first(predefined_ODE_SIR_agent).S color: #green;\n\t\t\t\tdata \"I\" value: first(predefined_ODE_SIR_agent).I color: #red;\n\t\t\t\tdata \"R\" value: first(predefined_ODE_SIR_agent).R color: #blue;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Epidemiology-SIR-(Built-In).md"},"Epidemiology-SIR-(Split-in-Agents).md":{"title":" SIR_split_in_agents","content":"[//]: # (keyword|operator_diff)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n# SIR_split_in_agents\n\n\n_Author : hqnghi _\n\nThis model illustrates the possibility to split an equation system into several agents. All the equations are solve together thanks to the `simultaneously` facet of the equation statement. We also compare the split model with the simple SIR one. \n\n\nCode of the model : \n\n```\n\nmodel SIR_split_in_agents\n\nglobal {\n\tint number_S <- 495 ; // The number of susceptible\n\tint number_I <- 5   ; // The number of infected\n\tint number_R <- 0   ; // The number of removed \n\n\tfloat beta  <- 1.0  ; // The parameter Beta\n\tfloat delta <- 0.01 ; // The parameter Delta\n\t\n\t// Note that N will remain constant as demography is not taken into account in the SIR model.\n\tint N <- number_S + number_I + number_R ;\n\tfloat hKR4 <- 0.07 ;\n\n\tinit {\n\t\t//Creation of the representation of the susceptible agents\n\t\tcreate S_agt {\n\t\t\tSsize <- float(number_S) ;\n\t\t\tself.beta <- myself.beta ;\n\t\t}\n\t\t//Creation of the representation of the infected agents\n\t\tcreate I_agt {\n\t\t\tIsize <- float(number_I) ;\n\t\t\tself.beta <- myself.beta ;\n\t\t\tself.delta <- myself.delta ;\n\t\t}\n\t\t//Creation of the representation of the recovered agents\n\t\tcreate R_agt {\n\t\t\tRsize <- float(number_R) ;\n\t\t\tself.delta <- myself.delta ;\n\t\t}\n\t\t//Creation of the representation of the SIR agent representing the non split system\n\t\tcreate SIR_agt {\n\t\t\tself.Sm <- float(number_S) ;\n\t\t\tself.Im <- float(number_I) ;\n\t\t\tself.Rm <- float(number_R) ;\n\t\t\t\n\t\t\tself.beta <- myself.beta ;\n\t\t\tself.delta <- myself.delta ;\n\t\t}\n\t}\n}\n\n//Species which represent the susceptible agents compartiment\nspecies S_agt {\n\tfloat t ;\t\t\n\tfloat Ssize ; //number of susceptible\n\t\n\tfloat beta ;\n\t//Equation that will be solved simultaneously with the two other equations systems\n\tequation evol simultaneously: [  ( I_agt ) ,  ( R_agt ) ] {\n\t\tdiff ( first ( S_agt ) . Ssize , t ) = \n\t\t\t( - beta * first ( S_agt ) . Ssize * first (\tI_agt ) . Isize / N ) ;\n\t}\n\t\n\treflex solving {solve evol method: \"rk4\" step: 0.01 ;}\n}\n//Species which represent the infected agents compartiment\nspecies I_agt {\n\tfloat t ;\n\tfloat Isize ; // number of infected\n\t\n\tfloat beta ;\n\tfloat delta ;\n\n\t//Equation that will be solved simultaneously with the two other equations systems\n\tequation evol simultaneously: [  ( S_agt ) ,  ( R_agt ) ] {\n\t\tdiff ( first ( I_agt ) . Isize , t ) = \n\t\t\t( beta * first ( S_agt ) . Ssize * first ( I_agt ) . Isize / N ) \n\t\t\t- ( delta * first ( I_agt ) . Isize ) ;\n\t}\n}\n//Species which represent the resistant agents compartiment\nspecies R_agt {\n\tfloat t ;\t\t\n\tfloat Rsize ; //number of resistant\n\t\n\tfloat delta ;\n\n\t//Equation that will be solved simultaneously with the two other equations systems\n\tequation evol simultaneously: [ ( S_agt ) + ( I_agt ) ] {\n\t\tdiff ( first ( R_agt ) . Rsize , t ) = \n\t\t\t( delta * first ( I_agt ) . Isize ) ;\n\t}\n}\n\n//Species which represent the ordinary differential equations system\nspecies SIR_agt {\n\tfloat t ;\n\tfloat Im ;\n\tfloat Sm ;\n\tfloat Rm ;\n\t\n\tfloat beta ;\n\tfloat delta ;\n\t\n\tequation SIR {\n\t\tdiff ( Sm , t ) = ( - beta * Sm * Im / N ) ; \n\t\tdiff ( Im , t ) = ( beta * Sm\t* Im / N ) - ( delta * Im ) ; \n\t\tdiff ( Rm , t ) = ( delta * Im ) ;\n\t}\n\t\n\treflex solving {solve SIR method: \"rk4\" step: 0.01 ;}\n}\n\n\nexperiment Simulation type: gui {\n\tparameter 'Number of Susceptible' type: int var: number_S <- 495 category: \"Initial population\"; // The initial number of susceptibles\n\tparameter 'Number of Infected'    type: int var: number_I <- 5   category: \"Initial population\";\n\tparameter 'Number of Removed'     type: int var: number_R <- 0   category: \"Initial population\";\n\n\tparameter 'Beta (S->I)'  type: float var: beta <- 1.0   category: \"Parameters\";\n\tparameter 'Delta (I->R)' type: float var: delta <- 0.01 category: \"Parameters\";\n\t\n\toutput {\n\t\tdisplay \"split system\" {\n\t\t\tchart 'Susceptible' type: series background: rgb ( 'lightGray' ) {\n\t\t\t\tdata 'susceptible' value: first ( S_agt ) . Ssize color: rgb ( 'green' ) ;\n\t\t\t\tdata 'infected' value: first ( I_agt ) . Isize color: rgb ( 'red' ) ;\n\t\t\t\tdata 'removed' value: first ( R_agt ) . Rsize color: rgb ( 'blue' ) ;\n\t\t\t}\n\t\t}\n\t\tdisplay \"unified system\"{\n\t\t\tchart 'Susceptible' type: series background: rgb ( 'lightGray' ) {\n\t\t\t\tdata 'susceptible_maths' value: first( SIR_agt ).Sm color: rgb ( 'green' ) ;\n\t\t\t\tdata 'infected_maths' value: first( SIR_agt ).Im color: rgb ( 'red' ) ;\n\t\t\t\tdata 'removed_maths' value: first( SIR_agt ).Rm color: rgb ( 'blue' ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Epidemiology-SIR-(Split-in-Agents).md"},"Epidemiology-SIR-(Switch).md":{"title":" SIR_switch","content":"[//]: # (keyword|operator_round)\n[//]: # (keyword|operator_diff)\n[//]: # (keyword|operator_of_species)\n[//]: # (keyword|operator_any)\n[//]: # (keyword|operator_^)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_grid)\n# SIR_switch\n\n\n_Author : tri and hqnghi _\n\nA model which show how to implement ODE system, IBM model, and to switch from one to another using a threshold. Another interesting point seen in this model is the the minimization of the execution time by reducing the number of agents to compute infections.\n\n\nCode of the model : \n\n```\nmodel SIR_switch\n\nglobal {\n\t// Parameters\n\tint initial_S <- 495 ; // The number of susceptible\n\tint initial_I <- 5   ; // The number of infected\n\tint initial_R <- 0   ; // The number of removed \n\n\tfloat beta <- 0.1   ; // The parameter Beta \n\tfloat delta <- 0.01 ; // The parameter Delta\t\n\t\n\tint switch_threshold <- 120 ; // threshold for switching models\n\tbool local_infection <- true ;\n\tint neighbours_range <- 2 ;\n\tbool local_random_walk <- true ; \n\t\n\t\n\t// Global variables\n\tint grid_size <- 50;\ngeometry shape <- square(grid_size);\n\tint number_Hosts <- initial_S + initial_I + initial_R; // Total number of individuals\n\tSIR_model current_model; // serves as an interface, it is transparent to user if model is maths or IBM\n\n\tfloat beta_maths;\n\tint gridSize <- 1; //size of the grid\n\tfloat neighbourhoodSize <- 1.0; // average size of the neighbourhood (in number of cells)\t\n\tfloat adjust <- 0.721; // to adjust math model to ABM when using random walk\n\tbool computeInfectionFromS <- initial_S < initial_I; // if true, use the S list to compute infections. If false, use I list.\n\t// the purpose is to minimize the number of evaluation by using the smallest list.\n\t\n\tinit {\n\t\tcreate new_scheduler;\n\t\t/* determine the size of the neighbourhood and the average count of hosts neighbours */\n\t\tgridSize <- length(sir_grid);\n\t\tint nbCells <- 0;\n\t\t\n\t\tloop cell over: sir_grid {\n\t\t\tnbCells <- nbCells + length(cell.neighbours);\n\t\t}\n\n\t\tneighbourhoodSize <- nbCells / gridSize + 1; // +1 to count itself in the neighbourhood;\n\t\tbeta_maths <- beta * neighbourhoodSize * number_Hosts / gridSize * adjust;\n\t\t\n\t\twrite 'Switch will happen at population sizes around ' +switch_threshold;\n\t\twrite 'Basic Reproduction Number (R0): ' + string(beta / delta) + '\\n';\n\t\t\n\t\t//Creation of the switch_model agent that will manage the switch between the mathematical and the individual based models\n\t\tcreate switch_model {\n\t\t\tthreshold_to_IBM <- switch_threshold;\n\t\t\tthreshold_to_Maths <- switch_threshold;\n\t\t}\n\t\t//Creation of the model according to the one to begin with\n\t\tif (first(switch_model).start_with_IBM) {\n\t\t//\t\twrite 'Starting with IBM model';\n\t\t\tcreate IBM_model;\n\t\t\tcurrent_model <- first(IBM_model);\n\t\t} else {\n\t\t//\t\twrite 'Starting with Maths model';\n\t\t\tcreate Math_model;\n\t\t\tcurrent_model <- first(Math_model);\n\t\t}\n\t\t//Initialization of the Susceptible, Infected, Resistant and Total Compartiment\n\t\tcurrent_model.S <- float(initial_S);\n\t\tcurrent_model.I <- float(initial_I);\n\t\tcurrent_model.R <- float(initial_R);\n\t\tcurrent_model.N <- number_Hosts;\n\t\t\n\t\t//Ask to the model to initialize itself according to the value initialized\n\t\task current_model {\n\t\t\tdo initialize;\n\t\t}\n\t\t\n\t\t//Create the SIR maths with ODE to compare\n\t\tcreate my_SIR_maths {\n\t\t\tself.S <- float(myself.initial_S);\n\t\t\tself.I <- float(myself.initial_I);\n\t\t\tself.R <- float(myself.initial_R);\n\t\t\tself.N <- number_Hosts;\n\t\t\tself.beta1 <- beta * neighbourhoodSize * (N / gridSize)* adjust;\n\t\t\tself.alpha <- delta;\n\t\t}\n\n\t}\n\n\treflex infection_computation_method {\n\t/* computing infection from S has a complexity of S*ngb, where ngb is the size of the neighbourhood.\n\t * computing infection from I has a complexity of I*ngb.\n\t * this reflex determine which method has the lowest cost.\n\t * */\n\t\tcomputeInfectionFromS <- (Host count (each.is_susceptible)) < (Host count (each.is_infected));\n\t}\n\n}\n//Grid which represent the discretized space for the host agents\n\tgrid sir_grid width: grid_size height: grid_size {\n\t\trgb color <- #black;\n\t\tlist<sir_grid> neighbours <- (self neighbors_at neighbours_range) of_species sir_grid;\n\t}\n\n\n//Species which allows the execution of only Host, IBM_model, Math_model and switch_model at each cycle\nspecies new_scheduler schedules: (Host + IBM_model + Math_model + switch_model) ;\n\n//Species which represent the manager between IBM and Math model\nspecies switch_model schedules: [] {\n\tint threshold_to_IBM <- 45; // threshold under which the model swith to IBM\n\tint threshold_to_Maths <- 50; // threshold under which the model swith to Maths model \n\tbool start_with_IBM function: { (initial_S < threshold_to_IBM or initial_I < threshold_to_IBM) };\n\n\t//Switch the model used to IBM when the threshold is higher than the population\n\treflex switch_to_IBM when: (current_model.model_type = 'Maths') {\n\t\tif (current_model.S < threshold_to_IBM or current_model.I < threshold_to_IBM) {\n\t\t\twrite 'Switch to IBM model at cycle ' + string(cycle);\n\t\t\tcreate IBM_model {\n\t\t\t\tself.S <- current_model.S;\n\t\t\t\tself.I <- current_model.I;\n\t\t\t\tself.R <- current_model.R;\n\t\t\t\tself.N <- current_model.N;\n\t\t\t\tdo initialize;\n\t\t\t}\n\n\t\t\task current_model {\n\t\t\t\tdo remove_model;\n\t\t\t}\n\n\t\t\tcurrent_model <- first(IBM_model);\n\t\t}\n\n\t}\n\t//Switch the model used to Maths when the threshold is lower than the population\n\treflex switch_to_Maths when: (current_model.model_type = 'IBM') {\n\t\tif (current_model.S > threshold_to_Maths and current_model.I > threshold_to_Maths) {\n\t\t\twrite 'Switch to Maths model at cycle ' + cycle;\n\t\t\tcreate Math_model {\n\t\t\t\tself.S <- current_model.S;\n\t\t\t\tself.I <- current_model.I;\n\t\t\t\tself.R <- current_model.R;\n\t\t\t\tself.N <- current_model.N;\n\t\t\t\tdo initialize;\n\t\t\t}\n\n\t\t\task current_model {\n\t\t\t\tdo remove_model;\n\t\t\t}\n\n\t\t\tcurrent_model <- first(Math_model);\n\t\t}\n\n\t}\n\n}\n//Species which represent the SIR model used by the IBM and the Math models \nspecies SIR_model schedules: [] {\n\tfloat S;\n\tfloat I;\n\tfloat R;\n\tint N;\n\tstring model_type <- 'none';\n\t\n\taction remove_model {\n\t\tdo die;\n\t}\n\n\taction initialize ;\n\n}\n\n//Species IBM Model which represent the Individual based model, derivated from SIR_model\nspecies IBM_model schedules: [] parent: SIR_model {\n\tstring model_type <- 'IBM';\n\t\n\t//Action to initialize the Model with SIR compartiments\n\taction initialize {\n\t\t\n\t\twrite 'Initializing IBM model with S=' + round(S) + ', I=' + round(I) + ', R=' + round(R) + '\\n';\n\t\t//Creation of the host agents\n\t\tcreate Host number: round(S) {\n\t\t\tis_susceptible <- true;\n\t\t\tis_infected <- false;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- #green;\n\t\t}\n\n\t\tcreate Host number: round(I) {\n\t\t\tis_susceptible <- false;\n\t\t\tis_infected <- true;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- #red;\n\t\t}\n\n\t\tcreate Host number: round(R) {\n\t\t\tis_susceptible <- false;\n\t\t\tis_infected <- false;\n\t\t\tis_immune <- true;\n\t\t\tcolor <- #yellow;\n\t\t}\n\t\tdo count;\n\t}\n\n\treflex count {\n\t\tdo count;\n\t}\n\t//Action to update the different compartiments\n\taction count {\n\t\tS <- float(Host count (each.is_susceptible));\n\t\tI <- float(Host count (each.is_infected));\n\t\tR <- float(Host count (each.is_immune));\n\t}\n\t//Action to remove the model and kill all the agents it contains\n\taction remove_model {\n\t\task Host {\n\t\t\tdo die;\n\t\t}\n\n\t\tdo die;\n\t}\n\n}\n\n//Species Math Model which represent the mathematical Ordinary Differential Equations model, derivated from SIR_model\nspecies Math_model schedules: [] parent: SIR_model {\n\tstring model_type <- 'Maths';\n\tfloat t;\n\t\n\taction initialize {\n\t\twrite 'Initializing Maths model with S=' + S + ', I=' + I + ', R=' + R + '\\n';\n\t}\n\n\tequation SIR {\n\t\tdiff(S, t) = (-beta_maths * S * I / N);\n\t\tdiff(I, t) = (beta_maths * S * I / N) - (delta * I);\n\t\tdiff(R, t) = (delta * I);\n\t}\n\n\treflex solving {solve SIR method: \"rk4\" step: 0.01 ;}\n}\n//Species host used by the Individual Based Model which move from one cell to another\nspecies Host schedules: [] skills: [moving] {\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tsir_grid myPlace;\n\t\n\t/* next function computes the number of neighbours of the agent */\n\tint ngb_number function: {\n\t\tlength(((self) neighbors_at (2)) of_species Host) - 1 // -1 is because the agent counts itself\n\t};\n\t\n\tinit {\n\t\tmyPlace <- one_of(sir_grid as list);\n\t\tlocation <- myPlace.location;\n\t}\n\n\t//Reflex to move the agents among the cells\n\treflex basic_move {\n\t\tif (!local_random_walk) {\n\t\t/* random walk among neighbours */\n\t\t\tmyPlace <- one_of(myPlace.neighbours);\n\t\t\tlocation <- myPlace.location;\n\t\t} else {\n\t\t/* move agent to a random place anywhere in the grid */\n\t\t\tmyPlace <- any(sir_grid);\n\t\t\tlocation <- myPlace.location;\n\t\t}\n\n\t}\n\t//Reflex to make the agent infected when the infection is computed from S for a better execution time\n\treflex become_infected when: (is_susceptible and computeInfectionFromS) {\n\t\tif (flip(1 - (1 - beta) ^ (((self) neighbors_at (2)) of_species Host) count (each.is_infected))) {\n\t\t\tis_susceptible <- false;\n\t\t\tis_infected <- true;\n\t\t\tis_immune <- false;\n\t\t\tcolor <- #red;\n\t\t}\n\n\t}\n\t//Reflex to make the agent infect others when the infection is not computed from S for a better execution time\n\treflex infecte_others when: (is_infected and not (computeInfectionFromS)) {\n\t\tloop hst over: ((self) neighbors_at (2)) {\n\t\t\tif (hst.is_susceptible) {\n\t\t\t\tif (flip(beta)) {\n\t\t\t\t\thst.is_susceptible <- false;\n\t\t\t\t\thst.is_infected <- true;\n\t\t\t\t\thst.is_immune <- false;\n\t\t\t\t\thst.color <- #red;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//Reflex to make the agent resistant\n\treflex become_immune when: (is_infected and flip(delta)) {\n\t\tis_susceptible <- false;\n\t\tis_infected <- false;\n\t\tis_immune <- true;\n\t\tcolor <- #yellow;\n\t}\n\n\taspect basic {\n\t\tdraw circle(1) color: color;\n\t}\n\n}\n//Species which represent the SIR mathematical model \nspecies my_SIR_maths {\n\tfloat t;\n\tfloat I <- float(iInit);\n\tfloat S <- N - I;\n\tfloat R <- 0.0;\n\t\t\t\n\tfloat alpha <- 0.01 min: 0.0 max: 1.0;\n\tfloat beta1 <- 0.1 min: 0.0 max: 1000.0;\n\tint N <- 500 min: 1 max: 3000;\n\tint iInit <- 1;\n\n\tequation SIR {\n\t\tdiff(S, t) = (-beta1 * S * I / N);\n\t\tdiff(I, t) = (beta1 * S * I / N) - (alpha * I);\n\t\tdiff(R, t) = (alpha * I);\n\t}\n\t\n\treflex solving {solve SIR method:\"rk4\" step:0.01;}\n\n}\n\n\n\nexperiment mysimulation type: gui {\n\tparameter 'Number of Susceptible' type: int var: initial_S <- 495 category: \"Initial population\"; \n\tparameter 'Number of Infected'    type: int var: initial_I <- 5   category: \"Initial population\";\n\tparameter 'Number of Removed'     type: int var: initial_R <- 0   category: \"Initial population\";\n\n\tparameter 'Beta (S->I)'  type: float var: beta <- 1.0   category: \"Parameters\";\n\tparameter 'Delta (I->R)' type: float var: delta <- 0.01 category: \"Parameters\";\t\n\t\n\tparameter 'Is the infection is computed locally?' type: bool var: local_infection <- true category: \"Infection\";\n\tparameter 'Size of the neighbours' type: int var: neighbours_range <- 2 min:1 max: 5 category: \"Infection\";\n\n\tparameter 'Local Random Walk' type: bool var: local_random_walk <- true category: \"Agents\";\t\n\t\n\tparameter 'Switch models at' type: int var: switch_threshold <- 120 category: \"Model\";\n\t\n\toutput {\n\t\tdisplay 'sir display' {\n\t\t\tgrid sir_grid lines: #black;\n\t\t\tspecies Host aspect: basic;\n\t\t}\n\t\n\t\tdisplay 'Switch model' {\n\t\t\tchart 'Susceptible' type: series background: #lightgray style: exploded {\n\t\t\t\tdata 'susceptible' value: current_model.S color: #green;\n\t\t\t\tdata 'infected' value: current_model.I color: #red;\n\t\t\t\tdata 'immune' value: current_model.R color: #yellow;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay SI_maths  {\n\t\t\tchart \"SI\" type: series background: #white {\n\t\t\t\tdata 'S' value: first((my_SIR_maths)).S color: #green;\n\t\t\t\tdata 'I' value: first((my_SIR_maths)).I color: #red;\n\t\t\t\tdata 'R' value: first((my_SIR_maths)).R color: #yellow;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Epidemiology-SIR-(Switch).md"},"Epidemiology-Susceptible-Infected-(SI).md":{"title":" SI without ODE","content":"[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_grid)\n# SI without ODE\n\n\n_Author : _\n\nA simple SI model without Ordinary Differential Equations showing agents moving randomly among a grid and becoming infected\n\n\nCode of the model : \n\n```\n\nmodel si\n\nglobal { \n\t\n    int number_S <- 495;  // The number of susceptible\n    int number_I <- 5 ;\t// The number of infected\n    float survivalProbability <- 1/(70*365) ; // The survival probability\n\tfloat beta <- 0.05 ; \t// The parameter Beta\n\tfloat nu <- 0.001 ;\t// The parameter Nu\n\tint numberHosts <- number_S+number_I; //Total number of hosts\n\tbool local_infection <- true ; //Infection spread locally or not\n\tint neighbours_size <- 2 ; //Size of the neighbourhood\n\tgeometry shape <- square(50);\n\tinit { \n\t\t//Creation of all the susceptible hosts\n\t\tcreate Host number: number_S {\n        \tis_susceptible <- true;\n        \tis_infected <-  false;\n            is_immune <-  false; \n            color <-  #green;\n        }\n        //Creation of all the infected hosts\n        create Host number: number_I {\n            is_susceptible <-  false; \n            is_infected <-  true;\n            is_immune <-  false; \n            color <-  #red;  \n       }\n   }\n   //Reflex to update the number of infected hosts\n   reflex compute_nb_infected {\n   \t\tnumber_I <- Host count (each.is_infected);\n   }  \n}\n\n//Grid to discretize space\ngrid si_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{\n\trgb color <- #black;\n\tlist<si_grid> neighbours <- (self neighbors_at neighbours_size) ;       \n}\n//Species host which represent the possible hosts of a disease\nspecies Host  {\n\t//Booleans to represent the state of the agent\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n    bool is_immune <- false;\n    rgb color <- #green;\n    int sic_count <- 0;\n    si_grid myPlace;\n    \n    //The agent is placed randomly among the grid\n    init {\n    \tmyPlace <- one_of (si_grid as list);\n    \tlocation <- myPlace.location;\n    }        \n    //Reflex to move the agents in its neighbourhood\n    reflex basic_move {\n    \tmyPlace <- one_of (myPlace.neighbours) ;\n        location <- myPlace.location;\n    }\n    //Reflex to infect the agent if it is susceptible and according to the other infected agents\n    reflex become_infected when: is_susceptible {\n    \tfloat rate <- 0.0;\n    \tif(local_infection) {\n    \t\tint nb_hosts <- 0;\n    \t\tint nb_hosts_infected <- 0;\n    \t\tloop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {\n    \t\t\tnb_hosts <- nb_hosts + 1;\n    \t\t\tif (hst.is_infected) {\n    \t\t\t\tnb_hosts_infected <- nb_hosts_infected + 1;\n    \t\t\t}\n    \t\t}\n    \t\trate <- nb_hosts_infected / nb_hosts;\n    \t} else {\n    \t\trate <- number_I / numberHosts;\n    \t}\n    \tif (flip(beta * rate)) {\n        \tis_susceptible <-  false;\n            is_infected <-  true;\n            is_immune <-  false;\n            color <-  #red;    \n        }\n    }\n    //Reflex to kill the agent according to the death rate\n    reflex shallDie when: flip(nu) {\n\t\tcreate species(self) {\n\t\t\tmyPlace <- myself.myPlace ;\n\t\t\tlocation <- myself.location ; \n\t\t}\n       \tdo die;\n    }\n            \n    aspect basic {\n        draw circle(1) color: color; \n    }\n}\n\n\nexperiment Simulation type: gui { \n \tparameter \"Number of Susceptible\" var: number_S ;// The number of susceptible\n    parameter \"Number of Infected\" var: number_I ;\t// The number of infected\n    parameter \"Survival Probability\" var: survivalProbability ; // The survival probability\n\tparameter \"Beta (S->I)\" var:beta; \t// The parameter Beta\n\tparameter \"Mortality\" var:nu ;\t// The parameter Nu\n\tparameter \"Is the infection is computed locally?\" var:local_infection ;\n\tparameter \"Size of the neighbours\" var:neighbours_size ;\n\t\n \toutput { \n\t    display si_display {\n\t        grid si_grid lines: #black;\n\t        species Host aspect: basic;\n\t    }\n\t        \n\t    display chart refresh: every(10) {\n\t\t\tchart \"Susceptible\" type: series background: #lightgray style: exploded {\n\t\t\t\tdata \"susceptible\" value: Host count (each.is_susceptible) color: #green;\n\t\t\t\tdata \"infected\" value: Host count (each.is_infected) color: #red;\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n}\n```\n","url":"wiki/Epidemiology-Susceptible-Infected-(SI).md"},"Epidemiology-Susceptible-Infected-Recovered-(SIR).md":{"title":" SIR without ODE","content":"[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_grid)\n# SIR without ODE\n\n\n_Author : _\n\nA simple SIR model without Ordinary Differential Equations showing agents moving randomly among a grid and becoming infected then resistant to a disease\n\n\nCode of the model : \n\n```\n\nmodel si\n\nglobal { \n\t//Number of susceptible host at init\n    int number_S <- 495;\n    //Number of infected host at init\n    int number_I <- 5 ;\n    //Number of resistant host at init\n    int number_R <- 0 ;\n    //Rate for the infection success \n\tfloat beta <- 0.05 ;\n\t//Mortality rate for the host\n\tfloat nu <- 0.001 ;\n\t//Rate for resistance \n\tfloat delta <- 0.01;\n\t//Number total of hosts\n\tint numberHosts <- number_S+number_I+number_R;\n\t//Boolean to represent if the infection is computed locally\n\tbool local_infection <- true parameter: \"Is the infection is computed locally?\";\n\t//Range of the cells considered as neighbours for a cell\n\tint neighbours_size <- 2 min:1 max: 5 parameter:\"Size of the neighbours\";\n\t\n\tfloat R0 ;\n\tgeometry shape <- square(50);\n\t\n\tinit {\n\t\t//Creation of all the susceptible Host\n\t\tcreate Host number: number_S {\n        \tis_susceptible <- true;\n        \tis_infected <-  false;\n            is_immune <-  false; \n            color <-  #green;\n        }\n        //Creation of all the infected Host\n        create Host number: number_I {\n            is_susceptible <-  false;\n            is_infected <-  true;\n            is_immune <-  false; \n            color <-  #red; \n       }\n       //Creation of all the resistant Host\n       create Host number: number_R {\n            is_susceptible <-  false;\n            is_infected <-  false;\n            is_immune <-  true; \n            color <-  #blue; \n       }\n       \n       \n       R0 <- beta/(delta+nu);\n\t\twrite \"Basic Reproduction Number: \"+ R0;\n   }\n   \n   //Reflex to update the number of infected\n   reflex compute_nb_infected {\n   \t\tnumber_I <- Host count (each.is_infected);\n   }       \n}\n\n\n//Grid used to discretize space \ngrid sir_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{\n\trgb color <- #black;\n\tlist<sir_grid> neighbours <- (self neighbors_at neighbours_size) ;       \n}\n\n//Species host which represent the Host of the disease\nspecies Host  {\n\t//Booleans to represent the state of the host agent\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n    bool is_immune <- false;\n    rgb color <- #green;\n    sir_grid myPlace;\n    \n    init {\n    \t//Place the agent randomly among the grid\n    \tmyPlace <- one_of (sir_grid as list);\n    \tlocation <- myPlace.location;\n    }     \n    //Reflex to make the agent move   \n    reflex basic_move {\n    \tmyPlace <- one_of (myPlace.neighbours) ;\n        location <- myPlace.location;\n    }\n    //Reflex to make the agent infected if it is susceptible\n    reflex become_infected when: is_susceptible {\n    \tfloat rate  <- 0.0;\n    \t//computation of the infection according to the possibility of the disease to spread locally or not\n    \tif(local_infection) {\n    \t\tint nb_hosts  <- 0;\n    \t\tint nb_hosts_infected  <- 0;\n    \t\tloop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {\n    \t\t\tnb_hosts <- nb_hosts + 1;\n    \t\t\tif (hst.is_infected) {nb_hosts_infected <- nb_hosts_infected + 1;}\n    \t\t}\n    \t\trate <- nb_hosts_infected / nb_hosts;\n    \t} else {\n    \t\trate <- number_I / numberHosts;\n    \t}\n    \tif (flip(beta * rate)) {\n        \tis_susceptible <-  false;\n            is_infected <-  true;\n            is_immune <-  false;\n            color <-  #red;    \n        }\n    }\n    //Reflex to make the agent recovered if it is infected and if it success the probability\n    reflex become_immune when: (is_infected and flip(delta)) {\n    \tis_susceptible <- false;\n    \tis_infected <- false;\n        is_immune <- true;\n        color <- #blue;\n    }\n    //Reflex to kill the agent according to the probability of dying\n    reflex shallDie when: flip(nu) {\n    \t//Create another agent\n\t\tcreate species(self)  {\n\t\t\tmyPlace <- myself.myPlace ;\n\t\t\tlocation <- myself.location ; \n\t\t}\n       \tdo die;\n    }\n            \n    aspect basic {\n        draw circle(1) color: color; \n    }\n}\n\n\nexperiment Simulation type: gui { \n \tparameter \"Number of Susceptible\" var: number_S ;// The number of susceptible\n    parameter \"Number of Infected\" var: number_I ;\t// The number of infected\n    parameter \"Number of Resistant\" var:number_R ;\t// The number of removed\n\tparameter \"Beta (S->I)\" var:beta; \t// The parameter Beta\n\tparameter \"Mortality\" var:nu ;\t// The parameter Nu\n\tparameter \"Delta (I->R)\" var: delta; // The parameter Delta\n\tparameter \"Is the infection is computed locally?\" var:local_infection ;\n\tparameter \"Size of the neighbours\" var:neighbours_size ;\n \toutput { \n\t    display sir_display {\n\t        grid sir_grid lines: #black;\n\t        species Host aspect: basic;\n\t    }\n\t        \n\t    display chart refresh: every(10) {\n\t\t\tchart \"Susceptible\" type: series background: #lightgray style: exploded {\n\t\t\t\tdata \"susceptible\" value: Host count (each.is_susceptible) color: #green;\n\t\t\t\tdata \"infected\" value: Host count (each.is_infected) color: #red;\n\t\t\t\tdata \"immune\" value: Host count (each.is_immune) color: #blue;\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n}\n```\n","url":"wiki/Epidemiology-Susceptible-Infected-Recovered-(SIR).md"},"Evacuation-Continuous-Move.md":{"title":" continuous_move","content":"[//]: # (keyword|operator_copy)\n[//]: # (keyword|operator_closest_points_with)\n[//]: # (keyword|operator_pyramid)\n[//]: # (keyword|operator_simplification)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n# continuous_move\n\n\n_Author : Patrick Taillandier_\n\nA 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point\n\n\nCode of the model : \n\n```\nmodel continuous_move \nglobal { \n\t//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/building.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(building_shapefile);\n\tint maximal_turn <- 90; //in degree\n\tint cohesion_factor <- 10;\n\t//Size of the people\n\tfloat people_size <- 2.0;\n\t//Space without buildings\n\tgeometry free_space;\n\t//Number of people agent\n\tint nb_people <- 500;\n\t//Point to evacuate\n\tpoint target_point <- {world.location.x, 0};\n\tinit { \n\t\t\n\t\tfree_space <- copy(shape);\n\t\t//Creation of the buildinds\n\t\tcreate building from: building_shapefile {\n\t\t\t//Creation of the free space by removing the shape of the different buildings existing\n\t\t\tfree_space <- free_space - (shape + people_size);\n\t\t}\n\t\t//Simplification of the free_space to remove sharp edges\n\t\tfree_space <- free_space simplification(1.0);\n\t\t//Creation of the people agents\n\t\tcreate people number: nb_people {\n\t\t\t//People agents are placed randomly among the free space\n\t\t\tlocation <- any_location_in(free_space);\n\t\t\ttarget_loc <-  target_point;\n\t\t} \t\t \t\n\t}\t\n}\n//Species which represent the building \nspecies building {\n\t//Height of the buildings\n\tfloat height <- 3.0 + rnd(5);\n\taspect default {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n//Species people which move to the evacuation point using the skill moving\nspecies people skills:[moving]{\n\t//Target point to evacuate\n\tpoint target_loc;\n\t//Speed of the agent\n\tfloat speed <- 0.5 + rnd(1000) / 1000;\n\t//Velocity of the agent\n\tpoint velocity <- {0,0};\n\t//Direction of the agent taking in consideration the maximal turn an agent is able to make\n\tint heading max: heading + maximal_turn min: heading - maximal_turn;\n\t\n\t//Size of the agent\n\tfloat size <- people_size;\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t\n\t//Reflex to kill the agent when it has evacuated the area\n\treflex end when: location distance_to target_loc <= 2 * people_size{\n\t\twrite name + \" is arrived\";\n\t\tdo die;\n\t}\n\t//Reflex to compute the velocity of the agent considering the cohesion factor\n\treflex follow_goal  {\n\t\tvelocity <- velocity + ((target_loc - location) / cohesion_factor);\n\t}\n\t//Reflex to apply separation when people are too close from each other\n\treflex separation {\n\t\tpoint acc <- {0,0};\n\t\task (people at_distance size)  {\n\t\t\tacc <- acc - (location - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t//Reflex to avoid the different obstacles\n\treflex avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<building> nearby_obstacles <- (building at_distance people_size);\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - (obs.location - location);\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t//Reflex to move the agent considering its location, target and velocity\n\treflex move {\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity ;\n\t\tif (not empty(building overlapping self )) {\n\t\t\tlocation <- point((location closest_points_with free_space)[1]);\n\t\t}\n\t\tvelocity <- location - old_location;\n\t}\t\n\taspect default {\n\t\tdraw pyramid(size) color: color;\n\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\n\toutput {\n\t\tdisplay map type: opengl {\n\t\t\tspecies building refresh: false;\n\t\t\tspecies people;\n\t\t\tgraphics \"exit\" refresh: false {\n\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Evacuation-Continuous-Move.md"},"Evacuation-continuous_move.md":{"title":" continuous_move","content":"[//]: # (keyword|operator_copy)\n[//]: # (keyword|operator_not)\n[//]: # (keyword|operator_closest_points_with)\n[//]: # (keyword|operator_pyramid)\n[//]: # (keyword|operator_simplification)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n# continuous_move\n\n\n_Author : Patrick Taillandier_\n\nA 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point\n\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Evacuation\\Evacuation continuous_move\\map-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Evacuation\\Evacuation continuous_move\\map-10.png)\n\nCode of the model : \n\n```\nmodel continuous_move \nglobal { \n\t//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/building.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(building_shapefile);\n\tint maximal_turn <- 90; //in degree\n\tint cohesion_factor <- 10;\n\t//Size of the people\n\tfloat people_size <- 2.0;\n\t//Space without buildings\n\tgeometry free_space;\n\t//Number of people agent\n\tint nb_people <- 500;\n\t//Point to evacuate\n\tpoint target_point <- {world.location.x, 0};\n\tinit { \n\t\t\n\t\tfree_space <- copy(shape);\n\t\t//Creation of the buildinds\n\t\tcreate building from: building_shapefile {\n\t\t\t//Creation of the free space by removing the shape of the different buildings existing\n\t\t\tfree_space <- free_space - (shape + people_size);\n\t\t}\n\t\t//Simplification of the free_space to remove sharp edges\n\t\tfree_space <- free_space simplification(1.0);\n\t\t//Creation of the people agents\n\t\tcreate people number: nb_people {\n\t\t\t//People agents are placed randomly among the free space\n\t\t\tlocation <- any_location_in(free_space);\n\t\t\ttarget_loc <-  target_point;\n\t\t} \t\t \t\n\t}\t\n}\n//Species which represent the building \nspecies building {\n\t//Height of the buildings\n\tfloat height <- 3.0 + rnd(5);\n\taspect default {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n//Species people which move to the evacuation point using the skill moving\nspecies people skills:[moving]{\n\t//Target point to evacuate\n\tpoint target_loc;\n\t//Speed of the agent\n\tfloat speed <- 0.5 + rnd(1000) / 1000;\n\t//Velocity of the agent\n\tpoint velocity <- {0,0};\n\t//Direction of the agent taking in consideration the maximal turn an agent is able to make\n\tint heading max: heading + maximal_turn min: heading - maximal_turn;\n\t\n\t//Size of the agent\n\tfloat size <- people_size;\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t\n\t//Reflex to kill the agent when it has evacuated the area\n\treflex end when: location distance_to target_loc <= 2 * people_size{\n\t\twrite name + \" is arrived\";\n\t\tdo die;\n\t}\n\t//Reflex to compute the velocity of the agent considering the cohesion factor\n\treflex follow_goal  {\n\t\tvelocity <- velocity + ((target_loc - location) / cohesion_factor);\n\t}\n\t//Reflex to apply separation when people are too close from each other\n\treflex separation {\n\t\tpoint acc <- {0,0};\n\t\task (people at_distance size)  {\n\t\t\tacc <- acc - (location - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t//Reflex to avoid the different obstacles\n\treflex avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<building> nearby_obstacles <- (building at_distance people_size);\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - (obs.location - location);\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t//Reflex to move the agent considering its location, target and velocity\n\treflex move {\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity ;\n\t\tif (not empty(building overlapping self )) {\n\t\t\tlocation <- point((location closest_points_with free_space)[1]);\n\t\t}\n\t\tvelocity <- location - old_location;\n\t}\t\n\taspect default {\n\t\tdraw pyramid(size) color: color;\n\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\n\t}\n}\n\nexperiment main type: gui {\n\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\n\toutput {\n\t\tdisplay map type: opengl camera_pos: {world.location.x,-world.shape.height*1.5,70}\n                        camera_look_pos:{world.location.x,0,0}    {\n\t\t\timage '../images/soil.jpg';\n\t\t\tspecies building refresh: false;\n\t\t\tspecies people;\n\t\t\tgraphics \"exit\" refresh: false {\n\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Evacuation-continuous_move.md"},"Evacuation-Goto-on-Grid.md":{"title":" evacuationgoto","content":"[//]: # (keyword|operator_rnd_color)\n[//]: # (keyword|operator_pyramid)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_grid)\n# evacuationgoto\n\n\n_Author : Patrick Taillandier_\n\nA 3D model with walls and exit, and people agents trying to evacuate from the area to a exit location, avoiding the walls with a discretized space by a grid\n\n\nCode of the model : \n\n```\n\nmodel evacuationgoto\n\nglobal {\n\t//Shapefile of the walls\n\tfile wall_shapefile <- shape_file(\"../includes/walls.shp\");\n\t//Shapefile of the exit\n\tfile exit_shapefile <- shape_file(\"../includes/exit.shp\");\n\t//DImension of the grid agent\n\tint nb_cols <- 50;\n\tint nb_rows <- 50;\n\t\n\t//Shape of the world initialized as the bounding box around the walls\n\tgeometry shape <- envelope(wall_shapefile);\n\t\n\tinit {\n\t\t//Creation of the wall and initialization of the cell is_wall attribute\n\t\tcreate wall from: wall_shapefile {\n\t\t\task cell overlapping self {\n\t\t\t\tis_wall <- true;\n\t\t\t}\n\t\t}\n\t\t//Creation of the exit and initialization of the cell is_exit attribute\n\t\tcreate exit from: exit_shapefile {\n\t\t\task (cell overlapping self) where not each.is_wall{\n\t\t\t\tis_exit <- true;\n\t\t\t}\n\t\t}\n\t\t//Creation of the people agent\n\t\tcreate people number: 50{\n\t\t\t//People agent are placed randomly among cells which aren't wall\n\t\t\tlocation <- one_of(cell where not each.is_wall).location;\n\t\t\t//Target of the people agent is one of the possible exits\n\t\t\ttarget <- one_of(cell where each.is_exit).location;\n\t\t}\n\t}\n}\n//Grid species to discretize space\ngrid cell width: nb_cols height: nb_rows neighbors: 8 {\n\tbool is_wall <- false;\n\tbool is_exit <- false;\n\trgb color <- #white;\t\n}\n//Species exit which represent the exit\nspecies exit {\n\taspect default {\n\t\tdraw shape color: #blue;\n\t}\n}\n//Species which represent the wall\nspecies wall {\n\taspect default {\n\t\tdraw shape color: #black depth: 10;\n\t}\n}\n//Species which represent the people moving from their location to an exit using the skill moving\nspecies people skills: [moving]{\n\t//Evacuation point\n\tpoint target;\n\trgb color <- rnd_color(255);\n\t\n\t//Reflex to move the agent \n\treflex move {\n\t\t//Make the agent move only on cell without walls\n\t\tdo goto target: target speed: 1 on: (cell where not each.is_wall) recompute_path: false;\n\t\t//If the agent is close enough to the exit, it dies\n\t\tif (self distance_to target) < 2.0 {\n\t\t\tdo die;\n\t\t}\n\t}\n\taspect default {\n\t\tdraw pyramid(2) color: color;\n\t\tdraw sphere(1) at: {location.x,location.y,2} color: color;\n\t}\n}\nexperiment evacuationgoto type: gui {\n\toutput {\n\t\tdisplay map type: opengl{\n\t\t\timage \"../images/floor.jpg\";\n\t\t\tspecies wall refresh: false;\n\t\t\tspecies exit refresh: false;\n\t\t\tspecies people;\n\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Evacuation-Goto-on-Grid.md"},"Evacuation-grid_goto.md":{"title":" evacuationgoto","content":"[//]: # (keyword|operator_rnd_color)\n[//]: # (keyword|operator_not)\n[//]: # (keyword|operator_pyramid)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_grid)\n# evacuationgoto\n\n\n_Author : Patrick Taillandier_\n\nA 3D model with walls and exit, and people agents trying to evacuate from the area to a exit location, avoiding the walls with a discretized space by a grid\n\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Evacuation\\Evacuation grid_goto\\map-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Evacuation\\Evacuation grid_goto\\map-10.png)\n\nCode of the model : \n\n```\n\nmodel evacuationgoto\n\nglobal {\n\t//Shapefile of the walls\n\tfile wall_shapefile <- shape_file(\"../includes/walls.shp\");\n\t//Shapefile of the exit\n\tfile exit_shapefile <- shape_file(\"../includes/exit.shp\");\n\t//DImension of the grid agent\n\tint nb_cols <- 50;\n\tint nb_rows <- 50;\n\t\n\t//Shape of the world initialized as the bounding box around the walls\n\tgeometry shape <- envelope(wall_shapefile);\n\t\n\tinit {\n\t\t//Creation of the wall and initialization of the cell is_wall attribute\n\t\tcreate wall from: wall_shapefile {\n\t\t\task cell overlapping self {\n\t\t\t\tis_wall <- true;\n\t\t\t}\n\t\t}\n\t\t//Creation of the exit and initialization of the cell is_exit attribute\n\t\tcreate exit from: exit_shapefile {\n\t\t\task (cell overlapping self) where not each.is_wall{\n\t\t\t\tis_exit <- true;\n\t\t\t}\n\t\t}\n\t\t//Creation of the people agent\n\t\tcreate people number: 50{\n\t\t\t//People agent are placed randomly among cells which aren't wall\n\t\t\tlocation <- one_of(cell where not each.is_wall).location;\n\t\t\t//Target of the people agent is one of the possible exits\n\t\t\ttarget <- one_of(cell where each.is_exit).location;\n\t\t}\n\t}\n}\n//Grid species to discretize space\ngrid cell width: nb_cols height: nb_rows neighbors: 8 {\n\tbool is_wall <- false;\n\tbool is_exit <- false;\n\trgb color <- #white;\t\n}\n//Species exit which represent the exit\nspecies exit {\n\taspect default {\n\t\tdraw shape color: #blue;\n\t}\n}\n//Species which represent the wall\nspecies wall {\n\taspect default {\n\t\tdraw shape color: #black depth: 10;\n\t}\n}\n//Species which represent the people moving from their location to an exit using the skill moving\nspecies people skills: [moving]{\n\t//Evacuation point\n\tpoint target;\n\trgb color <- rnd_color(255);\n\t\n\t//Reflex to move the agent \n\treflex move {\n\t\t//Make the agent move only on cell without walls\n\t\tdo goto target: target speed: 1 on: (cell where not each.is_wall) recompute_path: false;\n\t\t//If the agent is close enough to the exit, it dies\n\t\tif (self distance_to target) < 2.0 {\n\t\t\tdo die;\n\t\t}\n\t}\n\taspect default {\n\t\tdraw pyramid(2) color: color;\n\t\tdraw sphere(1) at: {location.x,location.y,2} color: color;\n\t}\n}\nexperiment evacuationgoto type: gui {\n\toutput {\n\t\tdisplay map type: opengl{\n\t\t\timage \"../images/floor.jpg\";\n\t\t\tspecies wall refresh: false;\n\t\t\tspecies exit refresh: false;\n\t\t\tspecies people;\n\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Evacuation-grid_goto.md"},"Evacuation-grid_move.md":{"title":" grid_move","content":"[//]: # (keyword|operator_not)\n[//]: # (keyword|operator_in)\n[//]: # (keyword|operator_with_min_of)\n[//]: # (keyword|operator_pyramid)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_grid)\n# grid_move\n\n\n_Author : _\n\nA 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point, within a discretized space by a grid. The agents don't use the skill moving to move.\n\n\n![F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Evacuation\\Evacuation grid_move\\map-10.png](F:\\Gama\\GamaWiki\\resources\\images\\modelLibraryScreenshots\\Toy Models\\Evacuation\\Evacuation grid_move\\map-10.png)\n\nCode of the model : \n\n```\nmodel grid_move\n\nglobal {\n\t//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/building.shp\");\n\t//Shape of the world\n\tgeometry shape <- envelope(building_shapefile);\n\t//Maximum memory of the agent to avoid loop of the agents\n\tint max_memory <- 5;\n\t//Size of the people agents\n\tfloat people_size <- 2.0;\n\t//Number of people agents\n\tint nb_people <- 500;\n\t//Evacuation point for the people agents\n\tpoint target_point <- {world.location.x, 0};\n\t\n\tinit {\n\t\t//Creation of the building agents using the shapefile\n\t\tcreate building from: building_shapefile\n\t\t{\n\t\t\t//Initialization of the cell is_obstacle attribute\n\t\t\task cell overlapping self {\n\t\t\t\tis_obstacle <- true;\n\t\t\t\tcolor <- #black;\n\t\t\t}\n\t\t}\n\n\t\tlist<cell> free_cell <- cell where not (each.is_obstacle);\n\t\tcell the_target_cell <- cell closest_to target_point;\n\t\t//Creation of the people agent\n\t\tcreate people number: nb_people {\n\t\t\t//People agent are placed randomly among the cells which haven't people or obstacle\n\t\t\tcurrent_cell <- one_of(free_cell);\n\t\t\tcurrent_cell.is_free <- false;\n\t\t\tremove current_cell from: free_cell;\n\t\t\tlocation <- current_cell.location;\n\t\t\ttarget_cell <- the_target_cell;\n\t\t\tmemory << current_cell;\n\t\t\t\n\t\t}\n\t}\n}\n//Species which represent the buildings\nspecies building {\n\tfloat height <- 3.0 + rnd(5);\n\taspect default {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n//Species which represent the people agent moving from one cell to its neighbours\nspecies people {\n\t//Current cell of the agent\n\tcell current_cell;\n\t//Evacuation cell of the agent\n\tcell target_cell;\n\t//List of the cells already passed by the agents and mesmorized\n\tlist<cell> memory;\n\t//Size of the agent\n\tfloat size <- people_size;\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\t\n\t\n\t//Reflex to kill the agent once it is close enough to an evacuation point\n\treflex end when: location distance_to target_cell.location <= 2 * people_size {\n\t\tcurrent_cell.is_free <- true;\n\t\tdo die;\n\t}\n\t//Reflex to move the agent\n\treflex move {\n\t\t//List of all the cells possible (which aren't obstacles, without people on it and on which the agent hasn't already passed\n\t\tlist<cell> possible_cells <- current_cell neighbors_at 1 where (not (each.is_obstacle) and each.is_free and not (each in memory));\n\t\t//If there is possible cell, the agent move on the closest one to the evacuation point\n\t\tif not empty(possible_cells) {\n\t\t\tcurrent_cell.is_free <- true;\n\t\t\tcurrent_cell <- shuffle(possible_cells) with_min_of (each.location distance_to target_cell.location);\n\t\t\tlocation <- current_cell.location;\n\t\t\tcurrent_cell.is_free <- false;\n\t\t\t//Management of the memory of the agents\n\t\t\tmemory << current_cell; \n\t\t\tif (length(memory) > max_memory) {\n\t\t\t\tremove memory[0] from: memory;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tdraw pyramid(size) color: color;\n\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\n\t}\n}\n//Grid species to discretize space\ngrid cell width: 150 height: 150  neighbors: 8 frequency: 0 {\n\tbool is_obstacle <- false;\n\tbool is_free <- true;\n\trgb color <- #white;\n}\n\nexperiment main type: gui {\n\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\n\toutput {\n\t\tdisplay map type: opengl camera_pos: {world.location.x,-world.shape.height*1.5,70}\n                        camera_look_pos:{world.location.x,0,0}    {\n\t\t\timage '../images/soil.jpg';\n\t\t\tspecies building refresh: false;\n\t\t\tspecies people;\n\t\t\tgraphics \"exit\" refresh: false {\n\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Evacuation-grid_move.md"},"Evacuation-Move-on-Grid.md":{"title":" grid_move","content":"[//]: # (keyword|operator_in)\n[//]: # (keyword|operator_with_min_of)\n[//]: # (keyword|operator_pyramid)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_grid)\n# grid_move\n\n\n_Author : _\n\nA 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point, within a discretized space by a grid. The agents don't use the skill moving to move.\n\n\nCode of the model : \n\n```\nmodel grid_move\n\nglobal {\n\t//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/building.shp\");\n\t//Shape of the world\n\tgeometry shape <- envelope(building_shapefile);\n\t//Maximum memory of the agent to avoid loop of the agents\n\tint max_memory <- 5;\n\t//Size of the people agents\n\tfloat people_size <- 2.0;\n\t//Number of people agents\n\tint nb_people <- 500;\n\t//Evacuation point for the people agents\n\tpoint target_point <- {world.location.x, 0};\n\t\n\tinit {\n\t\t//Creation of the building agents using the shapefile\n\t\tcreate building from: building_shapefile\n\t\t{\n\t\t\t//Initialization of the cell is_obstacle attribute\n\t\t\task cell overlapping self {\n\t\t\t\tis_obstacle <- true;\n\t\t\t\tcolor <- #black;\n\t\t\t}\n\t\t}\n\n\t\tlist<cell> free_cell <- cell where not (each.is_obstacle);\n\t\tcell the_target_cell <- cell closest_to target_point;\n\t\t//Creation of the people agent\n\t\tcreate people number: nb_people {\n\t\t\t//People agent are placed randomly among the cells which haven't people or obstacle\n\t\t\tcurrent_cell <- one_of(free_cell);\n\t\t\tcurrent_cell.is_free <- false;\n\t\t\tremove current_cell from: free_cell;\n\t\t\tlocation <- current_cell.location;\n\t\t\ttarget_cell <- the_target_cell;\n\t\t\tmemory << current_cell;\n\t\t\t\n\t\t}\n\t}\n}\n//Species which represent the buildings\nspecies building {\n\tfloat height <- 3.0 + rnd(5);\n\taspect default {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n//Species which represent the people agent moving from one cell to its neighbours\nspecies people {\n\t//Current cell of the agent\n\tcell current_cell;\n\t//Evacuation cell of the agent\n\tcell target_cell;\n\t//List of the cells already passed by the agents and mesmorized\n\tlist<cell> memory;\n\t//Size of the agent\n\tfloat size <- people_size;\n\trgb color <- rgb(rnd(255),rnd(255),rnd(255));\n\t\n\t\n\t//Reflex to kill the agent once it is close enough to an evacuation point\n\treflex end when: location distance_to target_cell.location <= 2 * people_size {\n\t\tcurrent_cell.is_free <- true;\n\t\tdo die;\n\t}\n\t//Reflex to move the agent\n\treflex move {\n\t\t//List of all the cells possible (which aren't obstacles, without people on it and on which the agent hasn't already passed\n\t\tlist<cell> possible_cells <- current_cell neighbors_at 1 where (not (each.is_obstacle) and each.is_free and not (each in memory));\n\t\t//If there is possible cell, the agent move on the closest one to the evacuation point\n\t\tif not empty(possible_cells) {\n\t\t\tcurrent_cell.is_free <- true;\n\t\t\tcurrent_cell <- shuffle(possible_cells) with_min_of (each.location distance_to target_cell.location);\n\t\t\tlocation <- current_cell.location;\n\t\t\tcurrent_cell.is_free <- false;\n\t\t\t//Management of the memory of the agents\n\t\t\tmemory << current_cell; \n\t\t\tif (length(memory) > max_memory) {\n\t\t\t\tremove memory[0] from: memory;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tdraw pyramid(size) color: color;\n\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\n\t}\n}\n//Grid species to discretize space\ngrid cell width: 150 height: 150  neighbors: 8 frequency: 0 {\n\tbool is_obstacle <- false;\n\tbool is_free <- true;\n\trgb color <- #white;\n}\n\nexperiment main type: gui {\n\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\n\toutput {\n\t\tdisplay map type: opengl camera_pos: {world.location.x,-world.shape.height*1.5,70}\n                        camera_look_pos:{world.location.x,0,0}    {\n\t\t\timage '../images/soil.jpg';\n\t\t\tspecies building refresh: false;\n\t\t\tspecies people;\n\t\t\tgraphics \"exit\" refresh: false {\n\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Evacuation-Move-on-Grid.md"},"Flood-Simulation-Hydrological-Model.md":{"title":" Hydrological Model","content":"[//]: # (keyword|operator_max_of)\n[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|statement_user_command)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|constant_#magenta)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|concept_hydrology)\n# Hydrological Model\n\n\n_Author : Patrick Taillandier_\n\nA model showing how to represent a flooding system with dykes and buildings. It uses a grid to discretize space, and has a 3D display. The water can flow from one cell to another considering the height of the cells, and the water pressure. It is also possible to delete dyke by clicking on one of them in the display.\n\n\nCode of the model : \n\n```\n\nmodel hydro\n\nglobal {\n   //Shapefile for the river\n   file river_shapefile <- file(\"../includes/RedRiver.shp\");\n   //Shapefile for the dykes\n   file dykes_shapefile <- file(\"../includes/Dykes.shp\");\n   //Shapefile for the buildings\n   file buildings_shapefile <- file(\"../includes/Building.shp\");\n   \n   //Data elevation file\n   file dem_file <- file(\"../includes/mnt50.asc\");  \n   //Diffusion rate\n   float diffusion_rate <- 0.6;\n   //Height of the dykes\n   float dyke_height <- 15.0;\n   //Width of the dyke\n   float dyke_width <- 15.0;\n    \n   //Shape of the environment using the dem file\n   geometry shape <- envelope(dem_file);\n   \n   //List of the drain and river cells\n   list<cell> drain_cells;\n   list<cell> river_cells;\n   \n   \n  \n   float step <- 1°h;\n   \n   init {\n   \t //Initialization of the cells\n      do init_cells;\n     //Initialization of the water cells\n      do init_water;\n     //Initialization of the river cells\n     river_cells <- cell where (each.is_river);\n     //Initialization of the drain cells\n      drain_cells <- cell where (each.is_drain);\n     //Initialization of the obstacles (buildings and dykes)\n      do init_obstacles;\n      //Set the height of each cell\n      ask cell {\n         obstacle_height <- compute_highest_obstacle();\n         do update_color;\n      }\n   }\n   //Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\n   //action to initialize the water cells according to the river shape file and the drain\n   action init_water {\n      geometry river <- geometry(river_shapefile);\n      ask cell overlapping river {\n         water_height <- 10.0;\n         is_river <- true;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }\n   //initialization of the obstacles (the buildings and the dykes)\n   action init_obstacles{\n      create buildings from: buildings_shapefile  {\n         do update_cells;\n      }\n      create dyke from: dykes_shapefile;\n      ask dyke {\n          shape <-  shape + dyke_width;\n            do update_cells;\n      }\n   }\n   //Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- rnd(100)/100;\n      ask river_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   //Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask cell {already <- false;}\n      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {\n         do flow;\n      }\n   }\n   //Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell {\n         do update_color;\n      }\n   }\n   //Reflex for the drain cells to drain water\n   reflex draining {\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }\n   \n}\n//Species which represent the obstacle\n   species obstacle {\n   \t  //height of the obstacle\n      float height min: 0.0;\n      //Color of the obstacle\n      rgb color;\n      //Pressure of the water\n      float water_pressure update: compute_water_pressure();\n      \n      //List of cells concerned\n      list<cell> cells_concerned ;\n      //List of cells in the neighbourhood \n      list<cell> cells_neighbours;\n      \n      //Action to compute the water pressure\n      float compute_water_pressure {\n      \t//If the obstacle doesn't have height, then there will be no pressure\n         if (height = 0.0) {\n            return 0.0;\n         } else {\n         \t//The leve of the water is equals to the maximul level of water in the neighbours cells\n            float water_level <- cells_neighbours max_of (each.water_height);\n            //Return the water pressure as the minimal value between 1 and the water level divided by the height\n            return min([1.0,water_level / height]);\n         } \n      }\n      \n      //Action to update the cells\n      action update_cells {\n      \t//All the cells concerned by the obstacle are the ones overlapping the obstacle\n         cells_concerned <- (cell overlapping self);\n        \task cells_concerned {\n        \t//Add the obstacles to the obstacles of the cell\n            add myself to: obstacles;\n            water_height <- 0.0;\n         }\n         //Cells neighbours are all the neighbours cells of the cells concerned\n         cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);\n         //The height is now computed\n      \t do compute_height();\n         if (height > 0.0) {   \n         \t//We compute the water pressure again\n            water_pressure <- compute_water_pressure();\n         } else {water_pressure <- 0.0;}\n      }\n      action compute_height;\n      aspect geometry {\n         int val <- int( 255 * water_pressure);\n         color <- rgb(val,255-val,0);\n         draw shape color: color depth: height*5 border: color;\n      }\n   }\n   //Species buildings which is derivated from obstacle\n   species buildings parent: obstacle {\n   \t //The building has a height randomly chosed between 2 and 10\n      float height <- 2.0 + rnd(8);\n   }\n   //Species dyke which is derivated from obstacle\n   species dyke parent: obstacle{\n   \t\n       int counter_wp <- 0;\n       int breaking_threshold <- 24;\n      \n      //Action to represent the break of the dyke\n       action break{\n         ask cells_concerned {\n            do update_after_destruction(myself);\n         }\n         do die;\n      }\n      //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps\n      action compute_height\n       {\n      \t   height <- dyke_height - mean(cells_concerned collect (each.altitude));\n      \n      }\n      \n      //Reflex to break the dynamic of the water\n      reflex breaking_dynamic {\n      \tif (water_pressure = 1.0) {\n      \t\tcounter_wp <- counter_wp + 1;\n      \t\tif (counter_wp > breaking_threshold) {\n      \t\t\tdo break;\n      \t\t}\n      \t} else {\n      \t\tcounter_wp <- 0;\n      \t}\n      }\n      //user command which allows the possibility to destroy the dyke for the user\n      user_command \"Destroy dyke\" action: break; \n   }\n   //Grid cell to discretize space, initialized using the dem file\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false {\n      //Altitude of the cell\n      float altitude;\n      //Height of the water in the cell\n      float water_height <- 0.0 min: 0.0;\n      //Height of the cell\n      float height;\n      //List of the neighbour cells\n      list<cell> neighbour_cells ;\n      //Boolean to know if it is a drain cell\n      bool is_drain <- false;\n      //Boolean to know if it is a river cell\n      bool is_river <- false;\n      //List of all the obstacles overlapping the cell\n      list<obstacle> obstacles;\n      //Height of the obstacles\n      float obstacle_height <- 0.0;\n      bool already <- false;\n      \n      //Action to compute the highest obstacle among the obstacles\n      float compute_highest_obstacle {\n         if (empty(obstacles))\n         {\n            return 0.0; \n         } else {\n            return obstacles max_of(each.height);\n         }\n      }\n      //Action to flow the water \n      action flow {\n      \t//if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t//We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            //If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}\n               //The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               //If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      //Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n      //action to compute the destruction of the obstacle\n      action update_after_destruction(obstacle the_obstacle){\n         remove the_obstacle from: obstacles;\n         obstacle_height <- compute_highest_obstacle();\n      }\n       \n   }\n\n\nexperiment main_gui type: gui {\n   parameter \"Shapefile for the river\" var:river_shapefile category:\"Water data\";\n   parameter \"Shapefile for the dykes\" var:dykes_shapefile category:\"Obstacles\";\n   parameter \"Shapefile for the buildings\" var:buildings_shapefile category:\"Obstacles\";\n   parameter \"Height of the dykes\" var:dyke_height category:\"Obstacles\";\n   parameter \"Diffusion rate\" var:diffusion_rate category:\"Water dynamic\";\n   output { \n      display map type: opengl {\n         grid cell triangulation: true;\n         species buildings aspect: geometry;\n         species dyke aspect: geometry ;\n      }\n      display chart_display refresh: every(24) { \n         chart \"Pressure on Dykes\" type: series {\n            data \"Mean pressure on dykes \" value: mean(dyke collect (each.water_pressure)) style: line color: #magenta ;\n            data \"Rate of dykes with max pressure\" value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;\n            data \"Rate of dykes with high pressure\" value: (dyke count (each.water_pressure > 0.5))/ length(dyke) style: line color: #orange ;\n            data \"Rate of dykes with low pressure\" value: (dyke count (each.water_pressure < 0.25))/ length(dyke) style: line color: #green ;\n         }\n      }\n   }\n}\n```\n","url":"wiki/Flood-Simulation-Hydrological-Model.md"},"Learning-MAS_KMEANS.md":{"title":" Agent Based Clustering","content":"[//]: # (keyword|operator_cross)\n[//]: # (keyword|operator_cube)\n[//]: # (keyword|operator_rnd_color)\n[//]: # (keyword|operator_even)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|operator_font)\n[//]: # (keyword|constant_#grey)\n[//]: # (keyword|constant_#bold)\n[//]: # (keyword|type_font)\n# Agent Based Clustering\n\n\n_Author : Jean-Danie Zucker with Patrick Taillandier's and Arnaud Grignard's Help_\n\nCode of the model : \n\n```\nmodel MASKMEANS\n\n\nglobal\n{\n// the number of classes to create (kmeans)\n// It corresponds to the centroids\n\tint k <- 4;\n\t// the number of points\n\tint N <- 100;\n\t//number of dimensions\n\tint dimensions;\n\tinit\n\t{\n\t//create datapoints agents\n\t\tcreate datapoints number: N\n\t\t{\n\t\t\tif (dimensions = 3)\n\t\t\t{\n\t\t\t\tlocation <- { rnd(100), rnd(100), rnd(100) };\n\t\t\t}\n\n\t\t\tif (dimensions = 2)\n\t\t\t{\n\t\t\t\tlocation <- { rnd(100), rnd(100) };\n\t\t\t}\n\n\t\t}\n\n\t\t//create centroid agents\n\t\tcreate centroids number: k\n\t\t{\n\t\t\tif (dimensions = 3)\n\t\t\t{\n\t\t\t\tlocation <- { rnd(100), rnd(100), rnd(100) };\n\t\t\t}\n\n\t\t\tif (dimensions = 2)\n\t\t\t{\n\t\t\t\tlocation <- { rnd(100), rnd(100) };\n\t\t\t}\n\n\t\t}\n\n\t\t//give a random color to each centroid (i.e. to each datapoints agents of the group)\n\t\tloop c over: centroids\n\t\t{\n\t\t\trgb col <- rnd_color(255);\n\t\t\task c\n\t\t\t{\n\t\t\t\tcolor_kmeans <- col;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treflex assign_points_to_centroid when: even(cycle)\n\t{\n\t// The \"assignment\" step is also referred to as expectation step,\n\t\task centroids\n\t\t{\n\t\t\tmypoints <- list<datapoints> ([]);\n\t\t}\n\n\t\tloop pt over: datapoints\n\t\t{\n\t\t\task pt\n\t\t\t{\n\t\t\t\tmycenter <- (centroids) closest_to self;\n\t\t\t\tcolor_kmeans <- mycenter.color_kmeans;\n\t\t\t\tadd self to: mycenter.mypoints;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treflex update_centroids when: not even(cycle)\n\t{\n\t// the \"update step\" as maximization step,\n\t// making this algorithm a variant of the generalized expectation-maximization algorithm.\n\n\t//We give a random color to each group (i.e. to each datapoints agents of the group)\n\t\tloop center over: centroids\n\t\t{\n\t\t//old code... center.location <- geometry(center.mypoints).location;\n\t\t\tcenter.location <- mean(center.mypoints collect each.location);\n\t\t}\n\n\t}\n\n}\n\nspecies datapoints\n{\n\trgb color_kmeans <- # grey;\n\tcentroids mycenter;\n\taspect kmeans_aspect2D\n\t{\n\t\tdraw circle(2) color: color_kmeans;\n\t}\n\n\taspect kmeans_aspect3D\n\t{\n\t\tdraw sphere(2) color: color_kmeans;\n\t}\n\n}\n\nspecies centroids\n{\n\trgb color_kmeans <- # grey;\n\tlist<datapoints> mypoints;\n\taspect kmeans_aspect2D\n\t{\n\t\tdraw cross(3, 0.5) color: color_kmeans border: # black;\n\t\tloop pt over: mypoints\n\t\t{\n\t\t\tdraw line([location, pt]) + 0.1 color: color_kmeans;\n\t\t}\n\t}\n\n\taspect kmeans_aspect3D\n\t{\n\t\tdraw cube(5) color: color_kmeans border: # black;\n\t\tloop pt over: mypoints\n\t\t{\n\t\t\tdraw line([location, pt], 0.2) color: color_kmeans;\n\t\t}\n\t}\n\n}\n\nexperiment clustering2D type: gui\n{\n\tparameter \"Number of clusters to split the data into\" var: k category: \"KMEANS\";\n\tparameter \"Number of points to be clustered\" var: N init: 100;\n\tparameter \"Number of dimensions\" var: dimensions init: 2 min: 2 max: 2;\n\tfont regular <- font(\"Helvetica\", 14, # bold);\n\t\t\n\tpoint target <- { 20, 95 };\n\toutput\n\t{\n\t\tdisplay map_kmeans\n\t\t{\n\t\t\tspecies datapoints aspect: kmeans_aspect2D;\n\t\t\tspecies centroids aspect: kmeans_aspect2D;\n\t\t\tgraphics \"Full target\"\n\t\t\t{\n\t\t\t\tdraw rectangle(100, 4) color: # yellow at: target + { 30, 0 };\n\t\t\t\tif (not even(cycle))\n\t\t\t\t{\n\t\t\t\t// the \"update step\" as maximization step, (a mean is done to recenter)\n\t\t\t\t\tdraw \"Next step is maximisation step the centroid will move to the means of its points\" at: target + { 0, 0 } font: regular color: # red;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tdraw \"Next step is estimation Step (each point is assigned the color of his nearest centroid\" at: target + { 0, 0 } font: regular color: # green;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n}\n\nexperiment clustering3D type: gui\n{\n\tparameter \"Number of clusters to split the data into\" var: k category: \"KMEANS\";\n\tparameter \"Number of points to be clustered\" var: N init: 100;\n\tfont regular <- font(\"Helvetica\", 14, # bold);\n\tpoint target <- { 20, 95 };\n\tparameter \"Number of dimensions\" var: dimensions init: 3 min: 3 max: 3;\n\taction _init_ {\n\t\tcreate MASKMEANS_model with: [dimensions::3];\n\t}\n\toutput\n\t{\n\t\tdisplay map_kmeans type: opengl\n\t\t{\n\t\t\tspecies datapoints aspect: kmeans_aspect3D;\n\t\t\tspecies centroids aspect: kmeans_aspect3D;\n\t\t}\n\n\t}\n\n}\n\n```\n","url":"wiki/Learning-MAS_KMEANS.md"},"Life-Life.md":{"title":" Life","content":"[//]: # (keyword|operator_in)\n[//]: # (keyword|concept_grid)\n# Life\n\n\n_Author : _\n\nA model using a cellular automata to represent the Game of Life, the most famous example of cellular automata. Each cell will see if the number of living neighbours meets the condition to emerge or to live.\n\n\nCode of the model : \n\n```\nmodel life\n\n//Declare the world as a torus or not torus environment\nglobal torus: torus_environment {\n\t//Size of the environment\n\tint environment_width <- 200 min: 10 max: 1000;\n\tint environment_height <- 200 min: 10 max: 1000;\n\t\n\t//Declare as torus or not\n\tbool torus_environment <- true;\n\t//Density \n\tint density <- 25 min: 1 max: 99;\n\t//Conditions to live\n\tlist<int> living_conditions <- [2, 3];\n\t//Conditions to birth\n\tlist<int> birth_conditions <- [3];\n\t//Color for living cells\n\trgb livingcolor <- °white;\n\t//Color for dying cells\n\trgb dyingcolor <- °red;\n\t//Color for emerging cells\n\trgb emergingcolor <- °orange;\n\t//Color for dead cells\n\trgb deadcolor <- °black;\n\t//Shape of the environment\n\tgeometry shape <- rectangle(environment_width, environment_height);\n\t\n\t//Initialization of the model by writing the description of the model in the console\n\tinit {\n\t\tdo description;\n\t}\n\t\n\t//Ask at each life_cell to evolve and update\n\treflex generation {\n\t\task life_cell {\n\t\t\tdo evolve;\n\t\t}\n\n\t\task life_cell {\n\t\t\tdo update;\n\t\t}\n\n\t}\n\t//Write the description of the model in the console\n\taction description {\n\t\twrite\n\t\t'Description. The Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is the best-known example of a cellular automaton. The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input from humans. One interacts with the Game of Life by creating an initial configuration and observing how it evolves.  The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead. Every cell interacts with its eight neighbors, which are the cells that are directly horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur: \\\\n\\\\t 1.Any live cell with fewer than two live neighbours dies, as if caused by underpopulation. \\\\n\\\\t 2.Any live cell with more than three live neighbours dies, as if by overcrowding. \\\\n\\\\t 3.Any live cell with two or three live neighbours lives on to the next generation. \\\\n\\\\t 4.Any dead cell with exactly three live neighbours becomes a live cell. The initial pattern constitutes the seed of the system. The first(generation) is created by applying the above rules simultaneously to every cell in the seed�births and deaths happen simultaneously, and the discrete moment at which this happens is sometimes called a tick (in other words, each generation is a pure function of the one before). The rules continue to be applied repeatedly to create further generations.';\n\t}\n\n}\n\n//Grid species representing a cellular automata\ngrid life_cell width: environment_width height: environment_height neighbors: 8  use_individual_shapes: false use_regular_agents: false frequency: 0\nuse_neighbors_cache: false {\n\t//Boolean to know if it is the new state of the cell\n\tbool new_state;\n\t//List of all the neighbours\n\tlist<life_cell> neighbours <- self neighbors_at 1;\n\t//Boolean  to know if it is a living or dead cell\n\tbool alive <- (rnd(100)) < density;\n\t\n\trgb color <- alive ? livingcolor : deadcolor;\n\t\n\t//Action to evolve the cell considering its neighbours\n\taction evolve {\n\t\t//Count the number of living neighbours of the cells\n\t\tint living <- neighbours count each.alive;\n\t\tif alive {\n\t\t\t//If the number of living respect the conditions, the cell is still alive\n\t\t\tnew_state <- living in living_conditions;\n\t\t\tcolor <- new_state ? livingcolor : dyingcolor;\n\t\t} else {\n\t\t\t//If the number of living meets the conditions, the cell go to born\n\t\t\tnew_state <- living in birth_conditions;\n\t\t\tcolor <- new_state ? emergingcolor : deadcolor;\n\t\t}\n\n\t}\n\t//Action to update the new state of the cell\n\taction update {\n\t\talive <- new_state;\n\t}\n\n}\n\n\nexperiment \"Game of Life\" type: gui {\n\tparameter 'Width:' var: environment_width category: 'Board';\n\tparameter 'Height:' var: environment_height category: 'Board';\n\tparameter 'Torus?:' var: torus_environment category: 'Board';\n\tparameter 'Initial density of live cells:' var: density category: 'Cells';\n\tparameter 'Numbers of live neighbours required to stay alive:' var: living_conditions category: 'Cells';\n\tparameter 'Numbers of live neighbours required to become alive:' var: birth_conditions category: 'Cells';\n\tparameter 'Color of live cells:' var: livingcolor category: 'Colors';\n\tparameter 'Color of dying cells:' var: dyingcolor category: 'Colors';\n\tparameter 'Color of emerging cells:' var: emergingcolor category: 'Colors';\n\tparameter 'Color of dead cells:' var: deadcolor category: 'Colors';\n\toutput {\n\t\tdisplay Life type: opengl{\n\t\t\tgrid life_cell;\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Life-Life.md"},"Multi-level-data-analysis-Graph-From-Bug-(Distance-Graph).md":{"title":" SpatialGraph","content":"[//]: # (keyword|operator_hsb)\n[//]: # (keyword|operator_as_distance_graph)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_mirror)\n[//]: # (keyword|concept_3d)\n# SpatialGraph\n\n\n_Author : Arnaud Grignard_\n\nFrom the reference model \"bug.gaml\" a spatial graph is created. We create a species node that mirrors the species bug and then a spatial graph is creating using as_distance_graph operator.\n\n\nCode of the model : \n\n```\n\nmodel SpatialGraph\n//Import the model Common Bug Species model\nimport '../includes/Common Bug Species.gaml'\n\n\nglobal { \n\t//Graph that will be computed at each step linking the bug agents according to their distance\n\tgraph myGraph;\n\t//Minimal distance to consider two nodes agents (ie the bug) as connected\n\tfloat distance parameter: 'Distance' min: 1.0 <- 10.0 category: 'Model';\n\t\n\t//Reflex to update the graph when cycle is greater than 0. Important because the mirroring has one step late from\n\t//the original species, and at step 0, the mirroring species aren't created\n\treflex updateGraph when:(cycle>0){\n\t\t//Kill all the edge agent to create a new graph\n\t\task edge_agent {\n\t\t\tdo die;\n\t\t}\n\t\t//Create a new graph using the distance to compute the edges\n\t\tmyGraph <- as_distance_graph(node_agent, [\"distance\"::distance, \"species\"::edge_agent]);\n\t}\n}\n//Species node_agent mirroring the bug species\nspecies node_agent mirrors: list(bug) {\n\t//Each location will be the one of the bug at the previous step\n\tpoint location <- target.location update: target.location;\n\taspect base {\n\t\tdraw sphere(1.1) color: #green; \n\t}\n}\n//Species to represent the edge of the graph\nspecies edge_agent {\n\taspect base {\n\t\tdraw shape color: #green;\n\t}\n}\n\nexperiment spatialGraph type: gui {\n\toutput {\t\n\t display graph_view type: opengl {\n\t \t    species bug aspect:base;\n\t\t\tspecies node_agent aspect: base position:{0,0,0.1};\n\t\t\tspecies edge_agent aspect: base position:{0,0,0.1};\n\t\t}\n\t}\n}\n```\n","url":"wiki/Multi-level-data-analysis-Graph-From-Bug-(Distance-Graph).md"},"Multi-level-data-analysis-Graph-From-Bug-(Mirror-Graph).md":{"title":" SpatialGraph3d","content":"[//]: # (keyword|operator_hsb)\n[//]: # (keyword|operator_degree_of)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|statement_using)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_mirror)\n[//]: # (keyword|concept_3d)\n# SpatialGraph3d\n\n\n_Author : Arnaud Grignard_\n\nFrom the reference model \"bug.gaml\" a spatial graph is created. We create a species node that mirrors the species bug and then a spatial graph is creating using as_distance_graph operator. The species node should then define its own related_to method to decide wether or not a node is related to another one.\n\n\nCode of the model : \n\n```\n\n\nmodel Graph\n\n//Import the model Common Bug Species model\nimport '../includes/Common Bug Species.gaml'\n\nglobal {\n\t//Distance to link two bugs\n\tint distance parameter: 'Distance' min: 1 <- 25 category: 'Model';\n\t//variable to start the animation of the model\n\tint startAnimation parameter: 'Start Animation ' min: 1 <- 25 category: 'Animation View';\n\t//Variable to save the time animation\n\tint timeAnim <- 0;\n\t//Reflex to update the time of animation\n\treflex updateAnimation \n\t{\n\t\tif (time > startAnimation) \n\t\t{\n\t\t\ttimeAnim <- int(time - startAnimation);\n\t\t}\n\t}\n}\n//Species node_agent mirroring the bug species, represented as graph node\nspecies node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent {\n\t//Their location is the one of the target location\n\tpoint location <- target.location update: target.location;\n\t\n\t//Action to know if an agent is related to another agent considering their distance\n\tbool related_to (node_agent other) {\n\t\tusing topology(target) {\n\t\t\treturn (target.location distance_to other.target.location) < distance;\n\t\t}\n\n\t}\n\n\taspect base {\n\t\tdraw sphere(2) color: #green;\n\t}\n\n\taspect dynamic {\n\t\tint degree <- (my_graph) degree_of (self);\n\t\tdraw sphere(1 + (degree / 5.0)) color: #blue;\n\t}\n\n}\n//Species edge to represent the edges of the graph\nspecies edge_agent parent: base_edge {\n\trgb color;\n\taspect base {\n\t\tdraw shape color: #green;\n\t}\n\t\n\taspect dynamic {\n\t\tshape <- line([{ self.source.location.x, self.source.location.y, self.source.location.z }, { self.target.location.x, self.target.location.y, self.target.location.z }]);\n\t\tfloat val <- 255.0 * (shape.perimeter / distance);\n\t\tcolor <- hsb(val, 1.0, 1.0);\n\t\tdraw shape + 0.1 color: color border: color;\n\t}\n\n}\n\nexperiment AdvancedView type: gui {\n\toutput {\n\t\tdisplay graph_plus_bug_layered type: opengl { \n\t\t  species bug aspect: base;\n\t\t  species node_agent aspect: base position: { 0, 0, 0.2 };\n\t\t  species edge_agent aspect: base position: { 0, 0, 0.2 };\n\t\t  species node_agent aspect: dynamic position: { 0, 0, 0.4 };\n\t\t  species edge_agent aspect: dynamic position: { 0, 0, 0.4 };\n\t\t}\n\t}\n}\n\n\n```\n","url":"wiki/Multi-level-data-analysis-Graph-From-Bug-(Mirror-Graph).md"},"Multi-level-data-analysis-MODAVI.md":{"title":" Modavi","content":"[//]: # (keyword|operator_list_with)\n[//]: # (keyword|operator_as_matrix)\n[//]: # (keyword|operator_hsb)\n[//]: # (keyword|operator_buffer)\n[//]: # (keyword|operator_source_of)\n[//]: # (keyword|operator_target_of)\n[//]: # (keyword|operator_generate_barabasi_albert)\n[//]: # (keyword|operator_as_distance_graph)\n[//]: # (keyword|operator_sin)\n[//]: # (keyword|statement_put)\n[//]: # (keyword|statement_user_command)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_gui)\n# Modavi\n\n\n_Author : Arnaud Grignard_\n\nFrom a reference model with node of a given class, a spatial graph is created (or a barabasi graph if spatialGraph is set to false) in the advanced view to represent the interaction in the reference model.An abstract view/controller is created to summarize the interaction in the advanced viewin a macro graph and control the reference model by defining an action (user_command) for each macroNode and macroEdge.\n\n\nCode of the model : \n\n```\n\nmodel modavi\n \nglobal {\n\t//Graph of the agents\n\tgraph<node_agent,edge_agent> my_graph ;\n\t\n\t//Number of agents to create\n\tint nbAgent parameter: 'Number of Agents' min: 1 <- 500 category: 'Model';\n\t//Number of value per class\n\tint nbValuePerClass parameter: 'Number of value per class' min: 1 max:100 <- 15 category: 'Model';\n\t//Boolean to know if we display a spatial graph or not\n\tbool spatialGraph parameter: 'Spatial Graph' <- true category: 'Model';\n\t//Distance to link two node agents\n\tfloat distance parameter: 'Distance' min: 1.0<- 10.0 category: 'Model';\n\t//Threshold\n\tint threshold parameter: 'Threshold' min: 0 <- 0 category: 'Model';\n\n\t//Size of a node agent\n\tint nodeSize parameter: 'Node size' min: 1 <- 1 category: 'Aspect';\n\t//Size of a macro node agent\n\tint macroNodeSize parameter: 'Macro Node size' min: 1 <- 2 category: 'Aspect';\n\t\n\t//Number of type of class\n\tint nbTypeOfClass <-1;\n\t\n\t//Zoom factor\n\tint zoomFactor <- nbTypeOfClass;\n\n\t//List of the different interaction matrices\n\tlist<matrix<int>> interactionMatrix <-list_with(nbTypeOfClass,matrix([0]));\n\t//Number maximum of edges\n    int nbEdgeMax;\n    \n    //Reflex to update the interaction matrix list\n    reflex updateInteractionMatrix{\n    \t//Ask for each edge agent to update it sources and destination to create the matrix\n    \task edge_agent{\n\t\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tsrc <- my_graph source_of(self);\n\t\t\t\tdest <- my_graph target_of(self);\n\t\t\t\tint tmp <- (interactionMatrix[i]  at {(src.classVector[i]-1),(dest.classVector[i]-1)});\n\t\t\t\tinteractionMatrix[i][src.classVector[i]-1,dest.classVector[i]-1] <- (tmp+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//Reflex to compute te maximum number of edges\n\treflex computeNbEdgeMax{\n\t\t//Number maximum of edges\n\t\tnbEdgeMax <-1;\n\t\t//Ask for each macro edge its aggregated link list number\n\t\task macroEdge{\n\t\t\tif(nbAggregatedLinkList[0] > nbEdgeMax){\n\t\t\t\tnbEdgeMax <-nbAggregatedLinkList[0];\n\t\t\t}\t\n\t\t}\n\t}\n\n\t//Initialization of the model\n\tinit {\n\t\t//Initialization of the matrix\n\t\tdo InitInteractionMatrix;\n\t\t//If we want a spatial graph in that case we create a graph according to their distance, else we create a barabasi albert graph\n\t\tif(spatialGraph){\n\t\t\tcreate node_agent number:nbAgent;\n\t\t\tmy_graph <- graph<node_agent, edge_agent>(as_distance_graph(node_agent, ([\"distance\"::distance, \"species\"::edge_agent])));\n\t\t\t\n\t\t}\n        else{\n          my_graph <- graph<node_agent, edge_agent>(generate_barabasi_albert(node_agent,edge_agent,nbAgent,2,true));\t\n        }\n        \n\t\t//For each node agent, we compute its class value\n\t\task node_agent as list{\n\t\t\tloop i from:0 to:nbTypeOfClass-1{\n\t\t\t\tclassVector[i] <- rnd(nbValuePerClass-1)+1;\n \t\t\t}\t\t\n\t\t}\n\n\t\tint i<-1;\n\t\t//Creation of the macronode according to the number of value per class\n\t\tcreate macroNode number: nbValuePerClass{\t \n\t\t\tclass <-i;\n\t\t\tlocation <- {(cos (((class-1)/nbValuePerClass)*360)*50 +50),(sin (((class-1)/nbValuePerClass)*360)*50+50),0};\n\t\t\tcolor <- hsb (i/nbValuePerClass,1.0,1.0);\n\t\t\tdo updatemyNodes;\n\t\t\ti<-i+1;\t\n\t\t}\n\t\t//We finally create the macroGraph\n\t\tcreate macroGraph;\n\t }\n\t //Action to initialize the interaction Matrix according to the number of type of classes\n\t action InitInteractionMatrix{\n\t\t loop i from:0 to:nbTypeOfClass-1{\n\t\t\t\tinteractionMatrix[i] <- 0 as_matrix({nbValuePerClass,nbValuePerClass});\n \t\t  }\t\n\t}\n}\n\n\n\t//Species to represent the node_agent\n\tspecies node_agent  {\n\t\t//Color of the node agent\n\t\trgb color;\n\t\t//List of the class\n\t\tlist<int> classVector <- list_with (nbTypeOfClass,0);\n\t\t//List of the position\n\t\tlist<point> posVector <- list_with (nbTypeOfClass,{0,0});\n\t\t//List of the color\n\t\tlist<rgb> colorList <- list_with (nbTypeOfClass, rgb(0,0,0));\n\t\t\t\t\t\t\t\t\n\t\t//Shuffle the classes of the node_agent\n\t\treflex shuffleClass{\n\t\t\tloop i from:0 to: nbTypeOfClass-1{\n\t\t\t\tclassVector[i] <- rnd(nbValuePerClass-1)+1;\n\t\t\t}\t\n\t\t}\n \t\t\n\t\taspect real {\t\t\t \n\t\t\tdraw sphere(nodeSize) color: colorList[0];\n\t\t} \n\t\t\t\t\t\t\t\t\n\t\taspect coloredByClass{\n\t\t\tloop i from:0 to: nbTypeOfClass-1{\n\t\t\t    colorList[i]<- hsb (classVector[i]/nbValuePerClass,1.0,1.0);\t\t\t\t\t\n\t\t\t    posVector[i] <- {(location.x+i*110)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};  \n\t\t\t    draw sphere(nodeSize/zoomFactor) color: colorList[i] at: posVector[i] ;   \n\t\t\t}\n\t\t}\n\t\n\t}\n\t\n\t//Species edge_agent to represent the edge of the graph\n\tspecies edge_agent { \n\t\trgb color;\n\t\t//Source of the edge\n\t\tnode_agent src;\n\t\t//Target of the edge\n\t\tnode_agent dest;\n\t\t\t \n\t\taspect base {\n\t\t\tdraw shape color: rgb(125,125,125);\n\t\t}\t\n\t\t\n\t\taspect edgeGenericSpatialized{\n\t\t\tloop i from:0 to: nbTypeOfClass-1{\n\t\t\t  if ((src != nil) and (dest !=nil) ){\n\t\t\t\tdraw line( [ (src.posVector[i]) , (dest.posVector[i])] ) color:rgb(125,125,125);\n\t\t\t  }\n\t\t\t}\n\t\t}\n\t}\n\t//Species representing the macro node agents\n\tspecies macroNode{\n\t\trgb color;\n\t\tint class;\n\t\t//List of all the aggregated nodes\n\t\tlist<int> nbAggregatedNodes <- list_with(nbTypeOfClass,0);\n\t\t//List of all the position\n\t\tlist<point> posVector <-list_with(nbTypeOfClass,{0,0});\n\t\t \n\t\t//Update the nodes of the agents\n\t\treflex update{\n\t\t\tdo updatemyNodes;\n\t\t}\n\t\t//For each classes, find all the nodes with the same classes\n\t\taction updatemyNodes{\n\t\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t\n\t\t\t\tnbAggregatedNodes[i]<-0;\n\t\t\t\task node_agent as list{\n\t\t\t\t  if\t(classVector[i] = myself.class) {\n\t\t\t\t\tmyself.nbAggregatedNodes[i] <- myself.nbAggregatedNodes[i]+1;\n\t\t\t\t  }\t \n\t\t\t    }\n\t\t    }\t    \n\t\t} \n\t\t\n\t\taspect sphere{\n\t\t\tdraw sphere((nbAggregatedNodes[0]/10)*macroNodeSize) color: color at: point([location.x,location.y]) ;\n\t\t}\n\t\t\n\t\taspect Generic{\n\t\t\tloop i from:0 to: nbTypeOfClass-1\n\t\t\t{\n\t\t\tposVector[i] <- {(location.x+i*150)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};\t\n\t\t\tdraw sphere((nbAggregatedNodes[i]/10)*macroNodeSize*(1/zoomFactor)) color: color at: posVector[i] ;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//This action only works when having nbTypeOfClass=1\n\t\taction removeMicroNode{\n\t\t\task node_agent as list{\n\t\t\t\t  if\t(classVector[0] = myself.class) {\n\t\t\t\t      do die;\n\t\t\t\t  }\t \n\t         }\n\t\t}\n\t\t\n\t\tuser_command \"Remove all micro node\" action: removeMicroNode;\n\t}\n\t\n\t//Species macroEdge representing the macro edges agents\n\tspecies macroEdge  { \n\t\trgb color <- #black;\n\t\t//Source of the macroedge\n\t\tmacroNode src;\n\t\t//Destination of the macroedge\n\t\tmacroNode dest;\n\t\t//List of all the aggregated links\n\t\tlist<int> nbAggregatedLinkList <- list_with(nbTypeOfClass,0);\n\t\t\n\t\taspect base {\n\t\t\tloop i from:0 to: nbTypeOfClass-1{\n\t\t\t\tif(nbAggregatedLinkList[i]>threshold){\n\t\t\t\tdraw (line([src.posVector[i],dest.posVector[i]]) buffer ((nbAggregatedLinkList[i])/((length(edge_agent)))*nbEdgeMax)) color: rgb(125,125,125) border:rgb(125,125,125); \t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Action to remove a micro edge\n\t\taction removeMicroEdge{\n\t\t\task edge_agent as list{\n\t\t\t\t  if\t((self.src.classVector[0] =  myself.src.class) and (self.dest.classVector[0] =  myself.dest.class)) {\n\t\t\t\t      do die;\n\t\t\t\t  }\t \n\t         }\n\t\t}\n\t\t\n\t\tuser_command \"Remove all micro edge\" action: removeMicroEdge;\t\n\t}\n\t\n\t//Species macroGraph representing the macro graph composed of macroNode and macroEdge\n\tspecies macroGraph {\n\t\t\n\n  \t//Reflex to update the graph by killing all the previous edges first \n   reflex updateAllMacroEdge {\t\n\t \task macroEdge as list{\n\t \t\tdo die;\n\t \t}\n\t \t\n\t \tloop h from:0 to: nbTypeOfClass-1{\n\t\t \tloop i from: 0 to: nbValuePerClass-1{\n\t\t      loop j from: 0 to: nbValuePerClass-1{\n\t\t        int tmp <- interactionMatrix[h] at {i,j}; \n\n\t\t        if(i!=j){\n\t\t            create macroEdge{\n\t\t              nbAggregatedLinkList[h] <- tmp;\n\t\t              src <- macroNode[i];\n\t\t\t\t      dest <- macroNode[j];\n\t\t            }\t  \n\t\t        }      \n\t\t      }\n\t\t    }\n\t    }\n  \t}\n  \t//Reflex to initialize the matrix\n  \treflex initMatrix{\n  \t\tloop i from:0 to:nbTypeOfClass-1{\n  \t\t  interactionMatrix[i] <- 0 as_matrix({nbValuePerClass,nbValuePerClass});\t\n  \t\t}\t\n\t  }\t\n\t}\n\n\n\nexperiment MODAVI type: gui {\n\toutput {\t\t\t\n\t\tdisplay MODAVI type:opengl draw_env:false {\n\t\t\tgraphics 'ReferenceModel'{\n\t\t\t\tdraw \"Reference model\" at:{200,50,0} size:5 color: #black perspective:false;\n\t\t\t}\n\t\t\tspecies node_agent aspect: real position:{100,0,0.01} ;\n\t\t\t\n\t\t\tgraphics 'View1'{\n\t\t\t\tdraw \"Advanced view\" at:{50,210,0} size:5 color: #black perspective:false;\n\t\t\t}\n\t\t\tspecies node_agent aspect: coloredByClass position: {0,100,0.02};\n\t\t\tspecies edge_agent aspect: edgeGenericSpatialized position: {0,100,0.02};\n\t\t\t\n\t\t\tgraphics 'AbstractView'{\n\t\t\t\tdraw \"Abstract view/controller\" at:{250,210,0} size:5 color: #black perspective:false;\n\t\t\t}\n\t\t\tspecies macroNode aspect:Generic position: {200,100,0.01};\n\t\t\tspecies macroEdge aspect:base position: {200,100,0.01};\t\n\t\t}\n\t}\t\t\n}\n\n\n\n```\n","url":"wiki/Multi-level-data-analysis-MODAVI.md"},"Predator-Prey-Lotka-Volterra-(Influence-of-Integration-Step).md":{"title":" ODE_LotkaVolterra","content":"[//]: # (keyword|operator_diff)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n# ODE_LotkaVolterra\n\n\n_Author : Huynh Quang Nghi & Nathalie Corson_\n\nCode of the model : \n\n```\n\nmodel ODE_LotkaVolterra_InfluenceTimeStep\n\nglobal {\n\n\tfloat prey_birth_rate ; \t\t// natural birth rate of preys\n\tfloat predation_rate ; \t\t\t// death rate of preys due to predators\n\tfloat predator_death_rate ; \t// natural death rate of predators\n\tfloat predation_efficiency ; \t// birth rate of predators due to prey consumption\n\t\n\tfloat nb_prey_init ; \t\t\t// initial number of preys\n\tfloat nb_predator_init  ; \t\t// initial number of predators\n\t\n\tfloat integration_step ; \t// integration time step of the Runge Kutta 4 method\n\tfloat t;   \t\t\t\t\t// simulation time : t = n * integration_time_step  where n is the number of already computed time step\n\t\n\t\n\tfloat integration_time_step1  <- 1.0;  // first integration time step to compare \n\tfloat integration_time_step2  <- 0.1;  // second integration time step to compare \n\tfloat integration_time_step3  <- 0.01;  // third integration time step to compare \n\t\n\tlist<LotkaVolterra_agent> LV_agents;\n\t\n\tinit{\n\t\tcreate LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step1]; \t// creation of an agent containing the ODE model with an integration time step of value integration_time_step1\n\t\tcreate LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step2]; \t// creation of an agent containing the ODE model with an integration time step of value integration_time_step2\n\t\tcreate LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step3]; \t// creation of an agent containing the ODE model with an integration time step of value integration_time_step3\n\t\tLV_agents <- list(LotkaVolterra_agent);\n\t}\n}\n\nspecies LotkaVolterra_agent {\n\t\n    float nb_prey <- nb_prey_init ; \t\t\t\t// number of preys initialized with the values given by the user\n\tfloat nb_predator <- nb_predator_init ; \t\t// number of predators initialized with the values given by the user\n\t\n\tfloat integration_time_step ; \t\t\t\t\t// integration time step used in the Runge Kutta 4 method\n  \n\tequation lotka_volterra { \n\t\tdiff(nb_prey,t) =   nb_prey * (prey_birth_rate - predation_rate * nb_predator); \t\t\t\t\t// evolution of the number of preys duting an integration time step\n\t\tdiff(nb_predator,t) = - nb_predator * (predator_death_rate - predation_efficiency * nb_prey); \t\t// evolution of the number of predator during an integration time step\n      }\n      reflex solving {        \n       \tsolve lotka_volterra method: \"rk4\" step:integration_time_step;// cycle_length:1/integration_time_step; \t\t\t// use of runge kutta 4 method with an integration time step of value integration_time_step\n       }\n}\n\n\nexperiment maths type: gui {\n\t\t\n\tparameter \"Prey birth rate\" var: prey_birth_rate <- 0.05 min: 0.0 max: 1.0 category: \"Prey\";\t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.05 and this value must be between 0 and 1\n\tparameter \"Predation rate\" var: predation_rate <- 0.001 min: 0.0 max: 1.0 category: \"Prey\"; \t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.001 and this value must be between 0 and 1\n\tparameter \"Predator death rate\" var: predator_death_rate <- 0.03 min: 0.0 max: 1.0 category: \"Predator\";\t \t\t// the user defines the value of parameter predator_death_rate on the interface, the default value is 0.03 and this value must be between 0 and 1\n\tparameter \"Predation efficiency\" var: predation_efficiency <- 0.0002 min: 0.0 max: 1.0 category: \"Predator\";\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 0.0002 and this value must be between 0 and 1\n\t\n\tparameter \"Initial number of prey\" var: nb_prey_init <- 250.0 min: 1.0 category: \"Prey\"; \t\t\t\t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 250, the minimum possible value is 1\n\tparameter \"Initial number of predator\" var: nb_predator_init <- 45.0 min: 1.0 category: \"Predator\"; \t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 45, the minimum possible value is 1\n\t\n\tparameter \"Integration time step of the first chart \" var:  integration_time_step1 <- 1.0  min: 0.0 max:1.0 category: \"Integration time steps\"; \t// the user defines the value of the first integration step he wants to compare, the default value is 1 and this value must be between 0 and 1\n\tparameter \"Integration time step of the second chart \" var:  integration_time_step2 <- 0.1  min: 0.0 max: 1.0 category: \"Integration time steps\"; \t// the user defines the value of the second integration step he wants to compare, the default value is 0.1 and this value must be between 0 and 1\n\tparameter \"Integration time step of the third chart \" var:  integration_time_step3 <- 0.01  min: 0.0 max: 1.0 category: \"Integration time steps\"; \t// the user defines the value of the third integration step he wants to compare, the default value is 0.01 and this value must be between 0 and 1\n\t\t\n\toutput {\t\t\n \t\tdisplay TimeSeries  {\t// creation of a display to show time series of the model, values are plotted at every step. Since there is more than one chart plotted in one display, every chart has a position and a size\n\t\t\tchart \"Lotka Volterra Time Series - Integration time step = 1 \" type: series background: #white position: {0,0} size:{1,0.33} x_range: 1000 { \t\t// one chart, of type 'serie', is named Lotka Volterra Time Series - Integration time step = 1, it shows quantities according to time, and the background is white\n\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent where (each.integration_time_step = 1.0)).nb_prey color: #green ;\t\t\t// number of preys in the case where the integration time step is 1 is plotted in green\t\t\n\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent where (each.integration_time_step = 1.0)).nb_predator color: #red ; \t// number of predators in the case where the integration time step is 1 is plotted in red\t\n\t\t\t}\n\t\t\tchart \"Lotka Volterra Time Series - Integration time step = 0.1 \" type: series background: #white position: {0,0.33} size:{1,0.33} x_range: 1000{\n\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.1)).nb_prey color: #green ;\t\t\t\t\n\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.1)).nb_predator color: #red ;\n\t\t\t}\n\t\t\tchart \"Lotka Volterra Time Series - Integration time step = 0.01 \" type: series background: #white position: {0,0.66} size:{1,0.33}x_range: 1000{\n\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.01)).nb_prey color: #green ;\t\t\t\t\n\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.01)).nb_predator color: #red ;\n\t\t\t}\n\t\t}\n\t\tdisplay PhasePortrait {\t\t\t\n\t\t\tchart \"Lotka Volterra Phase Portrait - Integration time step = 1\" type: xy background: #white position: {0,0} size:{1,0.33} {\t\t// creation of a display to show phase portrait of the model, values are plotted at every step. Since there is more than one chart plotted in one display, every chart has a position and a size\n\t\t\tdata 'Number of preys according to number of predators' value:{LV_agents[0].nb_prey, LV_agents[0].nb_predator} color: #black ;\t// number of predators are plotted in black according to the number of preys in the case where the integration time step is 1\t\t\n\t\t\t}\n\t\t\tchart \"Lotka Volterra Phase Portrait - Integration time step = 0.1\" type: xy background: #white position: {0,0.33} size:{1,0.33}{\n\t\t\tdata 'Number of preys according to number of predators' value:{LV_agents[1].nb_prey, LV_agents[1].nb_predator} color: #black ;\t\t\t\t\n\t\t\t}\n\t\t\tchart \"Lotka Volterra Phase Portrait - Integration time step = 0.01\" type: xy background: #white position: {0,0.66} size:{1,0.33} {\n\t\t\tdata 'Number of preys according to number of predators' value:{LV_agents[1].nb_prey, LV_agents[1].nb_predator} color: #black ;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Lotka-Volterra-(Influence-of-Integration-Step).md"},"Predator-Prey-Lotka-Volterra-(Simple).md":{"title":" ODE_LotkaVolterra","content":"[//]: # (keyword|operator_diff)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|concept_equation)\n[//]: # (keyword|concept_math)\n# ODE_LotkaVolterra\n\n\n_Author : Huynh Quang Nghi & Nathalie Corson_\n\nCode of the model : \n\n```\n\nmodel ODE_LotkaVolterra\n\nglobal {\n\n\tfloat prey_birth_rate<- 0.05 ; \t\t// natural birth rate of preys\n\tfloat predation_rate <- 0.001; \t\t\t// death rate of preys due to predators\n\tfloat predator_death_rate<- 0.03 ; \t// natural death rate of predators\n\tfloat predation_efficiency<- 0.0002 ; \t// birth rate of predators due to prey consumption\n\n\tfloat nb_prey_init <- 250.0; \t\t\t// initial number of preys\n\tfloat nb_predator_init <- 45.0 ; \t\t// initial number of predators\n\n\tfloat integration_time_step <- 0.01; \t// integration time step used in the Runge Kutta 4 method\n\tfloat t; \t\t\t\t\t\t// simulation time : t = n * integration_time_step  where n is the number of already computed time step\n\n\tinit{\n\t\tcreate LotkaVolterra_agent number:1 ; \t// creation of an agent containing the ODE model\n\t}\n}\n\nspecies LotkaVolterra_agent {\n\n\tfloat nb_prey <- nb_prey_init ; \t\t\t// number of preys initialized with the values given by the user\n\tfloat nb_predator <- nb_predator_init ; \t\t// number of predators initialized with the values given by the user\n\n\tequation lotka_volterra {\n\t\tdiff(nb_prey,t) =   nb_prey * (prey_birth_rate - predation_rate * nb_predator); \t\t\t\t\t// evolution of the number of preys duting an integration time step\n\t\tdiff(nb_predator,t) = - nb_predator * (predator_death_rate - predation_efficiency * nb_prey); \t\t// evolution of the number of predator during an integration time step\n      }\n      reflex solving {\n       \tsolve lotka_volterra method: \"rk4\" step:integration_time_step ;//cycle_length:1/step; \t\t\t// use of runge kutta 4 method with an integration time step of value integration_time_step\n       }\n}\n\n\nexperiment maths type: gui {\n\n\tparameter \"Prey birth rate\" var: prey_birth_rate <- 0.05 min: 0.0 max: 1.0 category: \"Prey\";\t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.05 and this value must be between 0 and 1\n\tparameter \"Predation rate\" var: predation_rate <- 0.001 min: 0.0 max: 1.0 category: \"Prey\"; \t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.001 and this value must be between 0 and 1\n\tparameter \"Predator death rate\" var: predator_death_rate <- 0.03 min: 0.0 max: 1.0 category: \"Predator\";\t \t\t// the user defines the value of parameter predator_death_rate on the interface, the default value is 0.03 and this value must be between 0 and 1\n\tparameter \"Predation efficiency\" var: predation_efficiency <- 0.0002 min: 0.0 max: 1.0 category: \"Predator\";\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 0.0002 and this value must be between 0 and 1\n\n\tparameter \"Initial number of prey\" var: nb_prey_init <- 250.0 min: 1.0 category: \"Prey\"; \t\t\t\t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 250, the minimum possible value is 1\n\tparameter \"Initial number of predator\" var: nb_predator_init <- 45.0 min: 1.0 category: \"Predator\"; \t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 45, the minimum possible value is 1\n\n\tparameter \"Integration time step\" var: integration_time_step <- 0.01 min: 0.0 max:0.1 category: \"Integration method\";  // the user defines the value of the integration step, the default value is 0.01 and this value must be between 0 and 1\n\n\toutput {\n \t\tdisplay TimeSeries  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// creation of a display to show time series of the model, values are plotted at every step\n\t\t\tchart \"Lotka Volterra Time Series\" type: series background: #white {  \t\t\t\t\t\t// the chart, of type 'serie', is named Lotka Volterra Time Series, it shows quantities according to time, and the background is white\n\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent).nb_prey color: #green ;\t\t\t// number of preys is plotted in green\n\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent).nb_predator color: #red ; \t// number of predators is plotted in red\n\t\t\t}\n\t\t}\n\t\tdisplay PhasePortrait  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// creation of a display to show the phase portait, values are plotted at every time step\n\t\t\tchart \"Lotka Volterra Phase Portrait\" type: xy background: #white {\t\t\t\t\t\t\t// the chart, os type 'xy', is named Lotka Volterra Phase portrait, it shows a quantity according to another one, and the background is white\n\t\t\tdata ' ' value: {predator_death_rate / predation_efficiency, prey_birth_rate/predation_rate} color: °blue; // equilibrium point\n\t\t\tdata 'Number of preys according to number of predators' value:{first(LotkaVolterra_agent).nb_prey, first(LotkaVolterra_agent).nb_predator} color: #black ;\t// number of predators according to the number of preys plotted in black\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Lotka-Volterra-(Simple).md"},"Segregation-(Schelling)-Segregation-(Agents).md":{"title":" segregationAgents","content":"[//]: # (keyword|operator_sum)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|concept_grid)\n# segregationAgents\n\n\n_Author : _\n\nA model showing the segregation of the people just by putting a similarity wanted parameter using agents to represent the individuals\n\n\nImported model : \n\n```\nmodel segregation_base\n\nglobal {\n\t//Different colors for the group\n\trgb color_1 <- rgb (\"yellow\") parameter: \"Color of group 1:\" category: \"User interface\";\n\trgb color_2 <- rgb (\"red\") parameter: \"Color of group 2:\" category: \"User interface\";\n\trgb color_3 <- rgb (\"blue\") parameter: \"Color of group 3:\" category: \"User interface\";\n\trgb color_4 <- rgb (\"orange\") parameter: \"Color of group 4:\" category: \"User interface\";\n\trgb color_5 <- rgb (\"green\") parameter: \"Color of group 5:\" category: \"User interface\";\n\trgb color_6 <- rgb (\"pink\") parameter: \"Color of group 6:\" category: \"User interface\";   \n\trgb color_7 <- rgb (\"magenta\") parameter: \"Color of group 7:\" category: \"User interface\";\n\trgb color_8 <- rgb (\"cyan\") parameter: \"Color of group 8:\" category: \"User interface\";\n    list colors <- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;\n\n\t\n\t//Number of groups\n\tint number_of_groups <- 2 max: 8 parameter: \"Number of groups:\" category: \"Population\";\n\t//Density of the people\n\tfloat density_of_people <- 0.7 parameter: \"Density of people:\" category: \"Population\" min: 0.01 max: 0.99;\n\t//Percentage of similar wanted for segregation\n\tfloat percent_similar_wanted <- 0.5 min: float (0) max: float (1) parameter: \"Desired percentage of similarity:\" category: \"Population\";\n\t//Dimension of the grid\n\tint dimensions <- 40 max: 400 min: 10 parameter: \"Width and height of the environment:\" category: \"Environment\";\n\t//Neighbours distance for the perception of the agents\n\tint neighbours_distance <- 2 max: 10 min: 1 parameter: \"Distance of perception:\" category: \"Population\";\n\t//Number of people agents\n\tint number_of_people <- 0;\n\t//Number of happy people\n\tint sum_happy_people <- 0 update: all_people count (each.is_happy);\n\t//Number of similar neighbours\n\tint sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby);\n\t//Number of neighbours\n\tint sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1;\n\t//List of all the places\n\tlist<agent> all_places;\n\t//List of all the people\n\tlist<base> all_people;  \n\t\n\t//Action to write the description of the model in the console\n\taction description {\n\t\twrite\n\t\t\"\\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. \";\n\t}\n\t//Initialization of the model\n\tinit {\n\t\t//Write the description of the model \n\t\tdo description;\n\t\t//Initialization of the places\n\t\tdo initialize_places;\n\t\t//Computation of the number of people according to the density of people\n\t\tnumber_of_people <- int( length (all_places) * density_of_people);\n\t\t//Initialization of the people\n\t\tdo initialize_people;\n\t}\n\t//Action to initialize places defined in the subclasses\n\taction initialize_places virtual: true;\n\t//Action to initialize people in the subclasses\n\taction initialize_people virtual: true;\n}\n\n//Species base representing the people agents\nspecies base {\n\trgb color;\n\t//List of all the neighbours agents\n\tlist<base> my_neighbours;\n\t//computation of the similar neighbours\n\tint similar_nearby -> {\n\t\t(my_neighbours count (each.color = color))\n\t};\n\t//Computation of the total neighbours nearby\n\tint total_nearby -> {\n\t\tlength (my_neighbours)\n\t};\n\t//Boolean to know if the agent is happy or not\n\tbool is_happy -> {similar_nearby >= (percent_similar_wanted * total_nearby )} ;\n}\n\n```\n\n\nCode of the model : \n\n```\n\nmodel segregation\n\n//import the Common Schelling Segregation model\nimport \"../include/Common Schelling Segregation.gaml\"\n\nglobal {\n\t//List of all the free places\n\tlist<space> free_places ;\n\t//List of all the places\n\tlist<space> all_places ;\n\t//Shape of the world\n\tgeometry shape <- square(dimensions);\n\t\n\t//Action to initialize the people agents\n\taction initialize_people { \n\t\tcreate people number: number_of_people; \n\t\tall_people <- people as list ;  \n\t} \n\t//Action to initialize the places\n\taction initialize_places { \n\t\tall_places <- shuffle (space);\n\t\tfree_places <- all_places;  \n\t} \n}\n//Grid to discretize space, each cell representing a free space for the people agents\ngrid space width: dimensions height: dimensions neighbors: 8 use_regular_agents: false frequency: 0{\n\trgb color  <- #black;\n}\n\n//Species representing the people agents\nspecies people parent: base  {\n\t//Color of the people agent\n\trgb color <- colors at (rnd (number_of_groups - 1));\n\t//List of all the neighbours of the agent\n\tlist<people> my_neighbours -> {people at_distance neighbours_distance} ;\n\t//Cell representing the place of the agent\n\tspace my_place;\n\tinit {\n\t\t//The agent will be located on one of the free places\n\t\tmy_place <- one_of(free_places);\n\t\tlocation <- my_place.location; \n\t\t//As one agent is in the place, the place is removed from the free places\n\t\tfree_places >> my_place;\n\t} \n\t//Reflex to migrate the people agent when it is not happy \n\treflex migrate when: !is_happy {\n\t\t//Add the place to the free places as it will move to another place\n\t\tfree_places << my_place;\n\t\t//Change the place of the agent\n\t\tmy_place <- one_of(free_places);\n\t\tlocation <- my_place.location; \n\t\t//Remove the new place from the free places\n\t\tfree_places >> my_place;\n\t}\n\t\n\taspect default{ \n\t\tdraw circle (0.5) color: color; \n\t}\n}\n\n\n\nexperiment schelling type: gui {\t\n\toutput {\n\t\tdisplay Segregation {\n\t\t\tspecies people;\n\t\t}\t\n\t\tdisplay Charts {\n\t\t\tchart \"Proportion of happiness\" type: pie background: #gray style: exploded position: {0,0} size: {1.0,0.5}{\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow;\n\t\t\t}\n\t\t\tchart \"Global happiness and similarity\" type: series background: #gray axes: #white position: {0,0.5} size: {1.0,0.5} {\n\t\t\t\tdata \"happy\" color: #blue value:  (sum_happy_people / number_of_people) * 100 style: spline ;\n\t\t\t\tdata \"similarity\" color: #red value:  (sum_similar_neighbours / sum_total_neighbours) * 100 style: step ;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Segregation-(Schelling)-Segregation-(Agents).md"},"Segregation-(Schelling)-Segregation-(Cellular-Automata).md":{"title":" segregationGrid","content":"[//]: # (keyword|operator_sum)\n[//]: # (keyword|operator_any)\n[//]: # (keyword|operator_copy)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|concept_grid)\n# segregationGrid\n\n\n_Author : _\n\nImported model : \n\n```\nmodel segregation_base\n\nglobal {\n\t//Different colors for the group\n\trgb color_1 <- rgb (\"yellow\") parameter: \"Color of group 1:\" category: \"User interface\";\n\trgb color_2 <- rgb (\"red\") parameter: \"Color of group 2:\" category: \"User interface\";\n\trgb color_3 <- rgb (\"blue\") parameter: \"Color of group 3:\" category: \"User interface\";\n\trgb color_4 <- rgb (\"orange\") parameter: \"Color of group 4:\" category: \"User interface\";\n\trgb color_5 <- rgb (\"green\") parameter: \"Color of group 5:\" category: \"User interface\";\n\trgb color_6 <- rgb (\"pink\") parameter: \"Color of group 6:\" category: \"User interface\";   \n\trgb color_7 <- rgb (\"magenta\") parameter: \"Color of group 7:\" category: \"User interface\";\n\trgb color_8 <- rgb (\"cyan\") parameter: \"Color of group 8:\" category: \"User interface\";\n    list colors <- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;\n\n\t\n\t//Number of groups\n\tint number_of_groups <- 2 max: 8 parameter: \"Number of groups:\" category: \"Population\";\n\t//Density of the people\n\tfloat density_of_people <- 0.7 parameter: \"Density of people:\" category: \"Population\" min: 0.01 max: 0.99;\n\t//Percentage of similar wanted for segregation\n\tfloat percent_similar_wanted <- 0.5 min: float (0) max: float (1) parameter: \"Desired percentage of similarity:\" category: \"Population\";\n\t//Dimension of the grid\n\tint dimensions <- 40 max: 400 min: 10 parameter: \"Width and height of the environment:\" category: \"Environment\";\n\t//Neighbours distance for the perception of the agents\n\tint neighbours_distance <- 2 max: 10 min: 1 parameter: \"Distance of perception:\" category: \"Population\";\n\t//Number of people agents\n\tint number_of_people <- 0;\n\t//Number of happy people\n\tint sum_happy_people <- 0 update: all_people count (each.is_happy);\n\t//Number of similar neighbours\n\tint sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby);\n\t//Number of neighbours\n\tint sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1;\n\t//List of all the places\n\tlist<agent> all_places;\n\t//List of all the people\n\tlist<base> all_people;  \n\t\n\t//Action to write the description of the model in the console\n\taction description {\n\t\twrite\n\t\t\"\\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. \";\n\t}\n\t//Initialization of the model\n\tinit {\n\t\t//Write the description of the model \n\t\tdo description;\n\t\t//Initialization of the places\n\t\tdo initialize_places;\n\t\t//Computation of the number of people according to the density of people\n\t\tnumber_of_people <- int( length (all_places) * density_of_people);\n\t\t//Initialization of the people\n\t\tdo initialize_people;\n\t}\n\t//Action to initialize places defined in the subclasses\n\taction initialize_places virtual: true;\n\t//Action to initialize people in the subclasses\n\taction initialize_people virtual: true;\n}\n\n//Species base representing the people agents\nspecies base {\n\trgb color;\n\t//List of all the neighbours agents\n\tlist<base> my_neighbours;\n\t//computation of the similar neighbours\n\tint similar_nearby -> {\n\t\t(my_neighbours count (each.color = color))\n\t};\n\t//Computation of the total neighbours nearby\n\tint total_nearby -> {\n\t\tlength (my_neighbours)\n\t};\n\t//Boolean to know if the agent is happy or not\n\tbool is_happy -> {similar_nearby >= (percent_similar_wanted * total_nearby )} ;\n}\n\n```\n\n\nCode of the model : \n\n```\nmodel segregation\n\n//Importation of the Common Schelling Segregation model\nimport \"../include/Common Schelling Segregation.gaml\"\n\n//Define the environment as torus\nglobal torus: true{\n\t//List of all the free places\n\tlist<space> free_places ;\n\t//List of all the places\n\tlist<space> all_places  ;\n\t//List of all the people\n\tlist<space> all_people;\n\t//Shape of the environment\n\tgeometry shape <- square(dimensions);\n\t\n\t//Action to initialize the places\n\taction initialize_places {\n\t\tall_places <- shuffle(space);\n\t\tfree_places <- shuffle(all_places);\n\t}\n\t//Action to initialize the people agents\n\taction initialize_people {\n\t\t//Place all the people agent in the cellular automata\n\t\tloop i from: 0 to: number_of_people - 1 {\n\t\t\tspace pp <- all_places at i;\n\t\t\tremove pp from: free_places;\n\t\t\tadd pp to: all_people;\n\t\t\tpp.color <- colors at (rnd(number_of_groups - 1));\n\t\t}\n\n\t}\n\t//Reflex to migrate all the people agents\n\treflex migrate {\n\t\task copy(all_people) {\n\t\t\tdo migrate;\n\t\t}\n\n\t}\n\n}\n\n//Grid species representing the places and the people in each cell\ngrid space parent: base width: dimensions height: dimensions neighbors: 8  {\n\trgb color <- #black;\n\t//List of the neighbours of the places\n\tlist<space> my_neighbours <- self neighbors_at neighbours_distance;\n\t//Action to migrate the agent in another cell if it is not happy\n\taction migrate {\n\t\tif !is_happy {\n\t\t\t//Change the space of the agent to a free space\n\t\t\tspace pp <- any(my_neighbours where (each.color = #black));\n\t\t\tif (pp != nil) {\n\t\t\t\tfree_places <+ self;\n\t\t\t\tfree_places >- pp;\n\t\t\t\tall_people >- self;\n\t\t\t\tall_people << pp;\n\t\t\t\tpp.color <- color;\n\t\t\t\tcolor <- #black;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nexperiment schelling type: gui {\n\toutput {\n\t\tdisplay Segregation {\n\t\t\tgrid space;\n\t\t}\n\n\t\tdisplay Charts {\n\t\t\tchart \"Proportion of happiness\" type: pie background: #lightgray style: exploded position: { 0, 0 } size: { 1.0, 0.5 } {\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow;\n\t\t\t}\n\n\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: { 0, 0.5 } size: { 1.0, 0.5 }  x_range: 50{\n\t\t\t\tdata \"happy\" color: #blue value: (sum_happy_people / number_of_people) * 100 style: spline;\n\t\t\t\tdata \"similarity\" color: #red value: (sum_similar_neighbours / sum_total_neighbours) * 100 style: step;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n```\n","url":"wiki/Segregation-(Schelling)-Segregation-(Cellular-Automata).md"},"Segregation-(Schelling)-Segregation-(GIS).md":{"title":" segregationGIS","content":"[//]: # (keyword|operator_sum)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_shapefile)\n# segregationGIS\n\n\n_Author : _\n\nA model showing the segregation of the people just by putting a similarity wanted parameter using agents to represent the individuals and GIS file for the places\n\n\nImported model : \n\n```\nmodel segregation_base\n\nglobal {\n\t//Different colors for the group\n\trgb color_1 <- rgb (\"yellow\") parameter: \"Color of group 1:\" category: \"User interface\";\n\trgb color_2 <- rgb (\"red\") parameter: \"Color of group 2:\" category: \"User interface\";\n\trgb color_3 <- rgb (\"blue\") parameter: \"Color of group 3:\" category: \"User interface\";\n\trgb color_4 <- rgb (\"orange\") parameter: \"Color of group 4:\" category: \"User interface\";\n\trgb color_5 <- rgb (\"green\") parameter: \"Color of group 5:\" category: \"User interface\";\n\trgb color_6 <- rgb (\"pink\") parameter: \"Color of group 6:\" category: \"User interface\";   \n\trgb color_7 <- rgb (\"magenta\") parameter: \"Color of group 7:\" category: \"User interface\";\n\trgb color_8 <- rgb (\"cyan\") parameter: \"Color of group 8:\" category: \"User interface\";\n    list colors <- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;\n\n\t\n\t//Number of groups\n\tint number_of_groups <- 2 max: 8 parameter: \"Number of groups:\" category: \"Population\";\n\t//Density of the people\n\tfloat density_of_people <- 0.7 parameter: \"Density of people:\" category: \"Population\" min: 0.01 max: 0.99;\n\t//Percentage of similar wanted for segregation\n\tfloat percent_similar_wanted <- 0.5 min: float (0) max: float (1) parameter: \"Desired percentage of similarity:\" category: \"Population\";\n\t//Dimension of the grid\n\tint dimensions <- 40 max: 400 min: 10 parameter: \"Width and height of the environment:\" category: \"Environment\";\n\t//Neighbours distance for the perception of the agents\n\tint neighbours_distance <- 2 max: 10 min: 1 parameter: \"Distance of perception:\" category: \"Population\";\n\t//Number of people agents\n\tint number_of_people <- 0;\n\t//Number of happy people\n\tint sum_happy_people <- 0 update: all_people count (each.is_happy);\n\t//Number of similar neighbours\n\tint sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby);\n\t//Number of neighbours\n\tint sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1;\n\t//List of all the places\n\tlist<agent> all_places;\n\t//List of all the people\n\tlist<base> all_people;  \n\t\n\t//Action to write the description of the model in the console\n\taction description {\n\t\twrite\n\t\t\"\\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. \";\n\t}\n\t//Initialization of the model\n\tinit {\n\t\t//Write the description of the model \n\t\tdo description;\n\t\t//Initialization of the places\n\t\tdo initialize_places;\n\t\t//Computation of the number of people according to the density of people\n\t\tnumber_of_people <- int( length (all_places) * density_of_people);\n\t\t//Initialization of the people\n\t\tdo initialize_people;\n\t}\n\t//Action to initialize places defined in the subclasses\n\taction initialize_places virtual: true;\n\t//Action to initialize people in the subclasses\n\taction initialize_people virtual: true;\n}\n\n//Species base representing the people agents\nspecies base {\n\trgb color;\n\t//List of all the neighbours agents\n\tlist<base> my_neighbours;\n\t//computation of the similar neighbours\n\tint similar_nearby -> {\n\t\t(my_neighbours count (each.color = color))\n\t};\n\t//Computation of the total neighbours nearby\n\tint total_nearby -> {\n\t\tlength (my_neighbours)\n\t};\n\t//Boolean to know if the agent is happy or not\n\tbool is_happy -> {similar_nearby >= (percent_similar_wanted * total_nearby )} ;\n}\n\n```\n\n\nCode of the model : \n\n```\nmodel segregation\n\n//Import the model Common Schelling Segregation\nimport \"../include/Common Schelling Segregation.gaml\" \nglobal {\n\t//List of all the free places\n\tlist<space> free_places  ;  \n\t//List of all the places\n\tlist<space> all_places ;\n\t//Neighbours distance for the perception of an agent\n\tint neighbours_distance <- 50 min: 1 parameter: \"Distance of perception:\" category: \"Population\" max: 1000;\n\t//Shapefile to load\n\tfile shape_file_name <- file(\"../gis/nha2.shp\") parameter: \"Shapefile to load:\" category: \"GIS specific\";\n\t//Shape of the environment\n\tgeometry shape <- envelope(shape_file_name);\n\t//Square meters per people in m2\n\tint square_meters_per_people <- 200 parameter: \"Occupancy of people (in m2):\" category: \"GIS specific\";\n\t\n\t//Action to initialize people agents\n\taction initialize_people { \n\t\t//Create all the places with a surface given within the shapefile\n\t\tcreate space from: shape_file_name with: [surface :: float(read(\"AREA\"))];\n\t\tall_places  <- shuffle(space);\n\t\t//Compute the number of people to create considering the density of people\n\t\tnumber_of_people <- int( density_of_people * sum (all_places collect (each.capacity))); \n\t\tcreate people number: number_of_people;  \n\t    all_people <- people as list ; \n\t    //Move all the people to a new place\n\t\task people  {  \n\t\t\tdo move_to_new_place;       \n\t\t}   \n\t}      \n\t//Action to initialize the places\n\taction initialize_places {}   \n\t\n} \n\n//Species people representing the people\nspecies people parent: base { \n\t//Size of the people agent\n\tfloat size const: true <- 2.0;\n\t//Color of the people agent  \n\trgb color const: true <- colors at (rnd (number_of_groups - 1)); \n\tint red const: true <- (color as list) at 0; \n\tint green const: true <- (color as list) at 1;  \n\tint blue const: true <- (color as list) at 2;  \n\t//Building in which the agent lives\n\tspace current_building <- nil;\n\t//List of all the neighbour people agents\n\tlist<people> my_neighbours -> {people at_distance neighbours_distance}; \n\t\n\t//Action to move to a new place\n\taction move_to_new_place {  \n\t\tcurrent_building <- (shuffle(all_places) first_with (((each).capacity) > 0));\n\t\task current_building {\n\t\t\tdo accept one_people: myself;   \n\t\t}\n\t}\n\t//Reflex to migrate to another place if the agent isn't happy\n\treflex migrate when: !is_happy {\n\t\tif current_building != nil {\n\t\t\task current_building { \n\t\t\t\tdo remove_one one_people: myself;\n\t\t\t}\n\t\t} \n\t\tdo move_to_new_place;\n\t}\n\n\taspect simple {\n\t\tdraw circle(5) color: color;\n\t}\n}\n\n//Species space representing a space for a people agent to live in\nspecies space {\t\n\t//List of all the people agents living within\n\tlist<people> insiders;\n\trgb color <- rgb(255, 255, 255); \n\t//Surface of the place\n\tfloat surface;\n\t//Capacity of the place\n\tint capacity  <- 1 + int(surface / square_meters_per_people);\n\t\n\t//Action to accept a people agent  \n\taction accept (people one_people) {\n\t\tadd one_people to: insiders;\n\t\tlocation of one_people <- any_location_in(shape);\n\t\tcapacity <- capacity - 1;\n\t}\n\t//Action to remove a people agent\n\taction remove_one (people one_people){\n\t\tremove one_people from: insiders;\n\t\tcapacity <- capacity + 1;\n\t}\n\taspect simple {\n\t\tcolor <- empty(insiders) ? #white : rgb ([mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\n\t\tdraw  square(40) color: color;\n\t}\n\taspect gis {\n\t\tcolor <- empty(insiders) ? #white : rgb( [mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\n\t\tdraw shape color: color border: #black;\n\t} \n\taspect highlighted {\n\t\tcolor <- #blue;\n\t\tdraw shape+10 color: color;\n\t}\n}\n\n\nexperiment schelling type: gui {\t\n\toutput {\n\t\tdisplay Town_display  {\n\t\t\tspecies space aspect: gis;\n\t\t\tspecies people  aspect: simple;\n\t\t}\n\t\tdisplay Charts {\n\t\t\tchart \"Proportion of happiness\" type: histogram background: #lightgray gap:0.05 position: {0,0} size: {1.0,0.5}{\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow ;\n\t\t\t}\n\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: {0,0.5} size: {1.0,0.5} {\n\t\t\t\tdata \"happy\" color: #blue value:  ((sum_happy_people * 100) / number_of_people)  style: spline ;\n\t\t\t\tdata \"similarity\" color: #red value:  (sum_similar_neighbours / sum_total_neighbours) * 100 style: step ;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Segregation-(Schelling)-Segregation-(GIS).md"},"Segregation-(Schelling)-Segregation-(Google-Map).md":{"title":" segregationGoogleMap","content":"[//]: # (keyword|operator_sum)\n[//]: # (keyword|operator_as_matrix)\n[//]: # (keyword|operator_in)\n[//]: # (keyword|operator_copy)\n[//]: # (keyword|operator_of_species)\n[//]: # (keyword|operator_any)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_grid)\n# segregationGoogleMap\n\n\n_Author : _\n\nA model showing the segregation of the people just by putting a similarity wanted parameter using agents to represent the individuals and a grid to discretize space. Use the colors of the image to know if it is a possible space or not\n\n\nImported model : \n\n```\nmodel segregation_base\n\nglobal {\n\t//Different colors for the group\n\trgb color_1 <- rgb (\"yellow\") parameter: \"Color of group 1:\" category: \"User interface\";\n\trgb color_2 <- rgb (\"red\") parameter: \"Color of group 2:\" category: \"User interface\";\n\trgb color_3 <- rgb (\"blue\") parameter: \"Color of group 3:\" category: \"User interface\";\n\trgb color_4 <- rgb (\"orange\") parameter: \"Color of group 4:\" category: \"User interface\";\n\trgb color_5 <- rgb (\"green\") parameter: \"Color of group 5:\" category: \"User interface\";\n\trgb color_6 <- rgb (\"pink\") parameter: \"Color of group 6:\" category: \"User interface\";   \n\trgb color_7 <- rgb (\"magenta\") parameter: \"Color of group 7:\" category: \"User interface\";\n\trgb color_8 <- rgb (\"cyan\") parameter: \"Color of group 8:\" category: \"User interface\";\n    list colors <- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;\n\n\t\n\t//Number of groups\n\tint number_of_groups <- 2 max: 8 parameter: \"Number of groups:\" category: \"Population\";\n\t//Density of the people\n\tfloat density_of_people <- 0.7 parameter: \"Density of people:\" category: \"Population\" min: 0.01 max: 0.99;\n\t//Percentage of similar wanted for segregation\n\tfloat percent_similar_wanted <- 0.5 min: float (0) max: float (1) parameter: \"Desired percentage of similarity:\" category: \"Population\";\n\t//Dimension of the grid\n\tint dimensions <- 40 max: 400 min: 10 parameter: \"Width and height of the environment:\" category: \"Environment\";\n\t//Neighbours distance for the perception of the agents\n\tint neighbours_distance <- 2 max: 10 min: 1 parameter: \"Distance of perception:\" category: \"Population\";\n\t//Number of people agents\n\tint number_of_people <- 0;\n\t//Number of happy people\n\tint sum_happy_people <- 0 update: all_people count (each.is_happy);\n\t//Number of similar neighbours\n\tint sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby);\n\t//Number of neighbours\n\tint sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1;\n\t//List of all the places\n\tlist<agent> all_places;\n\t//List of all the people\n\tlist<base> all_people;  \n\t\n\t//Action to write the description of the model in the console\n\taction description {\n\t\twrite\n\t\t\"\\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. \";\n\t}\n\t//Initialization of the model\n\tinit {\n\t\t//Write the description of the model \n\t\tdo description;\n\t\t//Initialization of the places\n\t\tdo initialize_places;\n\t\t//Computation of the number of people according to the density of people\n\t\tnumber_of_people <- int( length (all_places) * density_of_people);\n\t\t//Initialization of the people\n\t\tdo initialize_people;\n\t}\n\t//Action to initialize places defined in the subclasses\n\taction initialize_places virtual: true;\n\t//Action to initialize people in the subclasses\n\taction initialize_people virtual: true;\n}\n\n//Species base representing the people agents\nspecies base {\n\trgb color;\n\t//List of all the neighbours agents\n\tlist<base> my_neighbours;\n\t//computation of the similar neighbours\n\tint similar_nearby -> {\n\t\t(my_neighbours count (each.color = color))\n\t};\n\t//Computation of the total neighbours nearby\n\tint total_nearby -> {\n\t\tlength (my_neighbours)\n\t};\n\t//Boolean to know if the agent is happy or not\n\tbool is_happy -> {similar_nearby >= (percent_similar_wanted * total_nearby )} ;\n}\n\n```\n\n\nCode of the model : \n\n```\nmodel segregation\n\n//Import the model Common Schelling Segregation\nimport \"../include/Common Schelling Segregation.gaml\"    \n\nglobal {\n\t//List of all the free places\n\tlist<space> free_places ; \n\t//List of all the places\n\tlist<space> all_places;\n\t//Shape of the environment\n\tgeometry shape <- square(dimensions);\n\t//Percentage of similarity wanted by an agent\n\tfloat percent_similar_wanted <- 0.6;\n\t//Distance of perception of the neighbours\n\tint neighbours_distance <- 4; \n\t//Number of groups of people\n\tint number_of_groups <- 3;\n\tlist google_buildings  <- [rgb(\"#EBE6DC\"), rgb(\"#D1D0CD\"), rgb(\"#F2EFE9\"), rgb(\"#EEEBE1\"), rgb(\"#F9EFE8\")] ;\n\t//List of all the available places\n\tlist<space> available_places ;\n\t//Image file to load\n\tfile bitmap_file_name <- file<unknown, int>(\"../images/hanoi.png\") parameter: \"Name of image file to load:\" category: \"Environment\" ;\n\tmatrix<int> map_colors;\n \n \t//Action to initialize the people agents\n\taction initialize_people {\n\t\tcreate people number: number_of_people ;  \n\t\tall_people <- people as list ;  \n\t}\n\t//Action to initialize the places using the color in the image\n\taction initialize_places { \n\t\tmap_colors <- (bitmap_file_name) as_matrix {dimensions,dimensions} ;\n\t\task space as list {\n\t\t\tcolor <- rgb(map_colors at {grid_x,grid_y}) ;\n\t\t}\n\t\tall_places <- shuffle (space where (each.color in google_buildings)) ;\n\t\tfree_places <- copy(all_places);\n\t}  \n}\n//Grid to discretize the space\ngrid space width: dimensions height: dimensions neighbors: 8 use_individual_shapes: false use_regular_agents: false frequency: 0 ; \n \n//Species people representing the people agent\nspecies people parent: base  {\n\trgb color <- colors at (rnd (number_of_groups - 1));\n\t//List of all the neighbours\n\tlist<people> my_neighbours -> {(self neighbors_at neighbours_distance) of_species people};\n\t\n\t//Launched at the initialization of the agent\n\tinit {\n\t\t//Set the place of the agent as one of the free place\n\t\tlocation <- (one_of(free_places)).location; \n\t\tremove location as space from: free_places;\n\t} \n\t//Reflex to migrate the agent when it's not happy\n\treflex migrate when: !is_happy { \n\t\tadd location as space to: free_places;\n\t\tlocation <- any(free_places).location;\n\t\tremove location as space from: free_places;\n\t}\n\taspect geom {\n\t\tdraw square(1) color: color  ;\n\t}\n\taspect default {\n\t\tdraw  square(2) color: #black ;\n\t}\n}\n\n\nexperiment schelling type: gui {\t\n\toutput {\n\t\tdisplay Segregation {\n\t\t\timage \"bg\" file: bitmap_file_name.path ;\n\t\t\tspecies people transparency: 0.5 aspect: geom;\n\t\t}\t\n\t\tdisplay Charts {\n\t\t\tchart \"Proportion of happiness\" type: pie background: #lightgray style: exploded position: { 0, 0 } size: { 1.0, 0.5 } {\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow;\n\t\t\t}\n\n\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: { 0, 0.5 } size: { 1.0, 0.5 } x_range: 20 y_range: 20 {\n\t\t\t\tdata \"happy\" color: °blue value: (sum_happy_people / number_of_people) * 100 style: spline fill: false;\n\t\t\t\tdata \"similarity\" color: °red value: (sum_similar_neighbours / sum_total_neighbours) * 100 style: line fill: true ;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Segregation-(Schelling)-Segregation-(Google-Map).md"},"Soccer-soccer.md":{"title":" Soccer Game","content":"[//]: # (keyword|operator_norm)\n[//]: # (keyword|operator_sqrt)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_closest_points_with)\n[//]: # (keyword|operator_inter)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|operator_polyline)\n[//]: # (keyword|operator_sin)\n[//]: # (keyword|operator_font)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#chartreuse)\n[//]: # (keyword|constant_#darkblue)\n[//]: # (keyword|constant_#darkred)\n[//]: # (keyword|constant_#zoom)\n[//]: # (keyword|constant_#bold)\n[//]: # (keyword|concept_sport)\n# Soccer Game\n\n\n_Author : Julien_\n\nThis model shows how can we make an easy simulation of collective games, such as soccer. \nEach player have an offensive and a defensive position, and a behavior associated. Each player of the defensive team can either search to catch the ball or mark an other player (offensive player) according to his defensive position.\nEach player of the offensive team can either run to its offensive place (when he does not have the ball), run with the balloon / pass the ball / try to score a goal (when he has the ball). By changing the different parameters, you can see the concequences in real time. \n\n\nCode of the model : \n\n```\n\nmodel soccer\n\nglobal {\n\tgeometry shape <- rectangle(120#m,90#m);\n\tfloat red_players_speed <- 1.0;\n\tfloat blue_players_speed <- 1.0;\n\tfloat red_size_play_area <- 30.0 min:1.0 max:100.0;\n\tfloat blue_size_play_area <- 30.0 min: 1.0 max:100.0;\n\tfloat previous_red_size_play_area <- red_size_play_area; // just to check if the parameter value has been changed\n\tfloat previous_blue_size_play_area <- blue_size_play_area; // just to check if the parameter value has been changed\n\tfloat red_collective_play <- 0.5 min:0.0 max:1.0;\n\tfloat blue_collective_play <- 0.5 min:0.0 max:1.0;\n\tfloat red_recuperation_ability <- 0.5 min:0.0 max:1.0;\n\tfloat blue_recuperation_ability <- 0.5 min:0.0 max:1.0;\n\t\n\tint red_score <- 0;\n\tint red_possession <- 0;\n\tint nb_red_pass <- 0;\n\tint nb_red_pass_succeed <- 0;\n\tint nb_red_interception <- 0;\n\tint blue_score <- 0;\n\tint blue_possession <- 0;\n\tint nb_blue_pass <- 0;\n\tint nb_blue_pass_succeed <- 0;\n\tint nb_blue_interception <- 0;\n\t\n\tbool show_status <- false;\n\tbool show_area <- false;\n\tbool show_marked_player <- false;\n\tbool show_ball_indicator <- false;\n\t\n\tbool play_with_offside <- true;\n\t\n\tlist<point> bluePlayerPosition <- [{8,10}, {8,80}, {10,30}, {10,60},\n\t\t{30,25}, {28,45}, {30,65},\n\t\t{50,25}, {50,65}, {55,45}\n\t];\n\t\n\tlist<point> redPlayerPosition <- [{120-8,10}, {120-8,80}, {120-10,30}, {120-10,60},\n\t\t{120-30,25}, {120-28,45}, {120-30,65},\n\t\t{120-50,25}, {120-50,65}, {120-55,45}\n\t];\n\t\n\tball ball_agent;\n\tplayer closest_red_player_from_the_ball;\n\tplayer closest_blue_player_from_the_ball;\n\tplayer called_player;\n\tstring team_possession <- \"\";\n\tfloat blue_offside_pos <- 120.0;\n\tfloat red_offside_pos <- 0.0;\n\t\n\tinit {\n\t\tloop pos over:redPlayerPosition {\n\t\t\tcreate player with:[team::\"red\", location::pos];\n\t\t}\n\t\tloop pos over:bluePlayerPosition {\n\t\t\tcreate player with:[team::\"blue\", location::pos];\n\t\t}\n\t\tcreate ball with:[location::location] returns:ball_agt;\n\t\tball_agent<-ball_agt at 0;\n\t\tcreate goal with:[location::{0,location.y}, team::\"blue\"];\n\t\tcreate goal with:[location::{120,location.y}, team::\"red\"];\n\t}\n\t\n\treflex update {\n\t\tfloat shortest_distance <- 100.0;\n\t\tfloat offside_pos <- 0.0;\n\t\task player where (each.team = \"red\") {\n\t\t\tif (distance_to_ball < shortest_distance and inactivity_time=0) {\n\t\t\t\tclosest_red_player_from_the_ball <- self;\n\t\t\t\tshortest_distance <- distance_to_ball;\n\t\t\t}\n\t\t\tif (location.x > offside_pos) {\n\t\t\t\toffside_pos <- location.x;\n\t\t\t\tred_offside_pos <- offside_pos;\n\t\t\t}\n\t\t}\n\t\tif (not play_with_offside) {\n\t\t\tred_offside_pos <- 120.0;\n\t\t}\n\t\t\n\t\tshortest_distance <- 100.0;\n\t\toffside_pos <- 100.0;\n\t\task player where (each.team = \"blue\") {\n\t\t\tif (distance_to_ball < shortest_distance and inactivity_time=0) {\n\t\t\t\tclosest_blue_player_from_the_ball <- self;\n\t\t\t\tshortest_distance <- distance_to_ball;\n\t\t\t}\n\t\t\tif (location.x < offside_pos) {\n\t\t\t\toffside_pos <- location.x;\n\t\t\t\tblue_offside_pos <- offside_pos;\n\t\t\t}\n\t\t}\n\t\tif (not play_with_offside) {\n\t\t\tblue_offside_pos <- 0.0;\n\t\t}\n\t\t\n\t\tif (previous_red_size_play_area != red_size_play_area) {\n\t\t\task area where (each.team = \"red\") {\n\t\t\t\tdo update_size;\n\t\t\t}\n\t\t\tprevious_red_size_play_area <- red_size_play_area;\n\t\t}\n\t\tif (previous_blue_size_play_area != blue_size_play_area) {\n\t\t\task area where (each.team = \"blue\") {\n\t\t\t\tdo update_size;\n\t\t\t}\n\t\t\tprevious_blue_size_play_area <- blue_size_play_area;\n\t\t}\n\t\tif (team_possession = \"blue\") {\n\t\t\tblue_possession <- blue_possession + 1;\n\t\t}\n\t\tif (team_possession = \"red\") {\n\t\t\tred_possession <- red_possession + 1;\n\t\t}\n\t}\n\t\n\taction reinit_phase {\n\t\task player {\n\t\t\tlocation <- init_pos;\n\t\t\tprevious_pos <- init_pos;\n\t\t}\n\t\tball_agent.location <- location;\n\t\tball_agent.destination <- location;\n\t\tball_agent.speed <- 0.0;\n\t}\n}\n\nspecies player skills:[moving] {\n\tstring team <- \"\"; // value : \"blue\" (left side) or \"red\" (right side)\n\tbool possess_ball <- false;\n\tint inactivity_time <- 0 update:(inactivity_time<=0) ? 0 : inactivity_time-1;\n\tint seed <- rnd(100);\n\tpoint init_pos;\n\tpoint previous_pos;\n\t\n\t// strategy\n\tarea defensive_pos;\n\tarea offensive_pos;\n\tplayer marked_player;\n\tfloat collective_mark <- 0.5 update:(team=\"red\") ? red_collective_play : blue_collective_play;\n\tfloat recuperation_mark <- 0.5 update:(team=\"red\") ? red_recuperation_ability : blue_recuperation_ability;\n\t\n\tstring status <- \"\";\n\t\n\t// moving attributes\n\tfloat running_speed_without_ball <- 0.8 update:(team=\"red\") ? red_players_speed*0.8 : blue_players_speed*0.8;\n\tfloat running_speed_with_ball <- 0.6 update:(team=\"red\") ? red_players_speed*0.5 : blue_players_speed*0.5;\n\tfloat speed <- 0.0 max:1.2;\n\tpoint velocity <- {0,0};\n\t\n\tfloat distance_to_closest_ennemy <- 100.0;\n\tfloat distance_to_ennemy_goal <- 100.0 update:self distance_to ( (goal where (each.team != team)) at 0);\n\tfloat distance_to_ball <- 100.0 update:self distance_to ball_agent;\n\t\n\tinit {\n\t\tinit_pos <- location;\n\t\tprevious_pos <- location;\n\t\tcreate area with:[location::init_pos, team::self.team, position::init_pos] returns:def_pos;\n\t\tdefensive_pos <- def_pos at 0;\n\t\tpoint offensivePos <- {(team=\"red\") ? init_pos.x-60 : init_pos.x+60,init_pos.y};\n\t\tcreate area with:[location::offensivePos, team::self.team, position::offensivePos] returns:off_pos;\n\t\toffensive_pos <- off_pos at 0;\n\t}\n\t\n\treflex update_status {\n\t\tdistance_to_closest_ennemy <- 100.0;\n\t\tloop pl over:player where (each.team != team) {\n\t\t\tfloat distance_to_ennemy <- self distance_to pl;\n\t\t\tif (distance_to_ennemy < distance_to_closest_ennemy) {\n\t\t\t\tdistance_to_closest_ennemy <- distance_to_ennemy;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex defensive_behavior when:team_possession != team {\n\t\t// the ball is not possessed by the team.\n\t\tdo apply_inertia;\n\t\tif (self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball) {\n\t\t\tdo run_to_ball;\n\t\t}\n\t\telse {\n\t\t\tdo defensive_move;\n\t\t}\n\t}\n\t\n\treflex offensive_behavior when:team_possession = team {\n\t\tdo apply_inertia;\n\t\tif (possess_ball) {\n\t\t\tdo run_with_ball;\n\t\t\tif (distance_to_ennemy_goal < 30 and flip(1/(distance_to_ennemy_goal*distance_to_ennemy_goal/10+1))) {\n\t\t\t\t// shoot !\n\t\t\t\tdo kick_ball_to_goal;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// pass !\n\t\t\t\tif (distance_to_closest_ennemy < 5) {\n\t\t\t\t\tif (flip(collective_mark)) {\n\t\t\t\t\t\tdo pass_the_ball;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if flip(collective_mark/50) {\n\t\t\t\t\tdo pass_the_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ball_agent.belong_to_team = \"\" and\n\t\t\t(self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball\n\t\t\tor self = called_player)\n\t\t) {\n\t\t\tdo run_to_ball;\n\t\t}\n\t\telse {\n\t\t\tdo offensive_move;\n\t\t}\n\t}\n\t\n\treflex choose_player_to_mark when:(cycle mod 20=seed or cycle=0) {\n\t\tif ( not empty(player where(each.offensive_pos intersects defensive_pos)) ) {\n\t\t\tmarked_player <- 1 among (player where((each.offensive_pos intersects defensive_pos) and (each.team != team))) at 0;\n\t\t}\n\t}\n\t\n\taction apply_inertia {\n\t\tpoint prev_pos <- location;\n\t\tpoint inertia_vect <- {(location.x-previous_pos.x)*0.8,(location.y-previous_pos.y)*0.8};\n\t\tfloat max_inertia <- running_speed_without_ball;\n\t\tif (norm(inertia_vect) > max_inertia) {\n\t\t\tfloat inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\n\t\t\tfloat inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\n\t\t\tinertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;\n\t\t\tinertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;\n\t\t\tinertia_vect <- {inertia_x,inertia_y};\n\t\t}\n\t\tlocation <- location + inertia_vect;\n\t\tprevious_pos <- prev_pos;\n\t}\n\t\n\taction run_to_ball {\n\t\tpoint targetPos;\n\t\tif (ball_agent.ball_direction intersects circle(1)) {\n\t\t\ttargetPos <- ball_agent.location;\n\t\t}\n\t\telse {\n\t\t\ttargetPos <- (ball_agent.ball_direction closest_points_with self) at 0;\n\t\t}\n\t\tdo goto with:[target::targetPos, speed::running_speed_without_ball];\n\t\t\n\t\tstatus <- \"run to the ball\";\n\t\t\n\t\t// if close enough, catch the ball\n\t\tif (location distance_to ball_agent.location < 1.5#m) {\n\t\t\tif (self = called_player) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t\telse if (ball_agent.belong_to_team = \"\") {\n\t\t\t\tif flip(1/(ball_agent.speed*recuperation_mark+1)) {\n\t\t\t\t\tdo take_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (team_possession = team) {\n\t\t\t\t\t// result of a long pass for instance\n\t\t\t\t\tif (flip(recuperation_mark*1.5)) {\n\t\t\t\t\t\tdo take_ball;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// interception of the ball\n\t\t\t\t\tif (flip(recuperation_mark*0.8)) {\n\t\t\t\t\t\tdo take_ball;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction run_with_ball {\n\t\tstatus <- \"run with the ball\";\n\t\tpoint goal_pos;\n\t\task goal {\n\t\t\tif (self.team != myself.team) {\n\t\t\t\tgoal_pos <- location;\n\t\t\t}\n\t\t}\n\t\tdo goto with:[target::goal_pos, speed::running_speed_with_ball];\n\t\tball_agent.location <- location;\n\t}\n\t\n\taction offensive_move {\n\t\t// try to reach an offensive postion\n\t\tpoint target_location;\n\t\tgeometry possible_pos <- (team=\"red\") ? world inter (rectangle({blue_offside_pos,0},{120,90}))\n\t\t: world inter (rectangle({0,0},{red_offside_pos,90}));\n\t\t\n\t\t\n\t\t// check if the player is in the field\n\t\tif (location.y < 0) {\n\t\t\ttarget_location <- {location.x,90};\n\t\t}\n\t\telse if (location.y > 90) {\n\t\t\ttarget_location <- {location.x,0};\n\t\t}\n\t\t// check if the player is in offside position\n\t\telse if ( (location.x > red_offside_pos and team = \"blue\") or (location.x < blue_offside_pos and team = \"red\")) {\n\t\t\ttarget_location <- (team=\"red\") ? {120,location.y} : {0,location.y};\n\t\t\tstatus <- \"run to a non offside position\";\n\t\t}\n\t\telse {\n\t\t\tstatus <- \"run to a offensive place\";\n\t\t\tif (not (possible_pos intersects offensive_pos)) {\n\t\t\t\ttarget_location <- (team=\"red\") ? {blue_offside_pos,location.y} : {red_offside_pos,location.y};\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttarget_location <- any_location_in(offensive_pos inter possible_pos);\n\t\t\t}\n\t\t}\n\t\tdo goto target:target_location speed:running_speed_without_ball;\n\t}\n\t\n\taction defensive_move {\n\t\t// try to mark an ennemy player\n\t\tstatus <- \"mark ennemy player\";\n\t\tif (not (marked_player = nil)) {\n\t\t\tdo goto with:[target::marked_player.location+((team=\"red\")?{2+rnd(5.0),rnd(2.0)-1} : {-2-rnd(5.0),rnd(2.0)-1}), speed::running_speed_without_ball];\n\t\t}\n\t}\n\t\n\taction kick_ball_to_goal {\n\t\tdo loose_ball;\n\t\task ball_agent {\n\t\t\tdo shooted speed_atr:4.0 target_position:((goal where (each.team != myself.team)) at 0).location;\n\t\t}\n\t\tinactivity_time <- 20;\n\t}\n\t\n\taction pass_the_ball {\n\t\tfloat wisest_choice_mark <- -100.0;\n\t\tplayer wisest_target;\n\t\task player  where(each.team = team and each != self and (self distance_to each > 15)) {\n\t\t\tint number_of_ennemies_on_range <- length(player at_distance 5 where (each.team != myself.team));\n\t\t\tfloat wise_choice_mark <- 100-distance_to_ball+number_of_ennemies_on_range*10-2*distance_to_ennemy_goal;\n\t\t\tif (wise_choice_mark > wisest_choice_mark) {\n\t\t\t\twisest_target <- self;\n\t\t\t\twisest_choice_mark <- wise_choice_mark;\n\t\t\t}\n\t\t}\n\t\tif (wisest_choice_mark > -100.0) {\n\t\t\t// a target has been found\n\t\t\tdo loose_ball;\n\t\t\task ball_agent {\n\t\t\t\tdo shooted target_position:wisest_target.location speed_atr:wisest_target.distance_to_ball/8;\n\t\t\t}\n\t\t\tcalled_player <- wisest_target;\n\t\t\tinactivity_time <- 20;\n\t\t\tif (team = \"red\") {nb_red_pass <- nb_red_pass+1;}\n\t\t\telse {nb_blue_pass <- nb_blue_pass+1;}\n\t\t}\n\t}\n\t\n\taction take_ball {\n\t\tif (ball_agent.belong_to_team != \"\" and ball_agent.belong_to_team != team) {\n\t\t\task ball_agent.belong_to_player {\n\t\t\t\tdo loose_ball;\n\t\t\t}\n\t\t}\n\t\tteam_possession <- team;\n\t\tpossess_ball <- true;\n\t\tball_agent.belong_to_team <- team;\n\t\tball_agent.belong_to_player <- self;\n\t\tball_agent.speed <- 0.0;\n\t\tif (self = called_player) {\n\t\t\tif (team = \"red\") {nb_red_pass_succeed <- nb_red_pass_succeed+1;}\n\t\t\telse {nb_blue_pass_succeed <- nb_blue_pass_succeed+1;}\n\t\t}\n\t\telse {\n\t\t\tif (team = \"red\") {nb_red_interception <- nb_red_interception+1;}\n\t\t\telse {nb_blue_interception <- nb_blue_interception+1;}\n\t\t}\n\t\tcalled_player <- nil;\n\t}\n\t\n\taction loose_ball {\n\t\tpossess_ball <- false;\n\t\tball_agent.belong_to_team <- \"\";\n\t}\n\t\n\taspect base {\n\t\tdraw circle(1) color:(team=\"red\") ? #red : #blue;\n\t\tif (show_status) {\n\t\t\tdraw string(status);\n\t\t\tif (marked_player != nil) {\n\t\t\t\tdraw polyline([location,marked_player.location]);\n\t\t\t}\n\t\t}\n\t\tif (marked_player != nil and show_marked_player) {\n\t\t\tdraw polyline([location,marked_player.location]) end_arrow:1 color:#chartreuse;\n\t\t}\n\t}\n}\n\nspecies area {\n\tstring team <- \"\";\n\tpoint position;\n\t\n\tinit {\n\t\tshape <- ((team=\"red\") ? square(red_size_play_area) : square(blue_size_play_area)) inter world;\n\t}\n\t\n\taction update_size {\n\t\tlocation <- position;\n\t\tshape <- ((team=\"red\") ? square(red_size_play_area) : square(blue_size_play_area)) inter world;\n\t}\n\t\n\taspect base {\n\t\tif (show_area) {\n\t\t\tdraw shape color:rgb(128,128,128,50) border:(team=\"red\") ? rgb(256,0.0,0.0,100) : rgb(0.0,0.0,256.0,100);\n\t\t}\n\t}\n}\n\nspecies ball skills:[moving]{\n\tstring belong_to_team <- \"\";\n\tplayer belong_to_player;\n\tfloat speed <- 0.0 update:speed*0.9;\n\tlist<point> nextPlace;\n\tgeometry ball_direction;\n\treflex update {\n\t\tfloat future_speed <- speed;\n\t\tpoint tmpPos<-location;\n\t\tloop i from:0 to:10 {\n\t\t\ttmpPos <- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\n\t\t\tfuture_speed <- future_speed*0.9;\n\t\t}\n\t\tball_direction <- line([location,tmpPos]);\n\t\tif ((location.x+cos(heading)*speed) > 120) {\n\t\t\tblue_score <- blue_score + 1;\n\t\t\task world {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tif ((location.x+cos(heading)*speed) < 0) {\n\t\t\tred_score <- red_score + 1;\n\t\t\task world {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tdo wander amplitude:1;\n\t}\n\taction shooted (point target_position, float speed_atr) {\n\t\tspeed <- speed_atr;\n\t\tdo goto target:target_position;\n\t}\n\taspect base {\n\t\tdraw circle(0.5) color:#white border:#black;\n\t\tif (show_ball_indicator) {\n\t\t\tdraw ball_direction end_arrow:1 color:#chartreuse;\n\t\t\tif (team_possession=\"red\") {\n\t\t\t\tdraw circle(0.5) color:#darkred border:#black;\n\t\t\t}\n\t\t\telse if (team_possession=\"blue\") {\n\t\t\t\tdraw circle(0.5) color:#darkblue border:#black;\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies goal {\n\tstring team <- \"\";\n\taspect base {\n\t\tdraw rectangle(0.1,7.32) color:#black;\n\t}\n}\n\n\nexperiment match type:gui {\n\tparameter \"blue running speed\" var:blue_players_speed category:\"Blue Team\";\n\tparameter \"red running speed\" var:red_players_speed category:\"Red Team\";\n\t// speed of players when they run. Note that a player which have the ball will run at 50% of his max capacity, and he will run at 80% of his max capacity if he does not have the ball.\n\t\n\tparameter \"blue collective play\" var:blue_collective_play category:\"Blue Team\";\n\tparameter \"red collective play\" var:red_collective_play category:\"Red Team\";\n\t// propention of giving the ball to an other player of the team. If the value is 0, the player will never pass the ball.\n\t\n\tparameter \"blue recuperation ability\" var:blue_recuperation_ability category:\"Blue Team\";\n\tparameter \"red recuperation ability\" var:red_recuperation_ability category:\"Red Team\";\n\t// ability to catch the ball when no player has it and when a player of the other team has it. 1 for very good hability, 0 for very poor hability.\n\t\n\tparameter \"blue play area size\" var:blue_size_play_area category:\"Blue Team\";\n\tparameter \"red play area size\" var:red_size_play_area category:\"Red Team\";\n\t// change the size of the area of each player. The bigger this area is, the less players will maintains their position.\n\t\n\tparameter \"display status\" var:show_status category:\"Display\";\n\t// displays or not the current status of the player (his intentions)\n\t\n\tparameter \"display play area\" var:show_area category:\"Display\";\n\t// displays or not the offensive and defensive area of each player. The bigger this area is, the less players will maintains their position.\n\t\n\tparameter \"display marked player\" var:show_marked_player category:\"Display\";\n\t// displays or not an arrow between the player that are marked each other.\n\t\n\tparameter \"display ball indicators\" var:show_ball_indicator category:\"Display\";\n\t// changes the color of the ball if the ball is possessed by the blue or the red team. Display also the direction of the ball when it has been shooted.\n\t\n\tparameter \"play with offside position\" var:play_with_offside category:\"Rules\";\n\t// play with or without the \"offside\" rule.\n\t\n\toutput {\n\t\tdisplay \"soccer_field\" {\n\t\t\t// display the field.\n\t\t\timage \"../images/soccer_field.png\";\n\t\t\tspecies player aspect:base;\n\t\t\tspecies ball aspect:base;\n\t\t\tspecies goal aspect:base;\n\t\t\tspecies area aspect:base;\n\t\t\tgraphics \"score_display\" {\n\t\t\t\tdraw \"Blue side - \"+string(blue_score) color:#blue at: {10,5} font: font(\"Helvetica\", 18 * #zoom, #bold) perspective:true;\n\t\t\t\tdraw string(red_score)+\" - Red side\" color:#red at: {100,5} font: font(\"Helvetica\", 18 * #zoom, #bold) perspective:true;\n\t\t\t\tif (show_status) {\n\t\t\t\t\tdraw line([{red_offside_pos,0},{red_offside_pos,90}]) color:#red;\n\t\t\t\t\tdraw line([{blue_offside_pos,0},{blue_offside_pos,90}]) color:#blue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplay \"match_stats\" {\n\t\t\t// display some statistics about the game\n\t\t\tchart \"ball_possession\" type:pie position:{0,0} size:{0.5,0.5} {\n\t\t\t\tdata \"Red possession\" value:red_possession color:#red;\n\t\t\t\tdata \"Blue possession\" value:blue_possession color:#blue;\n\t\t\t}\n\t\t\tchart \"red pass\" type:pie position:{0,0.5} size:{0.5,0.5} {\n\t\t\t\t// note that a pass is said \"successful\" if the player that has the ball was the player called initially. A \"failed pass\" does not necessary means that the team have lost the ball.\n\t\t\t\t\tdata \"Red pass succeed\" value:(nb_red_pass = 0) ? 0 : float(nb_red_pass_succeed)/float(nb_red_pass) color:#red;\n\t\t\t\t\tdata \"Red pass failed\" value:(nb_red_pass = 0) ? 0 : 1-float(nb_red_pass_succeed)/float(nb_red_pass) color:#darkred;\n\t\t\t}\n\t\t\tchart \"blue pass\" type:pie position:{0.5,0.5} size:{0.5,0.5} {\n\t\t\t\t// note that a pass is said \"successful\" if the player that has the ball was the player called initially. A \"failed pass\" does not necessary means that the team have lost the ball.\n\t\t\t\tdata \"Blue pass succeed\" value:(nb_blue_pass = 0) ? 0 : float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#blue;\n\t\t\t\tdata \"Blue pass failed\" value:(nb_blue_pass = 0) ? 0 : 1-float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#darkblue;\n\t\t\t}\n\t\t\tchart \"number pass\" type:series position:{0.5,0} size:{0.5,0.5} {\n\t\t\t\tdata \"Number pass red\" value:nb_red_pass color:#red;\n\t\t\t\tdata \"Number pass blue\" value:nb_blue_pass color:#blue;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Soccer-soccer.md"},"Soccer-soccer_base.md":{"title":" _soccerbase","content":"[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_closest_points_with)\n[//]: # (keyword|operator_norm)\n[//]: # (keyword|operator_sqrt)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_sin)\n# _soccerbase\n\n\n_Author : Julien_\n\nThis model contains the parent classes of the model\n\n\nCode of the model : \n\n```\n\nmodel soccerbase\n\nspecies soccer_game {\n\t// contains the global informations of the game\n\trgb back_color_team;\n\trgb front_color_team;\n\t\n\tball_sp ball; // the ball agent\n\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\n\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\n\tlist<base_team> teams; // contains the 2 teams\n\tlist<base_player> players; // contains all the players of the game\n\t\n\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\n\t\n\tinit {\n\t\t// create the entities ball and the 2 goals\n\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\n\t\tball <- first(var_ball);\n\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\n\t\tfront_goal <- first(var_goal1);\n\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\n\t\tback_goal <- first(var_goal2);\n\t}\n\t\n\taction reinit_phase {\n\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\n\t\task players {\n\t\t\tlocation <- init_pos;\n\t\t\tprevious_pos <- init_pos;\n\t\t}\n\t\tball.location <- world.location;\n\t\tball.destination <- world.location;\n\t\tball.speed <- 0.0;\n\t}\n}\n\nspecies base_player skills:[moving] {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\n\tfloat speed_without_ball;\n\tfloat speed_with_ball;\n\tpoint previous_pos; // used to apply inertia\n\tbool displacement_effectued<-false update:false; // we can apply only one displacement by step !\n\t\n\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tbase_team team;\n\tsoccer_game game;\n\tbase_team ennemy_team <- nil update:first(game.teams where (each.position != team.position));\n\tball_sp ball <- nil update:first(ball_sp);\n\tgoal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position));\n\tgoal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position));\n\t// ratio of avancement of the ball (from the point of view of the current team)\n\tfloat ball_advancement <- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\n\t\n\tbool possess_ball;\n\tpoint init_pos;\n\tpoint init_pos_in_percent;\n\tfloat distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player;\n\t// the number of ennemy players in a range of 15 meters\n\tint number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\n\tfloat distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\n\tfloat distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\n\t// the closest player of this team\n\tbase_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the closest ennemy player\n\tbase_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the player of this team wich has the best \"position_mark\"\n\tbase_player best_position_player <- nil update:first((team.players where (each != self)) \n\t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\n\t);\n\tfloat current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\n\tfloat position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \n\t// By default, this mark is equal to -distance_to_goal.\n\tstring status <- \"\"; // the current status of the player (can be useful to build the model)\n\tgeometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\n\n\t\n\t// CONSTRUCTOR /////////////////////////////////////////////\n\tinit {\n\t\tinit_pos <- location;\n\t\tprevious_pos <- location;\n\t\tpossess_ball <- false;\n\t\tspeed_with_ball <- 0.4;\n\t\tspeed_without_ball <- 0.5;\n\t}\n\t\n\t// ACTIONS ////////////////////////////////////////////////////\n\t\n\t// ACTIONS TO CALL FROM THE STRATEGY FILE\n\t// action to run to a particular position\n\taction run_to(point target) {\n\t\tif (!displacement_effectued) {\n\t\t\t\tdo goto target:target speed:current_speed;\n\t\t\tif (possess_ball) {\n\t\t\t\tball.location <- location;\n\t\t\t}\n\t\t\tdisplacement_effectued <- true;\n\t\t}\n\t\telse {\n\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\n\t\t}\n\t}\n\t\n\t// action to run to the ball\n\taction run_to_ball {\n\t\tpoint targetPos;\n\t\tif (ball.ball_direction intersects circle(1)) {\n\t\t\ttargetPos <- ball.location;\n\t\t}\n\t\telse {\n\t\t\ttargetPos <- (ball.ball_direction closest_points_with self) at 0;\n\t\t}\n\t\tdo run_to(targetPos);\n\t}\n\t\n\t// action to run to the ennemy goal\n\taction run_to_ennemy_goal {\n\t\tdo run_to( ennemy_goal.location );\n\t}\n\t\n\t// action to run to its own goal\n\taction run_to_own_goal {\n\t\tdo run_to( own_goal.location );\n\t}\n\t\n\t// action to mark a player\n\taction mark_player (base_player player) {\n\t\tfloat rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.\n\t\tpoint pos <- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\n\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\n\t}\n\t\n\t// action ot shoot the ball to the ennemy goal\n\taction shoot {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\n\t\t}\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball (base_player target_player) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tfloat offset <- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\n\t\t\tpoint target_point <- {target_player.location.x,target_player.location.y+offset};\n\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\n\t// try to take the ball if it is close enough\n\taction try_to_take_ball {\n\t\t// if no player has the ball\n\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\n\t\t\t// if the player is the one called (result of a pass)\n\t\t\tif (team.called_player = self) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\n\t\t\telse {\n\t\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\t\tdo take_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// the ball is possessed by the ennemy team\n\t\telse if (ennemy_team.possess_ball) {\n\t\t\t// try to catch the ball from the other player\n\t\t\tif flip(recuperation_ability) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// action of taking the ball\n\taction take_ball {\n\t\tif (ennemy_team.possess_ball) {\n\t\t\task ennemy_team.player_with_ball {\n\t\t\t\tdo loose_ball;\n\t\t\t}\n\t\t}\n\t\tpossess_ball <- true;\n\t\tball.speed <- 0.0;\n\t\tball.destination <- ball.location;\n\t\tteam.called_player <- nil;\n\t\tteam.player_with_ball <- self;\n\t\tteam.possess_ball <- true;\n\t\tgame.team_possession <- team;\n\t}\n\t\n\t// action of loosing the ball\n\taction loose_ball {\n\t\tpossess_ball <- false;\n\t\tteam.player_with_ball <- nil;\n\t\tteam.possess_ball <- false;\n\t}\n\t\n\t// apply the inertia\n\taction apply_inertia {\n\t\tpoint prev_pos <- location;\n\t\tpoint inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\n\t\tfloat max_inertia <- current_speed;\n\t\tif (norm(inertia_vect) > max_inertia) {\n\t\t\tfloat inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\n\t\t\tfloat inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\n\t\t\tinertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;\n\t\t\tinertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;\n\t\t\tinertia_vect <- {inertia_x,inertia_y};\n\t\t}\n\t\tlocation <- location + inertia_vect;\n\t\tprevious_pos <- prev_pos;\n\t}\n\t\n\t// useful functions\n\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\n\tfloat getXPos(float x_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- 90-x_ratio*90;\n\t\t}\n\t\telse {\n\t\t\tresult <- x_ratio*90;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\n\tfloat getYPos(float y_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- y_ratio*120;\n\t\t}\n\t\telse {\n\t\t\tresult <- 120-y_ratio*120;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t///////////////////////////////////////////////////////\n\t\n\t// The update function, calls the adequate behavior\n\treflex update when:cycle>1 {\n\t\tdo apply_inertia;\n\t\t// verify if it is a non-offside position\n\t\tif ( (((team.position = \"back\") and (location.y > team.offside_pos))\n\t\t\tor ((team.position = \"front\") and (location.y < team.offside_pos))) \n\t\t\tand (!possess_ball) and (self != team.called_player)\n\t\t) {\n\t\t\t// offside position, go back to a correct position\n\t\t\tpoint target_pos <- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\n\t\t\tdo run_to(target_pos);\n\t\t\tstatus <- \"offside position !\";\n\t\t}\n\t\telse if ((distance_to_ball < 2) and !possess_ball) {\n\t\t\tdo try_to_take_ball;\n\t\t}\n\t\telse if (game.team_possession = team) {\n\t\t\tdo offensive_behavior;\n\t\t}\n\t\telse {\n\t\t\tdo defensive_behavior;\n\t\t}\n\t}\n\t\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of the ennemy team\n\taction defensive_behavior virtual:true {\n\t\t\n\t}\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of this team\n\taction offensive_behavior virtual:true {\n\t\t\n\t}\n\t\n\t\n\t// ASPECT ////////////////////////////////////////////////////////\n\taspect player {\n\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\n\t\tif (possess_ball) {\n\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t\telse {\n\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t}\n}\n\n\n\nspecies base_team {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat offside_pos <- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\n\t\t: min((game.players where (each.team != self)) collect (each.location.y));\n\t\n\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tstring position; // can be \"front\" or \"back\".\n\tlist<base_player> players; // all the players of the team.\n\tsoccer_game game;\n\t\n\tbase_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\n\tbase_player called_player;\n\tbool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) );\n\tbase_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\n\tlist<point> player_init_position;\n}\n\nspecies ball_sp skills:[moving] {\n\t// The ball agent.\n\tfloat speed <- 0.0;\n\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\n\treflex update {\n\t\tspeed <- speed*0.95;\n\t\tfloat future_speed <- speed;\n\t\tpoint tmpPos<-location;\n\t\tloop i from:0 to:10 {\n\t\t\ttmpPos <- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\n\t\t\tfuture_speed <- future_speed*0.9;\n\t\t}\n\t\tball_direction <- line([location,tmpPos]);\n\t\tdo wander amplitude:1;\n\t\t\n\t\t// anticipation of the ball position to detect a goal\n\t\tif ((location.y+sin(heading)*speed) > 120) {\n\t\t\twrite \"back team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tif ((location.y+sin(heading)*speed) < 0) {\n\t\t\twrite \"front team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t}\n\taction shooted (point target_position, float speed_atr) {\n\t\t// action called when a player shoots the ball\n\t\tspeed <- speed_atr;\n\t\tdo goto target:target_position;\n\t}\n\t\n\taspect ball {\n\t\tdraw circle(0.5) color:#white;\n\t}\n}\n\nspecies goal_sp {\n\tstring position; // can be \"front\" or \"back\".\n\t\n\tinit {\n\t\tcreate goal_keeper with:[position::position];\n\t}\n\t\n\taspect goal {\n\t\tdraw rectangle(7.32,1.0) color:#black;\n\t}\n}\n\nspecies goal_keeper {\n\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \n\tstring position; // can be \"front\" or \"back\".\n\tball_sp ball <- nil update:first(ball_sp);\n\t\n\treflex update when:cycle>0 {\n\t\tlocation <- {ball.location.x/90*12+(90-12)/2,location.y};\n\t\tif (ball distance_to self < 2) {\n\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\tfirst(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));\n\t\t\t\task ball {\n\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinit {\n\t\tlocation <- {45,(position=\"front\") ? 117 : 3};\n\t}\n\t\n\taction offensive_behavior {\n\t}\n\t\n\taction defensive_behavior {\n\t}\n\t\n\taspect goal_keeper {\n\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\n\t}\n}\n```\n","url":"wiki/Soccer-soccer_base.md"},"Soccer-soccer_expe.md":{"title":" Soccer game (Various strategies)","content":"[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_closest_points_with)\n[//]: # (keyword|operator_norm)\n[//]: # (keyword|operator_sqrt)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_sin)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|operator_^)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|concept_sport)\n# Soccer game (Various strategies)\n\n\n_Author : Julien_\n\nThis model shows a game between two teams, with the same of with different strategies :\n* The \"stupidTeam\" has a very basic strategy : when a player has the ball, he runs to the ennemy goal, he runs to the ball otherwise.\n* The \"intelligentTeam\" is composed of players that each one have a strategical place wich they are able to keep. They also do pass when they are in dangerous position, to the \"safer\" player.\nThis model is designed to show how, with the same set of rules and some predefined actions, we can build a strategy of a team. You are free to change the imported files \"team1_strategy.gaml\" and \"team2_strategy.gaml\", using the read-only and the read-write attributes of the mother species.\n\n\nImported models : \n\n```\n\nmodel soccerbase\n\nspecies soccer_game {\n\t// contains the global informations of the game\n\trgb back_color_team;\n\trgb front_color_team;\n\t\n\tball_sp ball; // the ball agent\n\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\n\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\n\tlist<base_team> teams; // contains the 2 teams\n\tlist<base_player> players; // contains all the players of the game\n\t\n\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\n\t\n\tinit {\n\t\t// create the entities ball and the 2 goals\n\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\n\t\tball <- first(var_ball);\n\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\n\t\tfront_goal <- first(var_goal1);\n\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\n\t\tback_goal <- first(var_goal2);\n\t}\n\t\n\taction reinit_phase {\n\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\n\t\task players {\n\t\t\tlocation <- init_pos;\n\t\t\tprevious_pos <- init_pos;\n\t\t}\n\t\tball.location <- world.location;\n\t\tball.destination <- world.location;\n\t\tball.speed <- 0.0;\n\t}\n}\n\nspecies base_player skills:[moving] {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\n\tfloat speed_without_ball;\n\tfloat speed_with_ball;\n\tpoint previous_pos; // used to apply inertia\n\tbool displacement_effectued<-false update:false; // we can apply only one displacement by step !\n\t\n\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tbase_team team;\n\tsoccer_game game;\n\tbase_team ennemy_team <- nil update:first(game.teams where (each.position != team.position));\n\tball_sp ball <- nil update:first(ball_sp);\n\tgoal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position));\n\tgoal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position));\n\t// ratio of avancement of the ball (from the point of view of the current team)\n\tfloat ball_advancement <- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\n\t\n\tbool possess_ball;\n\tpoint init_pos;\n\tpoint init_pos_in_percent;\n\tfloat distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player;\n\t// the number of ennemy players in a range of 15 meters\n\tint number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\n\tfloat distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\n\tfloat distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\n\t// the closest player of this team\n\tbase_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the closest ennemy player\n\tbase_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the player of this team wich has the best \"position_mark\"\n\tbase_player best_position_player <- nil update:first((team.players where (each != self)) \n\t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\n\t);\n\tfloat current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\n\tfloat position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \n\t// By default, this mark is equal to -distance_to_goal.\n\tstring status <- \"\"; // the current status of the player (can be useful to build the model)\n\tgeometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\n\n\t\n\t// CONSTRUCTOR /////////////////////////////////////////////\n\tinit {\n\t\tinit_pos <- location;\n\t\tprevious_pos <- location;\n\t\tpossess_ball <- false;\n\t\tspeed_with_ball <- 0.4;\n\t\tspeed_without_ball <- 0.5;\n\t}\n\t\n\t// ACTIONS ////////////////////////////////////////////////////\n\t\n\t// ACTIONS TO CALL FROM THE STRATEGY FILE\n\t// action to run to a particular position\n\taction run_to(point target) {\n\t\tif (!displacement_effectued) {\n\t\t\t\tdo goto target:target speed:current_speed;\n\t\t\tif (possess_ball) {\n\t\t\t\tball.location <- location;\n\t\t\t}\n\t\t\tdisplacement_effectued <- true;\n\t\t}\n\t\telse {\n\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\n\t\t}\n\t}\n\t\n\t// action to run to the ball\n\taction run_to_ball {\n\t\tpoint targetPos;\n\t\tif (ball.ball_direction intersects circle(1)) {\n\t\t\ttargetPos <- ball.location;\n\t\t}\n\t\telse {\n\t\t\ttargetPos <- (ball.ball_direction closest_points_with self) at 0;\n\t\t}\n\t\tdo run_to(targetPos);\n\t}\n\t\n\t// action to run to the ennemy goal\n\taction run_to_ennemy_goal {\n\t\tdo run_to( ennemy_goal.location );\n\t}\n\t\n\t// action to run to its own goal\n\taction run_to_own_goal {\n\t\tdo run_to( own_goal.location );\n\t}\n\t\n\t// action to mark a player\n\taction mark_player (base_player player) {\n\t\tfloat rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.\n\t\tpoint pos <- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\n\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\n\t}\n\t\n\t// action ot shoot the ball to the ennemy goal\n\taction shoot {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\n\t\t}\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball (base_player target_player) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tfloat offset <- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\n\t\t\tpoint target_point <- {target_player.location.x,target_player.location.y+offset};\n\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\n\t// try to take the ball if it is close enough\n\taction try_to_take_ball {\n\t\t// if no player has the ball\n\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\n\t\t\t// if the player is the one called (result of a pass)\n\t\t\tif (team.called_player = self) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\n\t\t\telse {\n\t\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\t\tdo take_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// the ball is possessed by the ennemy team\n\t\telse if (ennemy_team.possess_ball) {\n\t\t\t// try to catch the ball from the other player\n\t\t\tif flip(recuperation_ability) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// action of taking the ball\n\taction take_ball {\n\t\tif (ennemy_team.possess_ball) {\n\t\t\task ennemy_team.player_with_ball {\n\t\t\t\tdo loose_ball;\n\t\t\t}\n\t\t}\n\t\tpossess_ball <- true;\n\t\tball.speed <- 0.0;\n\t\tball.destination <- ball.location;\n\t\tteam.called_player <- nil;\n\t\tteam.player_with_ball <- self;\n\t\tteam.possess_ball <- true;\n\t\tgame.team_possession <- team;\n\t}\n\t\n\t// action of loosing the ball\n\taction loose_ball {\n\t\tpossess_ball <- false;\n\t\tteam.player_with_ball <- nil;\n\t\tteam.possess_ball <- false;\n\t}\n\t\n\t// apply the inertia\n\taction apply_inertia {\n\t\tpoint prev_pos <- location;\n\t\tpoint inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\n\t\tfloat max_inertia <- current_speed;\n\t\tif (norm(inertia_vect) > max_inertia) {\n\t\t\tfloat inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\n\t\t\tfloat inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\n\t\t\tinertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;\n\t\t\tinertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;\n\t\t\tinertia_vect <- {inertia_x,inertia_y};\n\t\t}\n\t\tlocation <- location + inertia_vect;\n\t\tprevious_pos <- prev_pos;\n\t}\n\t\n\t// useful functions\n\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\n\tfloat getXPos(float x_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- 90-x_ratio*90;\n\t\t}\n\t\telse {\n\t\t\tresult <- x_ratio*90;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\n\tfloat getYPos(float y_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- y_ratio*120;\n\t\t}\n\t\telse {\n\t\t\tresult <- 120-y_ratio*120;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t///////////////////////////////////////////////////////\n\t\n\t// The update function, calls the adequate behavior\n\treflex update when:cycle>1 {\n\t\tdo apply_inertia;\n\t\t// verify if it is a non-offside position\n\t\tif ( (((team.position = \"back\") and (location.y > team.offside_pos))\n\t\t\tor ((team.position = \"front\") and (location.y < team.offside_pos))) \n\t\t\tand (!possess_ball) and (self != team.called_player)\n\t\t) {\n\t\t\t// offside position, go back to a correct position\n\t\t\tpoint target_pos <- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\n\t\t\tdo run_to(target_pos);\n\t\t\tstatus <- \"offside position !\";\n\t\t}\n\t\telse if ((distance_to_ball < 2) and !possess_ball) {\n\t\t\tdo try_to_take_ball;\n\t\t}\n\t\telse if (game.team_possession = team) {\n\t\t\tdo offensive_behavior;\n\t\t}\n\t\telse {\n\t\t\tdo defensive_behavior;\n\t\t}\n\t}\n\t\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of the ennemy team\n\taction defensive_behavior virtual:true {\n\t\t\n\t}\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of this team\n\taction offensive_behavior virtual:true {\n\t\t\n\t}\n\t\n\t\n\t// ASPECT ////////////////////////////////////////////////////////\n\taspect player {\n\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\n\t\tif (possess_ball) {\n\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t\telse {\n\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t}\n}\n\n\n\nspecies base_team {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat offside_pos <- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\n\t\t: min((game.players where (each.team != self)) collect (each.location.y));\n\t\n\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tstring position; // can be \"front\" or \"back\".\n\tlist<base_player> players; // all the players of the team.\n\tsoccer_game game;\n\t\n\tbase_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\n\tbase_player called_player;\n\tbool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) );\n\tbase_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\n\tlist<point> player_init_position;\n}\n\nspecies ball_sp skills:[moving] {\n\t// The ball agent.\n\tfloat speed <- 0.0;\n\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\n\treflex update {\n\t\tspeed <- speed*0.95;\n\t\tfloat future_speed <- speed;\n\t\tpoint tmpPos<-location;\n\t\tloop i from:0 to:10 {\n\t\t\ttmpPos <- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\n\t\t\tfuture_speed <- future_speed*0.9;\n\t\t}\n\t\tball_direction <- line([location,tmpPos]);\n\t\tdo wander amplitude:1;\n\t\t\n\t\t// anticipation of the ball position to detect a goal\n\t\tif ((location.y+sin(heading)*speed) > 120) {\n\t\t\twrite \"back team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tif ((location.y+sin(heading)*speed) < 0) {\n\t\t\twrite \"front team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t}\n\taction shooted (point target_position, float speed_atr) {\n\t\t// action called when a player shoots the ball\n\t\tspeed <- speed_atr;\n\t\tdo goto target:target_position;\n\t}\n\t\n\taspect ball {\n\t\tdraw circle(0.5) color:#white;\n\t}\n}\n\nspecies goal_sp {\n\tstring position; // can be \"front\" or \"back\".\n\t\n\tinit {\n\t\tcreate goal_keeper with:[position::position];\n\t}\n\t\n\taspect goal {\n\t\tdraw rectangle(7.32,1.0) color:#black;\n\t}\n}\n\nspecies goal_keeper {\n\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \n\tstring position; // can be \"front\" or \"back\".\n\tball_sp ball <- nil update:first(ball_sp);\n\t\n\treflex update when:cycle>0 {\n\t\tlocation <- {ball.location.x/90*12+(90-12)/2,location.y};\n\t\tif (ball distance_to self < 2) {\n\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\tfirst(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));\n\t\t\t\task ball {\n\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinit {\n\t\tlocation <- {45,(position=\"front\") ? 117 : 3};\n\t}\n\t\n\taction offensive_behavior {\n\t}\n\t\n\taction defensive_behavior {\n\t}\n\t\n\taspect goal_keeper {\n\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\n\t}\n}\n```\n\n\n```\n\nmodel team2strategy\n\nimport \"./soccer_base.gaml\"\n\nspecies player_stupidTeam parent:base_player {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game\n\t//closest_player_to_ball\n\t// called_player : the player called for a pass\n\t// possess_ball : true or false\n\t// player_with_ball : player currently with the ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// position_mark\n\t// status : the current status of the player (can be useful to build the model)\n\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\n\t\n\taction defensive_behavior {\t\n\t\t// very basic defensive behavior : run to the ball\n\t\tdo run_to_ball;\n\t}\n\t\n\taction offensive_behavior {\t\n\t\t// very basic offensive behavior : run to the ennemy goal, or shoot the ball when close enough from the ennemy goal.\n\t\tif ((possess_ball) and (distance_to_goal < 30)) {\n\t\t\tdo shoot;\n\t\t}\n\t\telse {\n\t\t\tdo run_to_ennemy_goal;\n\t\t}\n\t}\n\t\n}\n\nspecies stupidTeam parent:base_team {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game.\n\t// closest_player_to_ball.\n\t// called_player : the player called for a pass.\n\t// possess_ball : true when a player of the team possess the ball.\n\t// player_with_ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// player_init_position\n\t\n\t// initial position of the player in percentage : for each point,\n\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\n\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\n\tlist<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];\n}\n\n```\n\n\n```\n\nmodel soccerbase\n\nspecies soccer_game {\n\t// contains the global informations of the game\n\trgb back_color_team;\n\trgb front_color_team;\n\t\n\tball_sp ball; // the ball agent\n\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\n\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\n\tlist<base_team> teams; // contains the 2 teams\n\tlist<base_player> players; // contains all the players of the game\n\t\n\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\n\t\n\tinit {\n\t\t// create the entities ball and the 2 goals\n\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\n\t\tball <- first(var_ball);\n\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\n\t\tfront_goal <- first(var_goal1);\n\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\n\t\tback_goal <- first(var_goal2);\n\t}\n\t\n\taction reinit_phase {\n\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\n\t\task players {\n\t\t\tlocation <- init_pos;\n\t\t\tprevious_pos <- init_pos;\n\t\t}\n\t\tball.location <- world.location;\n\t\tball.destination <- world.location;\n\t\tball.speed <- 0.0;\n\t}\n}\n\nspecies base_player skills:[moving] {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\n\tfloat speed_without_ball;\n\tfloat speed_with_ball;\n\tpoint previous_pos; // used to apply inertia\n\tbool displacement_effectued<-false update:false; // we can apply only one displacement by step !\n\t\n\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tbase_team team;\n\tsoccer_game game;\n\tbase_team ennemy_team <- nil update:first(game.teams where (each.position != team.position));\n\tball_sp ball <- nil update:first(ball_sp);\n\tgoal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position));\n\tgoal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position));\n\t// ratio of avancement of the ball (from the point of view of the current team)\n\tfloat ball_advancement <- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\n\t\n\tbool possess_ball;\n\tpoint init_pos;\n\tpoint init_pos_in_percent;\n\tfloat distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player;\n\t// the number of ennemy players in a range of 15 meters\n\tint number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\n\tfloat distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\n\tfloat distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\n\t// the closest player of this team\n\tbase_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the closest ennemy player\n\tbase_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the player of this team wich has the best \"position_mark\"\n\tbase_player best_position_player <- nil update:first((team.players where (each != self)) \n\t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\n\t);\n\tfloat current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\n\tfloat position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \n\t// By default, this mark is equal to -distance_to_goal.\n\tstring status <- \"\"; // the current status of the player (can be useful to build the model)\n\tgeometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\n\n\t\n\t// CONSTRUCTOR /////////////////////////////////////////////\n\tinit {\n\t\tinit_pos <- location;\n\t\tprevious_pos <- location;\n\t\tpossess_ball <- false;\n\t\tspeed_with_ball <- 0.4;\n\t\tspeed_without_ball <- 0.5;\n\t}\n\t\n\t// ACTIONS ////////////////////////////////////////////////////\n\t\n\t// ACTIONS TO CALL FROM THE STRATEGY FILE\n\t// action to run to a particular position\n\taction run_to(point target) {\n\t\tif (!displacement_effectued) {\n\t\t\t\tdo goto target:target speed:current_speed;\n\t\t\tif (possess_ball) {\n\t\t\t\tball.location <- location;\n\t\t\t}\n\t\t\tdisplacement_effectued <- true;\n\t\t}\n\t\telse {\n\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\n\t\t}\n\t}\n\t\n\t// action to run to the ball\n\taction run_to_ball {\n\t\tpoint targetPos;\n\t\tif (ball.ball_direction intersects circle(1)) {\n\t\t\ttargetPos <- ball.location;\n\t\t}\n\t\telse {\n\t\t\ttargetPos <- (ball.ball_direction closest_points_with self) at 0;\n\t\t}\n\t\tdo run_to(targetPos);\n\t}\n\t\n\t// action to run to the ennemy goal\n\taction run_to_ennemy_goal {\n\t\tdo run_to( ennemy_goal.location );\n\t}\n\t\n\t// action to run to its own goal\n\taction run_to_own_goal {\n\t\tdo run_to( own_goal.location );\n\t}\n\t\n\t// action to mark a player\n\taction mark_player (base_player player) {\n\t\tfloat rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.\n\t\tpoint pos <- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\n\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\n\t}\n\t\n\t// action ot shoot the ball to the ennemy goal\n\taction shoot {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\n\t\t}\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball (base_player target_player) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tfloat offset <- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\n\t\t\tpoint target_point <- {target_player.location.x,target_player.location.y+offset};\n\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\n\t// try to take the ball if it is close enough\n\taction try_to_take_ball {\n\t\t// if no player has the ball\n\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\n\t\t\t// if the player is the one called (result of a pass)\n\t\t\tif (team.called_player = self) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\n\t\t\telse {\n\t\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\t\tdo take_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// the ball is possessed by the ennemy team\n\t\telse if (ennemy_team.possess_ball) {\n\t\t\t// try to catch the ball from the other player\n\t\t\tif flip(recuperation_ability) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// action of taking the ball\n\taction take_ball {\n\t\tif (ennemy_team.possess_ball) {\n\t\t\task ennemy_team.player_with_ball {\n\t\t\t\tdo loose_ball;\n\t\t\t}\n\t\t}\n\t\tpossess_ball <- true;\n\t\tball.speed <- 0.0;\n\t\tball.destination <- ball.location;\n\t\tteam.called_player <- nil;\n\t\tteam.player_with_ball <- self;\n\t\tteam.possess_ball <- true;\n\t\tgame.team_possession <- team;\n\t}\n\t\n\t// action of loosing the ball\n\taction loose_ball {\n\t\tpossess_ball <- false;\n\t\tteam.player_with_ball <- nil;\n\t\tteam.possess_ball <- false;\n\t}\n\t\n\t// apply the inertia\n\taction apply_inertia {\n\t\tpoint prev_pos <- location;\n\t\tpoint inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\n\t\tfloat max_inertia <- current_speed;\n\t\tif (norm(inertia_vect) > max_inertia) {\n\t\t\tfloat inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\n\t\t\tfloat inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\n\t\t\tinertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;\n\t\t\tinertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;\n\t\t\tinertia_vect <- {inertia_x,inertia_y};\n\t\t}\n\t\tlocation <- location + inertia_vect;\n\t\tprevious_pos <- prev_pos;\n\t}\n\t\n\t// useful functions\n\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\n\tfloat getXPos(float x_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- 90-x_ratio*90;\n\t\t}\n\t\telse {\n\t\t\tresult <- x_ratio*90;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\n\tfloat getYPos(float y_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- y_ratio*120;\n\t\t}\n\t\telse {\n\t\t\tresult <- 120-y_ratio*120;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t///////////////////////////////////////////////////////\n\t\n\t// The update function, calls the adequate behavior\n\treflex update when:cycle>1 {\n\t\tdo apply_inertia;\n\t\t// verify if it is a non-offside position\n\t\tif ( (((team.position = \"back\") and (location.y > team.offside_pos))\n\t\t\tor ((team.position = \"front\") and (location.y < team.offside_pos))) \n\t\t\tand (!possess_ball) and (self != team.called_player)\n\t\t) {\n\t\t\t// offside position, go back to a correct position\n\t\t\tpoint target_pos <- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\n\t\t\tdo run_to(target_pos);\n\t\t\tstatus <- \"offside position !\";\n\t\t}\n\t\telse if ((distance_to_ball < 2) and !possess_ball) {\n\t\t\tdo try_to_take_ball;\n\t\t}\n\t\telse if (game.team_possession = team) {\n\t\t\tdo offensive_behavior;\n\t\t}\n\t\telse {\n\t\t\tdo defensive_behavior;\n\t\t}\n\t}\n\t\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of the ennemy team\n\taction defensive_behavior virtual:true {\n\t\t\n\t}\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of this team\n\taction offensive_behavior virtual:true {\n\t\t\n\t}\n\t\n\t\n\t// ASPECT ////////////////////////////////////////////////////////\n\taspect player {\n\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\n\t\tif (possess_ball) {\n\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t\telse {\n\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t}\n}\n\n\n\nspecies base_team {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat offside_pos <- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\n\t\t: min((game.players where (each.team != self)) collect (each.location.y));\n\t\n\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tstring position; // can be \"front\" or \"back\".\n\tlist<base_player> players; // all the players of the team.\n\tsoccer_game game;\n\t\n\tbase_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\n\tbase_player called_player;\n\tbool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) );\n\tbase_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\n\tlist<point> player_init_position;\n}\n\nspecies ball_sp skills:[moving] {\n\t// The ball agent.\n\tfloat speed <- 0.0;\n\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\n\treflex update {\n\t\tspeed <- speed*0.95;\n\t\tfloat future_speed <- speed;\n\t\tpoint tmpPos<-location;\n\t\tloop i from:0 to:10 {\n\t\t\ttmpPos <- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\n\t\t\tfuture_speed <- future_speed*0.9;\n\t\t}\n\t\tball_direction <- line([location,tmpPos]);\n\t\tdo wander amplitude:1;\n\t\t\n\t\t// anticipation of the ball position to detect a goal\n\t\tif ((location.y+sin(heading)*speed) > 120) {\n\t\t\twrite \"back team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tif ((location.y+sin(heading)*speed) < 0) {\n\t\t\twrite \"front team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t}\n\taction shooted (point target_position, float speed_atr) {\n\t\t// action called when a player shoots the ball\n\t\tspeed <- speed_atr;\n\t\tdo goto target:target_position;\n\t}\n\t\n\taspect ball {\n\t\tdraw circle(0.5) color:#white;\n\t}\n}\n\nspecies goal_sp {\n\tstring position; // can be \"front\" or \"back\".\n\t\n\tinit {\n\t\tcreate goal_keeper with:[position::position];\n\t}\n\t\n\taspect goal {\n\t\tdraw rectangle(7.32,1.0) color:#black;\n\t}\n}\n\nspecies goal_keeper {\n\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \n\tstring position; // can be \"front\" or \"back\".\n\tball_sp ball <- nil update:first(ball_sp);\n\t\n\treflex update when:cycle>0 {\n\t\tlocation <- {ball.location.x/90*12+(90-12)/2,location.y};\n\t\tif (ball distance_to self < 2) {\n\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\tfirst(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));\n\t\t\t\task ball {\n\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinit {\n\t\tlocation <- {45,(position=\"front\") ? 117 : 3};\n\t}\n\t\n\taction offensive_behavior {\n\t}\n\t\n\taction defensive_behavior {\n\t}\n\t\n\taspect goal_keeper {\n\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\n\t}\n}\n```\n\n\n```\n\nmodel team1strategy\n\nimport \"./soccer_base.gaml\"\n\nspecies player_intelligentTeam parent:base_player {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game\n\t//closest_player_to_ball\n\t// called_player : the player called for a pass\n\t// possess_ball : true or false\n\t// player_with_ball : player currently with the ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// position_mark\n\t// status : the current status of the player (can be useful to build the model)\n\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\n\t\n\tfloat position_mark <- 0.0 update: location.y - 20*number_of_ennemy_player_in_range + self.distance_to_closest_ennemy_player;\t\n\tstring role; // a value between \"defense\", \"mid\" and \"attack\".\n\tstring wing; // a value between \"left\", \"center\" and \"right\".\n\tgeometry influence_area <- circle(15,init_pos);\n\t\n\tfloat defense_mid_pos <- 30.0; // the y percent chosed to separate the defense from the mid position.\n\tfloat mid_attack_pos <- 60.0; // the y percent chosen to separate the mid from the attack position.\n\t\n\tinit {\n\t\t// set the role of the player (between \"defense\", \"mid\" and \"attack\").\n\t\tif ( init_pos_in_percent.y < defense_mid_pos ) {\n\t\t\trole <- \"defense\";\n\t\t}\n\t\telse if ( (init_pos_in_percent.y > mid_attack_pos ) ) {\n\t\t\trole <- \"attack\";\n\t\t}\n\t\telse {\n\t\t\trole <- \"mid\";\n\t\t}\n\t\t// set the wing of the player (between \"left\", \"center\" and \"right\")\n\t\tif ( init_pos_in_percent.x < 40 ) {\n\t\t\twing <- \"left\";\n\t\t}\n\t\telse if ( init_pos_in_percent.x > 60 ) {\n\t\t\twing <- \"right\";\n\t\t}\n\t\telse {\n\t\t\twing <- \"center\";\n\t\t}\n\t}\n\t\n\taction update_influence_area {\n\t\tstatus <- wing + \" \" + role;\n\t\tfloat y_ratio;\n\t\tif (role = \"defense\") { // defense position from 0% to 70% from the own goal, multiplied by the percentage of advancement of the ball\n\t\t\ty_ratio <- 0.7 * ball_advancement;\n\t\t}\n\t\tif (role = \"mid\") { // mid position from 15% to 85% from the own goal, multiplied by the percentage of advancement of the ball\n\t\t\ty_ratio <- 0.15 + 0.7 * ball_advancement;\n\t\t}\n\t\tif (role = \"attack\") { // attack position from 30% to 100% from the own goal, multiplied by the percentage of advancement of the ball\n\t\t\ty_ratio <- 0.3 + 0.7 * ball_advancement;\n\t\t}\n\t\tfloat x_ratio;\n\t\tif (wing = \"center\") {\n\t\t\tx_ratio <- 0.5;\n\t\t}\n\t\telse if (wing = \"left\") {\n\t\t\tx_ratio <- 0.5 - 0.3 * cos( (y_ratio-0.5)*120 ); // the \"side\" wings are more marked if the player is in the center of the field.\n\t\t}\n\t\telse {\n\t\t\tx_ratio <- 0.5 + 0.3 * cos( (y_ratio-0.5)*120 );\n\t\t}\n\t\tinfluence_area <- circle(15,{getXPos(x_ratio),getYPos(y_ratio)});\n\t}\n\t\n\taction defensive_behavior {\t\n\t\tdo update_influence_area;\n\t\t// advanced defensive behavior\n\t\t// run to the ball if the player is the closest player from the ball.\n\t\tif ((self = team.closest_player_to_ball) or (self distance_to ball < 5)) {\n\t\t\tstatus <- getStatus(\"run to ball\");\n\t\t\tdo run_to_ball;\n\t\t}\n\t\telse {\n\t\t\t// if there is an ennemy player in the influence area, mark the player.\n\t\t\tif ( length(self.ennemy_team.players where (each intersects influence_area)) != 0 ) {\n\t\t\t\tbase_player marked_player <- first(1 among (self.ennemy_team.players where (each intersects influence_area)));\n\t\t\t\tstatus <- getStatus(\"mark player \"+marked_player);\n\t\t\t\tdo mark_player( marked_player );\n\t\t\t}\n\t\t\t// if there is no ennemy player in the influence area, stay in influence area.\n\t\t\telse {\n\t\t\t\tstatus <- getStatus(\"run to influence area\");\n\t\t\t\tdo run_to(influence_area.location);\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction offensive_behavior {\t\n\t\tdo update_influence_area;\n\t\t// advanced offensive behavior\n\t\tif (possess_ball) {\n\t\t\t// if the player has the ball and is close enough to the ennemy goal, shoot.\n\t\t\tif (distance_to_goal < 35 and flip(1/(0.1+(self.distance_to_goal/10)^2))) {\n\t\t\t\tstatus <- getStatus(\"shoot the ball\");\n\t\t\t\tdo shoot;\n\t\t\t}\n\t\t\t// if the player has the ball and is in a safe position, run to the ennemy goal.\n\t\t\telse if ( (position_mark = max( team.players collect (each.position_mark) )) or (distance_to_closest_ennemy_player > 2) )\n\t\t\t{\n\t\t\t\tstatus <- getStatus(\"run to ennemy goal\");\n\t\t\t\tdo run_to_ennemy_goal;\n\t\t\t}\n\t\t\t// if the player has the ball but is in a dangerous situation, pass the ball to another player.\n\t\t\telse {\n\t\t\t\tbase_player target_player <- first(team.players where (each.position_mark = max( team.players collect (each.position_mark)) ) );\n\t\t\t\tstatus <- getStatus(\"pass the ball to \"+target_player);\n\t\t\t\tdo pass_the_ball_ahead ( target_player,10.0 );\n\t\t\t}\n\t\t}\n\t\t// if the player has not the ball but is the called player, run to the ball.\n\t\telse if (self = team.called_player) {\n\t\t\tstatus <- getStatus(\"run to ball\");\n\t\t\tdo run_to_ball;\n\t\t\tstatus <- \"called player\";\n\t\t}\n\t\t// else, run to influence area.\n\t\telse {\n\t\t\tstatus <- getStatus(\"run to influence area\");\n\t\t\tdo run_to(influence_area.location);\n\t\t}\n\t}\n\t\n\tstring getStatus(string str) {\n\t\treturn wing + \" \" + role + \"| action : \" + str;\n\t}\n\t\n}\n\nspecies intelligentTeam parent:base_team {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game.\n\t// closest_player_to_ball.\n\t// called_player : the player called for a pass.\n\t// possess_ball : true when a player of the team possess the ball.\n\t// player_with_ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// player_init_position\n\t\n\t// initial position of the player in percentage : for each point,\n\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\n\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\n\tlist<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];\n}\n\n```\n\n\nCode of the model : \n\n```\n\nmodel soccerexpe\n\n// import the 2 strategies\nimport \"./team1_strategy.gaml\"\nimport \"./team2_strategy.gaml\"\n\nglobal {\n\t// set the size of the environment\n\tgeometry shape <- rectangle(90#m,120#m);\n\t\n\tbool show_info <- false;\n\t\n\trgb back_color_team <- #blue;\n\trgb front_color_team <- #red;\n}\n\nspecies info_player1 mirrors:player_intelligentTeam {\n\t// mirror species that shows additionnal information about the player\n\tpoint location <- target.location update:target.location;\n\tstring status <- target.status update:target.status;\n\tfloat speed <- target.speed update:target.speed;\n\tgeometry influence_area <- target.influence_area update:target.influence_area;\n\taspect info {\n\t\tif (show_info) {\n\t\t\tdraw status color:#black;\n\t\t\tdraw influence_area color:rgb(200,200,255,0) border:rgb(200,200,255,255);\n\t\t}\n\t}\n}\n\nspecies info_player2 mirrors:player_stupidTeam {\n\t// mirror species that shows additionnal information about the player\n\tpoint location <- target.location update:target.location;\n\tstring status <- target.status update:target.status;\n\tfloat speed <- target.speed update:target.speed;\n\tgeometry influence_area <- target.influence_area update:target.influence_area;\n\taspect info {\n\t\tif (show_info) {\n\t\t\tdraw status color:#black;\n\t\t\tdraw influence_area color:rgb(255,200,200,0) border:rgb(255,200,200,255);\n\t\t}\n\t}\n}\n\nexperiment intelligentTeam_vs_stupidTeam type:gui {\n\tinit {\n\t\t// instantialization of the game (contains global information about the game)\n\t\tcreate soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;\n\t\t// instantialization of the teams\n\t\tcreate intelligentTeam with:(game:first(soccerGame),position:\"back\");\n\t\tcreate stupidTeam with:(game:first(soccerGame),position:\"front\");\n\t\tadd first(intelligentTeam) to:first(soccerGame).teams;\n\t\tadd first(stupidTeam) to:first(soccerGame).teams;\n\t\t// create players of the team1\n\t\tlist<player_intelligentTeam> player_list1;\n\t\tloop pos over:first(intelligentTeam).player_init_position {\n\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\n\t\t\tpoint real_pos <- (first(intelligentTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\n\t\t\tcreate player_intelligentTeam with:(team:first(intelligentTeam),game:first(intelligentTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\n\t\t\tadd first(pl) to:player_list1;\n\t\t}\n\t\tfirst(intelligentTeam).players <- player_list1;\n\t\t// create players of the team2\n\t\tlist<player_stupidTeam> player_list2;\n\t\tloop pos over:first(stupidTeam).player_init_position {\n\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\n\t\t\tpoint real_pos <- (first(stupidTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\n\t\t\tcreate player_stupidTeam with:(team:first(stupidTeam),game:first(stupidTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\n\t\t\tadd first(pl) to:player_list2;\n\t\t}\n\t\tfirst(stupidTeam).players <- player_list2;\n\t\tfirst(soccerGame).players <- player_list1+player_list2;\n\t}\n\tparameter \"show player info\" var:show_info;\n\toutput {\n\t\tdisplay \"soccer_field\"  {\n\t\t\t// display the field.\n\t\t\timage \"../images/soccer_field2.png\";\n\t\t\t// display the species with their correct aspect\n\t\t\tspecies player_intelligentTeam aspect:player;\n\t\t\tspecies player_stupidTeam aspect:player;\n\t\t\tspecies ball_sp aspect:ball;\n\t\t\tspecies goal_sp aspect:goal;\n\t\t\tspecies goal_keeper aspect:goal_keeper;\n\t\t\tspecies info_player1 aspect:info;\n\t\t\tspecies info_player2 aspect:info;\n\t\t}\n\t}\n}\n\nexperiment intelligentTeam_vs_intelligentTeam type:gui {\n\tinit {\n\t\t// instantialization of the game (contains global information about the game)\n\t\tcreate soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;\n\t\t// instantialization of the teams\n\t\tcreate intelligentTeam with:(game:first(soccerGame),position:\"back\") returns:backTeam;\n\t\tcreate intelligentTeam with:(game:first(soccerGame),position:\"front\") returns:frontTeam;\n\t\t\n\t\tadd first(backTeam) to:first(soccerGame).teams;\n\t\tadd first(frontTeam) to:first(soccerGame).teams;\n\t\t// create players of the team1\n\t\tlist<player_intelligentTeam> player_list1;\n\t\tloop pos over:first(backTeam).player_init_position {\n\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\n\t\t\tpoint real_pos <- (first(backTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\n\t\t\tcreate player_intelligentTeam with:(team:first(backTeam),game:first(backTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\n\t\t\tadd first(pl) to:player_list1;\n\t\t}\n\t\tfirst(backTeam).players <- player_list1;\n\t\t// create players of the team2\n\t\tlist<player_intelligentTeam> player_list2;\n\t\tloop pos over:first(frontTeam).player_init_position {\n\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\n\t\t\tpoint real_pos <- (first(frontTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\n\t\t\tcreate player_intelligentTeam with:(team:first(frontTeam),game:first(frontTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\n\t\t\tadd first(pl) to:player_list2;\n\t\t}\n\t\tfirst(frontTeam).players <- player_list2;\n\t\tfirst(soccerGame).players <- player_list1+player_list2;\n\t}\n\tparameter \"show player info\" var:show_info;\n\toutput {\n\t\tdisplay \"soccer_field\"  {\n\t\t\t// display the field.\n\t\t\timage \"../images/soccer_field2.png\";\n\t\t\t// display the species with their correct aspect\n\t\t\tspecies player_intelligentTeam aspect:player;\n\t\t\tspecies ball_sp aspect:ball;\n\t\t\tspecies goal_sp aspect:goal;\n\t\t\tspecies goal_keeper aspect:goal_keeper;\n\t\t\tspecies info_player1 aspect:info;\n\t\t\tspecies info_player2 aspect:info;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Soccer-soccer_expe.md"},"Soccer-team1_strategy.md":{"title":" _team1strategy","content":"[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_closest_points_with)\n[//]: # (keyword|operator_norm)\n[//]: # (keyword|operator_sqrt)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_sin)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|operator_^)\n# _team1strategy\n\n\n_Author : Julien_\n\nThis model contains one of the 2 team strategy. This strategy is quite advanced, attributing role for each player, with a custom influence_area and a custom position_mark.\n\n\nImported model : \n\n```\n\nmodel soccerbase\n\nspecies soccer_game {\n\t// contains the global informations of the game\n\trgb back_color_team;\n\trgb front_color_team;\n\t\n\tball_sp ball; // the ball agent\n\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\n\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\n\tlist<base_team> teams; // contains the 2 teams\n\tlist<base_player> players; // contains all the players of the game\n\t\n\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\n\t\n\tinit {\n\t\t// create the entities ball and the 2 goals\n\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\n\t\tball <- first(var_ball);\n\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\n\t\tfront_goal <- first(var_goal1);\n\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\n\t\tback_goal <- first(var_goal2);\n\t}\n\t\n\taction reinit_phase {\n\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\n\t\task players {\n\t\t\tlocation <- init_pos;\n\t\t\tprevious_pos <- init_pos;\n\t\t}\n\t\tball.location <- world.location;\n\t\tball.destination <- world.location;\n\t\tball.speed <- 0.0;\n\t}\n}\n\nspecies base_player skills:[moving] {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\n\tfloat speed_without_ball;\n\tfloat speed_with_ball;\n\tpoint previous_pos; // used to apply inertia\n\tbool displacement_effectued<-false update:false; // we can apply only one displacement by step !\n\t\n\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tbase_team team;\n\tsoccer_game game;\n\tbase_team ennemy_team <- nil update:first(game.teams where (each.position != team.position));\n\tball_sp ball <- nil update:first(ball_sp);\n\tgoal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position));\n\tgoal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position));\n\t// ratio of avancement of the ball (from the point of view of the current team)\n\tfloat ball_advancement <- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\n\t\n\tbool possess_ball;\n\tpoint init_pos;\n\tpoint init_pos_in_percent;\n\tfloat distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player;\n\t// the number of ennemy players in a range of 15 meters\n\tint number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\n\tfloat distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\n\tfloat distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\n\t// the closest player of this team\n\tbase_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the closest ennemy player\n\tbase_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the player of this team wich has the best \"position_mark\"\n\tbase_player best_position_player <- nil update:first((team.players where (each != self)) \n\t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\n\t);\n\tfloat current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\n\tfloat position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \n\t// By default, this mark is equal to -distance_to_goal.\n\tstring status <- \"\"; // the current status of the player (can be useful to build the model)\n\tgeometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\n\n\t\n\t// CONSTRUCTOR /////////////////////////////////////////////\n\tinit {\n\t\tinit_pos <- location;\n\t\tprevious_pos <- location;\n\t\tpossess_ball <- false;\n\t\tspeed_with_ball <- 0.4;\n\t\tspeed_without_ball <- 0.5;\n\t}\n\t\n\t// ACTIONS ////////////////////////////////////////////////////\n\t\n\t// ACTIONS TO CALL FROM THE STRATEGY FILE\n\t// action to run to a particular position\n\taction run_to(point target) {\n\t\tif (!displacement_effectued) {\n\t\t\t\tdo goto target:target speed:current_speed;\n\t\t\tif (possess_ball) {\n\t\t\t\tball.location <- location;\n\t\t\t}\n\t\t\tdisplacement_effectued <- true;\n\t\t}\n\t\telse {\n\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\n\t\t}\n\t}\n\t\n\t// action to run to the ball\n\taction run_to_ball {\n\t\tpoint targetPos;\n\t\tif (ball.ball_direction intersects circle(1)) {\n\t\t\ttargetPos <- ball.location;\n\t\t}\n\t\telse {\n\t\t\ttargetPos <- (ball.ball_direction closest_points_with self) at 0;\n\t\t}\n\t\tdo run_to(targetPos);\n\t}\n\t\n\t// action to run to the ennemy goal\n\taction run_to_ennemy_goal {\n\t\tdo run_to( ennemy_goal.location );\n\t}\n\t\n\t// action to run to its own goal\n\taction run_to_own_goal {\n\t\tdo run_to( own_goal.location );\n\t}\n\t\n\t// action to mark a player\n\taction mark_player (base_player player) {\n\t\tfloat rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.\n\t\tpoint pos <- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\n\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\n\t}\n\t\n\t// action ot shoot the ball to the ennemy goal\n\taction shoot {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\n\t\t}\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball (base_player target_player) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tfloat offset <- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\n\t\t\tpoint target_point <- {target_player.location.x,target_player.location.y+offset};\n\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\n\t// try to take the ball if it is close enough\n\taction try_to_take_ball {\n\t\t// if no player has the ball\n\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\n\t\t\t// if the player is the one called (result of a pass)\n\t\t\tif (team.called_player = self) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\n\t\t\telse {\n\t\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\t\tdo take_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// the ball is possessed by the ennemy team\n\t\telse if (ennemy_team.possess_ball) {\n\t\t\t// try to catch the ball from the other player\n\t\t\tif flip(recuperation_ability) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// action of taking the ball\n\taction take_ball {\n\t\tif (ennemy_team.possess_ball) {\n\t\t\task ennemy_team.player_with_ball {\n\t\t\t\tdo loose_ball;\n\t\t\t}\n\t\t}\n\t\tpossess_ball <- true;\n\t\tball.speed <- 0.0;\n\t\tball.destination <- ball.location;\n\t\tteam.called_player <- nil;\n\t\tteam.player_with_ball <- self;\n\t\tteam.possess_ball <- true;\n\t\tgame.team_possession <- team;\n\t}\n\t\n\t// action of loosing the ball\n\taction loose_ball {\n\t\tpossess_ball <- false;\n\t\tteam.player_with_ball <- nil;\n\t\tteam.possess_ball <- false;\n\t}\n\t\n\t// apply the inertia\n\taction apply_inertia {\n\t\tpoint prev_pos <- location;\n\t\tpoint inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\n\t\tfloat max_inertia <- current_speed;\n\t\tif (norm(inertia_vect) > max_inertia) {\n\t\t\tfloat inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\n\t\t\tfloat inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\n\t\t\tinertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;\n\t\t\tinertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;\n\t\t\tinertia_vect <- {inertia_x,inertia_y};\n\t\t}\n\t\tlocation <- location + inertia_vect;\n\t\tprevious_pos <- prev_pos;\n\t}\n\t\n\t// useful functions\n\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\n\tfloat getXPos(float x_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- 90-x_ratio*90;\n\t\t}\n\t\telse {\n\t\t\tresult <- x_ratio*90;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\n\tfloat getYPos(float y_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- y_ratio*120;\n\t\t}\n\t\telse {\n\t\t\tresult <- 120-y_ratio*120;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t///////////////////////////////////////////////////////\n\t\n\t// The update function, calls the adequate behavior\n\treflex update when:cycle>1 {\n\t\tdo apply_inertia;\n\t\t// verify if it is a non-offside position\n\t\tif ( (((team.position = \"back\") and (location.y > team.offside_pos))\n\t\t\tor ((team.position = \"front\") and (location.y < team.offside_pos))) \n\t\t\tand (!possess_ball) and (self != team.called_player)\n\t\t) {\n\t\t\t// offside position, go back to a correct position\n\t\t\tpoint target_pos <- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\n\t\t\tdo run_to(target_pos);\n\t\t\tstatus <- \"offside position !\";\n\t\t}\n\t\telse if ((distance_to_ball < 2) and !possess_ball) {\n\t\t\tdo try_to_take_ball;\n\t\t}\n\t\telse if (game.team_possession = team) {\n\t\t\tdo offensive_behavior;\n\t\t}\n\t\telse {\n\t\t\tdo defensive_behavior;\n\t\t}\n\t}\n\t\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of the ennemy team\n\taction defensive_behavior virtual:true {\n\t\t\n\t}\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of this team\n\taction offensive_behavior virtual:true {\n\t\t\n\t}\n\t\n\t\n\t// ASPECT ////////////////////////////////////////////////////////\n\taspect player {\n\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\n\t\tif (possess_ball) {\n\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t\telse {\n\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t}\n}\n\n\n\nspecies base_team {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat offside_pos <- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\n\t\t: min((game.players where (each.team != self)) collect (each.location.y));\n\t\n\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tstring position; // can be \"front\" or \"back\".\n\tlist<base_player> players; // all the players of the team.\n\tsoccer_game game;\n\t\n\tbase_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\n\tbase_player called_player;\n\tbool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) );\n\tbase_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\n\tlist<point> player_init_position;\n}\n\nspecies ball_sp skills:[moving] {\n\t// The ball agent.\n\tfloat speed <- 0.0;\n\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\n\treflex update {\n\t\tspeed <- speed*0.95;\n\t\tfloat future_speed <- speed;\n\t\tpoint tmpPos<-location;\n\t\tloop i from:0 to:10 {\n\t\t\ttmpPos <- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\n\t\t\tfuture_speed <- future_speed*0.9;\n\t\t}\n\t\tball_direction <- line([location,tmpPos]);\n\t\tdo wander amplitude:1;\n\t\t\n\t\t// anticipation of the ball position to detect a goal\n\t\tif ((location.y+sin(heading)*speed) > 120) {\n\t\t\twrite \"back team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tif ((location.y+sin(heading)*speed) < 0) {\n\t\t\twrite \"front team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t}\n\taction shooted (point target_position, float speed_atr) {\n\t\t// action called when a player shoots the ball\n\t\tspeed <- speed_atr;\n\t\tdo goto target:target_position;\n\t}\n\t\n\taspect ball {\n\t\tdraw circle(0.5) color:#white;\n\t}\n}\n\nspecies goal_sp {\n\tstring position; // can be \"front\" or \"back\".\n\t\n\tinit {\n\t\tcreate goal_keeper with:[position::position];\n\t}\n\t\n\taspect goal {\n\t\tdraw rectangle(7.32,1.0) color:#black;\n\t}\n}\n\nspecies goal_keeper {\n\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \n\tstring position; // can be \"front\" or \"back\".\n\tball_sp ball <- nil update:first(ball_sp);\n\t\n\treflex update when:cycle>0 {\n\t\tlocation <- {ball.location.x/90*12+(90-12)/2,location.y};\n\t\tif (ball distance_to self < 2) {\n\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\tfirst(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));\n\t\t\t\task ball {\n\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinit {\n\t\tlocation <- {45,(position=\"front\") ? 117 : 3};\n\t}\n\t\n\taction offensive_behavior {\n\t}\n\t\n\taction defensive_behavior {\n\t}\n\t\n\taspect goal_keeper {\n\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\n\t}\n}\n```\n\n\nCode of the model : \n\n```\n\nmodel team1strategy\n\nimport \"./soccer_base.gaml\"\n\nspecies player_intelligentTeam parent:base_player {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game\n\t//closest_player_to_ball\n\t// called_player : the player called for a pass\n\t// possess_ball : true or false\n\t// player_with_ball : player currently with the ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// position_mark\n\t// status : the current status of the player (can be useful to build the model)\n\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\n\t\n\tfloat position_mark <- 0.0 update: location.y - 20*number_of_ennemy_player_in_range + self.distance_to_closest_ennemy_player;\t\n\tstring role; // a value between \"defense\", \"mid\" and \"attack\".\n\tstring wing; // a value between \"left\", \"center\" and \"right\".\n\tgeometry influence_area <- circle(15,init_pos);\n\t\n\tfloat defense_mid_pos <- 30.0; // the y percent chosed to separate the defense from the mid position.\n\tfloat mid_attack_pos <- 60.0; // the y percent chosen to separate the mid from the attack position.\n\t\n\tinit {\n\t\t// set the role of the player (between \"defense\", \"mid\" and \"attack\").\n\t\tif ( init_pos_in_percent.y < defense_mid_pos ) {\n\t\t\trole <- \"defense\";\n\t\t}\n\t\telse if ( (init_pos_in_percent.y > mid_attack_pos ) ) {\n\t\t\trole <- \"attack\";\n\t\t}\n\t\telse {\n\t\t\trole <- \"mid\";\n\t\t}\n\t\t// set the wing of the player (between \"left\", \"center\" and \"right\")\n\t\tif ( init_pos_in_percent.x < 40 ) {\n\t\t\twing <- \"left\";\n\t\t}\n\t\telse if ( init_pos_in_percent.x > 60 ) {\n\t\t\twing <- \"right\";\n\t\t}\n\t\telse {\n\t\t\twing <- \"center\";\n\t\t}\n\t}\n\t\n\taction update_influence_area {\n\t\tstatus <- wing + \" \" + role;\n\t\tfloat y_ratio;\n\t\tif (role = \"defense\") { // defense position from 0% to 70% from the own goal, multiplied by the percentage of advancement of the ball\n\t\t\ty_ratio <- 0.7 * ball_advancement;\n\t\t}\n\t\tif (role = \"mid\") { // mid position from 15% to 85% from the own goal, multiplied by the percentage of advancement of the ball\n\t\t\ty_ratio <- 0.15 + 0.7 * ball_advancement;\n\t\t}\n\t\tif (role = \"attack\") { // attack position from 30% to 100% from the own goal, multiplied by the percentage of advancement of the ball\n\t\t\ty_ratio <- 0.3 + 0.7 * ball_advancement;\n\t\t}\n\t\tfloat x_ratio;\n\t\tif (wing = \"center\") {\n\t\t\tx_ratio <- 0.5;\n\t\t}\n\t\telse if (wing = \"left\") {\n\t\t\tx_ratio <- 0.5 - 0.3 * cos( (y_ratio-0.5)*120 ); // the \"side\" wings are more marked if the player is in the center of the field.\n\t\t}\n\t\telse {\n\t\t\tx_ratio <- 0.5 + 0.3 * cos( (y_ratio-0.5)*120 );\n\t\t}\n\t\tinfluence_area <- circle(15,{getXPos(x_ratio),getYPos(y_ratio)});\n\t}\n\t\n\taction defensive_behavior {\t\n\t\tdo update_influence_area;\n\t\t// advanced defensive behavior\n\t\t// run to the ball if the player is the closest player from the ball.\n\t\tif ((self = team.closest_player_to_ball) or (self distance_to ball < 5)) {\n\t\t\tstatus <- getStatus(\"run to ball\");\n\t\t\tdo run_to_ball;\n\t\t}\n\t\telse {\n\t\t\t// if there is an ennemy player in the influence area, mark the player.\n\t\t\tif ( length(self.ennemy_team.players where (each intersects influence_area)) != 0 ) {\n\t\t\t\tbase_player marked_player <- first(1 among (self.ennemy_team.players where (each intersects influence_area)));\n\t\t\t\tstatus <- getStatus(\"mark player \"+marked_player);\n\t\t\t\tdo mark_player( marked_player );\n\t\t\t}\n\t\t\t// if there is no ennemy player in the influence area, stay in influence area.\n\t\t\telse {\n\t\t\t\tstatus <- getStatus(\"run to influence area\");\n\t\t\t\tdo run_to(influence_area.location);\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction offensive_behavior {\t\n\t\tdo update_influence_area;\n\t\t// advanced offensive behavior\n\t\tif (possess_ball) {\n\t\t\t// if the player has the ball and is close enough to the ennemy goal, shoot.\n\t\t\tif (distance_to_goal < 35 and flip(1/(0.1+(self.distance_to_goal/10)^2))) {\n\t\t\t\tstatus <- getStatus(\"shoot the ball\");\n\t\t\t\tdo shoot;\n\t\t\t}\n\t\t\t// if the player has the ball and is in a safe position, run to the ennemy goal.\n\t\t\telse if ( (position_mark = max( team.players collect (each.position_mark) )) or (distance_to_closest_ennemy_player > 2) )\n\t\t\t{\n\t\t\t\tstatus <- getStatus(\"run to ennemy goal\");\n\t\t\t\tdo run_to_ennemy_goal;\n\t\t\t}\n\t\t\t// if the player has the ball but is in a dangerous situation, pass the ball to another player.\n\t\t\telse {\n\t\t\t\tbase_player target_player <- first(team.players where (each.position_mark = max( team.players collect (each.position_mark)) ) );\n\t\t\t\tstatus <- getStatus(\"pass the ball to \"+target_player);\n\t\t\t\tdo pass_the_ball_ahead ( target_player,10.0 );\n\t\t\t}\n\t\t}\n\t\t// if the player has not the ball but is the called player, run to the ball.\n\t\telse if (self = team.called_player) {\n\t\t\tstatus <- getStatus(\"run to ball\");\n\t\t\tdo run_to_ball;\n\t\t\tstatus <- \"called player\";\n\t\t}\n\t\t// else, run to influence area.\n\t\telse {\n\t\t\tstatus <- getStatus(\"run to influence area\");\n\t\t\tdo run_to(influence_area.location);\n\t\t}\n\t}\n\t\n\tstring getStatus(string str) {\n\t\treturn wing + \" \" + role + \"| action : \" + str;\n\t}\n\t\n}\n\nspecies intelligentTeam parent:base_team {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game.\n\t// closest_player_to_ball.\n\t// called_player : the player called for a pass.\n\t// possess_ball : true when a player of the team possess the ball.\n\t// player_with_ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// player_init_position\n\t\n\t// initial position of the player in percentage : for each point,\n\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\n\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\n\tlist<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];\n}\n\n```\n","url":"wiki/Soccer-team1_strategy.md"},"Soccer-team2_strategy.md":{"title":" _team2strategy","content":"[//]: # (keyword|operator_intersects)\n[//]: # (keyword|operator_closest_points_with)\n[//]: # (keyword|operator_norm)\n[//]: # (keyword|operator_sqrt)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_sin)\n# _team2strategy\n\n\n_Author : Julien_\n\nThis model contains one of the 2 team strategy. This strategy is very stupid : when you have the ball, run to the ennemy goal, else run to the ball\n\n\nImported model : \n\n```\n\nmodel soccerbase\n\nspecies soccer_game {\n\t// contains the global informations of the game\n\trgb back_color_team;\n\trgb front_color_team;\n\t\n\tball_sp ball; // the ball agent\n\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\n\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\n\tlist<base_team> teams; // contains the 2 teams\n\tlist<base_player> players; // contains all the players of the game\n\t\n\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\n\t\n\tinit {\n\t\t// create the entities ball and the 2 goals\n\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\n\t\tball <- first(var_ball);\n\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\n\t\tfront_goal <- first(var_goal1);\n\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\n\t\tback_goal <- first(var_goal2);\n\t}\n\t\n\taction reinit_phase {\n\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\n\t\task players {\n\t\t\tlocation <- init_pos;\n\t\t\tprevious_pos <- init_pos;\n\t\t}\n\t\tball.location <- world.location;\n\t\tball.destination <- world.location;\n\t\tball.speed <- 0.0;\n\t}\n}\n\nspecies base_player skills:[moving] {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\n\tfloat speed_without_ball;\n\tfloat speed_with_ball;\n\tpoint previous_pos; // used to apply inertia\n\tbool displacement_effectued<-false update:false; // we can apply only one displacement by step !\n\t\n\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tbase_team team;\n\tsoccer_game game;\n\tbase_team ennemy_team <- nil update:first(game.teams where (each.position != team.position));\n\tball_sp ball <- nil update:first(ball_sp);\n\tgoal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position));\n\tgoal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position));\n\t// ratio of avancement of the ball (from the point of view of the current team)\n\tfloat ball_advancement <- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\n\t\n\tbool possess_ball;\n\tpoint init_pos;\n\tpoint init_pos_in_percent;\n\tfloat distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player;\n\t// the number of ennemy players in a range of 15 meters\n\tint number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\n\tfloat distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\n\tfloat distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\n\t// the closest player of this team\n\tbase_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the closest ennemy player\n\tbase_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \n\t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \n\t);\n\t// the player of this team wich has the best \"position_mark\"\n\tbase_player best_position_player <- nil update:first((team.players where (each != self)) \n\t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\n\t);\n\tfloat current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\n\tfloat position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \n\t// By default, this mark is equal to -distance_to_goal.\n\tstring status <- \"\"; // the current status of the player (can be useful to build the model)\n\tgeometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\n\n\t\n\t// CONSTRUCTOR /////////////////////////////////////////////\n\tinit {\n\t\tinit_pos <- location;\n\t\tprevious_pos <- location;\n\t\tpossess_ball <- false;\n\t\tspeed_with_ball <- 0.4;\n\t\tspeed_without_ball <- 0.5;\n\t}\n\t\n\t// ACTIONS ////////////////////////////////////////////////////\n\t\n\t// ACTIONS TO CALL FROM THE STRATEGY FILE\n\t// action to run to a particular position\n\taction run_to(point target) {\n\t\tif (!displacement_effectued) {\n\t\t\t\tdo goto target:target speed:current_speed;\n\t\t\tif (possess_ball) {\n\t\t\t\tball.location <- location;\n\t\t\t}\n\t\t\tdisplacement_effectued <- true;\n\t\t}\n\t\telse {\n\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\n\t\t}\n\t}\n\t\n\t// action to run to the ball\n\taction run_to_ball {\n\t\tpoint targetPos;\n\t\tif (ball.ball_direction intersects circle(1)) {\n\t\t\ttargetPos <- ball.location;\n\t\t}\n\t\telse {\n\t\t\ttargetPos <- (ball.ball_direction closest_points_with self) at 0;\n\t\t}\n\t\tdo run_to(targetPos);\n\t}\n\t\n\t// action to run to the ennemy goal\n\taction run_to_ennemy_goal {\n\t\tdo run_to( ennemy_goal.location );\n\t}\n\t\n\t// action to run to its own goal\n\taction run_to_own_goal {\n\t\tdo run_to( own_goal.location );\n\t}\n\t\n\t// action to mark a player\n\taction mark_player (base_player player) {\n\t\tfloat rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.\n\t\tpoint pos <- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\n\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\n\t}\n\t\n\t// action ot shoot the ball to the ennemy goal\n\taction shoot {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\n\t\t}\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball (base_player target_player) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// action to pass the ball to an ally\n\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\n\t\tdo loose_ball;\n\t\task ball {\n\t\t\tfloat offset <- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\n\t\t\tpoint target_point <- {target_player.location.x,target_player.location.y+offset};\n\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\n\t\t}\n\t\tteam.called_player <- target_player;\n\t}\n\t\n\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\n\t// try to take the ball if it is close enough\n\taction try_to_take_ball {\n\t\t// if no player has the ball\n\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\n\t\t\t// if the player is the one called (result of a pass)\n\t\t\tif (team.called_player = self) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\n\t\t\telse {\n\t\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\t\tdo take_ball;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// the ball is possessed by the ennemy team\n\t\telse if (ennemy_team.possess_ball) {\n\t\t\t// try to catch the ball from the other player\n\t\t\tif flip(recuperation_ability) {\n\t\t\t\tdo take_ball;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// action of taking the ball\n\taction take_ball {\n\t\tif (ennemy_team.possess_ball) {\n\t\t\task ennemy_team.player_with_ball {\n\t\t\t\tdo loose_ball;\n\t\t\t}\n\t\t}\n\t\tpossess_ball <- true;\n\t\tball.speed <- 0.0;\n\t\tball.destination <- ball.location;\n\t\tteam.called_player <- nil;\n\t\tteam.player_with_ball <- self;\n\t\tteam.possess_ball <- true;\n\t\tgame.team_possession <- team;\n\t}\n\t\n\t// action of loosing the ball\n\taction loose_ball {\n\t\tpossess_ball <- false;\n\t\tteam.player_with_ball <- nil;\n\t\tteam.possess_ball <- false;\n\t}\n\t\n\t// apply the inertia\n\taction apply_inertia {\n\t\tpoint prev_pos <- location;\n\t\tpoint inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\n\t\tfloat max_inertia <- current_speed;\n\t\tif (norm(inertia_vect) > max_inertia) {\n\t\t\tfloat inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\n\t\t\tfloat inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\n\t\t\tinertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;\n\t\t\tinertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;\n\t\t\tinertia_vect <- {inertia_x,inertia_y};\n\t\t}\n\t\tlocation <- location + inertia_vect;\n\t\tprevious_pos <- prev_pos;\n\t}\n\t\n\t// useful functions\n\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\n\tfloat getXPos(float x_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- 90-x_ratio*90;\n\t\t}\n\t\telse {\n\t\t\tresult <- x_ratio*90;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\n\tfloat getYPos(float y_ratio) {\n\t\tfloat result;\n\t\tif (team.position=\"back\") {\n\t\t\tresult <- y_ratio*120;\n\t\t}\n\t\telse {\n\t\t\tresult <- 120-y_ratio*120;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t///////////////////////////////////////////////////////\n\t\n\t// The update function, calls the adequate behavior\n\treflex update when:cycle>1 {\n\t\tdo apply_inertia;\n\t\t// verify if it is a non-offside position\n\t\tif ( (((team.position = \"back\") and (location.y > team.offside_pos))\n\t\t\tor ((team.position = \"front\") and (location.y < team.offside_pos))) \n\t\t\tand (!possess_ball) and (self != team.called_player)\n\t\t) {\n\t\t\t// offside position, go back to a correct position\n\t\t\tpoint target_pos <- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\n\t\t\tdo run_to(target_pos);\n\t\t\tstatus <- \"offside position !\";\n\t\t}\n\t\telse if ((distance_to_ball < 2) and !possess_ball) {\n\t\t\tdo try_to_take_ball;\n\t\t}\n\t\telse if (game.team_possession = team) {\n\t\t\tdo offensive_behavior;\n\t\t}\n\t\telse {\n\t\t\tdo defensive_behavior;\n\t\t}\n\t}\n\t\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of the ennemy team\n\taction defensive_behavior virtual:true {\n\t\t\n\t}\n\t// defensive behavior, need to be redefined in the strategy file.\n\t// this action is called when the last player who was holding the ball was a player of this team\n\taction offensive_behavior virtual:true {\n\t\t\n\t}\n\t\n\t\n\t// ASPECT ////////////////////////////////////////////////////////\n\taspect player {\n\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\n\t\tif (possess_ball) {\n\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t\telse {\n\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\n\t\t}\n\t}\n}\n\n\n\nspecies base_team {\n\t// ATTRIBUTES ////////////////////////////////////////////////\n\t\n\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\n\tfloat offside_pos <- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\n\t\t: min((game.players where (each.team != self)) collect (each.location.y));\n\t\n\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\n\tstring position; // can be \"front\" or \"back\".\n\tlist<base_player> players; // all the players of the team.\n\tsoccer_game game;\n\t\n\tbase_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\n\tbase_player called_player;\n\tbool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) );\n\tbase_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));\n\t\n\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\n\tlist<point> player_init_position;\n}\n\nspecies ball_sp skills:[moving] {\n\t// The ball agent.\n\tfloat speed <- 0.0;\n\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\n\treflex update {\n\t\tspeed <- speed*0.95;\n\t\tfloat future_speed <- speed;\n\t\tpoint tmpPos<-location;\n\t\tloop i from:0 to:10 {\n\t\t\ttmpPos <- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\n\t\t\tfuture_speed <- future_speed*0.9;\n\t\t}\n\t\tball_direction <- line([location,tmpPos]);\n\t\tdo wander amplitude:1;\n\t\t\n\t\t// anticipation of the ball position to detect a goal\n\t\tif ((location.y+sin(heading)*speed) > 120) {\n\t\t\twrite \"back team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t\tif ((location.y+sin(heading)*speed) < 0) {\n\t\t\twrite \"front team score a goal !!\";\n\t\t\task first(soccer_game) {\n\t\t\t\tdo reinit_phase;\n\t\t\t}\n\t\t}\n\t}\n\taction shooted (point target_position, float speed_atr) {\n\t\t// action called when a player shoots the ball\n\t\tspeed <- speed_atr;\n\t\tdo goto target:target_position;\n\t}\n\t\n\taspect ball {\n\t\tdraw circle(0.5) color:#white;\n\t}\n}\n\nspecies goal_sp {\n\tstring position; // can be \"front\" or \"back\".\n\t\n\tinit {\n\t\tcreate goal_keeper with:[position::position];\n\t}\n\t\n\taspect goal {\n\t\tdraw rectangle(7.32,1.0) color:#black;\n\t}\n}\n\nspecies goal_keeper {\n\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \n\tstring position; // can be \"front\" or \"back\".\n\tball_sp ball <- nil update:first(ball_sp);\n\t\n\treflex update when:cycle>0 {\n\t\tlocation <- {ball.location.x/90*12+(90-12)/2,location.y};\n\t\tif (ball distance_to self < 2) {\n\t\t\tif (flip(1/(1+2*ball.speed))) {\n\t\t\t\tfirst(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));\n\t\t\t\task ball {\n\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinit {\n\t\tlocation <- {45,(position=\"front\") ? 117 : 3};\n\t}\n\t\n\taction offensive_behavior {\n\t}\n\t\n\taction defensive_behavior {\n\t}\n\t\n\taspect goal_keeper {\n\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\n\t}\n}\n```\n\n\nCode of the model : \n\n```\n\nmodel team2strategy\n\nimport \"./soccer_base.gaml\"\n\nspecies player_stupidTeam parent:base_player {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game\n\t//closest_player_to_ball\n\t// called_player : the player called for a pass\n\t// possess_ball : true or false\n\t// player_with_ball : player currently with the ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// position_mark\n\t// status : the current status of the player (can be useful to build the model)\n\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\n\t\n\taction defensive_behavior {\t\n\t\t// very basic defensive behavior : run to the ball\n\t\tdo run_to_ball;\n\t}\n\t\n\taction offensive_behavior {\t\n\t\t// very basic offensive behavior : run to the ennemy goal, or shoot the ball when close enough from the ennemy goal.\n\t\tif ((possess_ball) and (distance_to_goal < 30)) {\n\t\t\tdo shoot;\n\t\t}\n\t\telse {\n\t\t\tdo run_to_ennemy_goal;\n\t\t}\n\t}\n\t\n}\n\nspecies stupidTeam parent:base_team {\n\t// READ ONLY ATTRIBUTES :\n\t// position : can be \"front\" or \"back\".\n\t// players : list of all the players of the team.\n\t// game.\n\t// closest_player_to_ball.\n\t// called_player : the player called for a pass.\n\t// possess_ball : true when a player of the team possess the ball.\n\t// player_with_ball\n\t\n\t// READ AND WRITE ATTRIBUTES :\n\t// player_init_position\n\t\n\t// initial position of the player in percentage : for each point,\n\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\n\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\n\tlist<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];\n}\n\n```\n","url":"wiki/Soccer-team2_strategy.md"},"Sugarscape-Sugarscape.md":{"title":" sugarscape","content":"[//]: # (keyword|statement_put)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|concept_grid)\n# sugarscape\n\n\n_Author : _\n\nA model with animal moving on a grid to find sugar. The animal agents have a life duration and die if it is reached or if they don't have anymore sugar.\n\n\nCode of the model : \n\n```\nmodel sugarscape\n\n  \nglobal {\n\t// Parameters \n\t\n\t//Growth rate of the sugar\n\tint sugarGrowthRate <- 1;\n\t//Minimum age of death\n\tint minDeathAge <- 60;\n\t//Maximum age of death\n\tint maxDeathAge <- 100;\n\t//Metabolism maximum\n\tint maxMetabolism <- 3;\n\t\n\t//Maximum and Minimum initial sugar\n\tint maxInitialSugar <- 25 ;\n\tint minInitialSugar <- 5;\n\t//Maximum range\n\tint maxRange <- 6;\n\tbool replace <- true;\n\t//Number of agents\n\tint numberOfAgents <- 400;\t\n\t\n\t// Environment\n\tgeometry shape <- rectangle(50, 50);\n\t\t\n\tfile<int> types  <- file<int>('../images/sugarscape.pgm');\n\trgb FFFFAA const: true <- rgb('#FFFFAA');\n\trgb FFFF55 const: true <- rgb('#FFFF55');\n\trgb dark_yellow const: true <- rgb('#EEB422');\n\trgb less_red const: true <- rgb('#FF5F5F');\n\t\n\tinit {\n\t\t\n\t\t//Create the animal\n\t\tcreate animal number: numberOfAgents;\n\t\t\n\t\t//Ask to each sugar cell to set its sugar\n\t\task sugar_cell {\n\t\t\tmaxSugar <- (types at {grid_x,grid_y});\n\t\t\tsugar <- maxSugar;\n\t\t\tcolor <- [#white,FFFFAA,FFFF55,#yellow,dark_yellow] at sugar;\n\t\t}\n\t}\n}\n\n\t//Grid species representing the sugar cells\n\tgrid sugar_cell width: 50 height: 50 neighbors: 4 use_individual_shapes: false use_regular_agents: false{ \n\t\t//Maximum sugar\n\t\tint maxSugar;\n\t\t//Sugar contained in thecell\n\t\tint sugar update: sugar + sugarGrowthRate max: maxSugar;\n\t\trgb color update: [#white,FFFFAA,FFFF55,#yellow,dark_yellow] at sugar;\n\t\tmap<int,list<sugar_cell>> neighbours;\n\t\t\n\t\t//Initialization of the neighbours\n\t\tinit {\n\t\t\tloop i from: 1 to: maxRange {\n\t\t\t\tneighbours[i] <- self neighbors_at i; \n\t\t\t}\n\t\t}\n\t}\t\n\t\n//Species animal representing the animal agents\nspecies animal {\n\t//Color of the animal\n\trgb color  <- #red;\n\t//Speed of the animal\n\tfloat speed  <- 1.0;\n\t//Metabolism of the animal\n\tint metabolism  min: 1 <- rnd(maxMetabolism);\n\t//Perception range of the animal\n\tint vision  min: 1 <- rnd(maxRange);\n\t//Maximal age of the animal\n\tint maxAge  min: minDeathAge max: maxDeathAge <- rnd (maxDeathAge - minDeathAge) + minDeathAge;\n\t//Size of the animal\n\tfloat size  <- 0.5;\n\t//Sugar of the animal\n\tint sugar min: 0 <- (rnd (maxInitialSugar - minInitialSugar)) + minInitialSugar update: sugar - metabolism;\n\t//Age of the animal\n\tint age max: maxAge <- 0 update: int(age + step);\n\t//Place of the animal\n\tsugar_cell place ; \n\t\n\t//Launched at the initialization of the animal agent\n\tinit {\n\t\t//Set the place as one of the sugar cell\n\t\tplace <- one_of(sugar_cell);\n\t\tlocation <- place.location;\n\t}\n\t//Move the agent to another place and collect the sugar of the previous place\n\treflex basic_move { \n\t\tsugar <- sugar + place.sugar;\n\t\tplace.sugar <- 0;\n\t\tlist<sugar_cell> neighbours <- place.neighbours[vision];\n\t\tlist<sugar_cell> poss_targets <- (neighbours) where (each.sugar > 0);\n\t\t//If no sugar is found in the neighbours cells, move randomly\n\t\tplace <- empty(poss_targets) ? one_of (neighbours) : one_of (poss_targets);\n\t\tlocation <- place.location;\n\t}\n\t//Reflex to kill the animal once it reaches its maximal age or it doesn't have sugar anymore\n\treflex end_of_life when: (sugar = 0) or (age = maxAge) {\n\t\tif replace {\n\t\t\tcreate animal ;\n\t\t}\n\t\tdo die;\n\t}\n\taspect default {\n\t\tdraw circle(0.5) color: #red;\n\t}\n}\n\nexperiment sugarscape type: gui{\n\tparameter 'Growth rate of sugar:' var: sugarGrowthRate category: 'Environment';\n\tparameter 'Minimum age of death:' var: minDeathAge <- 60 category: 'Agents';\n\tparameter 'Maximum age of death:' var: maxDeathAge <- 100 category: 'Agents';\n\tparameter 'Maximum metabolism:' var: maxMetabolism <- 3 category: 'Agents';\n\tparameter 'Maximum initial sugar per cell:'  var: maxInitialSugar <- 25 category: 'Environment';\n\tparameter 'Minimum initial sugar per cell:' var: minInitialSugar <- 5 category: 'Environment';\n\tparameter 'Maximum range of vision:' var: maxRange <- 6 category: 'Agents';\n\tparameter 'Replace dead agents ?' var: replace <- true category: 'Agents';\n\tparameter 'Number of agents:' var: numberOfAgents <- 400 category: 'Agents';\n\t\n\toutput {\n\t\tdisplay grille {\n\t\t\tgrid sugar_cell;\n\t\t\tspecies animal;\n\t\t}\n\t\tdisplay chart refresh: every(5) {\n\t\t\tchart 'Energy' type: pie background: #lightgray style: exploded {\n\t\t\t\tdata \"strong\" value: (animal as list) count (each.sugar > 8) color: #green;\n\t\t\t\tdata \"weak\" value: (animal as list) count (each.sugar < 9) color: #red;\n\t\t\t}\n\t\t}\n\t\tdisplay chart2 refresh: every(5) {\n\t\t\tchart 'Energy' type: histogram background: #lightgray {\n\t\t\t\tdata \"strong\" value: (animal as list) count (each.sugar > 8)  color: #green;\n\t\t\t\tdata \"weak\" value: (animal as list) count (each.sugar < 9)  color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Sugarscape-Sugarscape.md"},"Traffic-LWR-Traffic-Flow-Model.md":{"title":" Trafic Group (R2D2) MAPS7 - LWR Model","content":"[//]: # (keyword|operator_ln)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|operator_sum)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|concept_transport)\n# Trafic Group (R2D2) MAPS7 - LWR Model\n\n\n_Author : A. Banos, N. Corson, C. Pivano, L. Rajaonarivo, P. Taillandier_\n\nThe LWR model was proposed by Lighthill and Whitham (1955) and by Richards (1956). It describes the trafic at a global level considering the speed, concentration and flows without taking into account the individual behavior af vehicles. Speed, concentration and flow are the three components of the LWR model. This models reproduces flow of traffic and congestion in specific conditions (homogeneous traffic), going from one equilibrium state to another (see the fundamental diagramm of traffic, which gives flow according to concentration).\nIn this model, a road is divided into sections and we arbitrarily give to the middle section a lower speed and critical concentration.\n\n\nCode of the model : \n\n```\n\n\nmodel TraficGroup\n\nglobal {\n\t\t\n\tfloat road_size <- 10 #km ; \t\t\t\t\t\t// Size of the road\n\t\n\tgeometry shape <- rectangle (road_size, 200 #m) ; \t// The world is a rectangle with a length equals to the size of the road and a height of 200m\n\t\t\n\tfloat time_step <- 1.0 ; \t\t\t\t\t\t\t// Time step \n\tint nb_sections <- 10 ; \t\t\t\t\t\t\t// Number of sections of the road\n\tfloat section_size <- road_size / nb_sections ; \t// Size of a section\n\t\n\tfloat car_size <- 4 #m ;\t\t\t\t\t\t\t\t\t// Size of a car\n\tfloat nb_max_cars_on_section <- section_size / car_size ;\t// Maximum number of cars on one section \n\t\n\t   init{\n\t   \t\t\n\t   \t\t// Creation of the nb_sections sections which compose the road. \n\t   \t\t\n\t\t   loop i from: 0 to: (nb_sections - 1){\n\t\t   \t  create section with: [shape:: line([{i * section_size , 100},{(i +1) * section_size , 100}])];\n\t\t   }\n\t\t   \t\n\t\t   \t// For each section, as we need to have information concerning the previous and the next one, we define which section is the previous and which is the next.\n\t\t   \t// The previous section is the one which last point corresponds to the first point of the actual section. \n\t\t   \t// The next section is the one which first point corresponds to the last point of the actual section. \n\t\t   \t\n\t    \task section{\n\t    \t\tprevious <- section first_with (last(each.shape.points) = first(self.shape.points)) ;\n\t    \t\tnext <- section first_with (first(each.shape.points) = last(self.shape.points)) ;\n\t    \t}\n\t\n\t    \t// For each section, we define a critical concentration (see the fundamental diagram), a maximum speed, a concentration and a flow (which are = 0 at initialization). \n\t    \t// A fundamental relation about trafic gives : flow = concentration * speed.\n\t    \t\n\t    \task section{\n\t    \t\tcritical_concentration <- 125.0 ; //Kc\n\t\t\t\tmax_speed <- 50 #km/#h; // Vl\n\t\t\t\tcurrent_concentration <- 0.0 ;\n\t\t\t\tcurrent_flow <- current_concentration * max_speed ;\n\t\t\t\tmax_flow <- critical_concentration * max_speed ; \n\t    \t}\n\t    \t\t    \t\n\t    \t// The concentration and flow ot first section are initialized.\n\t    \t\n\t    \task section[0]{\n\t    \t\tcurrent_concentration <- nb_max_cars_on_section ;\n\t\t\t\tcurrent_flow <- current_concentration * max_speed ;\n\t    \t}\n\t    \t\n\t    \t// The middle section is supposed to have a different maximum speed and a different critical concentration so that we can observe congestion phenomenon.\n\t    \t// This middle section is green.\n\t    \t\n\t    \task section[int(nb_sections/2)] {\n\t    \t\t\tcritical_concentration <- 10.0 ; \n\t    \t\t\tmax_flow <- critical_concentration * max_speed ; \n\t\t\t\t    max_speed <- 10 #km/#h; \n\t\t\t\t\tcolor <- #green;\n\t    \t}\n    \t}\n    \t\n   // To update flow and concentration at each time step in each section, we use an offer and a demand function. \n   // These functions define the welcome capacity (offer) and the emission capacity (demand) of a section.\n   \n    reflex offer_function {\n\t     ask section {\n\t\t\t  if current_concentration <= critical_concentration {\n\t\t\t  \toffer <- max_flow ;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t  \toffer <- max([0 , (- max_flow / critical_concentration) * current_concentration + 2 * max_flow ]);\n\t\t\t  }\n\t\t  \n\t  }\n\t}\n\t\n\treflex demand_function {\n\t\task section{\n\t\t\t  if current_concentration <= critical_concentration {\n\t\t\t  \t\tdemand <- max([0 , ( max_flow / critical_concentration) * current_concentration]) ;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t  \t\tdemand <- max_flow ;\n\t\t\t  }\n\t\t}\n\t}\n\t\n\t// The flow and concentration are then updated according to the offer and demand functions of the current section, but also of the next and previous ones.\n\t\n\t// During a time step, the flow of a section take the minimum value between its demand and the offer of the next section.\n\t// The flow of the last section is equal to its demand.\t\n\t\n\treflex update_flow{\n\t\task section  {\n\t\t\tfloat next_offer <-  (self.next != nil) ? (self.next).offer : self.demand;\n\t\t\tcurrent_flow <- min([self.demand, next_offer]);\n\t\t}\n\t}\n\t\n\t\n\t// After a time step, the concentration is updated from the current concentration, according to the incoming and outgoing concentrations.\n\t// The first section concentration on ly takes into account the outgoing concentration of vehicles.\n\t\n\treflex update_concentration{\n\t\task section   {\n\t\t\tfloat previous_flow <- (self.previous != nil) ? (self.previous).current_flow : 0.0;\n\t\t\tcurrent_concentration <- current_concentration + time_step/section_size *(previous_flow - self.current_flow) ;\n\t\t}\t\n\t}\n\t\n\t// When there is less than one car left on the road, the simulation stops.\n\t\n\treflex stop_simulation when: sum(section collect each.current_concentration) < 1.0 {\n\t\tdo pause;\n\t}\n}\n\n// A road is divided into sections. \n// Each section has a concentration, a flow, an offer and a demand, a critical concentration, a maximum speed and a maximum flow, \n// and a previous and a next section.\n\nspecies section {\n\tfloat current_concentration  ;\n\tfloat current_flow  ;\n\t\n\tfloat offer ;\n\tfloat demand  ;\n\t\n\trgb color;\n\t\n\tfloat critical_concentration ; \n\tfloat max_speed ; \n\tfloat max_flow ; \n\n\tsection previous ;\n\tsection next ;\n\t\n\t// The width of a section depends on its concentration.\n\t\n\taspect shape_section {\n\t\tdraw shape + (1 + 15 * ln (current_concentration + 1)) color: color;\t\t\n\t} \n\n}\n\n\nexperiment TraficGroup type: gui {\n\n\t// Users can chose the number of sections and the time step.\n\n    parameter 'Number of sections' var: nb_sections category: \"Section parameter\";\n    parameter 'Time step - DeltaT' var: time_step category: \"Time parameter\";\n        \n\toutput {\n\t\t\n\t\t// A monitor gives the number of cars on the road at every time step.\n\t\t\n\t\tmonitor \"Sum Concentrations\" value: sum(section collect each.current_concentration);\n\t\t\n\t\t// A display shows the road. Section width depend on their concentration.\n\t\t\n\t\tdisplay TheRoad{\n\t\t\tspecies section aspect: shape_section ;\n\t\t}\n\t\t\n\t\t// The greeen time series correspond to the middle section (on which concentration and maximum speed are lower).\n\t\t// The red time series correspond to the section just before the middle one.\n\t\t\t\t\n\t\tdisplay Concentrations {\n\t\t\tchart \"Concentrations\" type: series  {\n\t\t\t\tdata 'Section 0' value: section[0].current_concentration color: #gray marker: false ;\t\t\t\t\n\t\t\t\tdata 'Section 1' value: section[1].current_concentration color: #gray marker: false;\n\t\t\t\tdata 'Section 2' value: section[2].current_concentration color: #gray marker: false;\n\t\t\t\tdata 'Section 3' value: section[3].current_concentration color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 4' value: section[int(nb_sections/2 - 1 ) ].current_concentration color: #red marker: false;\n\t\t\t\tdata 'Section 5' value: section[int(nb_sections/2)].current_concentration color: #green marker: false;\n\t\t\t\tdata 'Section 6' value: section[6].current_concentration color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 7' value: section[7].current_concentration color: #gray marker: false;\n\t\t\t\tdata 'Section 8' value: section[8].current_concentration color: #gray marker: false;\n\t\t\t\tdata 'Section 9' value: section[9].current_concentration color: #gray marker: false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdisplay Flows {\n\t\t\t    chart \"Flows\" type: series  {\n\t\t\t\tdata 'Section 0' value: section[0].current_flow color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 1' value: section[1].current_flow color: #gray marker: false;\n\t\t\t\tdata 'Section 2' value: section[2].current_flow color: #gray marker: false;\n\t\t\t\tdata 'Section 3' value: section[3].current_flow color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 4' value: section[int(nb_sections/2 - 1)].current_flow color: #red marker: false;\n\t\t\t\tdata 'Section 5' value: section[int(nb_sections/2)].current_flow color: #green marker: false;\n\t\t\t\tdata 'Section 6' value: section[6].current_flow color: #gray marker: false;\t\t\t\t\n\t\t\t\tdata 'Section 7' value: section[7].current_flow color: #gray marker: false;\n\t\t\t\tdata 'Section 8' value: section[8].current_flow color: #gray marker: false;\n\t\t\t\tdata 'Section 9' value: section[9].current_flow color: #gray marker: false;\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n```\n","url":"wiki/Traffic-LWR-Traffic-Flow-Model.md"},"Traffic-Simple-traffic-model.md":{"title":" Traffic","content":"[//]: # (keyword|operator_rnd_color)\n[//]: # (keyword|operator_exp)\n[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|constant_#sec)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_transport)\n# Traffic\n\n\n_Author : Patrick Taillandier_\n\nA simple road network model: the speed on a road depends on the number of people on this road (the highest, the slowest)\n\n\nCode of the model : \n\n```\n\nmodel traffic\n\nglobal {\n\t//Shapefile of the buildings\n\tfile building_shapefile <- file(\"../includes/buildings.shp\");\n\t//Shapefile of the roads\n\tfile road_shapefile <- file(\"../includes/roads.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(road_shapefile);\n\t//Step value\n\tfloat step <- 10 #s;\n\t//Graph of the road network\n\tgraph road_network;\n\t//Map containing all the weights for the road network graph\n\tmap<road,float> road_weights;\n\t\n\tinit {\n\t\t//Initialization of the building using the shapefile of buildings\n\t\tcreate building from: building_shapefile;\n\t\t//Initialization of the road using the shapefile of roads\n\t\tcreate road from: road_shapefile;\n\t\t\n\t\t//Creation of the people agents\n\t\tcreate people number: 1000{\n\t\t\t//People agents are located anywhere in one of the building\n\t\t\tlocation <- any_location_in(one_of(building));\n      \t}\n      \t//Weights of the road\n      \troad_weights <- road as_map (each::each.shape.perimeter);\n      \troad_network <- as_edge_graph(road);\n\t}\n\t//Reflex to update the speed of the roads according to the weights\n\treflex update_road_speed  {\n\t\troad_weights <- road as_map (each::each.shape.perimeter / each.speed_coeff);\n\t\troad_network <- road_network with_weights road_weights;\n\t}\n}\n//Species to represent the people using the skill moving\nspecies people skills: [moving]{\n\t//Target point of the agent\n\tpoint target;\n\t//Probability of leaving the building\n\tfloat leaving_proba <- 0.05; \n\t//Speed of the agent\n\tfloat speed <- 5 #km/#h;\n\trgb color <- rnd_color(255);\n\t//Reflex to leave the building to another building\n\treflex leave when: (target = nil) and (flip(leaving_proba)) {\n\t\ttarget <- any_location_in(one_of(building));\n\t}\n\t//Reflex to move to the target building moving on the road network\n\treflex move when: target != nil {\n\t\tdo goto target: target on: road_network recompute_path: false move_weights: road_weights;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t}\t\n\t}\n\t\n\taspect default {\n\t\tdraw circle(5) color: color;\n\t}\n}\n//Species to represent the buildings\nspecies building {\n\taspect default {\n\t\tdraw shape color: #gray;\n\t}\n}\n//Species to represent the roads\nspecies road {\n\t//Capacity of the road considering its perimeter\n\tfloat capacity <- 1 + shape.perimeter/30;\n\t//Number of people on the road\n\tint nb_people <- 0 update: length(people at_distance 1);\n\t//Speed coefficient computed using the number of people on the road and the capicity of the road\n\tfloat speed_coeff <- 1.0 update:  exp(-nb_people/capacity) min: 0.1;\n\t\n\taspect default {\n\t\tdraw (shape + 3 * speed_coeff) color: #red;\n\t}\n}\nexperiment trafic type: gui {\n\tfloat minimum_cycle_duration <- 0.01;\n\toutput {\n\t\tdisplay carte type: opengl{\n\t\t\tspecies building refresh: false;\n\t\t\tspecies road ;\n\t\t\tspecies people ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Traffic-Simple-traffic-model.md"},"Urban-Growth-raster-model.md":{"title":" Cellular Automaton Based Urban Growth","content":"[//]: # (keyword|operator_max_of)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|operator_using)\n[//]: # (keyword|operator_sort_by)\n[//]: # (keyword|operator_last)\n[//]: # (keyword|statement_using)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|constant_#cyan)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_gis)\n[//]: # (keyword|concept_shapefile)\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_graph)\n# Cellular Automaton Based Urban Growth\n\n\n_Author : Truong Chi Quang, Patrick Taillandier, Benoit Gaudou & Alexis Drogoul_\n\nmodel based on the one proposed by (Raimbault et al., 2014): At each simulation step the nb_plots_to_build empty plots with the highest constructability are built The constructability is computed from 3 criteria: the density of construction in the neighborhood, the distance to a road, the distance to the city center (using the road network). \n\n\nCode of the model : \n\n```\n\nmodel raster3\n\n\nglobal\n{ \n\t//File for the ascii grid\n\tfile asc_grid <- grid_file(\"../includes/cantho_1999_v6.asc\");\n\t//Shapefile for the road\n\tfile road_shapefile <- shape_file(\"../includes/roads15_3.shp\");\n\t//Shapefile for the city\n\tfile city_center_shapefile <- shape_file(\"../includes/city center.shp\");\n\t//Shape of the environment\n\tgeometry shape <- envelope(asc_grid);\n\t//Graph of the roads\n\tgraph roads_network;\n\t\n\t// Dynamic list of the cells to consider at each cycle\n\tlist<plot> empty_plots <- plot where (each.grid_value = 0.0) update: shuffle(plot where (each.grid_value = 0.0));\n\t\n\tlist<rgb> plot_colors <- [ \n\t\t#lightgray, //empty\n\t\t#orange, // 1 built\n\t\t#blue // 2 River-lake\n\t];\n\t//Radius of density\n\tint density_radius <- 4;\n\t//Weight of density\n\tfloat weight_density <- 0.05;\n\t//Weight of the road distance\n\tfloat weight_road_dist <- 0.5;\n\t//Weight of the city center distance\n\tfloat weight_cc_dist <- 0.3;\n\t//Number of plot allowing to build a building\n\tint nb_plots_to_build <- 195;\n\n\tinit\n\t{\n\t\t//Creation of the roads using the shapefile of the road\n\t\tcreate roads from: road_shapefile;\n\t\t//Creation of the city center using the city center shapefile\n\t\tcreate city_center from: city_center_shapefile;\n\t\t//Creation of the graph of the road network\n\t\troads_network <- as_edge_graph(roads);\n\t\t\n\t\t//Each road has to compute its distance from the city center\n\t\task roads {\n\t\t\tdo compute_cc_dist;\n\t\t}\n\t\t//Compute the city distance for each plot\n\t\task empty_plots {\n\t\t\tdo compute_distances;\n\t\t}\n\t\t//Normalization of the distance\n\t\tdo normalize_distances;\n\t}\n\t//Action to normalize the distance\n\taction normalize_distances {\n\t\t//Maximum distance from the road of all the plots\n\t\tfloat max_road_dist <- empty_plots max_of each.dist_route;\n\t\t//Maximum distance from the city center for all the plots\n\t\tfloat max_cc_dist <- empty_plots max_of each.dist_cv;\n\t\t//Normalization of  each empty plot according to the maximal value of each attribute\n\t\task empty_plots {\n\t\t\tdist_cv <- 1 - dist_cv / max_cc_dist;\n\t\t\tdist_route <- 1 - dist_route / max_road_dist;\n\t\t}\n\t}\n\t\n\t\n\t//Reflex representing the global dynamic of the model\n\treflex dynamique_globale when: weight_density != 0 or weight_road_dist != 0 or weight_cc_dist != 0 {\n\t\t//Ask to each empty plot to compute its constructability\n\t\task empty_plots {\n\t\t\tconstructability <- compute_constructability();\n\t\t}\n\t\tlist<plot> ordered_plots <- empty_plots sort_by (each.constructability);\n\t\tordered_plots <- nb_plots_to_build last ordered_plots;\n\t\t//Build on each empty plot having the highest constructability\n\t\task ordered_plots\n\t\t{\n\t\t\tdo build;\n\t\t}\n\t}\t\n}\n//Species representing the city center\nspecies city_center {\n\taspect default {\n\t\tdraw circle(300) color: #cyan;\n\t}\t\n}\n//Species representing the roads\nspecies roads\n{\n\tfloat dist_cv;\n\t//Action to compute the city center distance for the road\n\taction compute_cc_dist {\n\t\tusing topology(roads_network)\n\t\t{\n\t\t\tdist_cv <- self distance_to first(city_center);\n\t\t}\n\t}\n\taspect default {\n\t\tdraw shape color: #black;\t\n\t}\n}\n//Grid species to represent the different building plots\ngrid plot file: asc_grid use_individual_shapes: false use_regular_agents: false neighbors: 4\n{\n\trgb color <- grid_value = -1 ? #white : plot_colors[int(grid_value)];\n\t//Distance from the road\n\tfloat dist_route <- 0.0;\n\t//Distance from the city center\n\tfloat dist_cv <- 0.0;\n\t//Constructability of the plot\n\tfloat constructability;\n\t\n\t//Action to compute all the distances for the cell\n\taction compute_distances\n\t{\n\t\troads route_pp <- roads closest_to self;\n\t\tdist_route <- (self distance_to route_pp) using topology(world);\n\t\tdist_cv <- dist_route + route_pp.dist_cv;\n\t}\n\t//Action to build on the cell\n\taction build\n\t{\n\t\tgrid_value <- 1.0;\n\t\tcolor <- plot_colors[1];\n\t}\n\t//Action to compute the constructability of the plot cell\n\tfloat compute_constructability\n\t{\n\t\t//Get all the neighbours plots\n\t\tlist<plot> voisins <- (self neighbors_at density_radius);\n\t\t//Compute the density of all the neighbours plots\n\t\tfloat densite <- (voisins count (each.grid_value = 1.0)) / length(voisins);\n\t\treturn (densite * weight_density + dist_route * weight_road_dist + dist_cv * weight_cc_dist) / (weight_density + weight_road_dist + weight_cc_dist);\n\t}\t\t\t\n}\n\nexperiment raster type: gui {\n \tparameter \"Weight of the density criteria\" var: weight_density;\n \tparameter \"Weight of the distance to roads criteria\" var: weight_road_dist;\n \tparameter \"Weight of the distance to city center criteria\" var: weight_cc_dist;\n \toutput {\n \t\tdisplay map type: opengl {\n\t\t\tgrid plot;\n\t\t\tspecies roads;\n\t\t\tspecies city_center;\n\t\t}\n\t}\n}\n\n```\n","url":"wiki/Urban-Growth-raster-model.md"},"Voronoi-Voronoi.md":{"title":" Voronoi","content":"[//]: # (keyword|operator_using)\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|type_topology)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|concept_agent_movement)\n[//]: # (keyword|concept_grid)\n# Voronoi\n\n\n_Author : _\n\nA model showing how to clusterize space using the closest center as the kernel of our cluster. The space is discretized using a grid, each cell computing its distance from a center to know in which cluster it is. \n\n\nCode of the model : \n\n```\n\nmodel voronoi\n \nglobal {\n\t// Parameters \n\t//Number of points\n\tint num_points <- 4 min: 1 max: 1000;\n\t//Size of the environment\n\tint env_width <- 100 min: 10 max: 400;\n\tint env_height <- 100 min: 10 max: 400;\n\t\n\t// Environment\n\tgeometry shape <- rectangle(env_width, env_height);\n\t\n\tinit { \n\t\twrite 'This model shows how Voronoi-like shapes can be drawn on a regular surface. A set of mobile agents is placed on a grid. Each agent possesses an attribute called *inside_color*. Each step, the agents move randomly and the grid cells paint themselves using the *inside_color* of the nearest agent. Dynamical boundaries then appear on the screen without any further calculations.';\n\t\t//Creation of all the points\n\t\tcreate center number: num_points ;  \n\t}   \n} \n//Grid for the voronoi clustering\ngrid cell width: env_width height: env_height neighbors: 8 use_regular_agents: false {\n\t// Note: since GAMA 1.7, the topology needs to be specified for this computation to use continuous distances\n\tcenter closest_center <- nil update: (center closest_to self.location) using topology(world);\n\trgb color <- #white update: (closest_center).color;\n}\n//Species representing the center of a Voronoi point\nspecies center skills: [moving] { \n\trgb color <- rgb([rnd (255),rnd (255),rnd (255)]); \n\t//Make the center of the cluster wander in the environment       \n\treflex wander {\n\t\tdo wander amplitude: 90;\n\t}  \n\taspect base {\n\t\tdraw square(1.0) color: color;\n\t}\n}\n\n\nexperiment voronoi type: gui{ \n\tparameter 'Number of points:' var: num_points;\n\tparameter 'Width of the environment:' var: env_width;\n\tparameter 'Height of the environment:' var: env_height;\n\t\n\toutput {\n\t\tdisplay Voronoi type: opengl {\n\t\t\tgrid cell  ;\n\t\t\tspecies center aspect: base ;\n\t\t}\n\t}\t\n}\n```\n","url":"wiki/Voronoi-Voronoi.md"},"Vote-Vote.md":{"title":" vote","content":"[//]: # (keyword|operator_points_at)\n[//]: # (keyword|operator_copy)\n[//]: # (keyword|operator_with_min_of)\n[//]: # (keyword|operator_gauss)\n[//]: # (keyword|operator_triangle)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|operator_in)\n[//]: # (keyword|operator_union)\n[//]: # (keyword|operator_buffer)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_sum)\n[//]: # (keyword|operator_ln)\n[//]: # (keyword|statement_switch)\n[//]: # (keyword|statement_match)\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|concept_gui)\n# vote\n\n\n_Author : MAPS TEAM (Frederic Amblard, Thomas Louail, Romain Reulier, Paul Salze et Patrick Taillandier) _\n\nModeling of an election\n\n\nCode of the model : \n\n```\n \nmodel vote\n\nglobal {\n\t//Shape of the environment\n\tgeometry shape <- rectangle({200, 200});\n\t\n\t//Number of electors\n\tint nb_electors <- 1500;\n\t//Number of candidates\n\tint nb_candidates <- 7;\n\t//Weight of each candidates\n\tint weight_candidates <- 50;\n\t//Threshold for the attraction candidates\n\tint threshold_attraction_candidates <- 80;\n\t//Threshold for the repulsion candidates\n\tint threshold_repulsion_candidates <- 200;\n\t//Threshold for the attraction electors\n\tint threshold_attraction_electors <- 20;\n\t\n\t//Distance traveled\n\tfloat distance_traveled <- 7.0;\n\t//Distribution of the electors\n\tstring distribution_electors <- \"Uniform\" among: [\"Uniform\", \"Normal\"];\n\t//Distribution of candidates\n\tstring distribution_candidates <- \"Polygon\" among: [\"Random\", \"Polygon\", \"Line\", \"Diagonal\"];\n\t//Strategy of the candidates\n\tstring strategy_candidates <- \"No strategy\" among: [\"No strategy\", \"Search electors\", \"Distinction\", \"Group\", \"Go closer to the best\",\"Random\" ];\n\t//Count of max group\n\tint cpt_Group_max <- 5;\n\t//Count  of group\n\tint cpt_Group <- cpt_Group_max;\n\t\n\tfloat entropy;\n\t\n\t//List of all the active candidates\n\tlist<candidate> active_candidates ;\n\t\n\tinit {\n\t\t//Creation of the elector\n\t\tcreate elector number: nb_electors;\n\t\tdo creation_candidates;\n\t}\n\t//Action to create the candidates according to the distribution of candidates\n\taction creation_candidates {\n\t\tswitch distribution_candidates { \n\t\t\tmatch \"Polygon\" {\n\t\t\t\tlist<point> liste_points <- list(nb_candidates points_at 50.0);\n\t\t\t\tint cpt <- 0;\n\t\t\t\tcreate candidate number: nb_candidates{\n\t\t\t\t\t color <- rgb (rnd(255), rnd(255), rnd(255)); \n\t\t\t\t\t location <- liste_points at cpt;\n\t\t\t\t\t cpt <- cpt + 1; \n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch \"Line\" {\n\t\t\t\tint cpt  <- 0;\n\t\t\t\tcreate candidate number: nb_candidates{\n\t\t\t\t\tcolor <- rgb ([rnd(255), rnd(255), rnd(255)]); \n\t\t\t\t\tfloat x_cord  <- 200 * cpt / nb_candidates;\n\t\t\t\t\tfloat y_cord <- 100.0;\n\t\t\t\t\tlocation <- {x_cord, y_cord};\n\t\t\t\t\tcpt <- cpt + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatch \"Diagonal\" {\n\t\t\t\tint cpt <- 0;\n\t\t\t\tcreate candidate number: nb_candidates{\n\t\t\t\t\tcolor <- rgb ([rnd(255), rnd(255), rnd(255)]); \n\t\t\t\t\tfloat x_cord <- 200 * cpt / nb_candidates;\n\t\t\t\t\tfloat y_cord <- x_cord;\n\t\t\t\t\tlocation <- {x_cord, y_cord};\n\t\t\t\t\tcpt <- cpt + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//Initialization of all the active candidates as the list of candidates\n\t\tactive_candidates <- list(copy(candidate));\t\n\t}\n\t//Reflex representing the dynamics of the models\n\treflex dynamique {\n\t\t//For each elector, ask to move\n\t\task elector {\n\t\t\tdo moving;\n\t\t}\n\t\t//For each candidate, ask to move\n\t\task active_candidates{\n\t\t\tdo moving;\n\t\t\tmy_electors <- list<elector>([]);\n\t\t}\n\t\t//For each elector, do its definition\n\t\task elector {\n\t\t\tdo definition_candidate;\n\t\t}\n\t\tint nb_electors_max <- 0;\n\t\tcandidate candidat_elected <- nil; \n\t\t\n\t\t//Ask to all the active candidates to compute their percentage of vote and set the number of maximum electors to know which candidate is elected\n\t\task active_candidates{ \n\t\t\tint nb_el <- length(my_electors) ;\n\t\t\tpercentage_vote <- (nb_el/nb_electors * 100) with_precision 2;\n\t\t\tif (nb_el > nb_electors_max) {\n\t\t\t\tnb_electors_max <- nb_el;\n\t\t\t \tcandidat_elected <- self;\n\t\t\t}\n\t\t}\n\t\t//update of the state of the candidate\n\t\task candidate {\n\t\t\tis_elected <- false; \n\t\t}\n\t\task candidat_elected {\n\t\t\tis_elected <- true; \n\t\t}\n\t}\n\t//Reflex to show the final results\n\treflex resultats_finaux when: time = 72 {\n\t\tcandidate elected <- active_candidates with_max_of (each.percentage_vote);\n\t\t//Display a window telling who is the winner and halt the model\n\t\tdo tell message: \"The winner is \" + elected.name; \n\t\tdo halt;\n\t}\n\t\n\t//Reflex to compute the creation of group when one candidate chooses this strategy\n\treflex creation_Group when: (strategy_candidates in [\"Group\", \"Random\"]) {\n\t\t if (cpt_Group = cpt_Group_max) {\n\t\t \t//Kill all the group of electors\n\t\t \task Group_electors as list {\n\t\t \t\tdo die;\n\t\t \t}\n\t\t \t//Compute the list of elector according to their distance\n\t\t\tlist<list<elector>> Groups;\n\t\t\tgeometry geoms <- union(elector collect ((each.shape) buffer ([\"distance\"::float(threshold_attraction_electors) , \"quadrantSegments\"::4, \"endCapStyle\"::1])));\n\t\t\tloop geom over: geoms.geometries { \n\t\t\t\tif (geom != nil and !empty(geom.points)) {\n\t\t\t\t\tlist<elector> els  <- (elector inside geom); \n\t\t\t\t\tadd els to: Groups;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Create new groups of electors according to the list of electors\n\t\t\tloop gp over: Groups {\n\t\t\t \tcreate Group_electors {\n\t\t\t\t\t effectif <- length(gp);\n\t\t\t \t\t electors_dans_Group <- gp;\n\t\t\t \t\t location <- mean(electors_dans_Group collect (each.location)) ;\n\t\t\t \t}\n\t\t\t }\t \n\t\t}\n\t\tcpt_Group <- cpt_Group - 1;\n\t\tif (cpt_Group = 0) { cpt_Group <- cpt_Group_max;}\t\n\t}\n\t//Reflex to compute the entropy\n\treflex calcule_entropy {\n\t\tentropy <- 0.0;\n\t\t//Compute the abstinence rate\n\t\tfloat abst <- (nb_electors - sum (active_candidates  collect (length(each.my_electors)))) / nb_electors;\n\t\tif (abst > 0) {\n\t\t\tentropy <- entropy - (abst * ln(abst));\n\t\t}\n\t\t//Ask to all the active candidates their number of electors to compute the entropy\n\t\task active_candidates {\n\t\t\tfloat p <- length(my_electors) / nb_electors;\n\t\t\tif (p > 0) {\n\t\t\t\tentropy <- entropy - (p * ln(p));\n\t\t\t}\n\t\t}\n\t\tentropy <- entropy / ln (length(active_candidates) + 1);\n\t}\n}\n\n\n\n//Species representing a group of electors\nspecies Group_electors {\n\tint effectif <- 0;\n\t//List of all the elector agents in the group\n\tlist<elector> electors_dans_Group ;\n\taspect default {\n\t\tdraw square(2) color: #orange;\n\t} \n\t\n}\n//Species representing the elector moving \nspecies elector skills: [moving]{\n\t\n\tinit {\n\t\t//At initialization, place the elector in a certain place according to the distribution of electors\n\t\tif (distribution_electors = \"Normal\") {\n\t\t\tfloat x_cord <- max([0.0, min([200.0, gauss ({100, 35})])]);\n\t\t\tfloat y_cord <- max([0.0, min([200.0, gauss ({100, 35})])]);\n\t\t\tlocation <- {x_cord, y_cord};\n\t\t}\n\t}\n\trgb color <- #white;\n\t//Candidate chosen by the elector\n\tcandidate my_candidate;  \n\t\n\taspect base {\n\t\tdraw triangle(2) color: color ;\n\t} \n\t//Action to define the candidate\n\taction definition_candidate {\n\t\t//The candidate chosen is the one closest to the elector in the attraction range\n\t\tmy_candidate <- active_candidates with_min_of (self distance_to each);\n\t\tmy_candidate <- (self distance_to my_candidate < threshold_attraction_candidates) ? my_candidate : nil;\n\t\tif (my_candidate != nil) {\n\t\t\tadd self to: my_candidate.my_electors; \n\t\t\tcolor <- my_candidate.color;\n\t\t}\n\t}\n\t//Action to move the elector\n\taction moving {\n\t\t//Make the agent move closer to another elector, representing the influence of this one\n\t\tif ( rnd(100) > (weight_candidates)) {\n\t\t\telector my_elector <- shuffle(elector) first_with ((self distance_to each) < threshold_attraction_electors);\n\t\t\tif (my_elector != nil) {\n\t\t\t\tdo goto target:my_elector speed: distance_traveled;\n\t\t\t} \n\t\t} else {\n\t\t\t//Move the elector closer to one of the candidate to represent its repulsion or attraction\n\t\t\tcandidate the_candidate <- one_of(candidate) ;\n\t\t\tif (the_candidate != nil) {\n\t\t\t\tfloat dist <- self distance_to the_candidate;\n\t\t\t\tif dist < threshold_attraction_candidates {\n\t\t\t\t\tdo goto target: the_candidate speed: distance_traveled;\n\t\t\t\t} else if dist > threshold_repulsion_candidates {\n\t\t\t\t\tdo goto target: location + location - the_candidate.location speed: distance_traveled;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t} \n\t\n}\n//Species candidate using the skill moving\nspecies candidate skills:[moving]{\n\trgb color <- rgb([100 + rnd(155),100 + rnd(155),100 + rnd(155)]);\n\t//Boolean to know if the candidate is active\n\tbool active <- true;\n\t//Float representing the percentage of vote for the candidate\n\tfloat percentage_vote; \n\t//List of all the electors of the candidate\n\tlist my_electors of: elector;\n\t//Boolean to know if the candidate is elected\n\tbool is_elected <- false;\n\taspect default {\n\t\tdraw circle(3) color: color;\n\t} \n\taspect dynamic {\n\t\tif (active) {\n\t\t\tfloat radius  <- 1 + (percentage_vote / 4.0);\n\t\t\tif (is_elected) {\n\t\t\t\tdraw square( radius *1.5) color: #red; \n\t\t\t\tdraw circle(radius) color: color;\n\t\t\t} else {\n\t\t\t\tdraw circle(radius) color: color;\n\t\t\t}\n\t\t\tdraw string(percentage_vote) size: 5 color: #white;\n\t\t}\n\t}\n\t//Action to move the candidate according to its strategy\n\taction moving {\n\t\tswitch strategy_candidates {\n\t\t\tmatch \"No strategy\" {}\n\t\t\tmatch \"Search electors\" {do strategy_1;}\n\t\t\tmatch \"Distinction\" {do strategy_2;}\n\t\t\tmatch \"Group\" {do strategy_3;}\n\t\t\tmatch \"Go closer to the best\" {do strategy_4;}\n\t\t\tmatch \"Random\" { \n\t\t\t\tswitch (rnd(4)) {\n\t\t\t\t\tmatch 0 {}\n\t\t\t\t\tmatch 1 {do strategy_1;}\t\n\t\t\t\t\tmatch 2 {do strategy_2;}\t\n\t\t\t\t\tmatch 3 {do strategy_3;}\t\n\t\t\t\t\tmatch 4 {do strategy_4;}\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction strategy_1 {\n\t\t//go closer to electors\n\t\telector my_elector <- shuffle(elector) first_with ((self distance_to each) < threshold_attraction_electors);\n\t\tif (my_elector != nil) {\n\t\t\tdo goto target:my_elector speed: distance_traveled;\n\t\t} \n\t}\n\t\n\taction strategy_2 {\n\t\t//go in opposite directions to other candidates\n\t\tlist<candidate> cands <- list(copy(candidate));\n\t\tremove self from: cands;\n\t\tcandidate the_candidate <- one_of(cands) ;\n\t\tif (the_candidate != nil) {\n\t\t\tdo goto target: (location + location - the_candidate.location) speed: distance_traveled;\t\n\t\t}\n\t}\n\t\n\taction strategy_3 {\n\t\t//go closer to a group of electors\n\t\tGroup_electors mon_Group  <- (Group_electors where ((self distance_to each) < threshold_attraction_electors)) with_max_of (each.effectif);\n\t\tif (mon_Group != nil) {\n\t\t\tdo goto target:mon_Group speed: distance_traveled;\n\t\t} \n\t}\n\t\n\taction strategy_4 {\n\t\t//go toward the candidate with max of votes\n\t\tcandidate the_candidate <- candidate with_max_of (percentage_vote) ;\n\t\tif (the_candidate != nil) {\n\t\t\tdo goto target:the_candidate speed: distance_traveled;\t\n\t\t}\n\t}\n\t\n}\n\n\nexperiment vote type: gui {\n\t/** Insert here the definition of the input and output of the model */\n\tparameter \"Number of electors : \" var: nb_electors category: \"elector\";\n\tparameter \"Moving speed of electors toward another electors : \" var: distance_traveled category: \"elector\";\n\tparameter \"Attraction distance between electors : \" var: threshold_attraction_electors category: \"elector\";\n\tparameter \"Number of candidates : \" var: nb_candidates category: \"Candidate\";\n\tparameter \"Attraction distance between candidates and electors : \" var: threshold_attraction_candidates category: \"elector\";\n\t\n\tparameter \"Repulsion distance between candidates : \" var: threshold_repulsion_candidates category: \"elector\";\n\tparameter \"weight of candidates : \" var: weight_candidates category: \"Candidate\";\n\t\n\tparameter \"Distribution type of electors : \" var: distribution_electors category: \"elector\";\n\tparameter \"Distribution type of  candidates : \" var: distribution_candidates category: \"Candidate\";\n\tparameter \"Strategy of candidates : \" var: strategy_candidates category: \"Candidate\";\n\t\n\toutput {\n\t\tdisplay main background: #black { \n\t\t\tspecies elector aspect: base;\n\t\t\tspecies candidate aspect: dynamic;\n\t\t\tspecies Group_electors;\n\t\t\t\n\t\t}\n\t\tdisplay votants {\n\t\t\tchart \"Distribution of electors\" type: pie background: #white  {\n\t\t\t \tloop cand over: candidate {\n\t\t\t \t\tdata  cand.name value:cand.percentage_vote color: cand.color ;\n\t\t\t \t}\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tdisplay indicateurs {\n\t\t\tchart \"Shannon Entropy\" type: series background: #white size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"entropy\" value: entropy color: #blue ;\n\t\t\t}\n\t\t\tchart \"Opinion distribution\" type: series background: #white size: {1,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"Space area covered\" value: (union(candidate collect (each.shape buffer threshold_attraction_candidates))).area / 40000 color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Vote-Vote.md"},"Ants-(Foraging-and-Sorting).md":{"title":" Ants (Foraging and Sorting)","content":"# Ants (Foraging and Sorting)\n\nThis sub-section is composed of the following models :\n\n* [Ant Foraging (Classic)](references#Ants(ForagingandSorting)AntForaging(Classic))\n\n* [Ant Foraging (Complex)](references#Ants(ForagingandSorting)AntForaging(Complex))\n\n* [Ant Foraging (Multi-Simulation)](references#Ants(ForagingandSorting)AntForaging(Multi-Simulation))\n\n* [Ant Foraging (Simple)](references#Ants(ForagingandSorting)AntForaging(Simple))\n\n* [Ant Sorting](references#Ants(ForagingandSorting)AntSorting)\n\n","url":"wiki/Ants-(Foraging-and-Sorting).md"},"Articles.md":{"title":" Articles","content":"# Articles\n\nThis sub-section is composed of the following models :\n\n* [Ville 1](references#Articlesville_1)\n\n* [Ville 2](references#Articlesville_2)\n\n* [Ville 3](references#Articlesville_3)\n\n* [Ville 4](references#Articlesville_4)\n\n* [Ville 5](references#Articlesville_5)\n\n* [Ville 6](references#Articlesville_6)\n\n* [Prima 1](references#ArticlesPrima_model1)\n\n* [Prima 2](references#ArticlesPrima_model2)\n\n* [Prima 3](references#ArticlesPrima_model3)\n\n* [Prima 4](references#ArticlesPrima_model4)\n\n* [Prima 5](references#ArticlesPrima_model5)\n\n* [Prima 5](references#ArticlesPrima_model6)\n\n","url":"wiki/Articles.md"},"Boids.md":{"title":" Boids","content":"# Boids\n\nThis sub-section is composed of the following models :\n\n* [Boids 3D Analysis](references#BoidsBoids3DAnalysis)\n\n* [Boids 3D Motion](references#BoidsBoids3DMotion)\n\n* [Boids With Flocks](references#BoidsBoidsWithFlocks)\n\n* [Boids](references#BoidsBoids)\n\n","url":"wiki/Boids.md"},"Circle.md":{"title":" Circle","content":"# Circle\n\nThis sub-section is composed of the following models :\n\n* [Circle](references#CircleCircle)\n\n","url":"wiki/Circle.md"},"Clock.md":{"title":" Clock","content":"# Clock\n\nThis sub-section is composed of the following models :\n\n* [Clock](references#ClockClock)\n\n","url":"wiki/Clock.md"},"Co-model-Example.md":{"title":" Co-model Example","content":"# Co-model Example\n\nThis sub-section is composed of the following models :\n\n* [Comodel of Boids and Voronoi](references#Co-modelExamplecomodelBoidsVoronoi)\n\n* [Comodel of Flood and Evacuation model](references#Co-modelExamplecomodel_Flood_Evacuation)\n\n* [Comodel SIR Switch](references#Co-modelExampleComodel_SIR_Switch)\n\n* [comodel Urban and Traffic model](references#Co-modelExamplecomodel_Urban_Traffic)\n\n","url":"wiki/Co-model-Example.md"},"Epidemiology.md":{"title":" Epidemiology","content":"# Epidemiology\n\nThis sub-section is composed of the following models :\n\n* [comparison_ABM_EBM_SIR](references#EpidemiologySIR(ABMvsEBM))\n\n* [simple_ODE_SIR_Predefined](references#EpidemiologySIR(Built-In))\n\n* [SIR_split_in_agents](references#EpidemiologySIR(SplitinAgents))\n\n* [SIR_switch](references#EpidemiologySIR(Switch))\n\n* [SI without ODE](references#EpidemiologySusceptibleInfected(SI))\n\n* [SIR without ODE](references#EpidemiologySusceptibleInfectedRecovered(SIR))\n\n","url":"wiki/Epidemiology.md"},"Evacuation.md":{"title":" Evacuation","content":"# Evacuation\n\nThis sub-section is composed of the following models :\n\n* [continuous_move](references#EvacuationContinuousMove)\n\n* [evacuationgoto](references#EvacuationGotoonGrid)\n\n* [grid_move](references#EvacuationMoveonGrid)\n\n","url":"wiki/Evacuation.md"},"Flood-Simulation.md":{"title":" Flood Simulation","content":"# Flood Simulation\n\nThis sub-section is composed of the following models :\n\n* [Hydrological Model](references#FloodSimulationHydrologicalModel)\n\n","url":"wiki/Flood-Simulation.md"},"Learning.md":{"title":" Learning","content":"# Learning\n\nThis sub-section is composed of the following models :\n\n* [Agent Based Clustering](references#LearningMAS_KMEANS)\n\n","url":"wiki/Learning.md"},"Life.md":{"title":" Life","content":"# Life\n\nThis sub-section is composed of the following models :\n\n* [Life](references#LifeLife)\n\n","url":"wiki/Life.md"},"Multi-level-data-analysis.md":{"title":" Multi-level data analysis","content":"# Multi-level data analysis\n\nThis sub-section is composed of the following models :\n\n* [SpatialGraph](references#Multi-leveldataanalysisGraphFromBug(DistanceGraph))\n\n* [SpatialGraph3d](references#Multi-leveldataanalysisGraphFromBug(MirrorGraph))\n\n* [Modavi](references#Multi-leveldataanalysisMODAVI)\n\n","url":"wiki/Multi-level-data-analysis.md"},"Predator-Prey.md":{"title":" Predator Prey","content":"# Predator Prey\n\nThis sub-section is composed of the following models :\n\n* [Basic model (prey agents)](references#PredatorPreyModel01)\n\n* [Dynamic of the vegetation (grid)](references#PredatorPreyModel02)\n\n* [Behavior of the prey agent](references#PredatorPreyModel03)\n\n* [Use of Inspectors/monitors](references#PredatorPreyModel04)\n\n* [Predator agents (parent species)](references#PredatorPreyModel05)\n\n* [Breeding of prey and predator agents](references#PredatorPreyModel06)\n\n* [Agent display (aspect)](references#PredatorPreyModel07)\n\n* [Complex behaviors for the preys and predators](references#PredatorPreyModel08)\n\n* [Adding of a stopping condition](references#PredatorPreyModel09)\n\n* [Definition of charts](references#PredatorPreyModel10)\n\n* [Writing files](references#PredatorPreyModel11)\n\n* [Image loading (raster data)](references#PredatorPreyModel12)\n\n* [Exploration (batch)](references#PredatorPreyModel13)\n\n","url":"wiki/Predator-Prey.md"},"Segregation-(Schelling).md":{"title":" Segregation (Schelling)","content":"# Segregation (Schelling)\n\nThis sub-section is composed of the following models :\n\n* [segregationAgents](references#Segregation(Schelling)Segregation(Agents))\n\n* [segregationGrid](references#Segregation(Schelling)Segregation(CellularAutomata))\n\n* [segregationGIS](references#Segregation(Schelling)Segregation(GIS))\n\n* [segregationGoogleMap](references#Segregation(Schelling)Segregation(GoogleMap))\n\n","url":"wiki/Segregation-(Schelling).md"},"Soccer.md":{"title":" Soccer","content":"# Soccer\n\nThis sub-section is composed of the following models :\n\n* [Soccer Game](references#Soccersoccer)\n\n* [Soccer game (Various strategies)](references#Soccersoccer_expe)\n\n","url":"wiki/Soccer.md"},"Sugarscape.md":{"title":" Sugarscape","content":"# Sugarscape\n\nThis sub-section is composed of the following models :\n\n* [sugarscape](references#SugarscapeSugarscape)\n\n","url":"wiki/Sugarscape.md"},"Traffic.md":{"title":" Traffic","content":"# Traffic\n\nThis sub-section is composed of the following models :\n\n* [Trafic Group (R2D2) MAPS7 - LWR Model](references#TrafficLWRTrafficFlowModel)\n\n* [Traffic](references#TrafficSimpletrafficmodel)\n\n","url":"wiki/Traffic.md"},"Urban-Growth.md":{"title":" Urban Growth","content":"# Urban Growth\n\nThis sub-section is composed of the following models :\n\n* [Cellular Automaton Based Urban Growth](references#UrbanGrowthrastermodel)\n\n","url":"wiki/Urban-Growth.md"},"Voronoi.md":{"title":" Voronoi","content":"# Voronoi\n\nThis sub-section is composed of the following models :\n\n* [Voronoi](references#VoronoiVoronoi)\n\n","url":"wiki/Voronoi.md"},"Vote.md":{"title":" Vote","content":"# Vote\n\nThis sub-section is composed of the following models :\n\n* [vote](references#VoteVote)\n\n","url":"wiki/Vote.md"},"Incremental-Model-Incremental-Model-1.md":{"title":" Simple SI Model","content":"[//]: # (keyword|operator_among)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#km)\n# Simple SI Model\n\n\nFirst part of the tutorial : Incremental Model\n\n\nCode of the model : \n\n```\n\nmodel SI_city\n\nglobal{ \n\tint nb_people <- 500;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #minutes;\n\tgeometry shape<-envelope(square(500 #m));\n\t\n\tinit{\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\t\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\treflex move{\n\t\tdo wander;\n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```\n","url":"wiki/Incremental-Model-Incremental-Model-1.md"},"Incremental-Model-Incremental-Model-2.md":{"title":" Charts","content":"[//]: # (keyword|operator_among)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|concept_chart)\n# Charts\n\n\nSecond part of the tutorial : Incremental Model\n\n\nCode of the model : \n\n```\n\nmodel SI_city\n\nglobal{\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tgeometry shape<-envelope(square(500 #m));\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tint current_hour update: (cycle / 60) mod 24;\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/length(people);\n\t\n\tinit{\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\treflex move{\n\t\tdo wander;\n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map {\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\tdisplay chart refresh: every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Incremental-Model-Incremental-Model-2.md"},"Incremental-Model-Incremental-Model-3.md":{"title":" Integration of GIS Data","content":"[//]: # (keyword|operator_among)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|concept_gis)\n# Integration of GIS Data\n\n\nthird part of the tutorial : Incremental Model\n\n\nCode of the model : \n\n```\n\nmodel model3 \n \nglobal {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tint current_hour update: (cycle / 60) mod 24;\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\t\n\tfloat infected_rate update: nb_people_infected/length(people);\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\t\t\n\treflex move{\n\t\tdo wander;\n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map {\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\tdisplay chart refresh: every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Incremental-Model-Incremental-Model-3.md"},"Incremental-Model-Incremental-Model-4.md":{"title":" Movement on Graph","content":"[//]: # (keyword|operator_^)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|concept_graph)\n# Movement on Graph\n\n\n4th part of the tutorial : Incremental Model\n\n\nCode of the model : \n\n```\n \nmodel model4 \n \nglobal {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m; \n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tint current_hour update: (cycle / 60) mod 24;\n\tgraph road_network;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\t\n\tfloat infected_rate update: nb_people_infected/length(people);\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile; \n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building); \n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo halt;\n\t}  \n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\treflex staying when: target = nil {\n\t\tstaying_counter <- staying_counter + 1;\n\t\tif flip(staying_counter / staying_coeff) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map {\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\tdisplay chart refresh: every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Incremental-Model-Incremental-Model-4.md"},"Incremental-Model-Incremental-Model-5.md":{"title":" 3D visualization","content":"[//]: # (keyword|operator_^)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|statement_light)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_light)\n# 3D visualization\n\n\n5th part of the tutorial : Incremental Model\n\n\nCode of the model : \n\n```\n\nmodel model5 \n \nglobal {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tint current_hour update: (cycle / 60) mod 24;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tbool is_night <- true update: current_hour < 7 or current_hour > 20;\n\t\n\tfloat infected_rate update: nb_people_infected/length(people);\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\treflex stay when: target = nil {\n\t\tstaying_counter <- staying_counter + 1;\n\t\tif flip(staying_counter / staying_coeff) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n\taspect sphere3D{\n\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\taspect geom {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n\nspecies building skills:[moving] {\n\tfloat height <- 10#m + rnd(10) #m;\n\taspect geom {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map_3D type: opengl {\n\t\t\tlight 1 color:(is_night ? 50 : 255) update:true;\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies people aspect:sphere3D;\t\t\t\n\t\t\tspecies building aspect:geom transparency: 0.5;\n\t\t}\n\t\tdisplay chart refresh: every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Incremental-Model-Incremental-Model-5.md"},"Incremental-Model-Incremental-Model-6.md":{"title":" Multi-level","content":"[//]: # (keyword|operator_^)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|operator_dead)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_light)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|concept_multi_level)\n# Multi-level\n\n\n6th part of the tutorial : Incremental Model\n\n\nCode of the model : \n\n```\n\nmodel model6 \n \nglobal  {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tint current_hour update: (cycle / 60) mod 24;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\n\t\n\tlist<people_in_building> list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));\n\t\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tbool is_night <- true update: current_hour < 7 or current_hour > 20;\n\t\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t\t\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\t\t\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n\taspect sphere3D{\n\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\taspect geom {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n\nspecies building {\n\tfloat height <- 10#m + rnd(10) #m;\n\tlist<people_in_building> people_inside -> {members collect people_in_building(each)};\n\t\n\taspect geom {\n\t\tint nbI <- members count people_in_building(each).is_infected;\n\t\tint nbT <- length(members);\n\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height;\n\t}\n\t\n\tspecies people_in_building parent: people schedules: [] {\n\t\taspect circle{}\n\t\taspect sphere3D{}\n\t}\n\t\n\treflex let_people_leave  {\n\t\task members as: people_in_building{\n\t\t\tstaying_counter <- staying_counter + 1;\n\t\t}\n\t\tlist<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\n\t\tif not (empty (leaving_people)) {\n\t\t\trelease leaving_people as: people in: world returns: released_people;\n\t\t\task released_people {\n\t\t\t\ttarget <- any_location_in (one_of(building));\n\t\t\t}\n\t\t}\n\t}\n\treflex let_people_enter {\n\t\tlist<people> entering_people <- people inside self where (each.target = nil);\n\t\tif not (empty (entering_people)) {\n\t\t\tcapture entering_people as: people_in_building ;\n \t\t}\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map_3D type: opengl {\n\t\t\tlight 1 color:(is_night ? 50 : 255) update:true;\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies people aspect:sphere3D;\t\t\t\n\t\t\tspecies building aspect:geom transparency: 0.5;\n\t\t}\n\t\tdisplay chart refresh: every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Incremental-Model-Incremental-Model-6.md"},"Incremental-Model-Incremental-Model-7.md":{"title":" Differential Equation","content":"[//]: # (keyword|operator_^)\n[//]: # (keyword|operator_abs)\n[//]: # (keyword|operator_accumulate)\n[//]: # (keyword|operator_dead)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_diff)\n[//]: # (keyword|operator_among)\n[//]: # (keyword|statement_release)\n[//]: # (keyword|statement_capture)\n[//]: # (keyword|statement_equation)\n[//]: # (keyword|statement_\\=)\n[//]: # (keyword|statement_solve)\n[//]: # (keyword|statement_light)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#m)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|concept_equation)\n# Differential Equation\n\n\n7th part of the tutorial : Incremental Model\n\n\nCode of the model : \n\n```\n\nmodel model7 \nglobal  {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tint current_hour update: (cycle / 60) mod 24;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\n\tfloat beta <- 0.01;\n\tfloat h<-0.1;\n\tlist<people_in_building> list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));\n\t\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tbool is_night <- true update: current_hour < 7 or current_hour > 20;\n\t\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t\t\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\t\t\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n\taspect sphere3D{\n\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\taspect geom {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n\nspecies building {\n\tfloat height <- 10#m + rnd(10) #m;\n\tlist<people_in_building> people_inside -> {members collect people_in_building(each)};\n\tfloat I;\n\tfloat S;\n\tfloat T;\n   \tfloat t;   \n   \tfloat I_to1; \n   \t\n\taspect geom {\n\t\tint nbI <- members count people_in_building(each).is_infected;\n\t\tint nbT <- length(members);\n\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height;\n\t}\n\t\n\tspecies people_in_building parent: people schedules: [] {\n\t\taspect circle{}\n\t\taspect sphere3D{}\n\t}\n\t\n\treflex let_people_leave  {\n\t\task members as: people_in_building{\n\t\t\tstaying_counter <- staying_counter + 1;\n\t\t}\n\t\tlist<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\n\t\tif not (empty (leaving_people)) {\n\t\t\trelease leaving_people as: people in: world returns: released_people;\n\t\t\task released_people {\n\t\t\t\ttarget <- any_location_in (one_of(building));\n\t\t\t}\n\t\t}\n\t}\n\treflex let_people_enter {\n\t\tlist<people> entering_people <- people inside self where (each.target = nil);\n\t\tif not (empty (entering_people)) {\n\t\t\tcapture entering_people as: people_in_building ;\n \t\t}\n\t}\n\tequation SIR{ \n\t\tdiff(S,t) = (- beta * S * I / T) ;\n\t\tdiff(I,t) = (  beta * S * I / T) ;\n\t}\n\n\treflex epidemic when: not empty(members){ \t\n\t\tT <- float(length(members));\n\t\tlist<people_in_building> S_members <- list<people_in_building>(members where not (people_in_building(each).is_infected));\n    \tS <- float(length(S_members));\n    \tI <- T-S;\n    \tfloat I0 <- I;\n    \tif (I > 0 and S > 0) {\n    \t\tsolve SIR method: \"rk4\" step: h;\n    \t\tI_to1 <- I_to1 + (I - I0);\n    \t\tint I_int <- min([int(S),int(I_to1)]);\n\t    \tI_to1 <- I_to1 - I_int;\n\t    \task(I_int among S_members){\n\t    \t\tis_infected <- true;\n\t    \t}\n    \t}\n    }  \n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map_3D type: opengl {\n\t\t\tlight 1 color:(is_night ? 50 : 255) update:true;\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies people aspect:sphere3D;\t\t\t\n\t\t\tspecies building aspect:geom transparency: 0.5;\n\t\t}\n\t\tdisplay chart refresh: every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Incremental-Model-Incremental-Model-7.md"},"Predator-Prey-Model-01.md":{"title":" Basic model (prey agents)","content":"# Basic model (prey agents)\n\n\nFirst part of the tutorial : Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tinit {\n\t\tcreate prey number: nb_preys_init ;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0 ;\n\trgb color <- #blue;\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n} \n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n\toutput {\n\t\tdisplay main_display {\n\t\t\tspecies prey aspect: base ;\n\t\t}\n\t}\n}\n\n \n```\n","url":"wiki/Predator-Prey-Model-01.md"},"Predator-Prey-Model-02.md":{"title":" Dynamic of the vegetation (grid)","content":"[//]: # (keyword|concept_grid)\n# Dynamic of the vegetation (grid)\n\n\nSecond part of the tutorial : Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tinit {\n\t\tcreate prey number: nb_preys_init ;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0 ;\n\trgb color <- #blue;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\t\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t}\n\t}\n}\n\n \n```\n","url":"wiki/Predator-Prey-Model-02.md"},"Predator-Prey-Model-03.md":{"title":" Behavior of the prey agent","content":"# Behavior of the prey agent\n\n\nThird part of the tutorial : Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0 ;\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\t\t\n\tvegetation_cell myCell <- one_of (vegetation_cell) ; \n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\t\n\tinit { \n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move { \n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\treflex eat when: myCell.food > 0 { \n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Model-03.md"},"Predator-Prey-Model-04.md":{"title":" Use of Inspectors/monitors","content":"[//]: # (keyword|concept_inspector)\n[//]: # (keyword|concept_monitor)\n# Use of Inspectors/monitors\n\n\n4th part of the tutorial : Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200 ;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tint nb_preys -> {length (prey)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ;\n\t}\n}\nspecies prey {\n\tfloat size <- 1.0 ;\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\t\t\n\tvegetation_cell myCell <- one_of (vegetation_cell) ; \n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\t\n\tinit { \n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move { \n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\treflex eat when: myCell.food > 0 { \n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys ;\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Model-04.md"},"Predator-Prey-Model-05.md":{"title":" Predator agents (parent species)","content":"[//]: # (keyword|operator_inside)\n[//]: # (keyword|concept_inheritance)\n# Predator agents (parent species)\n\n\n5th part of the tutorial : Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\t\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t\tspecies predator aspect: base ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n \n\n```\n","url":"wiki/Predator-Prey-Model-05.md"},"Predator-Prey-Model-06.md":{"title":" Breeding of prey and predator agents","content":"[//]: # (keyword|operator_inside)\n[//]: # (keyword|type_species)\n# Breeding of prey and predator agents\n\n\n6th part of the tutorial : Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\t\tint nb_offsprings <-int(1 + rnd(nb_max_offsprings -1));\n\t\t\tcreate species(self) number: nb_offsprings {\n\t\t\t\tmyCell <- myself.myCell ;\n\t\t\t\tlocation <- myCell.location ;\n\t\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t\t}\n\t\t\tenergy <- energy / nb_offsprings ;\n\t\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\t\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t\tspecies predator aspect: base ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Model-06.md"},"Predator-Prey-Model-07.md":{"title":" Agent display (aspect)","content":"[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_display)\n# Agent display (aspect)\n\n\n6th part of the tutorial: Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\t\tint nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));\n\t\t\tcreate species(self) number: nb_offsprings {\n\t\t\t\tmyCell <- myself.myCell ;\n\t\t\t\tlocation <- myCell.location ;\n\t\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t\t}\n\t\t\tenergy <- energy / nb_offsprings ;\n\t\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Model-07.md"},"Predator-Prey-Model-08.md":{"title":" Complex behaviors for the preys and predators","content":"[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|type_species)\n# Complex behaviors for the preys and predators\n\n\n8th part of the tutorial: Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\t\tmyCell <- choose_cell();\n\t\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\t\tint nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));\n\t\t\tcreate species(self) number: nb_offsprings {\n\t\t\t\tmyCell <- myself.myCell ;\n\t\t\t\tlocation <- myCell.location ;\n\t\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t\t}\n\t\t\tenergy <- energy / nb_offsprings ;\n\t\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Model-08.md"},"Predator-Prey-Model-09.md":{"title":" Adding of a stopping condition","content":"[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|type_species)\n# Adding of a stopping condition\n\n\n9th part of the tutorial: Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo halt ;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\t\tmyCell <- choose_cell();\n\t\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\t\tint nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));\n\t\t\tcreate species(self) number: nb_offsprings {\n\t\t\t\tmyCell <- myself.myCell ;\n\t\t\t\tlocation <- myCell.location ;\n\t\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t\t}\n\t\t\tenergy <- energy / nb_offsprings ;\n\t\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Model-09.md"},"Predator-Prey-Model-10.md":{"title":" Definition of charts","content":"[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_chart)\n# Definition of charts\n\n\n10th part of the tutorial: Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo halt ;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t} \n\t\t\n\treflex basic_move {\n\t\t\tmyCell <- choose_cell();\n\t\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\t\tint nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));\n\t\t\tcreate species(self) number: nb_offsprings {\n\t\t\t\tmyCell <- myself.myCell ;\n\t\t\t\tlocation <- myCell.location ;\n\t\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t\t}\n\t\t\tenergy <- energy / nb_offsprings ;\n\t\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tdisplay Population_information refresh: every(5) {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red ;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Model-10.md"},"Predator-Prey-Model-11.md":{"title":" Writing files","content":"[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_min_of)\n[//]: # (keyword|operator_max_of)\n[//]: # (keyword|statement_save)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_file)\n# Writing files\n\n\n11th part of the tutorial: Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n\t\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){\n\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\n\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\n\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \n\t   \t\t+ \"; nbPredators: \" + nb_predators           \n\t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \n\t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \n\t   \t\tto: \"results.txt\" type: \"text\" ;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo halt ;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\t\tmyCell <- choose_cell();\n\t\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\t\tint nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));\n\t\t\tcreate species(self) number: nb_offsprings {\n\t\t\t\tmyCell <- myself.myCell ;\n\t\t\t\tlocation <- myCell.location ;\n\t\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t\t}\n\t\t\tenergy <- energy / nb_offsprings ;\n\t\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tdisplay Population_information refresh: every(5) {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red ;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Model-11.md"},"Predator-Prey-Model-12.md":{"title":" Image loading (raster data)","content":"[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_min_of)\n[//]: # (keyword|operator_max_of)\n[//]: # (keyword|statement_save)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_file)\n[//]: # (keyword|concept_raster)\n# Image loading (raster data)\n\n\n12th part of the tutorial: Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tfile map_init <- image_file(\"../includes/data/raster_map.png\");\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t\task vegetation_cell {\n\t\t\tcolor <- rgb (map_init at {grid_x,grid_y}) ;\n\t\t\tfood <- 1 - (((color as list) at 0) / 255) ;\n\t\t\tfoodProd <- food / 100 ; \n\t\t}\n\t}\n\t\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){\n\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\n\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\n\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \n\t   \t\t+ \"; nbPredators: \" + nb_predators           \n\t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \n\t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \n\t   \t\tto: \"results.txt\" type: \"text\" ;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo halt ;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\t\tmyCell <- choose_cell();\n\t\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\t\tint nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));\n\t\t\tcreate species(self) number: nb_offsprings {\n\t\t\t\tmyCell <- myself.myCell ;\n\t\t\t\tlocation <- myCell.location ;\n\t\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t\t}\n\t\t\tenergy <- energy / nb_offsprings ;\n\t\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tdisplay Population_information refresh: every(5) {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red ;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```\n","url":"wiki/Predator-Prey-Model-12.md"},"Predator-Prey-Model-13.md":{"title":" Exploration (batch)","content":"[//]: # (keyword|operator_with_precision)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_inside)\n[//]: # (keyword|operator_min_of)\n[//]: # (keyword|operator_max_of)\n[//]: # (keyword|statement_save)\n[//]: # (keyword|statement_tabu)\n[//]: # (keyword|constant_#lightgray)\n[//]: # (keyword|type_species)\n[//]: # (keyword|concept_batch)\n# Exploration (batch)\n\n\n13th part of the tutorial: Predator Prey\n\n\nCode of the model : \n\n```\n\nmodel prey_predator\n\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tfile map_init <- image_file(\"../includes/data/raster_map.png\");\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t\task vegetation_cell {\n\t\t\tcolor <- rgb (map_init at {grid_x,grid_y}) ;\n\t\t\tfood <- 1 - (((color as list) at 0) / 255) ;\n\t\t\tfoodProd <- food / 100 ; \n\t\t}\n\t}\n\t\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){\n\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\n\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\n\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \n\t   \t\t+ \"; nbPredators: \" + nb_predators           \n\t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \n\t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \n\t   \t\tto: \"results.txt\" type: \"text\" ;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo halt ;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\timage_file my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\t\tmyCell <- choose_cell();\n\t\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\t\tint nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));\n\t\t\tcreate species(self) number: nb_offsprings {\n\t\t\t\tmyCell <- myself.myCell ;\n\t\t\t\tlocation <- myCell.location ;\n\t\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t\t}\n\t\t\tenergy <- energy / nb_offsprings ;\n\t\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../includes/data/wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbors_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tdisplay Population_information refresh: every(5) {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red ;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n\nexperiment Optimization type: batch repeat: 2 keep_seed: true until: ( time > 200 ) {\n\tparameter \"Prey max transfert:\" var: prey_max_transfert min: 0.05 max: 0.5 step: 0.05 ;\n\tparameter \"Prey energy reproduce:\" var: prey_energy_reproduce min: 0.05 max: 0.75 step: 0.05;\n\tparameter \"Predator energy transfert:\" var: predator_energy_transfert min: 0.1 max: 1.0 step: 0.1 ;\n\tparameter \"Predator energy reproduce:\" var: predator_energy_reproduce min: 0.1 max: 1.0 step: 0.1;\n\tmethod tabu maximize: nb_preys + nb_predators iter_max: 10 tabu_list_size: 3;\n}\n```\n","url":"wiki/Predator-Prey-Model-13.md"},"Road-Traffic-Model-01.md":{"title":" Loading of GIS data (buildings and roads)","content":"[//]: # (keyword|constant_#minute)\n[//]: # (keyword|concept_gis)\n# Loading of GIS data (buildings and roads)\n\n\nfirst part of the tutorial: Road Traffic\n\n\nCode of the model : \n\n```\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tgeometry shape <- envelope(envelope(buildings_shapefile) + envelope(roads_shapefile));\n\tfloat step <- 10 #mn;\n\t\n\tinit {\n\t\tcreate building from: buildings_shapefile ;\n\t\tcreate road from: roads_shapefile ;\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #red ;\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\t\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Road-Traffic-Model-01.md"},"Road-Traffic-Model-02.md":{"title":" Definition of people agents","content":"[//]: # (keyword|constant_#minute)\n[//]: # (keyword|concept_gis)\n# Definition of people agents\n\n\nsecond part of the tutorial: Road Traffic\n\n\nCode of the model : \n\n```\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tcreate people number: nb_people {\n\t\t\tlocation <- any_location_in (one_of (residential_buildings));\n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #black ;\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people {\n\trgb color <- #yellow ;\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Road-Traffic-Model-02.md"},"Road-Traffic-Model-03.md":{"title":" Movement of the people agents","content":"[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|concept_agent_movement)\n# Movement of the people agents\n\n\nthird part of the tutorial: Road Traffic\n\n\nCode of the model : \n\n```\n\nmodel tutorial_gis_city_traffic\n\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tthe_graph <- as_edge_graph(road);\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n}\n\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #black ;\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tdo goto target: the_target on: the_graph ; \n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\n\nexperiment road_traffic type: gui {\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 50 #km/#h;\n\t\n\toutput {\n\t\tdisplay city_display type: opengl {\n\t\t\tspecies building aspect: base refresh: false;\n\t\t\tspecies road aspect: base refresh: false;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Road-Traffic-Model-03.md"},"Road-Traffic-Model-04.md":{"title":" Definition of weight for the road network","content":"[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|concept_graph)\n# Definition of weight for the road network\n\n\n4th part of the tutorial: Road Traffic\n\n\nCode of the model : \n\n```\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tdo goto target: the_target on: the_graph ; \n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Road-Traffic-Model-04.md"},"Road-Traffic-Model-05.md":{"title":" Dynamic update of the road network","content":"[//]: # (keyword|operator_agent_from_geometry)\n[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_graph)\n# Dynamic update of the road network\n\n\n5th part of the tutorial: Road Traffic\n\n\nCode of the model : \n\n```\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}\n```\n","url":"wiki/Road-Traffic-Model-05.md"},"Road-Traffic-Model-06.md":{"title":" Definition of a chart display","content":"[//]: # (keyword|operator_agent_from_geometry)\n[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|operator_max_of)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|constant_#magenta)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_chart)\n# Definition of a chart display\n\n\n6th part of the tutorial: Road Traffic\n\n\nCode of the model : \n\n```\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t\tdisplay chart_display refresh: every(10) { \n\t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\n\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\n\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\n\t\t\t}\n\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\n\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\n\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Road-Traffic-Model-06.md"},"Road-Traffic-Model-07.md":{"title":" Automatic repair of roads","content":"[//]: # (keyword|operator_agent_from_geometry)\n[//]: # (keyword|operator_as_map)\n[//]: # (keyword|operator_\\:\\:)\n[//]: # (keyword|operator_with_weights)\n[//]: # (keyword|operator_with_max_of)\n[//]: # (keyword|operator_max_of)\n[//]: # (keyword|constant_#minute)\n[//]: # (keyword|constant_#km)\n[//]: # (keyword|constant_#magenta)\n[//]: # (keyword|type_path)\n[//]: # (keyword|concept_transport)\n# Automatic repair of roads\n\n\n7th part of the tutorial: Road Traffic\n\n\nCode of the model : \n\n```\n\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tint repair_time <- 2 ;\n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n\treflex repair_road when: every(repair_time #hour / step) {\n\t\troad the_road_to_repair <- road with_max_of (each.destruction_coeff) ;\n\t\task the_road_to_repair {\n\t\t\tdestruction_coeff <- 1.0 ;\n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\tparameter \"Number of hours between two road repairs\" var: repair_time category: \"Road\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t\tdisplay chart_display refresh: every(10) { \n\t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\n\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\n\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\n\t\t\t}\n\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\n\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\n\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","url":"wiki/Road-Traffic-Model-07.md"},"Incremental-Model.md":{"title":" Incremental Model","content":"# Incremental Model\n\nThis sub-section is composed of the following models :\n\n* [Simple SI Model](references#IncrementalModelIncrementalModel1)\n\n* [Charts](references#IncrementalModelIncrementalModel2)\n\n* [Integration of GIS Data](references#IncrementalModelIncrementalModel3)\n\n* [Movement on Graph](references#IncrementalModelIncrementalModel4)\n\n* [3D visualization](references#IncrementalModelIncrementalModel5)\n\n* [Multi-level](references#IncrementalModelIncrementalModel6)\n\n* [Differential Equation](references#IncrementalModelIncrementalModel7)\n\n","url":"wiki/Incremental-Model.md"},"Road-Traffic.md":{"title":" Road Traffic","content":"# Road Traffic\n\nThis sub-section is composed of the following models :\n\n* [Loading of GIS data (buildings and roads)](references#RoadTrafficModel01)\n\n* [Definition of people agents](references#RoadTrafficModel02)\n\n* [Movement of the people agents](references#RoadTrafficModel03)\n\n* [Definition of weight for the road network](references#RoadTrafficModel04)\n\n* [Dynamic update of the road network](references#RoadTrafficModel05)\n\n* [Definition of a chart display](references#RoadTrafficModel06)\n\n* [Automatic repair of roads](references#RoadTrafficModel07)\n\n","url":"wiki/Road-Traffic.md"},"Additionnal-Plugins.md":{"title":" Additionnal Plugins","content":"# Additionnal Plugins\n\nThis section is composed of the following sub-section :\n\n* [Diffusion Statement](references#DiffusionStatement)\n\n* [Ordinary Differential Equations](references#OrdinaryDifferentialEquations)\n\n","url":"wiki/Additionnal-Plugins.md"},"Features.md":{"title":" Features","content":"# Features\n\nThis section is composed of the following sub-section :\n\n* [3D Visualization](references#3DVisualization)\n\n* [Agent movement](references#Agentmovement)\n\n* [Batch](references#Batch)\n\n* [Charts](references#Charts)\n\n* [Clustering](references#Clustering)\n\n* [Co-model Usage](references#Co-modelUsage)\n\n* [Color](references#Color)\n\n* [Data Importation](references#DataImportation)\n\n* [Database Usage](references#DatabaseUsage)\n\n* [Date and Time](references#DateandTime)\n\n* [Driving Skill](references#DrivingSkill)\n\n* [Graphs](references#Graphs)\n\n* [Init Action](references#InitAction)\n\n* [Map comparison](references#Mapcomparison)\n\n* [Multi-Level Usage](references#Multi-LevelUsage)\n\n* [Multi-simulation](references#Multi-simulation)\n\n* [Multicriteria decision](references#Multicriteriadecision)\n\n* [Overlay](references#Overlay)\n\n* [Save statement](references#Savestatement)\n\n* [Spatial Operators](references#SpatialOperators)\n\n* [Statistics](references#Statistics)\n\n* [Unit Test](references#UnitTest)\n\n* [User Interaction](references#UserInteraction)\n\n","url":"wiki/Features.md"},"Syntax.md":{"title":" Syntax","content":"# Syntax\n\nThis section is composed of the following sub-section :\n\n* [Syntax models](references#Syntaxmodels)\n\n","url":"wiki/Syntax.md"},"Toy-Models.md":{"title":" Toy Models","content":"# Toy Models\n\nThis section is composed of the following sub-section :\n\n* [Ants (Foraging and Sorting)](references#Ants(ForagingandSorting))\n\n* [Articles](references#Articles)\n\n* [Boids](references#Boids)\n\n* [Circle](references#Circle)\n\n* [Clock](references#Clock)\n\n* [Co-model Example](references#Co-modelExample)\n\n* [Epidemiology](references#Epidemiology)\n\n* [Evacuation](references#Evacuation)\n\n* [Flood Simulation](references#FloodSimulation)\n\n* [Learning](references#Learning)\n\n* [Life](references#Life)\n\n* [Multi-level data analysis](references#Multi-leveldataanalysis)\n\n* [Predator Prey](references#PredatorPrey)\n\n* [Segregation (Schelling)](references#Segregation(Schelling))\n\n* [Soccer](references#Soccer)\n\n* [Sugarscape](references#Sugarscape)\n\n* [Traffic](references#Traffic)\n\n* [Urban Growth](references#UrbanGrowth)\n\n* [Voronoi](references#Voronoi)\n\n* [Vote](references#Vote)\n\n","url":"wiki/Toy-Models.md"},"Tutorials.md":{"title":" Tutorials","content":"# Tutorials\n\n\n\n\nWe propose some tutorials that are designed to allow modelers to become progressively autonomous with the GAMA platform. These tutorials cover different aspects of GAMA (Grid environment, GIS integration, 3D, multi-level modeling, equation-based models...). It is a good idea to keep a copy of the [reference of the GAML language](GamlReference) around when undertaking one of these tutorials.\n\n* [Predator Prey](#predator-prey-tutorial)\n* [Road Traffic](#road-traffic)\n* [3D Tutorial](#3d-tutorial)\n* [Luneray's flu](#lunerays-flu-tutorial)\n* [Incremental Model](#incremental-model)\n\n## [Predator Prey tutorial](PredatorPrey)\n\n![resources/images/tutorials/predator_prey.png](resources/images/tutorials/predator_prey.png)\n\nThis tutorial introduces the basic concepts of GAMA and the use of grids. It is based on the classic predator prey model (see for instance a formal definition [here](http://www.scholarpedia.org/article/Agent_based_modeling)). It is particularly adapted to beginners that want to quickly learn how to build a simple model in GAMA.\n\n\n\n## [Road Traffic](RoadTrafficModel)\n\n![resources/images/tutorials/road_traffic.png](resources/images/tutorials/road_traffic.png)\n\nThis tutorial introduces the use of GIS data. It is based on a mobility and daily activity model. It is particularly adapted to modelers that want to quickly learn how to integrate GIS data in their model and to use a road shapefile for the movement of their agents.\n\n\n\n\n## [3D Tutorial](ThreeD)\n<a></a>\nThis tutorial introduces the use of 3D in GAMA. In particular, it offers a quick overview of the 3D capabilities of the platform and how to integrate 3D features in models.\n\n\n## [Luneray's flu tutorial](LuneraysFlu)\n\n![resources/images/tutorials/Luneray.jpg](resources/images/tutorials/Luneray.jpg)\n\n\nThis tutorial dedicated to beginners introduces the basic concepts of GAMA and proposes a brief overview of many features.  It concerns a model of disease spreading in the small city of Luneray. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, and to define a 3D display.\n\n## [Incremental Model](IncrementalModel)\n\n![resources/images/tutorials/incremental_model.jpg](resources/images/tutorials/incremental_model.jpg)\n\n\nThis tutorial proposes is an advance version of the Luneray's tutorial. It concerns a model of disease spreading in a small city. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, to define a 3D display, to define a multi-level model and use differential equations.","url":"wiki/Tutorials.md"},"GamlEditorGeneralities.md":{"title":" The GAML Editor - Generalities","content":"# The GAML Editor - Generalities\n\nThe GAML Editor is a text editor that proposes several services to support the modeler in writing correct models: an integrated live validation system, a ribbon header that gives access to [experiments](LaunchingExperiments), information, warning and error markers.\n\n## Table of contents \n\n* [The GAML Editor - Generalities](#the-gaml-editor-generalities)\n\t* [Creating a first model](#creating-a-first-model)\n\t* [Status of models in editors](#status-of-models-in-editors)\n\t* [Editor Preferences](#editor-preferences)\n\t* [Multiple editors](#multiple-editors)\n\t* [Local history](#local-history)\n\n\n## Creating a first model\n\nEditing a model requires that at least one **project** is created in _User Models_. If there is none, right-click on _User Models_ and choose \"New... > Gama Project...\" (if you already have user projects and want to create a model in one of them, skip the next step).\n\n![images/1.new_project.png](resources/images/editingModels/1.new_project.png)\n\nA dialog is then displayed, offering you to enter the name of the project as well as its location on the filesystem. Unless you are absolutely sure of what you are doing, keep the \"Use default location\" option checked. An error will be displayed if the project name already exists in the workspace, in which case you will have to change it. Two projects with similar names can not coexist in the workspace (even if they belong to different categories).\n\n![images/2.new_project2.png](resources/images/editingModels/2.new_project2.png)\n\n\nOnce the project is created (or if you have an existing project), navigate to it and right-click on it. This time, choose \"New...>Model file...\" to create a new model.\n\n![images/3.new_model.png](resources/images/editingModels/3.new_model.png)\n\nA new dialog is displayed, which asks for several required or optional information. The _Container_ is normally the name of the project you have selected, but you can choose to place the file elsewhere. An error will be displayed if the container does not exist (yet) in the workspace. You can then choose whether you want to use a template or not for producing the initial file, and you are invited to give this file a name. An error is displayed if this name already exists in this project. The name of the model, which is by default computed with respect to the name of the file, can be actually completely different (but it may not contain white spaces or punctuation characters). The name of the author, as well as the textual description of the model and the creation of an HTML documentation, are optional.\n\n![images/4.new_model2.png](resources/images/editingModels/4.new_model2.png)\n\n\n## Status of models in editors\n\nOnce this dialog is filled and accepted, GAMA will display the new \"empty\" model.\n\n![images/5.view_model.png](resources/images/editingModels/5.view_model.png)\n\n\nAlthough GAML files are just plain text files, and can therefore be produced or modified in any text processor, using the dedicated GAML editor offers a number of advantages, among which the live display of errors and model statuses. A model can actually be in four different states, which are visually accessible above the editing area: _Functional_ (orange color), _Experimentable_ (green color), _InError_ (red color), InImportedError_(yellow color). See [the section on model compilation](ValidationOfModels) for more precise information about these statuses._\n\nIn its initial state, a model is always in the _Functional_ state, which means it compiles without problems, but cannot be used to launch experiments. The _InError_ state, depicted below, occurs when the file contains errors (syntactic or semantic ones).\n\n![images/6.view_model_with_error.png](resources/images/editingModels/6.view_model_with_error.png)\n\nWhile the file is not saved, these errors remain displayed in the editor and nowhere else. If you save the file, they are now considered as \"workspace errors\" and get displayed in the \"Problems\" view below the editor.\n\n![images/7.view_model_with_error_saved.png](resources/images/editingModels/7.view_model_with_error_saved.png)\n\nReaching the _Experimentable_ state requires that all errors are eliminated and that at least one experiment is defined in the model, which is the case now in our toy model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow to launch this experiment on your model. See [the section about running experiments](RunningExperiments) for more information on this point.\n\n![images/8.view_model_with_experiment.png](resources/images/editingModels/8.view_model_with_experiment.png)\n\nExperiment buttons are updated in real-time to reflect what's in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one.\n\n![images/9.view_model_with_3_experiments.png](resources/images/editingModels/9.view_model_with_3_experiments.png)\n\n\n\n\n## Editor Preferences\n\nText editing in general, and especially in Eclipse-based editors, sports a number of options and preferences. You might want to turn off/on the numbering of the lines, change the fonts used, change the colors used to highlight the code, etc. All of these preferences are accessible from the \"Preferences...\" item of the editor contextual menu.\n\n![images/10.view_model_with_preferences.png](resources/images/editingModels/10.view_model_with_preferences.png)\n\nExplore the different items present there, keeping in mind that these preferences will apply to all the editors of GAMA and will be stored in your workspace.\n\n![images/11.editor_preferences.png](resources/images/editingModels/11.editor_preferences.png)\n\n\n## Additional informations in the Editor\n\n![images/additional_informations_in_editor.png](resources/images/editingModels/additional_informations_in_editor.png)\n\nYou can choose to display or not some informations in your Editor\n\nOne particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model, but also its structure (complementing, in that sense, the _Outline_ view). It is a slightly modified version of a plugin called [EditBox](http://sourceforge.net/projects/editbox/), which can be activated by clicking on the \"green square\" icon in the toolbar.\n\n![images/12.view_model_with_editbox_default.png](resources/images/editingModels/12.view_model_with_editbox_default.png)\n\nThe Default theme of [EditBox](http://sourceforge.net/projects/editbox/) might not suit everyone's tastes, so the preferences allow to entirely customize how the \"boxes\" are displayed and how they can support the modeler in better understanding \"where\" it is in the code. The \"themes\" defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.\n\n![images/13.editbox_preferences.png](resources/images/editingModels/13.editbox_preferences.png)\n\n\n\n\n## Multiple editors\nGAMA inherits from [Eclipse](http://www.eclipse.org) the possibility to entirely configure the placement of the views, editors, etc. This can be done by rearranging their position using the mouse (click and hold on an editor's title and move it around). In particular, you can have several editors side by side, which can be useful for viewing the documentation while coding a model.\n\n![images/14.view_model_side_by_side.png](resources/images/editingModels/14.view_model_side_by_side.png)\n\n\n\n\n## Local history\nAmong the various options present to work with models, which you are invited to try out and test at will, one, called _Local history_ is particularly interesting and worth a small explanation. When you edit models, GAMA keeps in the background all the successive versions you save (the history duration is configurable in the preferences), whether or not you are using a versioning system like SVN or Git. This local history is accessible from different places in GAMA (the _Navigator_, the _Views_ menu, etc.), including the contextual menu of the editor.\n\n![images/15.view_model_with_local_history_menu.png](resources/images/editingModels/15.view_model_with_local_history_menu.png)\n\nThis command invokes the opening of a new view, which you can see on the figure below, and which lists the different versions of your file so far. You can then choose one and, right-clicking on it, either open it in a new editor, or compare it to your current version.\n\n![images/16.view_model_with_local_history_compare_menu.png](resources/images/editingModels/16.view_model_with_local_history_compare_menu.png)\n\nThis allows you to precisely pinpoint the modifications brought to the file and, in case of problems, to revert them easily, or even revert the entire file to a previous version. Never lose your work again !\n\n![images/17.view_model_with_local_history_side_by_side.png](resources/images/editingModels/17.view_model_with_local_history_side_by_side.png)\n\nThis short introduction to GAML editors is now over. You might want to take a look, now, at [how the models you edit are parsed, validated and compiled](ValidationOfModels), and how this information is accessible to the modeler.","url":"wiki/GamlEditorGeneralities.md"},"GamlEditorToolbar.md":{"title":" The GAML Editor Toolbar","content":"# The GAML Editor Toolbar\n\nThe GAML Editor provide some tools to make the editing easier, covering a lot of functionalities, such as tools for changes of visualization, tools for navigation through your model, tools to format your code, or also tools to help you finding the correct keywords to use in a given context.\n\n![images/graphical_editor_toolbar.png](resources/images/editingModels/graphical_editor_toolbar.png)\n\n## Table of contents\n\n* [The GAML Editor Toolbar](#the-gaml-editor-toolbar)\n    \t* [Visualization tools in the editor](#visualization-tools-in-the-editor)\n    \t* [Navigation tools in the editor](#navigation-tools-in-the-editor)\n    \t* [Format tools in the editor](#format-tools-in-the-editor)\n    \t* [Vocabulary tools in the editor](#vocabulary-tools-in-the-editor)\n\n## Visualization tools in the editor\n\n![images/additional_informations_in_editor.png](resources/images/editingModels/additional_informations_in_editor.png)\n\nYou can choose to display or not some informations in your Editor. Here are the different features for this part:\n\n### Display the number of lines\n\nThe first toggle is used to show / hide the number of lines.\n\n### Expand / Collapse lines\n\nThe second toggle provides you the possibility to expand or collapse lines in your model depending on the indentation. This feature can be very useful for big models, to collapse the part you have already finished.\n\n### Mark the occurrences\n\nThis third toggle is used to show occurrences when your cursor is pointing on one word.\n\n### Display colorization of code section\n\nOne particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model, but also its structure (complementing, in that sense, the *Outline* view). It is a slightly modified version of a plugin called [EditBox](http://sourceforge.net/projects/editbox/), which can be activated by clicking on the \"green square\" icon in the toolbar.\n\n![images/12.view_model_with_editbox_default.png](resources/images/editingModels/12.view_model_with_editbox_default.png)\n\nThe Default theme of [EditBox](http://sourceforge.net/projects/editbox/) might not suit everyone's tastes, so the preferences allow to entirely customize how the \"boxes\" are displayed and how they can support the modeler in better understanding \"where\" it is in the code. The \"themes\" defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.\n\n![images/13.editbox_preferences.png](resources/images/editingModels/13.editbox_preferences.png)\n\n### Change the font size\n\nThe two last tools of this section are used to increase / decrease the size of the displayed text.\n\n## Navigation tools in the editor\n\n![images/navigation_in_editor.png](resources/images/editingModels/navigation_in_editor.png)\n\nIn the Editor toolbar, you have some tools for search and navigation through the code. Here are the explanation for each functionalities:\n\n### The search engine\n\nIn order to search an occurrence of a word (or the part of a word), you can type your search in the field, and the result will be highlighted automatically in the text editor.\n\n![images/search_engine.png](resources/images/editingModels/search_engine.png)\n\nWith the left / right arrows, you can highlight the previous / next occurrence of the word. The two toggles just in the right side of the search field are used to constraint the results as \"case sensitive\" or \"whole word\". If you prefer the eclipse interface for the search engine, you can also access to the tool by taping Ctrl+F.\n\n### Previous / Next location\n\nThe two arrow shape buttons that are coming after are used to jump from the current location of your cursor to the last position, even if the last position was in an other file (and even if this file has been closed !).\n\n### Show outline\n\nThis last tool of this section is used to show the global architecture of your model, with explicit icons for each section. A search field is also available, if you want to search a specific section. By double clicking one line of the outline, you can jump directly to the chosen section. This feature can be useful if you have big model to manipulate.\n\n![images/show_outline.png](resources/images/editingModels/show_outline.png)\n\n## Format tools in the editor\n\n![images/format_the_text_in_editor.png](resources/images/editingModels/format_the_text_in_editor.png)\n\nSome other tools are available in the toolbar to help for the indentation of the model:\n\n### Shift left / shift right\n\nThose two first buttons are used to shift a line (or a group of lines) on the left or the right.\n\n### Format\n\nThis useful feature re-indent automatically all your model.\n\n### Re-serialize\n\nRe-serialize your model.\n\n### Comment\n\nThe two last buttons of this section are useful to comment a line (or a group of lines).\n\n## Vocabulary tools in the editor\n\n![images/vocabulary_help_in_editor.png](resources/images/editingModels/vocabulary_help_in_editor.png)\n\nThe last group of buttons are used to search the correct way to write a certain keyword.\n\n### Templates\n\nThe templates button is used to insert directly a code snippet in the current position of the cursor. Some snippets are already available, ordered by scope. You can custom the list of template as much as you want, it is very easy to add a new template.\n\n### Built-in attributes, built-in actions\n\nWith this feature, you can easily know the list of built-in attributes and built-in actions you can use in such or such context. With this feature, you can also insert some templates to help you, for example to insert a pre-made species using a particular skill, as it is shown it the following screenshot:\n\n![images/insert_species_with_moving_skill1.png](resources/images/editingModels/insert_species_with_moving_skill1.png)\n\n... will generate the following code:\n\n![images/insert_species_with_moving_skill2.png](resources/images/editingModels/insert_species_with_moving_skill2.png)\n\nAll the comments are generated automatically from the current documentation.\n\n### Operators\n\nOnce again, this powerful feature is used to generate example of structures for all the operators, ordered by categories.\n\n### Colors\n\nHere is the list of the name for the different pre-made colors you can use. You can also add some custom colors.\n\n![images/color.png](resources/images/editingModels/color.png)","url":"wiki/GamlEditorToolbar.md"},"GraphicalEditor.md":{"title":" The Graphical Editor","content":"# The Graphical Editor\n\n\nThe graphical editor that allow to build diagram (gadl files) is based on the [Graphiti](http://www.eclipse.org/graphiti/) Eclipse plugin. It allows to define a GAMA model through a graphical interface. It a allows as well to produce a graphical model (diagram) from a gaml model.\n\n![images/graphical_editor/gm_predator_prey.png](resources/images/graphical_editor/gm_predator_prey.png)\n\n## Table of contents \n\n* [The Graphical Editor](#the-graphical-editor)\n\t* [Installing the graphical editor](#installing-the-graphical-editor)\n\t* [Creating a first model](#creating-a-first-model)\n\t* [Status of models in editors](#status-of-models-in-editors)\n\t* [Diagram definition framework](#diagram-definition-framework)\n\t* [Features](#features)\n\t\t* [agents](#agents)\n\t\t\t* [species](#species)\n\t\t\t* [grid](#grid)\n\t\t\t* [Inheriting link](#inheriting-link)\n\t\t\t* [world](#world)\n\t\t* [agent features](#agent-features)\n\t\t\t* [action](#action)\n\t\t\t* [reflex](#reflex)\n\t\t\t* [aspect](#aspect)\n\t\t* [experiment](#experiment)\n\t\t\t* [GUI experiment](#gui-experiment)\n\t\t\t* [display](#display)\n\t\t\t* [batch experiment](#batch-experiment)\n\t* [Pictogram color modification](#pictogram-color-modification)\n\t* [GAML Model generation](#gaml-model-generation)\n\n\n## Installing the graphical editor\nUsing the graphical editor requires to install the graphical modeling plug-in. See [here](G__InstallingPlugins) for information about plug-ins and their installation.\n\nThe graphical editor plug-in is called **Graphical\\_modeling** and is directly available from GAMA update site **https://gama-platform.googlecode.com/svn/update_site/*.**\n\n\n![install](resources/images/graphical_editor/installing_graphical_editor.JPG)\n\n\nNote that the graphical editor is still under development. Updates of the plug-in will be add to the GAMA website. After installing the plug-in (and periodically), check for updates for this plug-in: in the \"Help\" menu, choose \"Check for Updates\" and install the proposed updates for the graphical modeling plug-in.\n\n\n\n\n## Creating a first model\n\nA new diagram can be created in a new GAMA project. First, right click on a project, then select \"New\" on the contextual menu.\nIn the New Wizard, select \"GAMA -> Model Diagram\", then \"Next>\"\n![images/graphical_editor/newDiagram.png](resources/images/graphical_editor/newDiagram.png)\n\nIn the next Wizard dialog, select the type of diagram (Empty, Skeleton or Example) then the name of the file and the author.\n\n![images/graphical_editor/modeldiagramNew.png](resources/images/graphical_editor/modeldiagramNew.png) \n\nSkeleton and Example diagram types allow to add to the diagram some basic features.\n\n\n\n\n\n## Status of models in editors\n\nSimilarly to GAML editor, the graphical editor proposes a live display of errors and model statuses. A graphical model can actually be in three different states, which are visually accessible above the editing area: **Functional** (orange color), **Experimentable** (green color) and **InError** (red color). See [the section on model compilation](CompilingModels161) for more precise information about these statuses.\n\nIn its initial state, a model is always in the **Functional** state, which means it compiles without problems, but cannot be used to launch experiments. The **InError** state occurs when the file contains errors (syntactic or semantic ones).\n\nReaching the **Experimentable** state requires that all errors are eliminated and that at least one experiment is defined in the model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow to launch this experiment on your model.\n\nExperiment buttons are updated in real-time to reflect what's in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one.\n\n\n\n\n\n## Diagram definition framework\n\nThe following figure presents the editing framework:\n![images/graphical_editor/framework.png](resources/images/graphical_editor/framework.png)\n\n\n\n\n\n## Features\n\n### agents\n#### species\n\n![images/graphical_editor/species.png](resources/images/graphical_editor/species.png)\n\nThe species feature allows to define a species with a continuous topology. A species is always a micro-species of another species. The top level (macro-species of all species) is the world species.\n\n  * **source**: a species (macro-species)\n  * **target**: -\n![images/graphical_editor/Frame_Speciesdef1.png](resources/images/graphical_editor/Frame_Speciesdef1.png)\n\n![images/graphical_editor/Frame_Speciesdef2.png](resources/images/graphical_editor/Frame_Speciesdef2.png)\n\n#### grid\n\n![images/graphical_editor/grid.png](resources/images/graphical_editor/grid.png)\n\nThe grid feature allows to define a [species](Species151) with a [grid topology](Sections151#environment). A grid is always a micro-species of another species.\n\n  * **source**: a species (macro-species)\n  * **target**: -\n\n![images/graphical_editor/Frame_grid.png](resources/images/graphical_editor/Frame_grid.png)\n\n#### Inheriting link\nThe inheriting link feature allows to define an inheriting link between two species.\n\n  * **source**: a species (parent)\n  * **target**: a species (child)\n\n![images/graphical_editor/inhereting_link.png](resources/images/graphical_editor/inhereting_link.png)\n\n\n#### world\n\n![images/graphical_editor/world.png](resources/images/graphical_editor/world.png)\n\nWhen a model is created, a world species is always defined. It represent the global part of the model. The world species, which is unique, is the top level species. All other species are micro-species of the world species.\n\n![images/graphical_editor/Frame_world.png](resources/images/graphical_editor/Frame_world.png)\n\n### agent features\n\n#### action\n![images/graphical_editor/action.png](resources/images/graphical_editor/action.png)\n\nThe action feature allows to define an action for a species.\n\n  * **source**: a species (owner of the action)\n  * **target**: -\n\n![images/graphical_editor/Frame_action.png](resources/images/graphical_editor/Frame_action.png)\n\n#### reflex\n![images/graphical_editor/reflex.png](resources/images/graphical_editor/reflex.png)\n\nThe reflex feature allows to define a reflex for a species.\n\n  * **source**: a species (owner of the reflex)\n  * **target**: -\n\n![images/graphical_editor/Frame_reflex.png](resources/images/graphical_editor/Frame_reflex.png)\n\n#### aspect\n![images/graphical_editor/aspect.png](resources/images/graphical_editor/aspect.png)\n\nThe aspect feature allows to define an aspect for a species.\n\n  * **source**: a species (owner of the aspect)\n  * **target**: -\n\n![images/graphical_editor/Frame_aspect.png](resources/images/graphical_editor/Frame_aspect.png)\n\n\n![images/graphical_editor/Frame_Aspect_layer.png](resources/images/graphical_editor/Frame_Aspect_layer.png)\n### experiment\n#### GUI experiment\n\n![images/graphical_editor/guiXP.png](resources/images/graphical_editor/guiXP.png)\n\nThe GUI Experiment feature allows to define a GUI experiment.\n\n  * **source**: world species\n  * **target**: -\n\n![images/graphical_editor/Frame_Experiment.png](resources/images/graphical_editor/Frame_Experiment.png)\n\n#### display\n\n![images/graphical_editor/display.png](resources/images/graphical_editor/display.png)\n\nThe display feature allows to define a display.\n\n  * **source**: GUI experiment\n  * **target**: -\n\n![images/graphical_editor/Frame_display.png](resources/images/graphical_editor/Frame_display.png)\n\n\n![images/graphical_editor/Frame_layer_display.png](resources/images/graphical_editor/Frame_layer_display.png)\n\n#### batch experiment\n\n![images/graphical_editor/batchxp.png](resources/images/graphical_editor/batchxp.png)\n\nThe Batch Experiment feature allows to define a Batch experiment.\n\n  * **source**: world species\n  * **target**: -\n\n\n\n\n\n## Pictogram color modification\nIt is possible to change the color of a pictogram.\n  * Right click on a pictogram, then select the \"Chance the color\".\n\n\n\n\n\n## GAML Model generation\nIt is possible to automatically generate a Gaml model from a diagram.\n  * Right click on the graphical framework (where the diagram is defined), then select the \"Generate Gaml model\".\nA new GAML model with the same name as the diagram is created (and open).\n","url":"wiki/GraphicalEditor.md"},"ValidationOfModels.md":{"title":" Validation of Models","content":"# Validation of Models\n\nWhen editing a model, GAMA will continuously validate (i.e. _compile_) what the modeler is entering and indicate, with specific visual affordances, various information on the state of the model. This information ranges from documentation items to errors indications. We will review some of them in this section.\n\n## Table of contents \n\n* [Validation of Models](#validation-of-models)\n\t* [Syntactic errors](#syntactic-errors)\n\t* [Semantic errors](#semantic-errors)\n\t* [Semantic warnings](#semantic-warnings)\n\t* [Semantic information](#semantic-information)\n\t* [Semantic documentation](#semantic-documentation)\n\t* [Changing the visual indicators](#changing-the-visual-indicators)\n\t* [Errors in imported files](#errors-in-imported-files)\n\t* [Cleaning models](#cleaning-models)\n\n\n## Syntactic errors\nThese errors are produced when the modeler enters a sentence that has no meaning in the grammar of GAML (see [the documentation of the language](GamlLanguage)). It can either be a non-existing symbol (like \"globals\" (instead of _global_) in the example below), a wrong punctuation scheme, or any other construct that puts the parser in the incapacity of producing a correct syntax tree. These errors are extremely common when editing models (since incomplete keywords or sentences are continuously validated). GAMA will report them using several indicators: the icon of the file in the title of the editor will sport an error icon and the gutter of the editor (i.e. the vertical space beside the line numbers) will use error **markers** to report two or more errors: one on the statement defining the model, and one (or more) in the various places where the parser has failed to produce the syntax tree. In addition, the toolbar over the editor will turn red and indicate that errors have been detected.\n\n![images/model_with_syntactic_errors.png](resources/images/editingModels/model_with_syntactic_errors.png)\n\nHovering over one of these **markers** indicates what went wrong during the syntactic validation. Note that these errors are sometimes difficult to interpret, since the parser might fail in places that are not precisely those where a wrong syntax is being used (it will usually fail **after**).\n\n![images/model_with_syntactic_errors_and_hover.png](resources/images/editingModels/model_with_syntactic_errors_and_hover.png)\n\n\n## Semantic errors\nWhen syntactic errors are eliminated, the validation enters a so-called semantic phase, during which it ensures that what the modeler has written makes sense with respect to the various rules of the language. To understand the difference between the two phases, take a look at the following example.\n\nThis sentence below is **syntactically** correct:\n```\nspecies my_species parent: my_species;\n```\nBut it is **semantically** incorrect because a species cannot be parent of itself. No syntactic errors will be reported here, but the validation will fail with a **semantic** error.\n\n![images/semantic_error_detail.png](resources/images/editingModels/semantic_error_detail.png)\n\n\n\nSemantic errors are reported in a way similar to syntactic errors, except that no **marker** are displayed beside the model statement. The compiler tries to report them as precisely as possible, underlining the places where they have been found and outputting hopefully meaningful error messages. In the example below, for instance, we use a wrong number of arguments for defining a square geometry. Although the sentence is syntactically correct, GAMA will nevertheless issue an error and prevent the model from being experimentable.\n\n![images/model_with_semantic_errors.png](resources/images/editingModels/model_with_semantic_errors.png)\n\n\n\nThe message accompanying this error can be obtained by hovering over the error **marker** found in the gutter (multiple messages can actually be produced for a same error, see below).\n\n![images/model_with_semantic_errors_and_hover.png](resources/images/editingModels/model_with_semantic_errors_and_hover.png)\n\n\n\nWhile the editor is in a so-called _dirty_ state (i.e. the model has not been saved), errors are only reported locally (in the editor itself). However, as soon as the user saves a model containing syntactic or semantic errors, they are \"promoted\" to become workspace errors, and, as such, indicated in other places: the file icon in the _Navigator_, and a new line in the _Errors_ view.\n\n![images/model_with_semantic_errors_saved.png](resources/images/editingModels/model_with_semantic_errors_saved.png)\n\n\n## Semantic warnings\n\nThe semantic validation phase does not only report errors. It also outputs various indicators that can help the modeler in verifying the correctness of his/her model. Among them are **warnings**. A warning is an indication that something is not completely right in the way the model is written, although it can _probably_ be worked around by GAMA when the model will be executed. For instance, in the example below, we pass a string argument to the facet \"number:\" of the \"create\" statement. GAMA will emit a warning in such a case, indicating that \"number:\" expects an integer, and that the string passed will be casted to int when the model will be executed. Warnings are to be considered seriously, as they usually indicate some flaws in the logic of the model.\n\n![images/model_with_warnings.png](resources/images/editingModels/model_with_warnings.png)\n\n\n\nHovering over the warning **marker** will allow the modeler to have access to the explanation and hopefully fix the cause of the warning.\n\n![images/model_with_warnings_and_hover.png](resources/images/editingModels/model_with_warnings_and_hover.png)\n\n\n\n## Semantic information\nBesides warnings, another type of harmless feedback is produce by the semantic validation phase: information **markers**. They are used to indicate useful information to the modeler, for example that an attribute has been redefined in a sub-species, or that some operation will take place when running the model (for instance, the truncation of a float to an int). The visual affordance used in this case is voluntarily discrete (a small \"i\" in the editor's gutter).\n\n![images/model_with_info.png](resources/images/editingModels/model_with_info.png)\n\n\nAs with the other types of **markers**, information markers unveil their messages when being hovered.\n\n![images/model_with_info_and_hover.png](resources/images/editingModels/model_with_info_and_hover.png)\n\n\n\n\n## Semantic documentation\nThe last type of output of the semantic validation phase consists in a complete documentation of the various elements present in the model, which the user can retrieve by hovering over the different symbols. Note that although the best effort is being made in producing a complete and consistent documentation, it may happen that some symbols do not produce anything. In that case, please report a new Issue [here](https://code.google.com/p/gama-platform/issues/list).\n\n![images/model_with_no_errors_and_hover.png](resources/images/editingModels/model_with_no_errors_and_hover.png)\n\n\n\n## Changing the visual indicators\nThe default visual indicators depicted in the examples above to report errors, warnings and information can be customized to be less (or more) intrusive. This can be done by choosing the \"Preferences...\" item of the editor contextual menu and navigating to \"General > Editors > Text Editors > Annotations\". There, you will find the various **markers** used, and you will be able to change how they are displayed in the editor's view. For instance, if you prefer to highlight errors in the text, you can change it here.\n\n![images/preferences_annotations.png](resources/images/editingModels/preferences_annotations.png)\n\n\nWhich will result in the following visual feedback for errors:\n\n![images/model_with_semantic_error_different_annotation.png](resources/images/editingModels/model_with_semantic_error_different_annotation.png)\n\n\n\n## Errors in imported files\n\nFinally, even if your model has been cleansed of all errors, it may happen that it refuses to launch because it imports another model that cannot be compiled. In the following screenshot, \"My First Model.gaml\" imports \"My Imported Model.gaml\", which sports a syntactic error.\n\n![images/model_with_imported_errors.png](resources/images/editingModels/model_with_imported_errors.png)\n\n\nIn such a case, the importing model refuses to compile (although it is itself valid) and to propose experiments. There are cases, however, where the same importation can work. Consider the following example, where, this time, \"My Imported Model.gaml\" sports a semantic error in the definition of the global 'shape' attribute. Without further modifications, the use case is similar to the first one.\n\n![images/model_with_imported_semantic_error.png](resources/images/editingModels/model_with_imported_semantic_error.png)\n\nHowever, if \"My First Model.gaml\" happens to redefine the _shape_ attribute (in global), it is now considered as valid. All the valid sections of \"My Imported Model.gaml\" are effectively imported, while the erroneous definition is superseded by the new one.\n\n![images/model_with_superseded_semantic_error.png](resources/images/editingModels/model_with_superseded_semantic_error.png)\n\nThis process is described by the information marker next to the redefinition.\n\n![images/model_with_superseded_semantic_error_and_hover.png](resources/images/editingModels/model_with_superseded_semantic_error_and_hover.png)\n\n\n\n## Cleaning models\nIt may happen that the metadata that GAMA maintains about the different projects (which includes the various **markers** on files in the workspace, etc.) becomes corrupted from time to time. This especially happens if you frequently switch workspaces, but not only. In those (hopefully rare) cases, GAMA may report incorrect errors for perfectly legible files.\n\nWhen such odd behaviors are detected, or if you want to regularly keep your metadata in a good shape, you can clean all your project, by clicking on the button \"Clear and validate all projects\" (in the syntax errors view).\n\n![images/action_clean.png](resources/images/editingModels/action_clean.png)","url":"wiki/ValidationOfModels.md"},"Headless.md":{"title":" Headless Mode","content":"# Headless Mode\n\nThe aim of this feature is to be able to run one or multiple instances of GAMA without any user interface, so that models and experiments can be launched on a grid or a cluster. Without GUI, the memory footprint, as well as the speed of the simulations, are usually greatly improved.\n\nIn this mode, GAMA can only be used to run experiments and that editing or managing models is not possible. In order to launch experiments and still benefit from a user interface (which can be used to prepare headless experiments), launch GAMA normally (see [here](G__Launching)) and refer to this [page](G__RunningExperiments) for instructions.\n\n## Table of contents \n\n* [Headless Mode](#headless-mode)\n\t* [Command](#command)\n\t\t* [Shell Script](#shell-script)\n\t\t* [Java Command](#java-command)\n\t* [Experiment Input File](#experiment-input-file)\n\t\t* [Heading](#heading)\n\t\t* [Parameters](#parameters)\n\t\t* [Outputs](#outputs)\n\t* [Output Directory](#output-directory)\n\t* [Simulation Output](#simulation-output)\n\t\t* [Step](#step)\n\t\t* [Variable](#variable)\n\t* [Snapshot files](#snapshot-files)\n\n\n## Command\n\nThere are two ways to run a GAMA experiment in headless mode: using a dedicated shell script (recommended) or directly from the command line. These commands take 2 arguments: an experiment file and an output directory.\n\n### Shell Script\nIt can be found in the `headless` directory located inside `Gama`. Its name is `gama-headless.sh` on MacOSX and Linux, and `gama-headless.bat` on Windows.\n\n```\n sh gama-headless.sh [m/c/t/hpc/v] $1 $2\n```\n\n* with:\n\t* $1 input parameter file : an xml file determining experiment parameters and attended outputs\n\t* $2 output directory path : a directory which contains simulation results (numerical data and simulation snapshot)\n\t* options [-m/c/t/hpc/v]\n\t\t* -m memory : memory allocated to gama\n\t\t* -c : console mode, the simulation description could be written with the stdin\n\t\t* -t : tunneling mode, simulation description are read from the stdin, simulation results are printed out in stdout\n\t\t* -hpc nb_of_cores : allocate a specific number of cores for the experiment plan\n\t\t* -v : verbose mode. trace are displayed in the console \n\n\n* For example (using the provided sample), navigate in your terminal to the GAMA root folder and type :\n\n```\nsh headless/gama-headless.sh headless/samples/predatorPrey.xml outputHeadLess\n```\n\nAs specified in **predatorPrey.xml**, this command runs the prey - predator model for 1000 steps and record a screenshot of the main display every 5 steps. The screenshots are recorded in the directory outputHeadLess (under the GAMA root folder).\n\n\nNot that the current directory to run gama-headless command must be $GAMA\\_PATH/headless\n\n### Java Command\n\n```\njava -cp $GAMA_CLASSPATH -Xms512m -Xmx2048m -Djava.awt.headless=true org.eclipse.core.launcher.Main -application msi.gama.headless.id4 $1 $2\n```\n\n* with:\n\t* $GAMA\\_CLASSPATH gama classpath: contains relative or absolute path of jars inside the gama plugin directory and jars created by users\n\t* $1 input parameter file: an xml file determining experiment parameters and attended outputs\n\t* $2 output directory path: a directory which contains simulation results (numerical data and simulation snapshot)\n\nNote that the output directory is created during the experiment and should not exist before.\n\n\n\n\n## Experiment Input File\n\nThe XML input file contains for example:\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Experiment_plan>\n <Simulation id=\"2\" sourcePath=\"./predatorPrey/predatorPrey.gaml\" finalStep=\"1000\" experiment=\"predPrey\">\n  <Parameters>\n    <Parameter name=\"nb_predator_init\" type=\"INT\" value=\"53\" />\n    <Parameter name=\"nb_preys_init\" type=\"INT\" value=\"621\" />\n  </Parameters>\n  <Outputs>\n    <Output id=\"1\" name=\"main_display\" framerate=\"10\" />\n    <Output id=\"2\" name=\"number_of_preys\" framerate=\"1\" />\n    <Output id=\"3\" name=\"number_of_predators\" framerate=\"1\" />\n    <Output id=\"4\" name=\"duration\" framerate=\"1\" />\n  </Outputs>\n </Simulation>\n</Experiment_plan>\n```\nNote that several simulations could be determined in one experiment plan. These simulations are run in parallel according to the number of allocated cores.\n\n### Heading\n\n```\n<Simulation id=\"2\" sourcePath=\"./predatorPrey/predatorPrey.gaml\" finalStep=\"1000\" experiment=\"predPrey\">\n```\n\n* with:\n\t* `id`: permits to prefix output files for experiment plan with huge simulations.\n\t* `sourcePath`: contains the relative or absolute path to read the gaml model.\n\t* `finalStep`: determines the number of simulation step you want to run.\n\t* `experiment`: determines which experiment should be run on the model. This experiment should exist, otherwise the headless mode will exit.\n\n### Parameters\nOne line per parameter you want to specify a value to:\n\n```\n<Parameter name=\"nb_predator_init\" type=\"INT\" value=\"53\" />\n```\n\n  * with:\n    * `name`:  name of the parameter in the gaml model\n    * `type`:  type of the parameter (INT, FLOAT, BOOLEAN, STRING)\n    * `value`: the chosen value\n\n### Outputs\nOne line per output value you want to retrieve. Outputs can be names of monitors or displays defined in the 'output' section of experiments, or the names of attributes defined in the experiment or the model itself (in the 'global' section).\n\n```\n    ... with the name of a monitor defined in the 'output' section of the experiment...\n    <Output id=\"2\" name=\"number_of_preys\" framerate=\"1\" />\n    ... with the name of a (built-in) variable defined in the experiment itself...\n    <Output id=\"4\" name=\"duration\" framerate=\"1\" />\n```\n\n* with:\n\t* `name` : name of the output in the 'output'/'permanent' section in the experiment or name of the experiment/model attribute to retrieve\n\t* `framerate` : the frequency of the monitoring (each step, each 2 steps,  each 100 steps...).\n\n* Note that :\n\t* the lower the framerate value the longer the experiment.\n\t* if the chosen output is a display, an image is produced and the output file contains the path to access this image\n\n\n\n## Output Directory\nDuring headless experiments, a directory is created with the following structure:\n\n```\nOutputed-directory-path/\n    |-simulation-output.xml\n    |- snapshot\n          |- main_display2-0.png\n          |- main_display2-10.png\n          |- ...\n\n```\n* with:\n\t* `simulation-output.xml`: containing the results\n\t* `snapshot`: containing the snapshots produced during the simulation\n\nIs it possible to change the output directory for the images by adding the attribute \"output_path\" in the xml : \n\nIf we write `<Output id=\"1\" name=\"my_display\" file:\"/F:/path/imageName\" framerate=\"10\" />`, then the display \"my_display\" will have the name \"imageName-stepNb.png\" and will be written in the folder \"/F:/path/\"\n\n## Simulation Output\nA file named `simulation-output.xml` is created with the following contents when the experiment runs.\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Simulation id=\"2\" >\n\t<Step id='0' >\n\t\t<Variable name='main_display' value='main_display2-0.png'/>\n\t\t<Variable name='number_of_preys' value='613'/>\n\t\t<Variable name='number_of_predators' value='51'/>\n                <Variable name='duration' value='6' />\n\t</Step>\n\t<Step id='1' >\n\t\t<Variable name='main_display' value='main_display2-0.png'/>\n\t\t<Variable name='number_of_preys' value='624'/>\n\t\t<Variable name='number_of_predators' value='51'/>\n                <Variable name='duration' value='5' />\n\t</Step>\n        <Step id='2'>\n\n...\n```\n\n* With:\n\t* `<Simulation id=\"2\" >` : block containing results of the simulation 2 (this Id is identified in the Input Experiment File)\n\t* `<Step id='1' > ... </Step>`: one block per step done. The id corresponds to the step number\n\n### Step\n```\n\t<Step id='1' >\n\t\t<Variable name='main_display' value='main_display2-0.png'/>\n\t\t<Variable name='number_of_preys' value='624'/>\n\t\t<Variable name='number_of_predators' value='51'/>\n                <Variable name='duration' value='6' />\n\t</Step>\n\n```\n\nThere is one Variable block per Output identified in the output experiment file.\n\n### Variable\n\n```\n <Variable name='main_display' value='main_display2-0.png'/>\n```\n\n* with:\n\t* `name`: name of the output, the model variable\n\t* `value`: the current value of model variable.\n\nNote that the value of an output is repeated according to the framerate defined in the input experiment file.\n\n\n\n\n## Snapshot files\nThis directory contains images generated during the experiment. There is one image per displayed output per step (according to the framerate). File names follow a naming convention, e.g:\n\n```\n   [outputName][SimulationID]_[stepID].png -> main_display2-20.png\n```\n\nNote that images are saved in '.png' format.","url":"wiki/Headless.md"},"Installation.md":{"title":" Installation","content":"# Installation\n\nGAMA 1.7 comes in 5 different versions (32 & 64 bits for Windows & Linux, and 64 bits for MacOS X). You first need to determine which version to use (it depends on your computer, which may, or not, support 64 bits instructions, but also on the version of Java already installed, as the number of bits of the two versions must match).\n\nYou can then download the right version from the [Downloads page](http://vps226121.ovh.net/download#GAMALATEST), expand the zip file wherever you want on your machine, and [launch GAMA](Launching).\n\n\n## Table of contents \n\n* [Installation](#installation)\n\t* [System Requirements](#system-requirements)\n\t* [Installation of Java](#installation-of-java)\n\t\t* [On MacOS X](#on-macos-x)\n\t\t* [On Windows](#on-windows-7--8-64-bits)\n\t\t* [On Ubuntu & Linux](#on-ubuntu--linux)\n\n\n## System Requirements\n\nGAMA 1.7 requires that **Java 1.8** be installed on your machine, approximately 200MB of disk space and a minimum of 4GB of RAM (to increase the portion of memory usable by GAMA, please refer to [these instructions](Troubleshooting#Memory_problems)).\n\n### MacOS \n\nIn some cases, \"Archive utility.app\" in MacOS may damage the files when extracting them from the zip or tar.gz archive files. This problem manifests itself by a dialog opening and explaining that the application is damaged and cannot be launched (see [Issue 2082](https://github.com/gama-platform/gama/issues/2082#issuecomment-271812519) and also [this thread](https://bugs.eclipse.org/bugs/show_bug.cgi?id=398450#c17). In that case, to expand the files, consider using a different utility, like the free [Stuffit Expander](http://my.smithmicro.com/stuffit-expander-mac.html) or directly from the command line. \n\nMacOS Sierra has introduced a series of issues linked to the so-called \"quarantine\" mode (where applications downloaded from Internet prevent to use and update their internal components, such as the models of the library or the self-updating of the application). See this [page](http://lapcatsoftware.com/articles/app-translocation.html) for background information. To be certain that Gama will work, and until we find an easier solution, the installation should follow these steps:\n\n1. Download the GAMA zip file\n2. Unzip it (possibly with another archive utility, see above)\n3. Copy and paste `Gama` in the `Applications` folder\n4. Launch `Terminal.app`\n5. Type `cd /Applications` and hit return.\n6. Type `xattr -d -r com.apple.quarantine Gama.app/` and hit return to remove the quarantine attribute\n\nFrom now on, Gama should be fully functional.\n\n## Installation of Java\n\nOn all environments, the recommended Java Virtual Machine under which GAMA has been tested is the one distributed by Oracle ([http://www.java.com/en/download/manual.jsp](http://www.java.com/en/download/manual.jsp)). It may work with others — or not. For better performances, you may also want to install the JDK version of the JVM (and not the standard JRE), although is it not mandatory  (GAMA should run fine, but slower, under a JRE).\n\n### On MacOS \nThe latest version of GAMA requires a JVM (or JDK or JRE) compatible with Java 1.8 to run. \n\n_Note for GAMA 1.6.1 users: if you plan to keep a copy of GAMA 1.6.1, you will need to have both Java 1.6 (distributed by Apple) and Java 1.8 (distributed by Oracle) installed at the same time. Because of this bug in SWT (https://bugs.eclipse.org/bugs/show_bug.cgi?id=374199), GAMA 1.6.1 will not run correctly under Java 1.8 (all the displays will appear empty). To install the JDK 1.6 distributed by Apple, follow the instructions here : http://support.apple.com/kb/DL1572. Alternatively, you might want to go to https://developer.apple.com/downloads and, after a free registration step if you're not an Apple Developer, get the complete JDK from the list of downloads._\n\n### On Windows\nPlease notice that, by default, Internet Explorer and Chrome browsers will download a 32 bits version of the JRE. Running GAMA 32 bits for Windows is ok, but you may want to download the latest JDK instead, in order to both improve the performances of the simulator and be able to run GAMA 64 bits.\n\n  * To download the appropriate java version, follow this link: http://www.java.com/en/download/manual.jsp\n  * Execute the downloaded file\n  * You can check that a **Java\\\\jre8** folder has been installed at the location **C:\\\\Program Files\\\\**\n\nIn order for Java to be found by Windows, you may have to modify environment variables:\n\n  * Go to the **Control Panel**\n  * In the new window, go to **System**\n  * On the left, click on **Advanced System parameters**\n  * In the bottom, click on **Environment Variables**\n  * In System Variables, choose to modify the **Path** variable\n  * At the end, add **;C:\\\\Program Files\\\\Java\\\\jre8\\\\bin** (or jre8\\\\bin)\n\n### On Ubuntu & Linux\n\nTo have a complete overview of java management on Ubuntu, have a look at:\n\n  * [Ubuntu Java documentation](https://help.ubuntu.com/community/Java)\n  * for French speaking users: [http://doc.ubuntu-fr.org/java#installations_alternatives](http://doc.ubuntu-fr.org/java#installations_alternatives)\n\nBasically, you need to do:\n```\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java8-installer \n```\n\nYou can then switch between java version using:\n```\nsudo update-alternatives --config java\n```\n\nSee [the troubleshooting page](Troubleshooting#Ubuntu) for more information on workaround for problems on Unbuntu.","url":"wiki/Installation.md"},"InstallingPlugins.md":{"title":" Installing Plugins","content":"# Installing Plugins\n\nBesides the plugins delivered by the developers of the GAMA platform, which can be installed and updated as explained [here](Updating), there are a number of additional plugins that can be installed to add new functionalities to GAMA or enhance the existing ones. GAMA being based on Eclipse, a number of plugins developed for Eclipse are then available (a complete listing of Eclipse plugins can be found in the so-called [Eclipse MarketPlace](http://marketplace.eclipse.org)).\n\nThere are, however, three important restrictions:\n\n1. The current version of GAMA is based on Eclipse Juno (version number 3.8.2), which excludes de facto all the plugins targeting solely the 4.3 (Kepler) or 4.4 (Luna) versions of Eclipse. These will refuse to install anyway.\n2. The Eclipse foundations in GAMA are only a subset of the complete Eclipse platform, and a number of libraries or frameworks (for example the Java Development Toolkit) are not (and will never be) installed in GAMA. So plugins relying on their existence will refuse to install as well.\n3. Some components of GAMA rely on a specific version of other plugins and will refuse to work with other versions, essentially because their compatibility will not be ensured anymore. For instance, the parser and validator of the GAML language in GAMA 1.6.1 require [XText v. 2.4.1](http://www.eclipse.org/Xtext/) to be installed (and neither XText 2.5.4 nor XText 2.3 will satisfy this dependency).\n\nWith these restrictions in mind, it is however possible to install interesting additional plugins. We propose here a list of some of these plugins (known to work with GAMA), but feel free to either add a comment if you have tested plugins not listed here or [create an issue](Troubleshooting) if a plugin does not work, in order for us to see what the requirements to make it work are and how we can satisfy them (or not) in GAMA.\n\n## Table of contents \n\n* [Installing Plugins](#installing-plugins)\n\t* [Installation](#installation)\n\t* [Selected Plugins](#selected-plugins)\n\t\t* [Overview](#overview)\n\t\t* [Git](#git)\n\t\t* [CKEditor] (#ckeditor)\n\t\t* [Startexplorer](#startexplorer)\n\t\t* [Pathtools](#pathtools)\n\t\t* [CSV Edit](#csv-edit)\n\t\t* [Quickimage](#quickimage)\n\n\n## Installation\nInstalling new plugins is a process identical to the one described when [updating GAMA](Updating), with one exception: the _update site_ to enter is normally provided by the vendor of the additional plugin and must be entered instead of GAMA's one in the dialog. Let us suppose, for instance, that we want to install a RSS feed reader available on this [site](http://junginger.biz/eclipse/).\nAn excerpt from the page reads that :\n\n> All plugins are installed with the standard update manager of Eclipse. It will guide you through the installation process and also eases keeping your plugins up-to-date. Just add the update site: http://www.junginger.biz/eclipse/\n\nSo we just have to follow these instructions, which leads us to the following dialog, in which we select \"RSS view\" and click \"Next\".\n\n![images/dialog_install_plugins.png](resources/images/installationAndLaunching/dialog_install_plugins.png)\n\nThe initial dialog is followed by two other ones, a first to report that the plugin satisfies all the dependencies, a second to ask the user to accept the license agreement.\n\n\n\n|![images/dialog_install_plugins_2.png](resources/images/installationAndLaunching/dialog_install_plugins_2.png)|![images/dialog_install_plugins_3.png](resources/images/installationAndLaunching/dialog_install_plugins_3.png)|\n|---|---|\n\nOnce we dismiss the warning that the plugin is not signed and accept to restart GAMA, we can test the new plugin by going to the \"Views\" menu.\n\n![images/menu_other_views.png](resources/images/installationAndLaunching/menu_other_views.png)\n\n\nThe new RSS view is available in the list of views that can be displayed in GAMA.\n\n![images/dialog_show_view.png](resources/images/installationAndLaunching/dialog_show_view.png)\n\n\nAnd we can enjoy (after setting some preferences available in its local menu) monitoring the Issues of GAMA from within GAMA itself !\n\n![images/feed_working.png](resources/images/installationAndLaunching/feed_working.png)\n\n\n\n\n\n## Selected Plugins\nIn addition to the RSS reader described above, below is a list of plugins that have been tested to work with GAMA. There are many others so take the time to explore them !\n\n### Overview\n  * A very useful plugin for working with large model files. It renders an overview of the file in a separate view (with a user selectable font size), allowing to know where the edition takes place, but also to navigate very quickly and efficiently to different places in the model.\n  * Update site: http://sandipchitaleseclipseplugins.googlecode.com/svn/trunk/text.overview.updatesite/site.xml\n  * After installing the plugin, an error might happen when closing GAMA. It is harmless. After restarting GAMA, go to Views > Open View > Others... > Overview >.\n\n### Git\n  * Git is a version control system (like CVS or SVN, extensively used in GAMA) http://git-scm.com/. Free sharing space are provided on [GitHub](https://github.com/) among others. Installing Git allows to share or gather models that are available in Git repositories.\n  * Update site (general): `http://download.eclipse.org/releases/mars/` (Alternatively, you can use `http://download.eclipse.org/egit/updates`)\n  * Select the two following plugins:\n    * Eclipse EGit\n    * Git Team Provider Core\n    \n### CKEditor\n  * CKEditor is a lightweight and powerful web-based editor, perfect for almost WYSIWYG edition of HTML files. It can be installed, directly in GAMA, in order to edit .html, .htm, .xml, .svg, etc. files directly without leaving the platform. No other dependencies are required. A must ! \n  * Update site: `http://kosz.bitbucket.org/eclipse-ckeditor/update-site`\n\n### Startexplorer\n  * A nice utility that allows the user to select files, folders or projects in the [Navigator](NavigatingWorkspace) and open them in the filesystem (either the UI Explorer, Finder, whatever, or in a terminal).\n  * Update site: `http://basti1302.github.com/startexplorer/update/`\n\n![images/start_explorer.png](resources/images/installationAndLaunching/start_explorer.png)\n\n\n### Pathtools\n  * Same purpose as StartExplorer, but much more complete, and additionally offers the possibility to add new commands to handle files (open them in specific editors, execute external programs on them, etc.). Very nice and professional. Works flawlessly in GAMA except that contributions to the toolbar are not accepted (so you have to rely on the commands present in the [Navigator](NavigatingWorkspace) pop-up menu).\n  * Update site: `http://pathtools.googlecode.com/svn/trunk/PathToolsUpdateSite/site.xml`\n  * Website: `https://pathtools.googlecode.com`\n\n### CSV Edit\n\n  * An editor for CSV files. Quite handy if you do not want to launch Excel every time you need to inspect or change the CSV data files used in models.\n  * Update site: `http://csvedit.googlecode.com/svn/trunk/csvedit.update`\n\n![images/csv_edit.png](resources/images/installationAndLaunching/csv_edit.png)\n\n### TM Terminal\n\n  * A powerful, yet simple, terminal which can connect locally or via ssh or other methods. \n  * Update site (general): `http://download.eclipse.org/releases/mars/`\n  * Select the following plugin: TM Terminal\n\n\n### Quickimage\n\n  * A lightweight viewer of images, which can be useful when several images are used in a model.\n  * Update site: `http://psnet.nu/eclipse/updates`\n\n![images/quick_image.png](resources/images/installationAndLaunching/quick_image.png)","url":"wiki/InstallingPlugins.md"},"Launching.md":{"title":" Launching GAMA","content":"# Launching GAMA\n\nRunning GAMA for the first time requires that you launch the application (`Gama.app` on MacOS X, `Gama.exe` on Windows, `Gama` on Linux, located in the folder called `Gama` once you have unzipped the archive). Other folders and files are present here, but you don't have to care about them for the moment. In case you are unable to launch the application, of if error messages appear, please refer to the [installation](Installation) or [troubleshooting](Troubleshooting) instructions.\n\n## Table of contents \n\n* [Launching GAMA](#launching-gama)\n\t* [Launching the Application](#launching-the-application)\n\t* [Choosing a Workspace](#choosing-a-workspace)\n\t* [Welcome Page](#welcome-page)\n\n\n## Launching the Application\n\n\nNote that GAMA can also be launched in two different other ways:\n\n1. In a so-called _headless mode_ (i.e. without user interface, from the command line, in order to conduct experiments or to be run remotely). Please refer to [the corresponding instructions](Headless).\n2. From the terminal, using a path to a model file and the name or number of an experiment, in order to allow running this experiment directly (note that the two arguments are optional: if the second is omitted, the file is imported in the workspace if not already present and opened in an editor; if both are omitted, GAMA is launched as usual):\n\n* `Gama.app/Contents/MacOS/Gama path_to_a_model_file#experiment_name_or_number` on MacOS X\n* `Gama path_to_a_model_file#experiment_name_or_number` on Linux\n* `Gama.exe path_to_a_model_file#experiment_name_or_number` on Windows\n\n![Eclipse folder.](resources/images/installationAndLaunching/0.folder.png)\n\n## Choosing a Workspace\nPast the splash screen, GAMA will ask you to choose a workspace in which to store your models and their associated data and settings. The workspace can be any folder in your filesystem on which you have read/write privileges. If you want GAMA to remember your choice next time you run it (it can be handy if you run Gama from the command line), simply check the corresponding option. If this dialog does not show up when launching GAMA, it probably means that you inherit from an older workspace used with GAMA 1.6 or 1.5.1 (and still \"remembered\"). In that case, a warning will be produced to indicate that the models library is out of date, offering you the possibility to create a new workspace.\n\n![Window to choose the workspace.](resources/images/installationAndLaunching/1.workspace_choice.png)\n\nYou can enter its address or browse your filesystem using the appropriate button. If the folder already exists, it will be reused (after a warning if it is not already a workspace). If not, it will be created. It is always a good idea, when you launch a new version of GAMA for the first time, to create a new workspace. You will then, later, be able to [import your existing models](ImportingModels) into it. Failing to do so might lead to odd errors in the various validation processes.\n\n![This pop-up appears when the user wants to create a new workspace. Click on OK.](resources/images/installationAndLaunching/2.workspace_choice2.png)\n\n\n\n## Welcome Page\nAs soon as the workspace is created, GAMA will open and you will be presented with its **first window**. GAMA is based on [Eclipse](http://www.eclipse.org) and reuses most of its visual metaphors for organizing the work of the modeler. The main window is then composed of several **parts**, which can be **views** or **editors**, and are organized in a **perspective**. GAMA proposes 2 main perspectives: _Modeling_, dedicated to the creation of models, and _Simulation_, dedicated to their execution and exploration. Other perspectives are available if you use shared models.\n\nThe default perspective in which GAMA opens is _Modeling_. It is composed of a central area where [GAML editors](GamlEditorGeneralities) are displayed, which is surrounded by a [Navigator view](NavigatingWorkspace) on the left-hand side of the window, an Outline view (linked with the open editor) and the Problems view, which indicates errors and warnings present in the models stored in the workspace.\n\n![GAMA after the first launch.](resources/images/installationAndLaunching/3.workbench_window.png)\n\nIn the absence of previously open models, GAMA will display a _Welcome page_ (actually a web page), from which you can find links to the website, current documentation, tutorials, etc. This page can be kept open (for instance if you want to display the documentation when editing models) but it can also be safely closed (and reopened later from the \"Views\" menu).\n\n![Menu to open new views.](resources/images/installationAndLaunching/5.welcome_page.png)\n\nFrom this point, you are now able to [edit a new model](EditingModels), [navigate in the models libraries](NavigatingWorkspace), or [import an existing model](ImportingModels).","url":"wiki/Launching.md"},"Troubleshooting.md":{"title":" Troubleshooting","content":"# Troubleshooting\n\nThis page exposes some of the most common problems a user may encounter when running GAMA — and offers advices and workarounds for them. It will be regularly enriched with new contents. Note also that the [Issues section](https://github.com/gama-platform/gama/issues) of the website might contain precious information on crashes and bugs encountered by other users. If neither the workarounds described here nor the solutions provided by other users allow to solve your particular problem, please submit a new issue report to the developers.\n\n\n## Table of contents \n\n* [Troubleshooting](#troubleshooting)\n\t* [Table of contents](#table-of-contents)\n\t* [On Ubuntu (& Linux Systems)](#on-ubuntu--linux-systems)\n\t\t* [Workaround if GAMA crashes when displaying web contents](#workaround-if-gama-crashes-when-displaying-web-contents)\n\t\t* [Workaround if GAMA does not display the menus (the 'Edit' menu is the only one working)](#workaround-if-gama-does-not-display-the-menus-the-edit-menu-is-the-only-one-working)\n\t* [On Windows](#on-windows)\n\t* [On MacOS X](#on-macos-x)\n\t\t* [Workaround in case of glitches in the UI](#workaround-in-case-of-glitches-in-the-ui)\n\t\t* [Workaround in case of corrupted icons in menus under El Capitan](#workaround-in-case-of-corrupted-icons-in-menus-under-el-capitan)\n\t* [Memory problems](#memory-problems)\n\t* [Submitting an Issue](#submitting-an-issue)\n\n\n## On Ubuntu (& Linux Systems)\n### Workaround if GAMA crashes when displaying web contents\nIn case GAMA crashes whenever trying to display a web page or the pop-up online documentation, you may try to edit the file Gama.ini and add the line `-Dorg.eclipse.swt.browser.DefaultType=mozilla` to it. This workaround is described here: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=705420 and in Issue 700 (on Google Code).\n\n### Workaround if GAMA does not display the menus (the 'Edit' menu is the only one working)\nIf, when selecting a menu, nothing happens (or, in the case of the 'Agents' menu, all population submenus appear empty), it is likely that you have run into this issue: https://bugs.eclipse.org/bugs/show_bug.cgi?id=330563. The only workaround known is to launch GAMA from the command line (or from a shell script) after having told Ubuntu to attach its menu back to its main window. For example (if you are in the directory where the \"Gama\" executable is present):\n\n```\nexport UBUNTU_MENUPROXY=0\n./Gama\n```\n\nNo fix can be provided from the GAMA side for the moment.\n\n\n\n\n## On Windows\nNo common trouble...\n\n\n\n\n## On MacOS X\n\n### Workaround in case of glitches in the UI\n\nThe only problems reported so far on MacOS X (from Lion to Yosemite) concern visual glitches in the UI and problems with displays, either not showing or crashing the JVM. Most (all ?) of these problems are usually related to the fact that GAMA does not run under the correct version of Java Virtual Machine. In that case, follow [these instructions](Installation#On_MacOS_X_(Lion,_Mountain_Lion,_Mavericks)) to install the correct version.\n\n### Workaround in case of corrupted icons in menus under El Capitan\n\nFor some particular configurations (in particular some particular graphic cards), the icons of the menus (e.g. Edit menu) may be corrupted. This bug is documented for all RCP products under El Capitan. See these references:\n[https://bugs.eclipse.org/bugs/show_bug.cgi?id=479590](https://bugs.eclipse.org/bugs/show_bug.cgi?id=479590)\n[https://trac.filezilla-project.org/ticket/10669](https://trac.filezilla-project.org/ticket/10669)\n\nThese is nothing we can do now except using the workaround that consists in switching the language of the OS to English (in System Preferences, Language & Region).\n\n\n## Memory problems\nThe most common causes of problems when running GAMA are memory problems. Depending on your activities, on the size of the models you are editing, on the size of the experiments you are running, etc., you have a chance to require more memory than what is currently allocated to GAMA. A typical GAMA installation  will need between 40 and 200MB of memory to run \"normally\" and launch small models.\nMemory problems are easy to detect: on the bottom right corner of its window, GAMA will always display the status of the current memory. The first number represents the memory currently used (in MB), the second (always larger) the memory currently allocated by the JVM. And the little trash icon allows to \"garbage collect\" the memory still used by agents that are not used anymore (if any). If GAMA appears to hang or crash and if you can see that the two numbers are very close, it means that the memory required by GAMA exceeds the memory allocated.\n\n\n![images/memory_status.png](resources/images/installationAndLaunching/memory_status.png)\n\nThere are two ways to circumvent this problem: the first one is to increase the memory allocated to GAMA by the Java Virtual Machine. The second, detailed [on this page](OptimizingModels) is to try to optimize your models to reduce their memory footprint at runtime.\nTo increase the memory allocated, first locate the file called `Gama.ini`. On Windows and Ubuntu, it is located next to the executable. On MacOS X, you have to right-click on `Gama.app`, choose \"Display Package Contents...\", and you will find `Gama.ini` in `Contents/MacOS`.\nThis file typically looks like the following (some options/keywords may vary depending on the system), and we are interested in two JVM arguments:\n\n![images/gama_ini.png](resources/images/installationAndLaunching/gama_ini.png)\n\n\n`-Xms` supplies the minimal amount of memory the JVM should allocate to GAMA, `-Xmx` the maximal amount. By changing these values (esp. the second one, of course, for example to 4096M, or 4g), saving the file and relaunching GAMA, you can probably solve your problem. Note that 32 bits versions of GAMA will not accept to run with a value of `-Xmx` greater than 1500M. See [here](http://stackoverflow.com/questions/14763079/what-are-the-xms-and-xmx-parameters-when-starting-jvms) for additional information on these two options.\n\n\n\n\n## Submitting an Issue\nIf you think you have found a new bug/issue in GAMA, it is time to create an issue report [here](https://github.com/gama-platform/gama/issues/new) ! Alternatively, you can click the [Issues](https://github.com/gama-platform/gama/issues) tab on the project site, search if a similar problem has already been reported (and, maybe, solved) and, if not, enter a new issue with as much information as possible:\n  * A complete description of the problem and how it occurred.\n  * The GAMA model or code you are having trouble with. If possible, attach a complete model.\n  * Screenshots or other files that help describe the issue.\n\nTwo files may be particularly interesting to attach to your issue: the **configuration details** and the **error log**. Both can be obtained quite easily from within GAMA itself in a few steps. First, click the \"About GAMA...\" menu item (under the \"Gama\" menu on MacOS X, \"Help\" menu on Linux & Windows)\n\n> \n![images/menu_about_gama.png](resources/images/installationAndLaunching/menu_about_gama.png)\n\n\nIn the dialog that appears, you will find a button called \"Installation Details\".\n\n\n![images/dialog_about_gama.png](resources/images/installationAndLaunching/dialog_about_gama.png)\n\n\nClick this button and a new dialog appears with several tabs.\n\n\n![images/dialog_configuration.png](resources/images/installationAndLaunching/dialog_configuration.png)\n\n\nTo provide a complete information about the status of your system at the time of the error, you can\n\n(1) copy and paste the text found in the tab \"Configuration\" into your issue. Although, it is preferable to attach it as a text file (using textEdit, Notepad or Emacs e.g.) as it may be too long for the comment section of the issue form.\n\n(2) click the \"View error log\" button, which will bring you to the location, in your file system, of a file called \"log\", which you can then attach to your issue as well.\n\n\n![images/log_file.png](resources/images/installationAndLaunching/log_file.png)","url":"wiki/Troubleshooting.md"},"Updating.md":{"title":" Updating GAMA","content":"# Updating GAMA\n\nUnless you are using the version of GAMA built from the sources available in the GIT repository of the project (see [here](InstallingGitVersion)), you are normally running a specific **release** of GAMA that sports a given **version number** (e.g. GAMA 1.6.1, GAMA 1.7, etc.). When new features were developed, or when serious issues were fixed, the release you had on your disk, prior to GAMA 1.6.1, could not benefit from them. Since this version, however, GAMA has been enhanced to support a _self\\_update_ mechanism, which allows to import from the GAMA update site additional plugins (offering new features) or updated versions of the plugins that constitute the core of GAMA.\n\n## Table of contents \n\n* [Updating GAMA](#updating-gama)\n\t* [Manual Update](#manual-update)\n\t* [Automatic Update](#automatic-update)\n\n\n\n## Manual Update\nTo activate this feature, you have to invoke the \"Check for Updates\" or \"Install New Software...\" menu commands in the \"Help\" menu.\n\nThe first one will only check if the existing plugins have any updates available, while the second will, in addition, scan the update site to detect any new plugins that might be added to the current installation.\n\n![Menu to install new extensions to GAMA.](resources/images/installationAndLaunching/menu_install.png)\n\nIn general, it is preferable to use the second command, as more options (including that of _desinstalling_ some plugins) are provided. Once invoked, it makes the following dialog appear:\n\n![Window where the user enters the adress of an update site and can choose plugins to install.](resources/images/installationAndLaunching/dialog_install.png)\n\nGAMA expects the user to enter a so-called _update site_. You can copy and paste the following line (or choose it from the drop-down menu as this address is built inside GAMA):\n```\nhttp://updates.gama-platform.org\n```\n\nGAMA will then scan the entire update site, looking both for new plugins (the example below) and updates to existing plugins. The list available in your installation will of course be different from the one displayed here.\n\n![Display of the list of available extensions.](resources/images/installationAndLaunching/dialog_install_2.png)\n\nChoose the ones you want to install (or update) and click \"Next...\". A summary page will appear, indicating which plugins will actually be installed (since some plugins might require additional plugins to run properly), followed by a license page that you have to accept. GAMA will then proceed to the installation (that can be cancelled any time) of the plugins chosen.\n\nDuring the course of the installation, you might receive the following warning, that you can dismiss by clicking \"OK\".\n\n![Warning window that can be dismissed.](resources/images/installationAndLaunching/warning_install.png)\n\nOnce the plugins are installed, GAMA will ask you whether you want to restart or not. It is always safer to do so, so select \"Yes\" and let it close by itself, register the new plugins and restart.\n\n![After installation, GAMA has to be restarted.](resources/images/installationAndLaunching/install_restart.png)\n\n\n\n## Automatic Update\nGAMA offers a mechanism to monitor the availability of updates to the plugins already installed. To install this feature, [open the preferences of GAMA](Preferences) and choose the button \"Advanced...\", which gives access to additional preferences.\n\n![Button to give access to additional preferences.](resources/images/installationAndLaunching/open_advanced.png)\n\nIn the dialog that appears, navigate to \"Install/Update > Automatic Updates\". Then, enable the option using the check-box on the top of the dialog and choose the best settings for your workflow. Clicking on \"OK\" will save these preferences and dismiss the dialog.\n\n![Check for automatic update.](resources/images/installationAndLaunching/prefs_update.png)\n\n\nFrom now on, GAMA will continuously support you in having an up-to-date version of the platform, provided you accept the updates.\n","url":"wiki/Updating.md"},"BatchSpecific.md":{"title":" Batch Specific UI","content":"# Batch Specific UI\n\nWhen an [experiment of type Batch](BatchExperiments) is run, a dedicated UI is displayed, depending on the parameters to explore and of the exploration methods.\n\n\n## Table of contents \n\n* [Batch Specific UI](#batch-specific-ui)\n\t* [Information bar](#information-bar)\n\t* [Batch UI](#batch-ui)\n\n## Information bar\n\nIn batch mode, the top information bar displays 3 distinct information (instead of only the cycle number in the GUI experiment):\n  * The **run** number: One run corresponds to X executions of simulation with one given parameters values (X is an integer given by the facet `repeat` in the definition of the [exploration method](ExplorationMethods));\n  * The **simulation** number: the number of replications done (and the number of replications specified with the `repeat` facet);\n  * The number of **thread**: the number of threads used for the simulation.\n\n![images/batch_Information_bar.png](resources/images/runningExperiments/batch_Information_bar.png)\n\n\n## Batch UI\n\nThe parameters view is also a bit different in the case of a Batch UI. The following interface is generated given the following model part:\n```\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time > 400) {\n   parameter 'Size of the grid:' var: gridsize init: 75 unit: 'width and height';\n   parameter 'Number:' var: ants_number init: 200 unit: 'ants';\n   parameter 'Evaporation:' var: evaporation_rate among: [0.1, 0.2, 0.5, 0.8, 1.0] unit: 'rate every cycle (1.0 means 100%)';\n   parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\n   method exhaustive maximize: food_gathered;\n```\n\n![images/batch_Parameters_pane.png](resources/images/runningExperiments/batch_Parameters_pane.png)\n\n\nThe interface summarizes all model parameters and the parameters given to the exploration method:\n  * **Environment and Population**: displays all the model parameters that should not be explored;\n  * **Parameters to explore**: the parameters to explore are the parameters defined in the experiment with a range of values (with `among` facet or `min`, `max` and `step` facets);\n  * **Exploration method**: it summarizes the Exploration method and the stop condition. For exhaustive method it also evaluates the parameter space. For other methods, it also displays the method parameters (e.g. mutation or crossover probability...). Finally the best fitness found and the last fitness found are displayed (with the associated parameter set).","url":"wiki/BatchSpecific.md"},"Displays.md":{"title":" Displays","content":"# Displays\n\nGAMA allows modelers to [define several and several kinds of displays](DefiningDisplaysGeneralities) in a [GUI experiment](DefiningGUIExperiment):\n  * java 2D displays\n  * OpenGL displays\n\nThese 2 kinds of display allows the modeler to display the same objects (agents, charts, texts ...). The OpenGL display offers extended features in particular in terms of 3D visualisation.\nThe OpenGL displays offers in addition better performance when zooming in and out.\n\n## Table of contents \n\n* [Displays](#displays)\n\t* [Classical displays (java2D)](#classical-displays-java2d)\n\t* [OpenGL displays](#opengl-displays)\n\n\n## Classical displays (java2D)\n\nThe classical displays displaying any kind of content can be manipulated via the mouse (if no mouse event has been defined):\n* the **mouse left** press and move allows to move the camera (in 2D),\n* the **mouse right** click opens a context menu allowing the modeler to inspect displayed agents,\n* the **wheel** allows the modeler to zoom in or out.\n\n![images/display-java2D.png](resources/images/runningExperiments/display-java2D.png)\n\n\nEach display provides several buttons to manipulate the display (from left to right):\n  * **Show/hide side bar**,\n  * **Show/hide overlay**,\n  * **Browse through all displayed agents**: open a context menu to inspect agents,\n  * **Update every X step**: configure the refresh frequence of the display,\n  * **Pause the-display**: when pressed, the display will not be displayed anymore, the simulation is still running,\n  * **Synchronize the display and the execution of the model**,\n  * **Zoom in**,\n  * **Zoom to fit view**,\n  * **Zoom out**,\n  * **Take a snapshot**: take a snapshot saved as a png image in the `snapshots` folder of the models folder.\n\nThe Show/Hide side bar button opens a side panel in the display allowing the modeler to configure:\n  * **Properties** of the display: background and highlight color, display the scale bar\n  * For each layer, we can configure visibility, transparency, position and size of the layer. For grid layers, we can in addition show/hide grids. For species layers, we can also configure the displayed aspect. For text layers, we can the expression displayed with the color and the font.\n\nThe bottom overlay bar displays information about the way it is displayed:\n  * the position of the mouse in the display,\n  * the zoom ratio,\n  * the scale of the display (depending on the zoom).\n\n![images/display-sidebar-overlay.png](resources/images/runningExperiments/display-sidebar-overlay.png)\n\n\n\n\n## OpenGL displays\n\nThe OpenGL display has an additional button **3D Options** providing 3D features:\n  * **Use FreeFly camera**/**Use Arcball camera**: switch between cameras, the default camera is the Arcball one,\n  * **Use mouse to rotate**/**Use mouse to drag** (only with Arcball camera): use left click for one of the 2 actions, left click + Ctrl for the other of the 2 actions.\n  * **Apply inertia** (only with Arcball camera): in inertia mode, when the modeler stops moving the camera, there is no straight halt but a kind of inertia.\n  * **Rotate scene**: rotate the scene around an axis orthogonal to the scene,\n  * **Split layers**/**Merge layers**: display each layer at a distinct height,\n  * **Triangulate scene**: display the polygon primitives.\n\n![images/display-OpenGL.png](resources/images/runningExperiments/display-OpenGL.png)\n\nIn addition, the bottom overlay bar provides the Camera position in 3D.\n\n### FreeFly camera commands\n\n| **Key** | **Function** |\n|:--------------------------|:-----------------------------------------------------------|\n| **Double Click** | Zoom Fit     |\n| **+**   | Zoom In      |\n| **-**   | Zoom Out     |\n| **Up**  | Move forward |\n| **Down**| Move backward|\n| **Left**| Strafe left  |\n| **Right**| Strafe right |\n| **SHIFT+Up**| Look up      |\n| **SHIFT+Down**| Look down    |\n| **SHIFT+Left**| Look left    |\n| **SHIFT+Right**| Look right   |\n| **MOUSE**| Makes the camera look up, down, left and right |\n| **MouseWheel**| Zoom-in/out to the current target (center of the screen)|\n\n### ArcBall camera commands\n\n| **Key** | **Function** |\n|:--------------------------|:-----------------------------------------------------------|\n| **Double Click** | Zoom Fit     |\n| **+**   | Zoom In      |\n| **-**   | Zoom Out     |\n| **Up**  | Horizontal movement to the top|\n| **Down**| Horizontal movement to the bottom|\n| **Left**| Horizontal movement to the left |\n| **Right**| Horizontal movement to the right|\n| **SHIFT+Up**| Rotate the model up (decrease the phi angle of the spherical coordinates)|\n| **SHIFT+Down**| Rotate the model down (increase the phi angle of the spherical coordinates)|\n| **SHIFT+Left**| Rotate the model left (increase the theta angle of the spherical coordinates)|\n| **SHIFT+Right**| Rotate the model right (decrease the theta angle of the spherical coordinates)|\n| **SPACE** | Reset the pivot to the center of the envelope |\n| **KEYPAD 2,4,6,8**| Quick rotation (increase/decrease phi/theta by 30°)|\n| **CMD+MOUSE1** | Makes the camera rotate around the model |\n| **ALT+LEFT_MOUSE**| Enables ROI Agent Selection |\n| **SHIFT+LEFT_MOUSE**| Enables ROI Zoom |\n| **SCROLL**| Zoom-in/out to the current target (center of the sphere)|\n| **WHEEL CLICK** | Reset the pivot to the center of the envelope |","url":"wiki/Displays.md"},"ErrorsView.md":{"title":" Errors View","content":"# Errors View\n\nWhenever a runtime error, or a warning, is issued by the currently running experiment, a view called \"Errors\" is opened automatically. This view provides, together with the error/warning itself, some contextual information about who raised the error (i.e. which agent(s)) and where (i.e. in which portion of the model code). As with other \"status\" in GAMA, errors will appear in red color and warnings in orange.\n\nSince an error appearing in the code is likely to be raised by several agents at once, GAMA groups similar errors together, simply indicating which agent(s) raised them. Note that, unless the error is raised by the experiment agent itself, its message will indicate that at least 2 agents raised it: the original agent and the experiment in which it is plunged.\n\n![images/errors_view.png](resources/images/runningExperiments/errors_view.png)","url":"wiki/ErrorsView.md"},"ExperimentsUserInterface.md":{"title":" Experiments User Interface","content":"# Experiments User Interface\n\n\n\nAs soon as an experiment is [launched](LaunchingExperiments), the modeler is facing a new environment (with different menus and views) called the _Simulation Perspective_). The _Navigator_ is still opened in this perspective, though, and it is still possible to [edit models](EditingModels) in it, but it is considered as good practice to use each perspective for what is has been designed for. Switching perspectives is easy. The small button in the top-left corner of the window allows to switch back and forth the two perspectives.\n\n![images/button_switch.png](resources/images/runningExperiments/button_switch.png)\n\n\nThe actual contents of the simulation perspective will depend on the experiment being run and the [outputs it defines](G__DefiningOutputs). The next sections will present the most common ones ([inspectors, monitors](InspectorsAndMonitors) and [displays](G__Display)), as well as the views that are not defined in outputs, like the [Parameters](ParametersView) or [Errors view](ErrorsView). An overview of the [menus and commands](MenusAndCommands) specific to the simulation perspective is also available.","url":"wiki/ExperimentsUserInterface.md"},"InspectorsAndMonitors.md":{"title":" Inspectors and monitors","content":"# Inspectors and monitors\n\nGAMA offers some tools to obtain informations about one or several agents. There are two kinds of tools :\n* agent browser\n* agent inspector\n\nGAMA offers as well a tool to get the value of a specific expression: monitors.\n\n## Table of contents \n\n* [Inspectors and monitors](#inspectors-and-monitors)\n\t* [Agent Browser](#agent-browser)\n\t* [Agent Inspector](#agent-inspector)\n\t* [Monitor](#monitor)\n\n\n## Agent Browser\nThe species browser provides informations about all or a selection of agents of a species.\n\nThe agent browser is available through the **Agents** menu or by right clicking on a display (screenshots from the ).\n\n![images/browse-menu.png](resources/images/runningExperiments/browse-menu.png)\n\n\n![images/browse_right_clicking.png](resources/images/runningExperiments/browse_right_clicking.png)\n\n\nIt displays in a table all the values of the agent variables of the considered species; each line corresponding to an agent. The list of attributes is displayed on the left side of the view, and you can select the attributes you want to be displayed, simply by clicking on it (Ctrl + Click for multi-selection).\n\n![images/browse_result.png](resources/images/runningExperiments/browse_result.png)\n\n\nBy clicking on the right mouse button on a line, it is possible to do some action for the corresponding agent.\n\n\n\n\n\n## Agent Inspector\nThe agent inspector provides information about one specific agent. It also allows to change the values of its variables during the simulation. The agent inspector is available from the **Agents** menu, by right\\_clicking on a display, in the species inspector or when inspecting another agent.\n\n![images/Agent_inspector.png](resources/images/runningExperiments/Agent_inspector.png)\n\nIt is possible to «highlight» the selected agent.\n\n![images/Inspector_highlight.png](resources/images/runningExperiments/Inspector_highlight.png)\n\nTo change the color of the highlighted agent, go to Preferences/Display.\n\n![images/Inspector_change_highlight_color.png](resources/images/runningExperiments/Inspector_change_highlight_color.png)\n\n\n\n## Monitor\nMonitors allow to follow the value of a GAML expression. For instance the following monitor allow to follow the number of infected people agents during the simulation. The monitor is updated at each simulation step.\n\n![images/monitor.png](resources/images/runningExperiments/monitor.png)\n\n\n\nIt is possible to define a monitor inside a model (see [this page](DefiningMonitorsAndInspectors)). It is also possible to define a monitor through the graphical interface.\n\nTo define a monitor, first choose **Add Monitor** in the **Views** menu (or by clicking on the icon in the Monitor view), then define the display legend and the expression to monitor.\n\n![images/add_monitor.png](resources/images/runningExperiments/add_monitor.png)\n\nIn the following example, we defined a monitor with the legend \"Number initial of preys\" and that has for value the global variable \"nb_preys_init\".\n\n![images/monitor_definition.png](resources/images/runningExperiments/monitor_definition.png)\n\nThe expression should be written with the GAML language. See [this page](GamlReference) for more details about the GAML language.","url":"wiki/InspectorsAndMonitors.md"},"LaunchingExperiments.md":{"title":" Launching Experiments from the User Interface","content":"# Launching Experiments from the User Interface\n\n\n\nGAMA supports multiple ways of launching experiments from within the Modeling Perspective, in editors or in the [navigator](NavigatingWorkspace).\n\n\n## Table of contents \n\n* [Launching Experiments from the User Interface](#launching-experiments-from-the-user-interface)\n\t* [From an Editor](#from-an-editor)\n\t* [From the Navigator](#from-the-navigator)\n\t* [Running Experiments Automatically](#running-experiments-automatically)\n\t* [Running Several Simulations](#running-several-simulations)\n\n\n\n## From an Editor\nAs already mentioned on [this page](GamlEditorGeneralities), GAML editors will provide the easiest way to launch experiments. Whenever a model that contains the definition of experiments is validated, these experiments will appear as distinct buttons, in the order in which they are defined in the file, in the header ribbon above the text. Simply clicking one of these buttons launches the corresponding experiment.\n\n![images/editor_launch.png](resources/images/runningExperiments/editor_launch.png)\n\nFor each of those launching buttons, you can see 2 different pictograms, showing the type of experiment. An experiment can either be a [GUI Experiment](DefiningGUIExperiment) or a [Batch Experiment](BatchExperiments).\n\n![images/editor_different_types_of_experiment.png](resources/images/runningExperiments/editor_different_types_of_experiment.png)\n\n\n## From the Navigator\nYou can also launch your experiments from the navigator, by expanding a model and double clicking on one of the experiments available (The number of experiments for each model is visible also in the navigator). As for the editor, the two types of experimentations (gui and batch) are differentiated by a pictogram.\n\n![images/navigator_launch.png](resources/images/runningExperiments/navigator_launch.png)\n\n\n## Running Experiments Automatically\nOnce an experiment has been launched (unless it is run in [headless](Headless) mode, of course), it normally displays its views and waits from an input from the user, usually a click on the \"Run\" or \"Step\" buttons (see [here](MenusAndCommands)).\n\nIt is however possible to make experiments run directly once launched, without requiring any intervention from the user.  To install this feature, [open the preferences of GAMA](Preferences). On the first tab, simply check \"Auto-run experiments when they are launched\" (which is unchecked by default) and hit \"OK\" to dismiss the dialog. Next time you'll launch an experiment, it will run automatically (this option also applies to experiments launched from the command line).\n\n![images/prefs_auto_run.png](resources/images/runningExperiments/prefs_auto_run.png)\n\n## Running Several Simulations\n\nIt is possible in GAMA to run several simulations. Each simulation will be launched with the same seed (which means that if the parameters are the same, then the result will be exactly the same). All those simulations are synchronized in the same cycle.\n\nTo run several experiments, you have to [write it directly in your model](LaunchSeveralSimulations).\n\n![images/run_several_simulations.png](resources/images/runningExperiments/run_several_simulations.png)","url":"wiki/LaunchingExperiments.md"},"MenusAndCommands.md":{"title":" Menus and Commands","content":"# Menus and Commands\n\n\n\nThe simulation perspective adds on the user interface a number of new menus and commands (i.e. buttons) that are specific to experiment-related tasks.\n\n\n\n## Table of contents \n\n* [Menus and Commands](#menus-and-commands)\n\t* [Experiment Menu](#experiment-menu)\n\t* [Agents Menu](#agents-menu)\n\t* [General Toolbar](#general-toolbar)\n\n\n\n## Experiment Menu\nA menu, called \"Experiment\", allows to control the current experiment. It shares some of its commands with the general toolbar (see [below](#general-toolbar)).\n\n![images/menu_experiment.png](resources/images/runningExperiments/menu_experiment.png)\n\n\n  * **Run/Pause**: allows to run or pause the experiment depending on its current state.\n  * **Step by Step**: runs the experiment for one cycle and pauses it after.\n  * **Reload**: stops the current experiment, deletes its contents, and reloads it, **taking into account the [parameters values](ParametersView) that might have been changed by the user**.\n  * **Stop at first error**: if checked, the current experiment will stop running when an error is issued. The default value can be configured in the [preferences](Preferences).\n  * **Treat warnings as errors**: if checked, a warning will be considered as an error (and if the previous item is checked, will stop the experiment). The default value can be configured in the [preferences](Preferences).\n  * **Display warnings and errors**: if checked, displays the errors and warnings issued by the experiment. If not, do not display them. The default value can be configured in the [preferences](Preferences).\n  * **Force interrupt**: forces the experiment to stop, whatever it is currently doing, purges the memory from it, and switches to the modeling perspective. **Use this command with caution**, as it can have undesirable effects depending on the state of the experiment (for example, if it is reading files, or outputting data, etc.).\n\n\n\n\n\n\n## Agents Menu\n\nA second menu is added in the simulation perspective: \"Agents\". This menu allows for an easy access to the different agents that populate an experiment.\n\n![images/menu_agents.png](resources/images/runningExperiments/menu_agents.png)\n\n\nThis hierarchical menu is always organized in the same way, whatever the experiment being run. A first level is dedicated to the current simulation agent: it allows to [browse](InspectorsAndMonitors) its population or to inspect the simulation agent itself. Browsing the population will give access to the current experiment agent (the \"host\" of this population). A second level lists the \"micro-populations\" present in the simulation agent. And the third level will give access to each individual agent in these populations. This organization is of course recursive: if these agents are themselves hosts of micro-populations, they will be displayed in their individual menu.\n\n![images/menu_agents_2.png](resources/images/runningExperiments/menu_agents_2.png)\n\n\n\nEach agent, when selected, will reveal a similar individual menu. This menu will contain a set of predefined actions, [the commands defined by the user for this species](DefiningUserInteraction#define-user-command), if any, and then the micro-populations hosted by this agent, if any. Agents (like the instances of \"ant\" below) that do not host other agents and whose species has no user commands will have a \"simple\" individual menu.\n\n![images/menu_agents_3.png](resources/images/runningExperiments/menu_agents_3.png)\n\nThese are the 4 actions that will be there most of the time:\n\n  * **Inspect**: open an [inspector](InspectorsAndMonitors) on this agent.\n  * **Highlight**: makes this agent the current \"highlighted\" agent, forcing it to appear \"highlighted\" in all the displays that might have been defined.\n  * **Focus**: this option is not accessible if no displays are defined. Makes the current display zoom on the selected agent (if it is displayed) so that it occupies the whole view.\n  * **Kill**: destroys the selected agent and disposes of it. **Use this command with caution**, as it can have undesirable effects if the agent is currently executing its behavior.\n\nIf an agent hosts other agents (it is the case in [multi-level architecture](MultiLevelArchitecture)), you can access to the micro-population quite easily: \n\n![images/menu_agents_multi_level.png](resources/images/runningExperiments/menu_agents_multi_level.png)\n\nIf [user commands](DefiningUserInteraction#define-user-command) are defined for a species (for example in the existing model Features/Driving Skill/Road Traffic simple (City)), their individual menu will look like the following:\n\n![images/menu_agents_user_command.png](resources/images/runningExperiments/menu_agents_user_command.png)\n\n\n\n\n## General Toolbar\n\nThe last piece of user interface specific to the Simulation Perspective is a toolbar, which contains controls and information displays related to the current experiment.\n\nThis toolbar is voluntarily minimalist, with three buttons already present in the [experiment menu](#experiment-menu) (namely, \"Play/Pause\", \"Step by Step\" and \"Reload\"), which don't need to be detailed here, and two new controls (\"Experiment status\" and \"Cycle Delay\"), which are explained below.\n\n![images/toolbar.png](resources/images/runningExperiments/toolbar.png)\n\n\nWhile opening an experiment, the status will display some information about what's going on. For instance, that GAMA is busy instantiating the agents, or opening the displays.\n\n![images/toolbar_instantiating_agents.png](resources/images/runningExperiments/toolbar_instantiating_agents.png)\n\n\n![images/toolbar_building_outputs.png](resources/images/runningExperiments/toolbar_building_outputs.png)\n\n\nThe orange color usually means that, although the experiment is not ready, things are progressing without problems (a red color message is an indication that something went wrong). When the loading of the experiment is finished, GAMA displays the message \"Simulation ready\" on a green background. If the user runs the simulation, the status changes and displays the number of cycles already elapsed in the simulation currently managed by the experiment.\n\n![images/toolbar_running.png](resources/images/runningExperiments/toolbar_running.png)\n\n\nHovering over the status produces a more accurate information about the internal clock of the simulation.\n\n![images/toolbar_running_with_info.png](resources/images/runningExperiments/toolbar_running_with_info.png)\n\n\n\nFrom top to bottom of this hover, we find the number of cycles elapsed, the simulated time already elapsed (in the example above, one cycle lasts one second of _simulated time_), the duration of cycle in milliseconds, the average duration of one cycle (computed over the number of cycles elapsed), and the total duration, so far, of the simulation (still in milliseconds).\n\nAlthough these durations are entirely dependent on the speed of the simulation engine (and, of course, the number of agents, their behaviors, etc.), there is a way to control it partially with the second control, which allows the user to force a minimal duration (in milliseconds) for a cycle, from 0 (its initial position) to 1000. Note that this minimal duration (or delay) will remain the same for the subsequent reloads of the experiment.\n\n![images/toolbar_running_with_delay.png](resources/images/runningExperiments/toolbar_running_with_delay.png)\n\n\nIn case it is necessary to have more than 1s of delay, it has to be defined, instead, as an attribute of the [experiment](ExperimentBuiltIn).","url":"wiki/MenusAndCommands.md"},"ParametersView.md":{"title":" Parameters View","content":"# Parameters View\n\n\n\nIn the case of an [experiment](DefiningGUIExperiment), the modeler can [define the parameters](DefiningParameters) he wants to be able to modify to explore the simulation, and thus the ones he wants to be able to display and alter in the GUI interface.\n\n**It important to notice that all modification made in the parameters are used for simulation reload only. Creation of a new simulation from the model will erase the modifications.**\n\n\n\n## Table of contents \n\n* [Parameters View](#parameters-view)\n\t* [Built-in parameters](#built-in-parameters)\n\t* [Parameters View](#parameters-view)\n\t* [Modification of parameters values](#modification-of-parameters-values)\n\n\n## Built-in parameters\nEvery [GUI experiment](DefiningGUIExperiment) displays a pane named \"Parameters\" containing at least two built-in parameters related to the random generator:\n  * the Random Number Generator, with a choice between 3 RNG implementations,\n  * the Random Seed\n\n![images/parameters_built_in.png](resources/images/runningExperiments/parameters_built_in.png)\n\n\n## Parameters View\nThe modeler can [define himself parameters](DefiningParameters) that can be displayed in the GUI and that are sorted by categories. Note that the interface will depend on the data type of the parameter: for example, for integer or float parameters, a simple text box will be displayed whereas a color selector will be available for color parameters. The parameters value displayed are the initial value provided to the variables associated to the parameters in the model.\n\n![images/parameters.png](resources/images/runningExperiments/parameters.png)\n\nThe above parameters view is generated from the following code:\n```\nglobal\n{\n\tint i;\n\tfloat f;\n\tstring s;\n\tlist l;\n\tmatrix m;\n\tpair p;\n\trgb c;\n}\n\nexperiment maths type: gui {\n    parameter \"my_integer\" var: i <- 0 category:\"Simple types\";\n    parameter \"my_float\" var: f <- 0.0 category:\"Simple types\";\n    parameter \"my_string\" var: s <- \"\" category:\"Simple types\";\n\n    parameter \"my_list\" var: l <- [] category:\"Complex types\";\n    parameter \"my_matrix\" var: m <- matrix([[1,2],[3,4]]) category:\"Complex types\";\n    parameter \"my_pair\" var: p <- 3::5 category:\"Complex types\";\n    parameter \"my_color\" var: c <- #green category:\"Complex types\";\n\n    output {}\n}\n```\nClick on Edit button in case of list or map parameters or the color or matrix will open an additional window to modify the parameter value.\n\n\n\n\n\n## Modification of parameters values\n\nThe modeler can modify the parameter values. After modifying the parameter values, you can reload the simulation by clicking on the top-right circular arrow button. \n\nYou can also add a new simulation to the old one, using those new parameters, by clicking on the top-right plus symbol button.\n\nIf he wants to come back to the initial value of parameters, he can click on the top-right red curved arrow of the parameters view.","url":"wiki/ParametersView.md"},"ChangingWorkspace.md":{"title":" Changing Workspace","content":"# Changing Workspace\n\nIt is possible, and actually common, to store different projects/models in different workspaces and to tell GAMA to switch between these workspaces. Doing so involves being able to create one or several new workspace locations (even if GAMA has been told to [remember](Launching#Choosing_a_Workspace) the current one) and being able to easily switch between them.\n\n## Table of contents \n\n* [Changing Workspace](#changing-workspace)\n\t* [Switching to another Workspace](#switching-to-another-workspace)\n\t* [Cloning the Current Workspace](#cloning-the-current-workspace)\n\n\n\n## Switching to another Workspace\nThis process is similar to the [choice of the workspace location](Launching#Choosing_a_Workspace) when GAMA is launched for the first time. The only preliminary step is to invoke the appropriate command (\"Switch Workspace\") from the \"File\" menu.\n\n![images/menu_switch.png](resources/images/workspaceProjectsAndModels/menu_switch.png)\n\nIn the dialog that appears, the current workspace location should already be entered. Changing it to a new location (or choosing one in the file selector invoked by clicking on \"Browse...\") and pressing \"OK\" will then either create a new workspace if none existed at that location or switch to this new workspace. Both operations will restart GAMA and set the new workspace location. To come back to the previous location, just repeat this step (the previous location is normally now accessible from the combo box).\n\n![images/dialog_switch_ok.png](resources/images/workspaceProjectsAndModels/dialog_switch_ok.png)\n\n## Cloning the Current Workspace\nAnother possibility, if you have models in your current workspace that you would like to keep in the new one (and that you do not want to [import](ImportingModels) one by one after switching workspace), or if you change workspace because you suspect the current one is corrupted, or outdated, etc. but you still want to keep your models, is to **clone** the current workspace into a new (or existing) one.\n\n**Please note that cloning (as its name implies) is an operation that will make a _copy_ of the files into a new workspace. So, if projects are stored in the current workspace, this will result in two different instances of the same projets/models with the same name in the two workspaces. However, for projects that are simply linked from the current workspace, only the link will be copied (which allows to have different workspaces \"containing\" the same project)**\n\nThis can be done by entering the new workspace location and choosing \"Clone current workspace\" in the previous dialog instead of \"Ok\".\n\n![images/dialog_switch_clone.png](resources/images/workspaceProjectsAndModels/dialog_switch_clone.png)\n\n\nIf the new location does not exist, GAMA will ask you to confirm the creation and cloning using a specific dialog box. Dismissing it will cancel the operation.\n\n![images/clone_confirm_new.png](resources/images/workspaceProjectsAndModels/clone_confirm_new.png)\n\n\nIf the new location is already the location of an existing workspace, another confirmation dialog is produced. **It is important to note that all projects in the target workspace will be erased and replaced by the projects in the current workspace if you proceed**. Dismissing it will cancel the operation.\n\n![images/clone_confirm_existing.png](resources/images/workspaceProjectsAndModels/clone_confirm_existing.png) \n\n\nThere are two cases where cloning is not accepted. The first one is when the user tries to clone the current workspace into itself (i.e. the new location is the same as the current location).\n\n![images/close_error_same.png](resources/images/workspaceProjectsAndModels/close_error_same.png)\n\nThe second case is when the user tries to clone the current workspace into one of its subdirectories (which is not feasible).\n\n![images/close_error_subdir.png](resources/images/workspaceProjectsAndModels/close_error_subdir.png)","url":"wiki/ChangingWorkspace.md"},"ImportingModels.md":{"title":" Importing Models","content":"# Importing Models\n\n\n_Importing_ a model refers to making a model file (or a complete project) available for edition and experimentation in the **workspace**. With the exception of [headless](Headless) experiments, GAMA requires that models be manageable in the current workspace to be able to validate them and eventually experiment them.\n\nThere are many situations where a model needs to be _imported_ by the user: someone sent it to him/her by mail, it has been attached to an [issue report](Troubleshooting), it has been shared on the web or an SVN server, or it belongs to a previous workspace after the user has [switched workspace](ChangingWorkspace). The instructions below apply equally to all these situations.\n\nSince model files need to reside in a project to be managed by GAMA, it is usually preferable to import a whole project rather than individual files (unless, of course, the corresponding models are simple enough to not require any additional resources, in which case, the model file can be imported with no harm into an existing project). GAMA will then try to detect situations where a model file is imported alone and, if a corresponding project can be found (for instance, in the upper directories of this file), to import the project instead of the file. As the last resort, GAMA will import orphan model files into a _generic_ project called _\"Unclassified Models\"_ (which will be created if it does not exist yet).\n\n## Table of contents \n\n* [Importing Models](#importing-models)\n\t* [The \"Import...\" Menu Command](#the-import-menu-command)\n\t* [Silent import](#silent-import)\n\t* [Drag'n Drop / Copy-Paste Limitations](#dragn-drop--copy-paste-limitations)\n\n\n\n## The \"Import...\" Menu Command\nThe simplest, safest and most secure way to import a project into the workspace is to use the built-in \"Import...\" menu command, available in the \"File\" menu or in the contextual menu of the _Navigator_.\n\n![images/menu_file_import.png](resources/images/workspaceProjectsAndModels/menu_file_import.png)\n\n\nWhen invoked, this command will open a dialog asking the user to choose the source of the importation. It can be a directory in the filesystem (in which GAMA will look for existing projects), a zip file, a SVN site, etc. It is safer in any case to choose \"Existing Projects into Workspace\".\n\n\n![images/dialog_import.png](resources/images/workspaceProjectsAndModels/dialog_import.png)\n\nNote that when invoked from the contextual menu, \"Import...\" will directly give access to a shortcut of this source in a submenu.\n\n![images/menu_navigator_import.png](resources/images/workspaceProjectsAndModels/menu_navigator_import.png)\n\n\nBoth options will lead the user to a last dialog where he/she will be asked to:\n\n1. Enter a location (or browse to a location) containing the GAMA project(s) to import\n2. Choose among the list of available projects (computed by GAMA) the ones to effectively import\n3. Indicate whether or not these projects need to be **copied to** or **linked from** the workspace (the latter is done by default)\n\n![images/dialog_import_2.png](resources/images/workspaceProjectsAndModels/dialog_import_2.png)\n\n\n\n## Silent import\nAnother (possibly simpler, but less controllable) way of importing projects and models is to either pass a path to a model when [launching](Launching) GAMA from the command line or to double-click on a model file (ending in _.gaml_) in the Explorer or Finder (depending on your OS).\n\nIf the file is not already part of an imported project in the current workspace, GAMA will:\n\n  1. silently import the project (by creating a link to it),\n  1. open an editor on the file selected.\n\nThis procedure may fail, however, if a project of the same name (but in a different location) already exists in the workspace, in which case GAMA will refuse to import the project (and hence, the file). The solution in this case is to rename the project to import (or to rename the existing project in the workspace).\n\n\n\n\n## Drag'n Drop / Copy-Paste Limitations\nCurrently, **there is no way** to drag and drop an entire project into GAMA _Navigator_ (or to copy a project in the filesystem and paste it in the _Navigator_). Only individual model files, folders or resources can be moved this way (and they have to be dropped or pasted into existing projects).\n\nThis limitation might be removed some time in the future, however, allowing users to use the _Navigator_ as a project drop or paste target, but it is not the case yet.","url":"wiki/ImportingModels.md"},"NavigatingWorkspace.md":{"title":" Navigating in the Workspace","content":"# Navigating in the Workspace\n\nAll the models that you edit or run using GAMA are accessible from a central location: the _Navigator_, which is always on the left-hand side of the main window and cannot be closed. This view presents the models currently present in (or linked from) your **workspace**.\n\n![images/navigator_first.png](resources/images/workspaceProjectsAndModels/navigator_first.png)\n\n## Table of contents \n\n* [Navigating in the Workspace](#navigating-in-the-workspace)\n\t* [The Different Categories of Models](#the-different-categories-of-models)\n\t\t* [Models library](#models-library)\n\t\t* [Plugin models](#plugin-models)\n\t\t* [User models](#user-models)\n\t* [Inspect Models](#inspect-models)\n\t* [Moving Models Around](#moving-models-around)\n\t* [Closing and Deleting Projects](#closing-and-deleting-projects)\n\n\n## The Different Categories of Models\n\nIn the _Navigator_, models are organized in three different categories: _Models library_, _Plugin models_, and _User models_. This organization is purely logical and does not reflect where the models are actually stored in the workspace (or elsewhere). Whatever their actual location, model files need to be stored in **projects**, which may contain also other files (called _resources_) necessary for the models to function. A project may of course contain several model files, especially if they are importing each other, if they represent different models on the same topic, or if they share the same resources.\n\n![images/navigator_3_categories.png](resources/images/workspaceProjectsAndModels/navigator_3_categories.png)\n\n### Models library\n\nThis category represents the models that are shipped with each version of GAMA. They do not reside in the workspace, but are considered as _linked_ from it. This link is established every time a new workspace is created. Their actual location is within a plugin (msi.gama.models) of the GAMA application. This category contains four main projects in GAMA 1.6.1, which are further refined in folders and sub-folders that contain model files and resources.\n\n![images/navigator_library_2_folders_expanded.png](resources/images/workspaceProjectsAndModels/navigator_library_2_folders_expanded.png)\n\nIt may happen, in some occasions, that the library of models is not synchronized with the version of GAMA that uses your workspace. This is the case if you use different versions of GAMA to work with the same workspace. In that case, it is required that the library be manually updated. This can be done using the \"Update library\" item in the contextual menu.\n\n![images/navigator_update_library.png](resources/images/workspaceProjectsAndModels/navigator_update_library.png)\n\n\nTo look up for a particular model in the library, users can use the \"Search for file\" menu item. A search dialog is then displayed, which allows to look for models by their title (for example, models containing \"GIS\" in the example below).\n\n\n![images/navigator_menu_search.png](resources/images/workspaceProjectsAndModels/navigator_menu_search.png)\n![images/navigator_dialog_search.png](resources/images/workspaceProjectsAndModels/navigator_dialog_search.png)\n\n### Plugin models\n\nThis category represents the models that are related to a specific plugin (additional or integrated by default). The corresponding plugin is shown between parenthesis.\n\n![images/navigator_plugin_models.png](resources/images/workspaceProjectsAndModels/navigator_plugin_models.png)\n\nFor each projects, you can see the list of plugins needed, and a caption to show you if the plugin is actually installed in your GAMA version or not : green if the plugin is installed, red otherwise.\n\n### User models\n\nThis category regroups all the projects that have been [created](GamlEditorGeneralities) or [imported](ImportingModels) in the workspace by the user. Each project is actually a folder that resides in the folder of the workspace (so they can be easily located from within the filesystem). Any modification (addition, removal of files...) made to them in the file system (or using another application) is immediately reflected in the _Navigator_ and vice-versa.\n\nModel files, although it is by no means mandatory, usually reside in a sub-folder of the project called \"models\".\n\n![images/navigator_user_expanded.png](resources/images/workspaceProjectsAndModels/navigator_user_expanded.png)\n\n## Inspect Models\n\nEach models is presented as a node in the navigation workspace, including _Experiment_ buttons and/or _Requires_ node and/or _Uses_ node.\n\n![images/inspect_model.png](resources/images/workspaceProjectsAndModels/inspect_model.png)\n\n* **Experiment button** : Experiment button are present if your model contains experiments (it is usually the case !). To run the corresponding experiment, just click on it. To learn more about running experiments, jump into this [section](LaunchingExperiments).\n\n* **Require node** : The node _Require_ is present if your model uses some plugins (additional or integrated by default). Each plugin is listed in this node, with a green icon if the plugin is already installed in your GAMA, and a red one if it is not the case. If the plugin you want in not installed, an error will be raised in your model. Please read about [how to install plugins](InstallingPlugins) to learn some more about it.\n\n![images/requires_plugin_not_found.png](resources/images/workspaceProjectsAndModels/requires_plugin_not_found.png)\n\n* **Uses node** : The node _Uses_ is present if your model uses some external resources, *and if the path to the resource is correct* (if the path to the resource is not correct, the resource will not be displayed under _Uses_)\n\n![images/uses_non_correct_paths.png](resources/images/workspaceProjectsAndModels/uses_non_correct_paths.png)\n![images/uses_correct_paths.png](resources/images/workspaceProjectsAndModels/uses_correct_paths.png)\n\n## Moving Models Around\nModel files, as well as resources, or even complete projects, can be moved around between the \"Models Library\"/\"Plugin Models\" and \"Users Models\" categories, or within them, directly in the _Navigator_. Drag'n drop operations are supported, as well as copy and paste. For example, the model \"Life.gaml\", present in the \"Models Library\", can perfectly be copied and then pasted in a project in the \"Users Model\". This local copy in the workspace can then be further edited by the user without altering the original one.\n\n![images/navigator_menu_copy_paste.png](resources/images/workspaceProjectsAndModels/navigator_menu_copy_paste.png)\n\n\n## Closing and Deleting Projects\nUsers can choose to get rid of old projects by either **closing** or **deleting** them. Closing a project means that it will still reside in the workspace (and be still visible, although a bit differently, in the _Navigator_) but its model(s) won't participate to the build process and won't be displayable until the project is opened again.\n\n![images/navigator_menu_close.png](resources/images/workspaceProjectsAndModels/navigator_menu_close.png)\n![images/navigator_close_result.png](resources/images/workspaceProjectsAndModels/navigator_close_result.png)\n\n**Deleting** a project must be invoked when the user wants this project to not appear in the workspace anymore (unless, that is, it is [imported](ImportingModels) again). Invoking this command will effectively make the workspace \"forget\" about this project, and this can be further doubled with a deletion of the projects resources and models from the filesystem.\n\n![images/navigator_menu_delete.png](resources/images/workspaceProjectsAndModels/navigator_menu_delete.png)\n![images/navigator_delete_dialog.png](resources/images/workspaceProjectsAndModels/navigator_delete_dialog.png)","url":"wiki/NavigatingWorkspace.md"},"EditingModels.md":{"title":" Editing models","content":"# Editing models\n\n\n\nEditing models in GAMA is very similar to editing programs in a modern IDE like [Eclipse](http://www.eclipse.rog). After having successfully [launched](Launching) the program, the user has two fundamental concepts at its disposal: a **workspace**, which contains models or links to models organized like a hierarchy of files in a filesystem, and the **workbench** (aka, the _main window_), which contains the tools to create, modify and experiment these models.\n\nUnderstanding how to navigate in the **workspace** is covered in [another section](NavigatingWorkspace) and, for the purpose of this section, we just need to understand that it is organized in **projects**, which contain **models** and their associated data. **Projects** are further categorized, in GAMA, into three categories : _Models Library_ (built-in models shipped with GAMA and automatically linked from the workspace), _Shared Models_, and _User Models_.\n\nThis section covers the following sub-sections :\n\n  * 1. [GAML Editor Generalities](GamlEditorGeneralities)\n  * 2. [GAML Editor Toolbar](GamlEditorToolbar)\n  * 3. [Validation of Models](ValidationOfModels)\n  * 4. [Graphical Editor](G__GraphicalEditor)","url":"wiki/EditingModels.md"},"InstallationAndLaunching.md":{"title":" Installation and Launching","content":"# Installation and Launching\n\nThe GAMA platform can be easily installed in your machine, either if you are using Windows, Mac OS or Ubuntu. GAMA can then be extended by using a number of additional plugins.\n\nThis part is dedicated to explain how to [install GAMA](Installation), [launching GAMA](Launching) and extend the platform by [installing additional plugins](InstallingPlugins). All the [known issues concerning installation](Troubleshooting) are also explain. The GAMA team provides you a continuous support by proposing corrections to some serious issues through [updating patchs](Updating). In this part, we will also present you briefly an other way to launch GAMA without any GUI : the [headless mode](Headless).\n\n* [Installation](Installation)\n* [Launching GAMA](Launching)\n* [Headless Mode](Headless)\n* [Updating GAMA](Updating)\n* [Installing Plugins](InstallingPlugins)\n* [Troubleshooting](Troubleshooting)","url":"wiki/InstallationAndLaunching.md"},"Preferences.md":{"title":" Preferences","content":"# Preferences\n\nVarious preferences are accessible in GAMA to allow users and modelers to personalize their working environment. This section review the different preference tabs available in the current version of GAMA, as well as how to access the preferences and settings inherited by GAMA from Eclipse.\n\nPlease note that the preferences specific to GAMA will be shared, on a same machine, and for a same user, among all the workspaces managed by GAMA. [Changing workspace](ChangingWorkspace) will not alter them. If you happen to run several instances of GAMA, they will also share these preferences.\n\n\n## Table of contents \n\n* [Preferences](#preferences)\n\t* [Opening Preferences](#opening-preferences)\n\t* [Simulation](#simulation)\n\t* [Display](#display)\n\t* [Editor](#editor)\n\t* [External](#external)\n\t* [Advanced Preferences](#advanced-preferences)\n\n\n## Opening Preferences\nTo open the preferences dialog of GAMA, either click on the small \"form\" button on the top-left corner of the window or select \"Preferences...\" from the Gama, \"Help\" or \"Views\" menu depending on your OS.\n\n![images/open_prefs.png](resources/images/preferences/open_prefs.png)\n\n\n## Simulation\n\n![images/simulation.png](resources/images/preferences/simulation.png)\n\n  * **Random Number Generation**: all the options pertaining to generating random numbers in simulations\n    * Random Number Generator: the name of the generator to use by default (if none is specified in the model).\n    * Define a default seed: whether or not a default seed should be used if none is specified in the model  (otherwise it is chosen randomly by GAMA)\n    * Default Seed value: the value of this default seed\n    * Include in the parameters of models: whether the choice of generator and seed is included by default in the [parameters views](ParametersView) of experiments or not.\n  * **Errors**: how to manage and consider simulation errors\n    * Display Errors: whether errors should be displayed or not.\n    * Number of errors to display: how many errors should be displayed at once\n    * Display most recent first: errors will be sorted in the inverse chronological order if true.\n    * Stop simulation at first error: if false, the simulations will display the errors and continue (or try to).\n    * Treat warnings as errors: if true, no more distinction is made between warnings (which do not stop the simulation) and errors (which can potentially stop it.\n  * **Runtime**: various settings regarding the execution of experiments.\n    * Default Step for Delay Slider: the number of seconds that one step of the slider used to impose a delay between two cycles of a simulation lasts.\n    * Auto-run experiments when they are launched: see [this page](LaunchingExperiments#Running_Experiments_Automatically).\n    * Ask to close the previous simulation before launching a new one: if false, previous simulations (if any) will be closed without warning.\n\n    \n## UI\n\n![images/UI.png](resources/images/preferences/UI.png)\n\n  * **Menus**\n    * Break down agents in menu every: when [inspecting](InspectorsAndMonitors) a large number of agents, how many should be displayed before the decision is made to separate the population in sub-menus.\n    * Sort colors menu by\n    * Sort operators menu by\n  * **Console**\n    * Max. number of characters to display in the console (-1 means no limit)\n    * Max. number of characters to keep in memory when console is paused (-1 means no limit)\n  * **Icons**\n    * Icons and buttons dark mode (restart to see the change): Change the highlight for the icons and the button.\n    * Size of icons in the UI (restart to see the change): Size of the icons in pixel\n  * **Viewers**\n    * Default shapefile viewer fill color:\n    * Default shapefile viewer line color:\n    * Default image viewer background color: Background color for the image viewer (when you select an image from the model explorer for example)\n\n\n## General\n\n![images/general.png](resources/images/preferences/general.png)\n\n  * **Startup**\n    * Display welcome page at startup: if true, and if no editors are opened, the [welcome page](Launching#Welcome_Page) is displayed when opening GAMA.\n\n\n## Display\n\n![images/display.png](resources/images/preferences/display.png)\n\n  * **Properties**: various properties of displays\n    * Default display method: use either 'Java2D' or 'OpenGL' if nothing is specified in the [declaration of a display](DefiningDisplaysGeneralities).\n    * Synchronize displays with simulations: if true, simulation cycles will wait for the displays to have finished their rendering before passing to the next cycle (this setting can be changed on an individual basis dynamically [here](Displays)).\n    * Show display overlay: if true, the [bottom overlay](Displays) is visible when opening a display.\n    * Show scale bar in overlay: if true, the scale bar is displayed in the bottom overlay.\n    * Apply antialiasing: if true, displays are drawn using antialiasing, which is slower but renders a better quality of image and text (this setting can be changed on an individual basis dynamically [here](Displays)).\n    * Default background color: indicates which color to use when none is specified in the [declaration of a display](DefiningDisplaysGeneralities).\n    * Default highlight color: indicates which color to use for highlighting agents in the displays.\n    * Stack displays on screen...: if true, the [display views](Displays), in case they are stacked on one another, will put the first [display declared in the model](DefiningDisplaysGeneralities) on top of the stack.\n  * **Default Aspect**: which aspect to use when an ['agent' or 'species' layer](G__DefiningOtherLayers) does not indicate it\n    * Default shape: a choice between 'shape' (which represents the actual geometrical shape of the agent) and geometrical operators ('square', etc.).\n    * Default size: what size to use. This expression must be a constant.\n    * Default color: what color to use.\n    * Default font to use in text layers or draw statements when none is specified\n  * **OpenGL**: various properties specific to OpenGL-based displays\n    * Use improved z positioning: if true, two agents positioned at the same z value will be slightly shifted in z in order to draw them more accurately.\n    * Draw 3D referential: if true, the shape of the world and the 3 axes are drawn\n    * Show number of frames per second\n    * Enable lighting: if true, lights can be defined in the display\n    * Draw normals to objects: if true, the 'normal' of each object is displayed together with it.\n    * Display as a cube: if true, the scene is drawn on all the facets of a cube.\n\n\n## Editor\n\n![images/editor.png](resources/images/preferences/editor.png)\n\n\nMost of the settings and preferences regarding editors can be found in the [advanced preferences](#advanced-preferences).\n\n  * **Options**\n    * Automatically switch to Modeling Persepective: if true, if a model is edited in the Simulation Perspective, then the perspective is automatically switched to Modeling (_inactive for the moment_)\n    * Automatically close curly brackets ({)\n    * Automatically close square brackets (])\n    * Automatically close parenthesis\n    * Mark occurrences of symbols in models: if true, when a symbol is selected in a model, all its occurrences are also highlighted.\n    * Applying formatting to models on save: if true, every time a model file is saved, its code is formatted.\n    * Save all model files before launching an experiment\n    * Ask before saving each file\n  * **Validation**\n    * Show warning markers when editing a model\n    * Show information markers when editing a model\n  * **Presentation**\n    * Turn on colorization of code sections by default\n    * Font of editors\n    * Background color of editors\n  * **Toolbars**\n    * Show edition toolbar by default\n    * Show other models' experiments in toolbar: if true, you are able to launch other models' experiments from a particular model.\n\n\n\n## External\n\n![images/external.png](resources/images/preferences/external.png)\n\n\nThese preferences pertain to the use of external libraries or data with GAMA.\n\n  * **Paths**\n    * Path to Spatialite: the path to the Spatialite library (http://www.gaia-gis.it/gaia-sins/) in the system.\n    * Path to RScript: the path to the RScript library (http://www.r-project.org) in the system.\n  * **GIS Coordinate Reference Systems**: settings about CRS to use when loading or saving GIS files\n    * Let GAMA decide which CRS to use to project GIS data: if true, GAMA will decide which CRS, based on input, should be used to project GIS data. Default is false (i.e. only one CRS, entered below, is used to project data in the models)\n    * ...or use the following CRS (EPSG code): choose a CRS that will be applied to all GIS data when projected in the models. Please refer to http://spatialreference.org/ref/epsg/ for a list of EPSG codes.\n    * When no .prj file or CRS is supplied, consider GIS data to be already projected: if true, GIS data that is not accompanied by a CRS information will be considered as projected using the above code.\n    * ...or use the following CRS (EPSG code): choose a CRS that will represent the default code for loading uninformed GIS data.\n    * When no CRS is provided, save the GIS data with the current CRS: if true, saving GIS data will use the projected CRS unless a CRS is provided.\n    * ...or use the following CRS (EPSG code): otherwise, you might enter a CRS to use to save files.\n\n\n\n\n## Advanced Preferences\n\nThe set of preferences described above are specific to GAMA. But there are other preferences or settings that are inherited from the Eclipse underpinnings of GAMA, which concern either the \"core\" of the platform (workspace, editors, updates, etc.) or plugins (like SVN, for instance) that are part of the distribution of GAMA.\n\nThese \"advanced\" preferences are accessible by clicking on the \"Advanced...\" button in the Preferences view.\n\n![images/advanced.png](resources/images/preferences/advanced.png)\n\n\nDepending on what is installed, the second view that appears will contain a tree of options on the left and preference pages on the right. **Contrary to the first set of preferences, please note that these preferences will be saved in the current workspace**, which means that changing workspace will revert them to their default values. It is however possible to import them in the new workspace using of the wizards provided in the standard \"Import...\" command (see [here](ImportingModels)).\n\n![images/advanced_2.png](resources/images/preferences/advanced_2.png)","url":"wiki/Preferences.md"},"RunningExperiments.md":{"title":" Running Experiments","content":"# Running Experiments\n\n\n\n_Running an experiment_ is the only way, in GAMA, to execute simulations on a model. Experiments can be run in different ways.\n  1. The first, and most common way, consists in [launching an experiment](LaunchingExperiments) from the Modeling perspective, using the [user interface](ExperimentsUserInterface) proposed by the simulation perspective to run simulations.\n  1. The second way, detailed on this [page](Launching), allows to automatically launch an experiment when opening GAMA, subsequently using the same [user interface](ExperimentsUserInterface).\n  1. The last way, known as running [headless experiments](Headless), does not make use of the user interface and allows to manipulate GAMA entirely from the command line.\n\nAll three ways are strictly equivalent in terms of computations (with the exception of the last one omitting all the computations necessary to render simulations on displays or in the UI). They simply differ by their usage:\n  1. The first one is heavily used when designing models or demonstrating several models.\n  1. The second is intended to be used when demonstrating or experimenting a single model.\n  1. The last one is useful when running large sets of simulations, especially over networks or grids of computers.","url":"wiki/RunningExperiments.md"},"WorkspaceProjectsAndModels.md":{"title":" Workspace, Projects and Models","content":"# Workspace, Projects and Models\n\n\n\nThe **workspace** is a directory in which GAMA stores all the current projects on which the user is working, links to other projects, as well as some meta-data like preference settings, current status of the different projects, [error markers](ValidationOfModels), and so on.\n\nExcept when running in [headless mode](Headless), **GAMA cannot function without a valid workspace**.\n\nThe workspace is organized in 3 **[categories](NavigatingWorkspace)**, which are themselves organized into **projects**.\n\nThe **projects** present in the **workspace** can be either directly _stored_ within it (as sub-directories), which is usually the case when the user [creates](EditingModels#Creating_a_first_model) a new project, or _linked_ from it (so the workspace will only contain a link to the directory of the project, supposed to be somewhere in the filesystem or on the network). A same **project** can be linked from different **workspaces**.\n\n**GAMA models files** are stored in these **projects**, which may contain also other files (called _resources_) necessary for the **models** to function. A project may of course contain several **model files**, especially if they are importing each other, if they represent different views on the same topic, or if they share the same resources.\n\nLearning how to [navigate](NavigatingWorkspace) in the workspace, how to [switch](ChangingWorkspace) workspace or how to [import, export](ImportingModels) is a necessity to use GAMA correctly. It is the purpose of the following sections.\n\n* 1. [Navigating in the Workspace](NavigatingWorkspace)\n* 2. [Changing Workspace](ChangingWorkspace)\n* 3. [Importing Models](ImportingModels)","url":"wiki/WorkspaceProjectsAndModels.md"},"Extension_cenres.gaml.extensions.hydro.md":{"title":" Extension","content":"# Extension\n\n----\n\n cenres.gaml.extensions.hydro\n\n## Table of Contents\n### Operators\n[water_area_for](#water_area_for), [water_level_for](#water_level_for), [water_polylines_for](#water_polylines_for), \n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n    \t\n----\n\n\n[//]: # (keyword|operator_water_area_for)\n### `water_area_for`\n\n#### Possible use: \n  * `geometry` **`water_area_for`** `float` --->  `float`\n  *  **`water_area_for`** (`geometry` , `float`) --->  `float`\n\n#### Special cases:     \n  * if the left operand is a polyline and the right operand a float for the water y coordinate, returrns the area of the water (water flow area)\n\n#### Examples: \n```\nwaterarea <- my_river_polyline water_area_for my_height_value\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_water_level_for)\n### `water_level_for`\n\n#### Possible use: \n  * `geometry` **`water_level_for`** `float` --->  `float`\n  *  **`water_level_for`** (`geometry` , `float`) --->  `float`\n\n#### Special cases:     \n  * if the left operand is a polyline and the right operand a float for the area, returrns the y coordinate of the water (water level)\n\n#### Examples: \n```\nwaterlevel <- my_river_polyline water_level_for my_area_value\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_water_polylines_for)\n### `water_polylines_for`\n\n#### Possible use: \n  * `geometry` **`water_polylines_for`** `float` --->  `msi.gama.util.IList<msi.gama.util.IList<msi.gama.metamodel.shape.GamaPoint>>`\n  *  **`water_polylines_for`** (`geometry` , `float`) --->  `msi.gama.util.IList<msi.gama.util.IList<msi.gama.metamodel.shape.GamaPoint>>`\n\n#### Special cases:     \n  * if the left operand is a polyline and the right operand a float for the water y coordinate, returrns the shapes of the river sections (list of list of points)\n\n#### Examples: \n```\nwaterarea <- my_river_polyline water_area_for my_height_value\n```\n  \n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_cenres.gaml.extensions.hydro.md"},"Extension_cict.gaml.extensions.netcdf.md":{"title":" Extension","content":"# Extension\n\n----\n\n cict.gaml.extensions.netcdf\n\n## Table of Contents\n### Operators\n[is_netcdf](#is_netcdf), [netcdf_file](#netcdf_file), [reduce_dimension](#reduce_dimension), \n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n    \t\n----\n\n\n[//]: # (keyword|operator_is_netcdf)\n### `is_netcdf`\n\n#### Possible use: \n  *  **`is_netcdf`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a netcdf file.\n    \t\n----\n\n\n[//]: # (keyword|operator_netcdf_file)\n### `netcdf_file`\n\n#### Possible use: \n  *  **`netcdf_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type netcdf. Allowed extensions are limited to nc\n    \t\n----\n\n\n[//]: # (keyword|operator_reduce_dimension)\n### `reduce_dimension`\n\n#### Possible use: \n  * `string` **`reduce_dimension`** `container` --->  `container`\n  *  **`reduce_dimension`** (`string` , `container`) --->  `container` \n\n#### Result: \ngeneral operator to manipylate multidimension netcdf data.\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_cict.gaml.extensions.netcdf.md"},"Extension_dream.gama.opengis.md":{"title":" Extension","content":"# Extension\n\n----\n\n dream.gama.opengis\n\n## Table of Contents\n### Operators\n[gml_from_wfs](#gml_from_wfs), [image_from_direct_wms](#image_from_direct_wms), [image_from_wms](#image_from_wms), [read_json_rest](#read_json_rest), \n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n    \t\n----\n\n\n[//]: # (keyword|operator_gml_from_wfs)\n### `gml_from_wfs`\n\n#### Possible use: \n  *  **`gml_from_wfs`** (`string`, `string`, `string`) --->  `msi.gama.util.IList<msi.gama.util.IList<java.lang.Object>>` \n\n#### Result: \nWMS: A simple call to WFS/GML2\n    \t\n----\n\n\n[//]: # (keyword|operator_image_from_direct_wms)\n### `image_from_direct_wms`\n\n#### Possible use: \n  * `string` **`image_from_direct_wms`** `string` --->  `file`\n  *  **`image_from_direct_wms`** (`string` , `string`) --->  `file` \n\n#### Result: \nWMS: A simple call to WMS\n    \t\n----\n\n\n[//]: # (keyword|operator_image_from_wms)\n### `image_from_wms`\n\n#### Possible use: \n  *  **`image_from_wms`** (`string`, `string`, `int`, `int`, `int`, `float`, `float`, `float`, `float`) --->  `file` \n\n#### Result: \nWMS: A simple call to WMS\n    \t\n----\n\n\n[//]: # (keyword|operator_read_json_rest)\n### `read_json_rest`\n\n#### Possible use: \n  * `string` **`read_json_rest`** `string` --->  `msi.gama.util.IList<msi.gama.util.IList<java.lang.Object>>`\n  *  **`read_json_rest`** (`string` , `string`) --->  `msi.gama.util.IList<msi.gama.util.IList<java.lang.Object>>` \n\n#### Result: \nREST: Read data from RESTService\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_dream.gama.opengis.md"},"Extension_idees.gama.mapcomparison.md":{"title":" Extension","content":"# Extension\n\n----\n\n idees.gama.mapcomparison\n\n## Table of Contents\n### Operators\n[fuzzy_kappa](#fuzzy_kappa), [fuzzy_kappa_sim](#fuzzy_kappa_sim), [kappa](#kappa), [kappa_sim](#kappa_sim), [percent_absolute_deviation](#percent_absolute_deviation), \n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n    \t\n----\n\n\n[//]: # (keyword|operator_fuzzy_kappa)\n### `fuzzy_kappa`\n\n#### Possible use: \n  *  **`fuzzy_kappa`** (`list<agent>`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`) --->  `float`\n  *  **`fuzzy_kappa`** (`list<agent>`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`, `list`) --->  `float` \n\n#### Result: \nfuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21\nfuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21\n\n#### Examples: \n```\nfuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2)\nfuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_fuzzy_kappa_sim)\n### `fuzzy_kappa_sim`\n\n#### Possible use: \n  *  **`fuzzy_kappa_sim`** (`list<agent>`, `list`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`) --->  `float`\n  *  **`fuzzy_kappa_sim`** (`list<agent>`, `list`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`, `list`) --->  `float` \n\n#### Result: \nfuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, \nfuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, \n\n#### Examples: \n```\nfuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2)\nfuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_kappa)\n### `kappa`\n\n#### Possible use: \n  *  **`kappa`** (`list`, `list`, `list`) --->  `float`\n  *  **`kappa`** (`list`, `list`, `list`, `list`) --->  `float` \n\n#### Result: \nkappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.\nkappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20. \n\n#### Examples: \n```\nkappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3])\nfloat var1 <- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]); \t// var1 equals the similarity between 0 and 1\nfloat var2 <- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]); \t// var2 equals 1.0\nkappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_kappa_sim)\n### `kappa_sim`\n\n#### Possible use: \n  *  **`kappa_sim`** (`list`, `list`, `list`, `list`) --->  `float`\n  *  **`kappa_sim`** (`list`, `list`, `list`, `list`, `list`) --->  `float` \n\n#### Result: \nkappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8)\nkappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8).\n\n#### Examples: \n```\nkappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0])\nkappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3])\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_percent_absolute_deviation)\n### `percent_absolute_deviation`\n\n#### Possible use: \n  * `list<float>` **`percent_absolute_deviation`** `list<float>` --->  `float`\n  *  **`percent_absolute_deviation`** (`list<float>` , `list<float>`) --->  `float` \n\n#### Result: \npercent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)\n\n#### Examples: \n```\npercent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])\n```\n  \n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_idees.gama.mapcomparison.md"},"Extension_idees.gama.weka.md":{"title":" Extension","content":"# Extension\n\n----\n\n idees.gama.weka\n\n## Table of Contents\n### Operators\n[clustering_cobweb](#clustering_cobweb), [clustering_DBScan](#clustering_dbscan), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestfirst), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_xmeans](#clustering_xmeans), \n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n    \t\n----\n\n\n[//]: # (keyword|operator_clustering_cobweb)\n### `clustering_cobweb`\n\n#### Possible use: \n  *  **`clustering_cobweb`** (`list<agent>`, `list<string>`, `map<string,unknown>`) --->  `list<list<agent>>` \n\n#### Result: \nA list of agent groups clusteredby CobWeb Algorithm based on the given attributes. Some paremeters can be defined: acuity: minimum standard deviation for numeric attributes; cutoff: category utility threshold by which to prune nodes seed\n\n#### Examples: \n```\nlist<list<agent>> var0 <- clustering_cobweb([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"acuity\"::3.0, \"cutoff\"::0.5); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]\n```\n      \n\n#### See also: \n[clustering_xmeans](#clustering_xmeans), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestfirst), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_cobweb](#clustering_cobweb), \n    \t\n----\n\n\n[//]: # (keyword|operator_clustering_DBScan)\n### `clustering_DBScan`\n\n#### Possible use: \n  *  **`clustering_DBScan`** (`list<agent>`, `list<string>`, `map<string,unknown>`) --->  `list<list<agent>>` \n\n#### Result: \nA list of agent groups clustered by DBScan Algorithm based on the given attributes. Some paremeters can be defined: distance_f: The distance function to use for instances comparison (euclidean or manhattan); min_points: minimun number of DataObjects required in an epsilon-range-queryepsilon: epsilon -- radius of the epsilon-range-queries\n\n#### Examples: \n```\nlist<list<agent>> var0 <- clustering_DBScan([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"distance_f\"::\"manhattan\"]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]\n```\n      \n\n#### See also: \n[clustering_xmeans](#clustering_xmeans), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestfirst), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_cobweb](#clustering_cobweb), \n    \t\n----\n\n\n[//]: # (keyword|operator_clustering_em)\n### `clustering_em`\n\n#### Possible use: \n  *  **`clustering_em`** (`list<agent>`, `list<string>`, `map<string,unknown>`) --->  `list<list<agent>>` \n\n#### Result: \nA list of agent groups clustered by EM Algorithm based on the given attributes. Some paremeters can be defined: max_iterations: the maximum number of iterations to perform;num_clusters: the number of clusters; minStdDev: minimum allowable standard deviation\n\n#### Examples: \n```\nlist<list<agent>> var0 <- clustering_em([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"max_iterations\"::10, \"num_clusters\"::3]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]\n```\n      \n\n#### See also: \n[clustering_xmeans](#clustering_xmeans), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_farthestFirst](#clustering_farthestfirst), [clustering_DBScan](#clustering_dbscan), [clustering_cobweb](#clustering_cobweb), \n    \t\n----\n\n\n[//]: # (keyword|operator_clustering_farthestFirst)\n### `clustering_farthestFirst`\n\n#### Possible use: \n  *  **`clustering_farthestFirst`** (`list<agent>`, `list<string>`, `map<string,unknown>`) --->  `list<list<agent>>` \n\n#### Result: \nA list of agent groups clustered by Farthest First Algorithm based on the given attributes. Some paremeters can be defined: num_clusters: the number of clusters\n\n#### Examples: \n```\nlist<list<agent>> var0 <- clustering_farthestFirst([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"num_clusters\"::3]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]\n```\n      \n\n#### See also: \n[clustering_xmeans](#clustering_xmeans), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_em](#clustering_em), [clustering_DBScan](#clustering_dbscan), [clustering_cobweb](#clustering_cobweb), \n    \t\n----\n\n\n[//]: # (keyword|operator_clustering_simple_kmeans)\n### `clustering_simple_kmeans`\n\n#### Possible use: \n  *  **`clustering_simple_kmeans`** (`list<agent>`, `list<string>`, `map<string,unknown>`) --->  `list<list<agent>>` \n\n#### Result: \nA list of agent groups clustered by K-Means Algorithm based on the given attributes. Some paremeters can be defined: distance_f: The distance function to use. 4 possible distance functions: euclidean (by default) ; 'chebyshev', 'manhattan' or 'levenshtein'; dont_replace_missing_values: if false, replace missing values globally with mean/mode; max_iterations: the maximum number of iterations to perform;num_clusters: the number of clusters\n\n#### Examples: \n```\nlist<list<agent>> var0 <- clustering_simple_kmeans([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"distance_f\"::\"manhattan\", \"num_clusters\"::3]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]\n```\n      \n\n#### See also: \n[clustering_xmeans](#clustering_xmeans), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestfirst), [clustering_DBScan](#clustering_dbscan), [clustering_cobweb](#clustering_cobweb), \n    \t\n----\n\n\n[//]: # (keyword|operator_clustering_xmeans)\n### `clustering_xmeans`\n\n#### Possible use: \n  *  **`clustering_xmeans`** (`list<agent>`, `list<string>`, `map<string,unknown>`) --->  `list<list<agent>>` \n\n#### Result: \nA list of agent groups clustered by X-Means Algorithm based on the given attributes. Some paremeters can be defined: bin_value: value given for true value of boolean attributes; cut_off_factor: the cut-off factor to use;distance_f: The distance function to use. 4 possible distance functions: euclidean (by default) ; 'chebyshev', 'manhattan' or 'levenshtein'; max_iterations: the maximum number of iterations to perform; max_kmeans: the maximum number of iterations to perform in KMeans; max_kmeans_for_children: the maximum number of iterations KMeans that is performed on the child centers;max_num_clusters: the maximum number of clusters; min_num_clusters: the minimal number of clusters\n\n#### Examples: \n```\nlist<list<agent>> var0 <- clustering_xmeans([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\", \"is_male\"],[\"bin_value\"::1.0, \"distance_f\"::\"manhattan\", \"max_num_clusters\"::10, \"min_num_clusters\"::2]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]\n```\n      \n\n#### See also: \n[clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestfirst), [clustering_DBScan](#clustering_dbscan), [clustering_cobweb](#clustering_cobweb), \n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_idees.gama.weka.md"},"Extension_irit.maelia.gaml.additions.md":{"title":" Extension","content":"# Extension\n\n----\n\n irit.maelia.gaml.additions\n\n## Table of Contents\n### Operators\n\n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_irit.maelia.gaml.additions.md"},"Extension_miat.gama.extension.ifcfile.md":{"title":" Extension","content":"# Extension\n\n----\n\n miat.gama.extension.ifcfile\n\n## Table of Contents\n### Operators\n[eleldkdjxuxsnel](#eleldkdjxuxsnel), [ifc_file](#ifc_file), [is_ifc](#is_ifc), \n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n    \t\n----\n\n\n[//]: # (keyword|operator_eleldkdjxuxsnel)\n### `eleldkdjxuxsnel`\n\n#### Possible use: \n  * `rgb` **`eleldkdjxuxsnel`** `rgb` --->  `string`\n  *  **`eleldkdjxuxsnel`** (`rgb` , `rgb`) --->  `string`\n    \t\n----\n\n\n[//]: # (keyword|operator_ifc_file)\n### `ifc_file`\n\n#### Possible use: \n  *  **`ifc_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type ifc. Allowed extensions are limited to ifc\n    \t\n----\n\n\n[//]: # (keyword|operator_is_ifc)\n### `is_ifc`\n\n#### Possible use: \n  *  **`is_ifc`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a ifc file.\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_miat.gama.extension.ifcfile.md"},"Extension_msi.gaml.extensions.cplex.md":{"title":" Extension","content":"# Extension\n\n----\n\n msi.gaml.extensions.cplex\n\n## Table of Contents\n### Operators\n\n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_msi.gaml.extensions.cplex.md"},"Extension_msi.gaml.extensions.humanmoving.md":{"title":" Extension","content":"# Extension\n\n----\n\n msi.gaml.extensions.humanmoving\n\n## Table of Contents\n### Operators\n\n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_msi.gaml.extensions.humanmoving.md"},"Extension_msi.gaml.extensions.traffic2d.md":{"title":" Extension","content":"# Extension\n\n----\n\n msi.gaml.extensions.traffic2d\n\n## Table of Contents\n### Operators\n\n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_msi.gaml.extensions.traffic2d.md"},"Extension_simtools.graphanalysis.fr.md":{"title":" Extension","content":"# Extension\n\n----\n\n simtools.graphanalysis.fr\n\n## Table of Contents\n### Operators\n\n\n### Statements\n[layout_forceatlas2](#layout_forceatlas2), [layout_yifanhu](#layout_yifanhu), \n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\n\n----\n\n[//]: # (keyword|statement_layout_forceatlas2)\n### layout_forceatlas2 \n#### Facets \n  \n  * **`graph`** (graph), (omissible) : the graph to apply the layout.\n  * `approximate_repulsion` (boolean): Barnes Hut optimization: n2 complexity to n.ln(n); allows larger graphs. default: false\n  * `approximation` (float): Theta of the Barnes Hut optimization. default: 1.2\n  * `bounded_point1` (point): The new nodes positions are bounded within the two bound points if both are not null. default: null\n  * `bounded_point2` (point): The new nodes positions are bounded within the two bound points if both are not null. default: null\n  * `dissuade_hubs` (boolean): Distributes attraction along outbound edges. Hubs attract less and thus are pushed to the borders (default: false).\n  * `edge_weight_influence` (float): How much influence you give to the edges wight. 0 is no influence, 1 is normal. default: 1.0\n  * `gravity` (float): Attracts nodes to the center. Prevents islands from drifting away. default: 1.0\n  * `linlog_mode` (boolean): Switch model from lin-lin to lin-log. Makes clusters more tight (default: false).\n  * `nb_steps` (int): The number of steps of the algorithm to perform (default 1).\n  * `prevent_overlap` (boolean): Should not be used with approximate_repulsion default: false\n  * `scaling` (float): How much repulsion you want. More makes a more sparse graph. default: 2.0\n  * `stronger_gravity` (boolean): A stronger gravity law default: false\n  * `thread_number` (int): More threads means more speed (default: 1).\n  * `tolerance` (float): How much swinging you allow. Above 1 discouraged. Lower gives less speed and more precision. default: 0.1\n\n#### Embedments\n* The `layout_forceatlas2` statement is of type: **Single statement**\n* The `layout_forceatlas2` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `layout_forceatlas2` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_layout_yifanhu)\n### layout_yifanhu \n#### Facets \n  \n  * **`graph`** (graph), (omissible) : the graph to apply the layout.\n  * `bounded_point1` (point): The new nodes positions are bounded within the two bound points if both are not null. default: null\n  * `bounded_point2` (point): The new nodes positions are bounded within the two bound points if both are not null. default: null\n  * `nb_steps` (int): The number of steps of the algorithm to perform (default 1).\n  * `optimal_distance` (float): the natural length of the springs. Bigger values mean nodes will be farther apart (default: 100).\n  * `quadtree_max_level` (int): The maximum level to be used in the quadtree representation. Greater values mean more accuracy (default: 10).\n  * `relative_strength` (float): The relative strength between electrical force (repulsion) and spring force (attriaction). default: 0.2\n  * `step_size` (float): The step size used in the algorithm. It has to be a meaningful size compared to the optimal distance (e.g. 10%). default: 10\n  * `theta` (float): The theta parameter for Barnes-Hut opening criteria. Smaller values mean more accuracy (default: 1.2).\n\n#### Embedments\n* The `layout_yifanhu` statement is of type: **Single statement**\n* The `layout_yifanhu` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `layout_yifanhu` statement embeds statements: \t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_simtools.graphanalysis.fr.md"},"Extension_ummisco.gama.communicator.md":{"title":" Extension","content":"# Extension\n\n----\n\n ummisco.gama.communicator\n\n## Table of Contents\n### Operators\n\n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_ummisco.gama.communicator.md"},"Extension_ummisco.gama.gpu.md":{"title":" Extension","content":"# Extension\n\n----\n\n ummisco.gama.gpu\n\n## Table of Contents\n### Operators\n[CPU_path_between](#cpu_path_between), [GPU_path_between](#gpu_path_between), \n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n    \t\n----\n\n\n[//]: # (keyword|operator_CPU_path_between)\n### `CPU_path_between`\n\n#### Possible use: \n  *  **`CPU_path_between`** (`graph`, `geometry`, `geometry`) --->  `path` \n\n#### Result: \nThe shortest path between a list of two objects in a graph computed with CPU\n\n#### Examples: \n```\npath var0 <- my_graph CPU_path_between (ag1:: ag2); \t// var0 equals A path between ag1 and ag2\n```\n  \n    \t\n----\n\n\n[//]: # (keyword|operator_GPU_path_between)\n### `GPU_path_between`\n\n#### Possible use: \n  *  **`GPU_path_between`** (`graph`, `geometry`, `geometry`) --->  `path` \n\n#### Result: \nThe shortest path between a list of two objects in a graph computed with GPU\n\n#### Examples: \n```\npath var0 <- my_graph GPU_path_between (ag1:: ag2); \t// var0 equals A path between ag1 and ag2\n```\n  \n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_ummisco.gama.gpu.md"},"Extension_ummisco.gaml.extensions.rjava.md":{"title":" Extension","content":"# Extension\n\n----\n\n ummisco.gaml.extensions.rjava\n\n## Table of Contents\n### Operators\n\n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_ummisco.gaml.extensions.rjava.md"},"Extension_ummisco.gaml.extensions.sound.md":{"title":" Extension","content":"# Extension\n\n----\n\n ummisco.gaml.extensions.sound\n\n## Table of Contents\n### Operators\n\n\n### Statements\n[pause_sound](#pause_sound), [resume_sound](#resume_sound), [start_sound](#start_sound), [stop_sound](#stop_sound), \n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\n\n----\n\n[//]: # (keyword|statement_pause_sound)\n### pause_sound \n#### Facets \n\n\n#### Embedments\n* The `pause_sound` statement is of type: **Sequence of statements or action**\n* The `pause_sound` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `pause_sound` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_resume_sound)\n### resume_sound \n#### Facets \n\n\n#### Embedments\n* The `resume_sound` statement is of type: **Sequence of statements or action**\n* The `resume_sound` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `resume_sound` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_start_sound)\n### start_sound \n#### Facets \n  \n  * **`source`** (string): The path to music file. This path is relative to the path of the model.\n  * `mode` (an identifier), takes values in: {overwrite, ignore}: Mode of \n  * `repeat` (boolean): \n\n#### Embedments\n* The `start_sound` statement is of type: **Sequence of statements or action**\n* The `start_sound` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `start_sound` statement embeds statements: \n\n----\n\n[//]: # (keyword|statement_stop_sound)\n### stop_sound \n#### Facets \n\n\n#### Embedments\n* The `stop_sound` statement is of type: **Sequence of statements or action**\n* The `stop_sound` statement can be embedded into: Behavior, Sequence of statements or action, \n* The `stop_sound` statement embeds statements: \t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_ummisco.gaml.extensions.sound.md"},"Extension_ummisco.gaml.extensions.stats.md":{"title":" Extension","content":"# Extension\n\n----\n\n ummisco.gaml.extensions.stats\n\n## Table of Contents\n### Operators\n[auto_correlation](#auto_correlation), [beta](#beta), [binomial_coeff](#binomial_coeff), [binomial_complemented](#binomial_complemented), [binomial_sum](#binomial_sum), [chi_square](#chi_square), [chi_square_complemented](#chi_square_complemented), [correlation](#correlation), [covariance](#covariance), [dnorm](#dnorm), [durbin_watson](#durbin_watson), [gamma](#gamma), [gamma_distribution](#gamma_distribution), [gamma_distribution_complemented](#gamma_distribution_complemented), [incomplete_beta](#incomplete_beta), [incomplete_gamma](#incomplete_gamma), [incomplete_gamma_complement](#incomplete_gamma_complement), [kurtosis](#kurtosis), [lgamma](#lgamma), [log_gamma](#log_gamma), [moment](#moment), [normal_area](#normal_area), [normal_density](#normal_density), [normal_inverse](#normal_inverse), [pbinom](#pbinom), [pchisq](#pchisq), [percentile](#percentile), [pgamma](#pgamma), [pnorm](#pnorm), [pValue_for_fStat](#pvalue_for_fstat), [pValue_for_tStat](#pvalue_for_tstat), [quantile](#quantile), [quantile_inverse](#quantile_inverse), [rank_interpolated](#rank_interpolated), [rms](#rms), [skew](#skew), [student_area](#student_area), [student_t_inverse](#student_t_inverse), [variance](#variance), \n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n    \t\n----\n\n\n[//]: # (keyword|operator_auto_correlation)\n### `auto_correlation`\n\n#### Possible use: \n  * `container` **`auto_correlation`** `int` --->  `float`\n  *  **`auto_correlation`** (`container` , `int`) --->  `float` \n\n#### Result: \nReturns the auto-correlation of a data sequence\n    \t\n----\n\n\n[//]: # (keyword|operator_beta)\n### `beta`\n\n#### Possible use: \n  * `float` **`beta`** `float` --->  `float`\n  *  **`beta`** (`float` , `float`) --->  `float` \n\n#### Result: \nReturns the beta function with arguments a, b.\n    \t\n----\n\n\n[//]: # (keyword|operator_binomial_coeff)\n### `binomial_coeff`\n\n#### Possible use: \n  * `int` **`binomial_coeff`** `int` --->  `float`\n  *  **`binomial_coeff`** (`int` , `int`) --->  `float` \n\n#### Result: \nReturns n choose k as a double. Note the integerization of the double return value.\n    \t\n----\n\n\n[//]: # (keyword|operator_binomial_complemented)\n### `binomial_complemented`\n\n#### Possible use: \n  *  **`binomial_complemented`** (`int`, `int`, `float`) --->  `float` \n\n#### Result: \nReturns the sum of the terms k+1 through n of the Binomial probability density, where n is the number of trials and P is the probability of success in the range 0 to 1.\n    \t\n----\n\n\n[//]: # (keyword|operator_binomial_sum)\n### `binomial_sum`\n\n#### Possible use: \n  *  **`binomial_sum`** (`int`, `int`, `float`) --->  `float` \n\n#### Result: \nReturns the sum of the terms 0 through k of the Binomial probability density, where n is the number of trials and p is the probability of success in the range 0 to 1.\n    \t\n----\n\n\n[//]: # (keyword|operator_chi_square)\n### `chi_square`\n\n#### Possible use: \n  * `float` **`chi_square`** `float` --->  `float`\n  *  **`chi_square`** (`float` , `float`) --->  `float` \n\n#### Result: \nReturns the area under the left hand tail (from 0 to x) of the Chi square probability density function with df degrees of freedom.\n    \t\n----\n\n\n[//]: # (keyword|operator_chi_square_complemented)\n### `chi_square_complemented`\n\n#### Possible use: \n  * `float` **`chi_square_complemented`** `float` --->  `float`\n  *  **`chi_square_complemented`** (`float` , `float`) --->  `float` \n\n#### Result: \nReturns the area under the right hand tail (from x to infinity) of the Chi square probability density function with df degrees of freedom.\n    \t\n----\n\n\n[//]: # (keyword|operator_correlation)\n### `correlation`\n\n#### Possible use: \n  * `container` **`correlation`** `container` --->  `float`\n  *  **`correlation`** (`container` , `container`) --->  `float` \n\n#### Result: \nReturns the correlation of two data sequences\n    \t\n----\n\n\n[//]: # (keyword|operator_covariance)\n### `covariance`\n\n#### Possible use: \n  * `container` **`covariance`** `container` --->  `float`\n  *  **`covariance`** (`container` , `container`) --->  `float` \n\n#### Result: \nReturns the covariance of two data sequences\n    \t\n----\n\n\n[//]: # (keyword|operator_dnorm)\n### `dnorm`\nSame signification as [normal_density](#normal_density)\n    \t\n----\n\n\n[//]: # (keyword|operator_durbin_watson)\n### `durbin_watson`\n\n#### Possible use: \n  *  **`durbin_watson`** (`container`) --->  `float` \n\n#### Result: \nDurbin-Watson computation\n    \t\n----\n\n\n[//]: # (keyword|operator_gamma)\n### `gamma`\n\n#### Possible use: \n  *  **`gamma`** (`float`) --->  `float` \n\n#### Result: \nReturns the value of the Gamma function at x.\n    \t\n----\n\n\n[//]: # (keyword|operator_gamma_distribution)\n### `gamma_distribution`\n\n#### Possible use: \n  *  **`gamma_distribution`** (`float`, `float`, `float`) --->  `float` \n\n#### Result: \nReturns the integral from zero to x of the gamma probability density function.  \n\n#### Comment: \nincomplete_gamma(a,x) is equal to pgamma(a,1,x).\n    \t\n----\n\n\n[//]: # (keyword|operator_gamma_distribution_complemented)\n### `gamma_distribution_complemented`\n\n#### Possible use: \n  *  **`gamma_distribution_complemented`** (`float`, `float`, `float`) --->  `float` \n\n#### Result: \nReturns the integral from x to infinity of the gamma probability density function.\n    \t\n----\n\n\n[//]: # (keyword|operator_incomplete_beta)\n### `incomplete_beta`\n\n#### Possible use: \n  *  **`incomplete_beta`** (`float`, `float`, `float`) --->  `float` \n\n#### Result: \nReturns the regularized integral of the beta function with arguments a and b, from zero to x.\n    \t\n----\n\n\n[//]: # (keyword|operator_incomplete_gamma)\n### `incomplete_gamma`\n\n#### Possible use: \n  * `float` **`incomplete_gamma`** `float` --->  `float`\n  *  **`incomplete_gamma`** (`float` , `float`) --->  `float` \n\n#### Result: \n Returns the regularized integral of the Gamma function with argument a to the integration end point x.\n    \t\n----\n\n\n[//]: # (keyword|operator_incomplete_gamma_complement)\n### `incomplete_gamma_complement`\n\n#### Possible use: \n  * `float` **`incomplete_gamma_complement`** `float` --->  `float`\n  *  **`incomplete_gamma_complement`** (`float` , `float`) --->  `float` \n\n#### Result: \nReturns the complemented regularized incomplete Gamma function of the argument a and integration start point x.\n    \t\n----\n\n\n[//]: # (keyword|operator_kurtosis)\n### `kurtosis`\n\n#### Possible use: \n  *  **`kurtosis`** (`container`) --->  `float`\n  * `float` **`kurtosis`** `float` --->  `float`\n  *  **`kurtosis`** (`float` , `float`) --->  `float` \n\n#### Result: \nReturns the kurtosis (aka excess) of a data sequence\nReturns the kurtosis (aka excess) of a data sequence\n    \t\n----\n\n\n[//]: # (keyword|operator_lgamma)\n### `lgamma`\nSame signification as [log_gamma](#log_gamma)\n    \t\n----\n\n\n[//]: # (keyword|operator_log_gamma)\n### `log_gamma`\n\n#### Possible use: \n  *  **`log_gamma`** (`float`) --->  `float` \n\n#### Result: \nReturns the log of the value of the Gamma function at x.\n    \t\n----\n\n\n[//]: # (keyword|operator_moment)\n### `moment`\n\n#### Possible use: \n  *  **`moment`** (`container`, `int`, `float`) --->  `float` \n\n#### Result: \nReturns the moment of k-th order with constant c of a data sequence\n    \t\n----\n\n\n[//]: # (keyword|operator_normal_area)\n### `normal_area`\n\n#### Possible use: \n  *  **`normal_area`** (`float`, `float`, `float`) --->  `float` \n\n#### Result: \nReturns the area to the left of x in the normal distribution with the given mean and standard deviation.\n    \t\n----\n\n\n[//]: # (keyword|operator_normal_density)\n### `normal_density`\n\n#### Possible use: \n  *  **`normal_density`** (`float`, `float`, `float`) --->  `float` \n\n#### Result: \nReturns the probability of x in the normal distribution with the given mean and standard deviation.\n    \t\n----\n\n\n[//]: # (keyword|operator_normal_inverse)\n### `normal_inverse`\n\n#### Possible use: \n  *  **`normal_inverse`** (`float`, `float`, `float`) --->  `float` \n\n#### Result: \nReturns the x in the normal distribution with the given mean and standard deviation, to the left of which lies the given area. normal.Inverse returns the value in terms of standard deviations from the mean, so we need to adjust it for the given mean and standard deviation.\n    \t\n----\n\n\n[//]: # (keyword|operator_pbinom)\n### `pbinom`\nSame signification as [binomial_sum](#binomial_sum)\n    \t\n----\n\n\n[//]: # (keyword|operator_pchisq)\n### `pchisq`\nSame signification as [chi_square](#chi_square)\n    \t\n----\n\n\n[//]: # (keyword|operator_percentile)\n### `percentile`\nSame signification as [quantile_inverse](#quantile_inverse)\n    \t\n----\n\n\n[//]: # (keyword|operator_pgamma)\n### `pgamma`\nSame signification as [gamma_distribution](#gamma_distribution)\n    \t\n----\n\n\n[//]: # (keyword|operator_pnorm)\n### `pnorm`\nSame signification as [normal_area](#normal_area)\n    \t\n----\n\n\n[//]: # (keyword|operator_pValue_for_fStat)\n### `pValue_for_fStat`\n\n#### Possible use: \n  *  **`pValue_for_fStat`** (`float`, `int`, `int`) --->  `float` \n\n#### Result: \nReturns the P value of F statistic fstat with numerator degrees of freedom dfn and denominator degress of freedom dfd. Uses the incomplete Beta function.\n    \t\n----\n\n\n[//]: # (keyword|operator_pValue_for_tStat)\n### `pValue_for_tStat`\n\n#### Possible use: \n  * `float` **`pValue_for_tStat`** `int` --->  `float`\n  *  **`pValue_for_tStat`** (`float` , `int`) --->  `float` \n\n#### Result: \nReturns the P value of the T statistic tstat with df degrees of freedom. This is a two-tailed test so we just double the right tail which is given by studentT of -|tstat|.\n    \t\n----\n\n\n[//]: # (keyword|operator_quantile)\n### `quantile`\n\n#### Possible use: \n  * `container` **`quantile`** `float` --->  `float`\n  *  **`quantile`** (`container` , `float`) --->  `float` \n\n#### Result: \nReturns the phi-quantile; that is, an element elem for which holds that phi percent of data elements are less than elem. The quantile need not necessarily be contained in the data sequence, it can be a linear interpolation.\n    \t\n----\n\n\n[//]: # (keyword|operator_quantile_inverse)\n### `quantile_inverse`\n\n#### Possible use: \n  * `container` **`quantile_inverse`** `float` --->  `float`\n  *  **`quantile_inverse`** (`container` , `float`) --->  `float` \n\n#### Result: \nReturns how many percent of the elements contained in the receiver are <= element. Does linear interpolation if the element is not contained but lies in between two contained elements.\n    \t\n----\n\n\n[//]: # (keyword|operator_rank_interpolated)\n### `rank_interpolated`\n\n#### Possible use: \n  * `container` **`rank_interpolated`** `float` --->  `float`\n  *  **`rank_interpolated`** (`container` , `float`) --->  `float` \n\n#### Result: \nReturns the linearly interpolated number of elements in a list less or equal to a given element. The rank is the number of elements <= element. Ranks are of the form {0, 1, 2,..., sortedList.size()}. If no element is <= element, then the rank is zero. If the element lies in between two contained elements, then linear interpolation is used and a non integer value is returned.\n    \t\n----\n\n\n[//]: # (keyword|operator_rms)\n### `rms`\n\n#### Possible use: \n  * `int` **`rms`** `float` --->  `float`\n  *  **`rms`** (`int` , `float`) --->  `float` \n\n#### Result: \nReturns the RMS (Root-Mean-Square) of a data sequence. The RMS of data sequence is the square-root of the mean of the squares of the elements in the data sequence. It is a measure of the average size of the elements of a data sequence.\n    \t\n----\n\n\n[//]: # (keyword|operator_skew)\n### `skew`\n\n#### Possible use: \n  *  **`skew`** (`container`) --->  `float`\n  * `float` **`skew`** `float` --->  `float`\n  *  **`skew`** (`float` , `float`) --->  `float` \n\n#### Result: \nReturns the skew of a data sequence.\nReturns the skew of a data sequence, which is moment(data,3,mean) / standardDeviation3\n    \t\n----\n\n\n[//]: # (keyword|operator_student_area)\n### `student_area`\n\n#### Possible use: \n  * `float` **`student_area`** `int` --->  `float`\n  *  **`student_area`** (`float` , `int`) --->  `float` \n\n#### Result: \nReturns the area to the left of x in the Student T distribution with the given degrees of freedom.\n    \t\n----\n\n\n[//]: # (keyword|operator_student_t_inverse)\n### `student_t_inverse`\n\n#### Possible use: \n  * `float` **`student_t_inverse`** `int` --->  `float`\n  *  **`student_t_inverse`** (`float` , `int`) --->  `float` \n\n#### Result: \nReturns the value, t, for which the area under the Student-t probability density function (integrated from minus infinity to t) is equal to x.\n    \t\n----\n\n\n[//]: # (keyword|operator_variance)\n### `variance`\n\n#### Possible use: \n  *  **`variance`** (`float`) --->  `float`\n  *  **`variance`** (`int`, `float`, `float`) --->  `float` \n\n#### Result: \nReturns the variance from a standard deviation.\nReturns the variance of a data sequence. That is (sumOfSquares - mean*sum) / size with mean = sum/size.\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_ummisco.gaml.extensions.stats.md"},"Extension_ummisco.miro.extension.md":{"title":" Extension","content":"# Extension\n\n----\n\n ummisco.miro.extension\n\n## Table of Contents\n### Operators\n\n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_ummisco.miro.extension.md"},"Extension_ummisco.miro.extension.traffic.md":{"title":" Extension","content":"# Extension\n\n----\n\n ummisco.miro.extension.traffic\n\n## Table of Contents\n### Operators\n\n\n### Statements\n\n\n### Skills\n\n\n### Architectures\n\n\n\n### Species\n\n\n\n----\n\n## Operators\n\t\n\n----\n\n## Skills\n\t\n\n----\n\n## Statements\n\t\t\n\t\n----\n\n## Species\n\t\n\t\n----\n\n## Architectures \n\t","url":"wiki/Extension_ummisco.miro.extension.traffic.md"},"Extension.md":{"title":" Extensions","content":"# Extensions\n----\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Introduction\nThis page provides a link to each of the extension pages. Extensions are the additional GAMA plugins that exist in the GAMA GitHub repository but will not be packaged with the release. **These extensions are not maintained by GAMA core team but by their authors.**\n* [idees.gama.weka](PluginDocumentation/Extension_idees.gama.weka)\n* [ummisco.gaml.extensions.stats](PluginDocumentation/Extension_ummisco.gaml.extensions.stats)\n* [miat.gama.extension.ifcfile](PluginDocumentation/Extension_miat.gama.extension.ifcfile)\n* [ummisco.gaml.extensions.sound](PluginDocumentation/Extension_ummisco.gaml.extensions.sound)\n* [simtools.graphanalysis.fr](PluginDocumentation/Extension_simtools.graphanalysis.fr)\n* [ummisco.gaml.extensions.rjava](PluginDocumentation/Extension_ummisco.gaml.extensions.rjava)\n","url":"wiki/Extension.md"},"GamlReferences.md":{"title":" Gaml Reference","content":"# Gaml Reference\n\nThe following pages introduce the various constructs that are made available to the modelers in GAML. All these constructs are **built-in**, i.e. defined in Java, either in the core of GAMA or in its extensions. They include [species](BuiltInSpecies), [skills](BuiltInSkills), [control architectures](BuiltInArchitectures), [statements](Statements), [data types](DataTypes), and various types of [expressions](Expressions), including a long and quite exhaustive list of [operators](Operators).\n\nThis set of pages is to be used as a _reference_, which means its role is not to explain _how_ to properly use these constructs but to detail their structures and components.\n\nIf you are not familiar yet with GAML language, please read carefully the section [Learn GAML Step by Step](LearnGAMLStepByStep) before.","url":"wiki/GamlReferences.md"},"ModelLibrary.md":{"title":" Models Library","content":"# Models Library\n\nHere is the list of models accessible when you download GAMA. Do not hesitate to consult those models to have an idea of the possibilities of the platform.\n\nModels are divided within 5 categories :\n\n* [Features](references#Features) : very short models designed to present the differents features of the platform.\n* [Syntax](references#Syntax) : some gaml files in order to show you the syntax to use for basic things (casting, containers manipulation...).\n* [Toy Models](references#ToyModels) : some pre-made models designed to answer to concrete problematics.\n* [Tutorials](tutorials) : models build in the [tutorial section](tutorials#ThematicTutorials).\n* [Additionnal Plugins](references#AdditionnalPlugins) : models using particular additionnal plugins.","url":"wiki/ModelLibrary.md"},"PlatformDocumentation.md":{"title":" Platform","content":"# Platform\n\nGAMA consists of a single application that is based on the RCP architecture provided by [Eclipse](http://www.eclipse.org). Within this single application software, often referred to as a _**platform**_, users can undertake, without the need of additional third-parties softwares, most of the activities related to modeling and simulation, namely [editing models](EditingModels) and [simulating, visualizing and exploring them](RunningExperiments) using dedicated tools.\n\nFirst-time users may however be intimidated by the apparent complexity of the platform, so this part of the documentation has been designed to ease their first contact with it, by clearly identifying tasks of interest to modelers and how they can be accomplished within GAMA.\n\nIt is accomplished by firstly providing some background about important notions found throughout the platform, especially those of [workspace and projects](WorkspaceProjectsAndModels) and explaining how to [organize and navigate through models](NavigatingWorkspace). Then we take a look at the [edition of models](EditingModels) and its various tools and components ([dedicated editors](GamlEditorGeneralities) and [related tools](GamlEditorToolbar), of course, but also [validators](ValidationOfModels)). Finally, we show how to [run experiments](RunningExperiments) on these models and what support the [user interface](ExperimentsUserInterface) can provide to users in this task.","url":"wiki/PlatformDocumentation.md"},"PluginDocumentation.md":{"title":" Extensions","content":"# Extensions\n\nIn this part, we will present you all the different plugins available for GAMA.\n\n## Introduction\nThis page provides a link to each of the extension pages. Extensions are the additional GAMA plugins that exist in the GAMA GitHub repository but will not be packaged with the release. **These extensions are not maintained by GAMA core team but by their authors.**\n* [msi.gaml.extensions.humanmoving](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_msi.gaml.extensions.humanmoving.md)\n* [ummisco.gaml.extensions.stats](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_ummisco.gaml.extensions.stats.md)\n* [ummisco.gama.gpu](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_ummisco.gama.gpu.md)\n* [ummisco.gama.communicator](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_ummisco.gama.communicator.md)\n* [ummisco.gaml.extensions.rjava](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_ummisco.gaml.extensions.rjava.md)\n* [ummisco.gaml.extensions.sound](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_ummisco.gaml.extensions.sound.md)\n* [ummisco.miro.extension.traffic](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_ummisco.miro.extension.traffic.md)\n* [cenres.gaml.extensions.hydro](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_cenres.gaml.extensions.hydro.md)\n* [irit.maelia.gaml.additions](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_irit.maelia.gaml.additions.md)\n* [ummisco.miro.extension](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_ummisco.miro.extension.md)\n* [dream.gama.opengis](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_dream.gama.opengis.md)\n* [msi.gaml.extensions.cplex](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_msi.gaml.extensions.cplex.md)\n* [idees.gama.weka](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_idees.gama.weka.md)\n* [msi.gaml.extensions.traffic2d](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_msi.gaml.extensions.traffic2d.md)\n* [simtools.graphanalysis.fr](https://github.com/gama-platform/gama/wiki/Content\\References\\PluginDocumentation\\Extension_simtools.graphanalysis.fr.md)","url":"wiki/PluginDocumentation.md"},"GraphSpecies.md":{"title":" Graph Species","content":"[//]: # (startConcept|graph)\n[//]: # (keyword|concept_graph)\n[//]: # (keyword|concept_node)\n[//]: # (keyword|concept_edge)\n# Graph Species\n[//]: # (keyword|type_graph)\n[//]: # (keyword|concept_topology)\n\nUsing a graph species enables to easily show interaction between agents of a same species. This kind of species is particularly useful when trying to show the interaction (especially the non-spatial one) that exist between agents.\n\n## Index\n\n* [Declaration](#declaration)\n  * [Declare a graph with handmade agents](#declare-a-graph-with-handmade-agents)\n  * [Declare a graph by using an geometry file](#declare-a-graph-by-using-an-geometry-file)\n  * [Declare a graph with nodes and edges](#declare-a-graph-with-nodes-and-edges)\n* [Useful operators with graph](#useful-operators-with-graph)\n  * [Knowing the degree of a node](#knowing-the-degree-of-a-node)\n  * [Get the neighbors of a node](#get-the-neighbors-of-a-node)\n  * [Compute the shortest path](#compute-the-shortest-path)\n  * [Control the weight in graph](#control-the-weight-in-graph)\n* [Example](#example)\n\n## Declaration\n\n### Declare a graph with handmade agents\n\nTo instantiate this `graph` species, several steps must be followed. First the graph species must inherit from the abstract species `graph_node`, then the method `related_to` must be redefined and finally an auxiliary species that inherits from `base_edge` used to represent the edges of the generated graph must be declared.\nA graph node is an abstract species that must redefine one method called `related_to`. \n\n```\nspecies graph_agent parent: graph_node edge_species: edge_agent{\n  bool related_to(graph_agent other){\n  \treturn true;\n  }\n}\n\nspecies edge_agent parent: base_edge {\n}\n```\n\nThe method `related_to` returns a boolean, and take the agents from the current species in argument. If the method returns true, the two agents (the current instance and the one as argument) will be linked.\n\n```\nglobal{\n\tint number_of_agents <- 5;\n\tinit {\n\t\tcreate graph_agent number:number_of_agents;\n\t}\n}\n\nspecies graph_agent parent: graph_node edge_species: edge_agent{\n  bool related_to(graph_agent other){\n  \treturn true;\n  }\n  aspect base {\n  \tdraw circle(1) color:#green;\n  }\n}\n\nspecies edge_agent parent: base_edge {\n\taspect base {\n  \tdraw shape color:#blue;\n  }\n}\n\nexperiment MyExperiment type: gui {\n    output {\n        display MyDisplay type: java2D {\n            species graph_agent aspect:base;\n            species edge_agent aspect:base;\n        }\n    }\n}\n``` \n\n![graph_related_to.png](resources/images/definingAdvancedSpecies/graph_related_to.png)\n\nYou can for example link 2 agents when they are closer than a certain distance.\nBeware: The topology used in graph species is the graph topology, and not the continuous topology. You can force the use of the continuous topology with the action `using` as follow:\n\n```\nbool related_to(graph_agent other){\n  \tusing topology:topology(world) {\n  \t\treturn (self.location distance_to other.location < 20);\n  \t}\n}\n``` \n\n![graph_related_to2.png](resources/images/definingAdvancedSpecies/graph_related_to2.png)\n\nThe abstract mother species \"graph_node\" has an attribute \"my_graph\", with the type \"graph\". The graph type represent a graph composed of vertices linked with edges. This type has built-in attributes such as `edges` (the list of all the edges agents), or `vertices` (the list of all the vertices agents).\n\n### Declare a graph by using an geometry file\n\n[//]: # (keyword|concept_load_file)\n[//]: # (keyword|operator_as_edge_graph)\nIn most cases, you will have to construct a graph from an existing file (example: a \"shp\" file). In that case, you will have to first instantiate a species from the shape file (with the `create` statement, using the facet `from`). When, you will have to extract a graph from the agent, using the operator `as_edge_graph`.\n\n```\nmodel load_shape_file \n \nglobal {\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies road aspect:geom;\t\t\n\t\t}\n\t}\n}\n```\n\n### Declare a graph with nodes and edges\n\n[//]: # (keyword|operator_add_node)\n[//]: # (keyword|operator_add_edge)\nAnother way to create a graph is building it manually nodes by nodes, and then edges by edges, without using agent structures. Use the `add_node` operator and the `add_edge` operator to do so. Here is an example of how to do:\n\n```\nadd point(0.0,0.0) to:nodes;\nadd point(90.0,90.0) to:nodes;\nadd point(20.0,20.0) to:nodes;\nadd point(40.0,50.0) to:nodes;\nadd point(100.0,0.0) to:nodes;\n\nloop nod over:nodes {\n\tmy_graph <- my_graph add_node(nod);\n}\n\t\t\nmy_graph <- my_graph add_edge (nodes at 0::nodes at 2);\nmy_graph <- my_graph add_edge (nodes at 2::nodes at 3);\nmy_graph <- my_graph add_edge (nodes at 3::nodes at 1);\nmy_graph <- my_graph add_edge (nodes at 0::nodes at 4);\nmy_graph <- my_graph add_edge (nodes at 4::nodes at 1);\n```\n\nUsing this solution, my_graph can have two types: it can be an a-spatial graph, or a spatial graph. The spatial graph will have a proper geometry, with segments that follow the position of your graph (you can access to the segments by using the built-in \"segments\"). The a-spatial graph will not have any shape.\n\n```\nglobal\n{\n\tgraph my_spatial_graph<-spatial_graph([]);\n\tgraph my_aspatial_graph<-graph([]);\n\t\n\tinit {\n\t\tpoint node1 <- {0.0,0.0};\n\t\tpoint node2 <- {10.0,10.0};\n\t\tmy_spatial_graph <- my_spatial_graph add_node(node1);\n\t\tmy_spatial_graph <- my_spatial_graph add_node(node2);\n\t\tmy_spatial_graph <- my_spatial_graph add_edge(node1::node2);\n\t\twrite my_spatial_graph.edges;\n\t\t// the output is [polyline ([{0.0,0.0,0.0},{10.0,10.0,0.0}])]\n\t\tmy_aspatial_graph <- my_aspatial_graph add_node(node1);\n\t\tmy_aspatial_graph <- my_aspatial_graph add_node(node2);\n\t\tmy_aspatial_graph <- my_aspatial_graph add_edge(node1::node2);\n\t\twrite my_aspatial_graph.edges;\n\t\t// the output is [{0.0,0.0,0.0}::{10.0,10.0,0.0}]\n\t}\n}\n```\n\n## Useful operators with graph\n\n### Knowing the degree of a node\n\n[//]: # (keyword|operator_degree_of)\nThe operator `degree_of` returns the number of edge attached to a node. To use it, you have to specify a graph (on the left side of the operator), and a node (on the right side of the operator).\n\nThe following code (to put inside the node species) displays the number of edges attached to each node:\n\n```\naspect base\n{\n\tdraw text:string(my_graph degree_of node(5)) color:# black;\n\tstatus <- 0;\n}\n```\n\n### Get the neighbors of a node\n\n[//]: # (keyword|operator_neighbors_of)\nTo get the list of neighbors of a node, you should use the neighbors_of operator. On the left side of the operator, specify the graph you are using, and on the right side, specify the node. The operator returns the list of nodes located at a distance inferior or equal to 1, considering the graph topology.\n\n```\nspecies graph_agent parent: graph_node edge_species: edge_agent\n{\n  list<graph_agent> list_neighbors <- list<graph_agent>(my_graph neighbors_of (self));\n}\n```\n\nHere is an example of model using those two previous concepts (a random node is chosen each step, displayed in red, and his neighbors are displayed in yellow):\n\n![graph_model.png](resources/images/definingAdvancedSpecies/graph_model.png)\n\n```\nmodel graph_model\n\nglobal\n{\n\tint number_of_agents <- 50;\n\tinit\n\t{\n\t\tcreate graph_agent number: number_of_agents;\n\t}\n\t\n\treflex update {\n\t\task graph_agent(one_of(graph_agent)) {\n\t\t\tstatus <- 2;\n\t\t\tdo update_neighbors;\n\t\t}\n\t}\n}\n\nspecies graph_agent parent: graph_node edge_species: edge_agent\n{\n\tint status <- 0;\n\tlist<int> list_connected_index;\n\t\n\tinit {\n\t\tint i<-0;\n\t\tloop over:graph_agent {\n\t\t\tif (flip(0.1)) {\n\t\t\t\tadd i to:list_connected_index;\n\t\t\t}\n\t\t\ti <- i+1;\n\t\t}\n\t}\n\t\n\tbool related_to(graph_agent other){\n\t  \tif (list_connected_index contains (graph_agent index_of other)) {\n\t  \t\treturn true;\n\t  \t}\n\t  \treturn false;\n\t}\n\t\n\taction update_neighbors {\n\n\t\tlist<graph_agent> list_neighbors <- list<graph_agent>(my_graph neighbors_of (self));\n\n\t\tloop neighb over:list_neighbors {\n\t\t\tneighb.status <- 1;\n\t\t}\n\t}\n\n\taspect base\n\t{\n\t\tif (status = 0) {\n\t\t\tdraw circle(2) color: # green;\n\t\t}\n\t\telse if (status = 1) {\n\t\t\tdraw circle(2) color: # yellow;\n\t\t}\n\t\telse if (status = 2) {\n\t\t\tdraw circle(2) color: # red;\n\t\t}\n\t\tdraw text:string(my_graph degree_of self) color:# black size:4 at:point(self.location.x-1,self.location.y-2);\n\t\tstatus <- 0;\n\t}\n}\n\nspecies edge_agent parent: base_edge\n{\n\taspect base\n\t{\n\t\tdraw shape color: # blue;\n\t}\n}\n\nexperiment MyExperiment type: gui\n{\n\toutput\n\t{\n\t\tdisplay MyDisplay type: java2D\n\t\t{\n\t\t\tspecies graph_agent aspect: base;\n\t\t\tspecies edge_agent aspect: base;\n\t\t}\n\t}\n}\n```\n\n### Compute the shortest path\n\n[//]: # (keyword|concept_shortest_path)\nTo compute the shortest path to go from a point to another, pick a source and a destination among the vertices you have for your graph. Store those values as point type.\n\n```\npoint source;\npoint destination;\nsource <- point(one_of(my_graph.vertices));\ndestination <- point(one_of(my_graph.vertices));\n```\n\n[//]: # (keyword|operator_path_between)\nThen, you can use the operator `path_between` to return the shortest path. To use this action, you have to give the graph, then the source point, and the destination point. This action returns a path type.\n\n```\npath shortest_path;\nshortest_path <- path_between (my_graph, source,destination);\n```\n\n[//]: # (keyword|operator_paths_between)\nAnother operator exists, `paths_between`, that returns a list of shortest paths between two points. Please read the documentation to learn more about this operator.\n\nHere is an example of code that show the shortest path between two points of a graph:\n\n![shortest_path.png](resources/images/definingAdvancedSpecies/shortest_path.png)\n\n```\nmodel graph_model\n\nglobal\n{\n\tint number_of_agents <- 50;\n\tpoint source;\n\tpoint target;\n\tgraph my_graph;\n\tpath shortest_path;\n\t\t\n\tinit\n\t{\n\t\tcreate graph_agent number: number_of_agents;\n\t}\n\t\n\treflex pick_two_points {\n\t\tif (my_graph=nil) {\n\t\t\task graph_agent {\n\t\t\t\tmyself.my_graph <- self.my_graph;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tshortest_path <- nil;\n\t\tloop while:shortest_path=nil {\n\t\t\tsource <- point(one_of(my_graph.vertices));\n\t\t\ttarget <- point(one_of(my_graph.vertices));\n\t\t\tif (source != target) {\n\t\t\t\tshortest_path <- path_between (my_graph, source,target);\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies graph_agent parent: graph_node edge_species: edge_agent\n{\n\tlist<int> list_connected_index;\n\t\n\tinit {\n\t\tint i<-0;\n\t\tloop over:graph_agent {\n\t\t\tif (flip(0.1)) {\n\t\t\t\tadd i to:list_connected_index;\n\t\t\t}\n\t\t\ti <- i+1;\n\t\t}\n\t}\n\t\n\tbool related_to(graph_agent other) {\n\t  \tusing topology:topology(world) {\n  \t\t\treturn (self.location distance_to other.location < 20);\n  \t\t}\n\t}\n\n\taspect base\t{\n\t\tdraw circle(2) color: # green;\n\t}\n}\n\nspecies edge_agent parent: base_edge\n{\n\taspect base\t{\n\t\tdraw shape color: # blue;\n\t}\n}\n\nexperiment MyExperiment type: gui {\n\toutput {\n\t\tdisplay MyDisplay type: java2D {\n\t\t\tspecies graph_agent aspect: base;\n\t\t\tspecies edge_agent aspect: base;\n\t\t\tgraphics \"shortest path\" {\n\t\t\t\tif (shortest_path != nil) {\n\t\t\t\t\tdraw circle(3) at: source color: #yellow;\n\t\t\t\t\tdraw circle(3) at: target color: #cyan;\n\t\t\t\t\tdraw (shortest_path.shape+1) color: #magenta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### Control the weight in graph\n\n[//]: # (keyword|concept_graph_weight)\n[//]: # (keyword|operator_with_weights)\nYou can add a map of weight for the edges that compose the graph. Use the operator `with_weights` to put weights in your graph. The graph has to be on the left side of the operator, and the map has to be on the right side. In the map, you have to put edges as key, and the weight for that edge as value. One common use is to put the distance as weight:\n\n```\nmy_graph <- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));\n```\n\nThe calculation of shortest path can change according to the weight you choose for your edges. For example, here is the result of the calculation of the shortest path when all the edges have 1 as weight value (it is the default graph topology), and when the edges have their length as weight.\n\n![path_weight.png](resources/images/definingAdvancedSpecies/path_weight.png)\n\nHere is an example of implementation:\n\n```\nmodel shortest_path_with_weight\n\nglobal\n{\n\tgraph my_graph<-spatial_graph([]);\n\tpath shortest_path;\n\tlist<point> nodes;\n\t\t\n\tinit\n\t{\n\t\tadd point(10.0,10.0) to:nodes;\n\t\tadd point(90.0,90.0) to:nodes;\n\t\tadd point(40.0,20.0) to:nodes;\n\t\tadd point(80.0,50.0) to:nodes;\n\t\tadd point(90.0,20.0) to:nodes;\n\n\t\tloop nod over:nodes {\n\t\t\tmy_graph <- my_graph add_node(nod);\n\t\t}\n\t\t\n\t\tmy_graph <- my_graph add_edge (nodes at 0::nodes at 2);\n\t\tmy_graph <- my_graph add_edge (nodes at 2::nodes at 3);\n\t\tmy_graph <- my_graph add_edge (nodes at 3::nodes at 1);\n\t\tmy_graph <- my_graph add_edge (nodes at 0::nodes at 4);\n\t\tmy_graph <- my_graph add_edge (nodes at 4::nodes at 1);\n\t\t\n\t\t// comment/decomment the following line to see the difference.\n\t\tmy_graph <- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));\n\t\t\n\t\tshortest_path <- path_between(my_graph,nodes at 0, nodes at 1);\n\t}\n}\n\nexperiment MyExperiment type: gui {\n\toutput {\n\t\tdisplay MyDisplay type: java2D {\n\t\t\tgraphics \"shortest path\" {\n\t\t\t\tif (shortest_path != nil) {\n\t\t\t\t\tdraw circle(3) at: point(shortest_path.source) color: #yellow;\n\t\t\t\t\tdraw circle(3) at: point(shortest_path.target) color: #cyan;\n\t\t\t\t\tdraw (shortest_path.shape+1) color: #magenta;\n\t\t\t\t}\n\t\t\t\tloop edges over: my_graph.edges {\n\t\t\t\t\tdraw edges color: #black;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n[//]: # (endConcept|graph)","url":"wiki/GraphSpecies.md"},"GridSpecies.md":{"title":" Grid Species","content":"[//]: # (startConcept|grid)\n[//]: # (keyword|concept_grid)\n# Grid Species\n[//]: # (keyword|concept_topology)\n\nA grid is a particular species of agents. Indeed, a grid is a set of agents that share a grid topology (until now, we only saw species with continuous topology). As other agents, a grid species can have attributes, attributes, behaviors, aspects\nHowever, contrary to regular species, grid agents are created automatically at the beginning of the simulation. It is thus not necessary to use the create statement to create them.\nMoreover, in addition to classic built-in variables, grid a provided with a set of additional built-in variables.\n\n## Index\n\n* [Declaration](#declaration)\n* [Built-in attributes](#built-in-attributes)\n* [Access to cells](#access-to-cells)\n* [Display grid](#display-grid)\n* [Grid with matrix](#grid-with-matrix)\n* [Example](#example)\n\n## Declaration\n\nInstead of using the `species` keyword, use the keyword `grid` to declare a grid species. The grid species has exactly the same facets of the regular species, plus some others.\nTo declare a grid, you have to specify the number of columns and rows first. You can do it two different ways:\n\nUsing the two facets `width:` and `height:` to fix the number of cells (the size of each cells will be determined thanks to the environment dimension).\n\n```\ngrid my_grid width:8 height:10 {\n// my_grid has 8 columns and 10 rows\n}\n```\n\nUsing the two facets `cell_width:` and `cell_height:` to fix the size of each cells (the number cells will be determined thanks to the environment dimension).\n\n```\ngrid my_grid cell_width:3 cell_height:2 {\n// my_grid has cells with dimension 3m width by 2m height\n}\n```\n\nBy default, a grid is composed by 100 rows and 100 columns.\n\nAnother facet exists for grid only, very useful. It is the `neighbors` facet, used to determine how many neighbors has each cell. You can choose among 3 values: 4 (Von Neumann), 6 (hexagon) or 8 (Moore).\n\n![images/grid_neighbors.png](resources/images/definingAdvancedSpecies/grid_neighbors.png)\n\nA grid can also be provided with specific facets that allows to optimize the computation time and the memory space, such as `use_regular_agents`, `use_indivitual_shapes` and `use_neighbours_cache`. Please refer to the GAML Reference for more explanation about those particular facets.\n\n## Built-in attributes\n\n### grid\\_x\nThis variable stores the column index of a cell.\n```\n   grid cell width: 10 height: 10 neighbors: 4 {\n        init {\n             write \"my column index is:\" + grid_x;\n        }\n   }\n```\n\n### grid\\_y\nThis variable stores the row index of a cell.\n```\n   grid cell width: 10 height: 10 neighbors: 4 {\n        init {\n             write \"my row index is:\" + grid_y;\n        }\n   }\n```\n### agents\n\nreturn the set of agents located inside the cell. Note the use of this variable is deprecated.\nIt is preferable to use the `inside` operator:\n[//]: # (keyword|operator_inside)\n\n```\n grid cell width: 10 height: 10 neighbors: 4 { \n        list<bug> bugs_inside -> {bug inside self};\n   }\n```\n\n[//]: # (keyword|concept_color)\n### color\nThe **color** built-in variable is used by the optimized grid display. Indeed, it is possible to use for grid agents an optimized aspect by using in a display the **grid** keyword. In this case, the grid will be displayed using the color defined by the **color** variable. The border of the cells can be displayed with a specific color by using the **lines** facet.\n\nHere an example of the display of a grid species named **cell** with black border.\n\n```\nexperiment main_xp type: gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tgrid cell lines: rgb(\"black\") ;\n\t\t}\n\t}\n}\n```\n\n[//]: # (keyword|concept_neighbors)\n### neighbors\nThe **neighbors** built-in variable returns the list of cells at a distance of 1.\n\n```\ngrid my_grid {\n  reflex writeNeighbors {\n    write neighbors;\n  }\n}\n```\n\n### grid\\_value\nThe **grid\\_value** built-in variable is used when initializing a grid from grid file (see later). It is also used for the 3D representation of DEM.\n\n## Access to a cell\n\nthere are several ways to access to a specific cell:\n\n  * by a location: by casting a location to a cell (the unity (`#m`, `#cm`, etc...) is defined when you choose your environment size, in the [global species](GlobalSpecies).\n\n```\n   global {\n         init {\n             write \"cell at {57.5, 45} :\" + cell({57.5, 45});\n         }\n   }\n\n   grid cell width: 10 height: 10 neighbors: 4 {\n   }\n```\n\n  * by the row and column indexes: like matrix, it is possible to directly access to a cell from its indexes\n\n```\n   global {\n         init {\n             write \"cell [5,8] :\" + cell[5,8];\n         }\n   }\n   grid cell width: 10 height: 10 neighbors: 4 {\n   }\n```\n\n[//]: # (keyword|operator_grid_at)\nThe operator `grid_at` also exists to get a particular cell. You just have to specify the index of the cell you want (in x and y):\n\n```\n   global {\n         init {\n             agent cellAgent <- cell grid_at {5,8};\n             write \"cell [5,8] :\" + cellAgent;\n         }\n   }\n   grid cell width: 10 height: 10 neighbors: 4 {\n   }\n```\n\n## Display Grid\n\nYou can easily display your grid in your experiment as followed :\n\n```\nexperiment MyExperiment type: gui {\n    output {\n        display MyDisplay type: opengl {\n            grid MyGrid;\n        }\n    }\n}\n```\n\nThe grid will be displayed, using the color you defined for each cell (with the \"color\" built-in attribute). You can also show border of each cell by using the facet \"line:\" and choosing a rgb color:\n\n```\ngrid MyGrid line:#black;\n```\n\nAn other way to display a grid will be to define an aspect in your grid agent (the same way as for a [regular species](RegularSpecies)), and define your grid as a regular species then in your experiment, choosing your aspect : \n\n```\ngrid MyGrid {\n    aspect firstAspect {\n        draw square(1);\n    }\n    aspect secondAspect {\n        draw circle(1);\n    }\n}\n\nexperiment MyExperiment type: gui {\n    output {\n        display MyDisplay type: opengl {\n            species MyGrid aspect:firstAspect;\n        }\n    }\n}\n```\n\nBeware : don't use this second display when you have large grids : it's much slower.\n\n[//]: # (keyword|type_matrix)\n[//]: # (keyword|concept_matrix)\n## Grid from a matrix\n\nAn easy way to load some values in a grid is to use matrix data. A `matrix` is a type of container (we invite you to learn some more about this useful type [here](DataTypes#matrix)). Once you have declared your matrix, you can set the values of your cells using the `ask` statement :\n\n```\nglobal {\n  init {\n    matrix data <- matrix([[0,1,1],[1,2,0]]);\n    ask cell {\n      grid_value <- float(data[grid_x, grid_y]);\n    } \n  }\n}\n```\n\n[//]: # (keyword|operator_matrix)\n[//]: # (keyword|concept_csv)\n[//]: # (keyword|concept_load_file)\nDeclaring larger matrix in GAML can be boring as you can imagine. You can load your matrix directly from a csv file with the operator `matrix` (used for the contruction of the matrix).\n\n```\nfile my_file <- csv_file(\"path/file.csv\",\"separator\");\nmatrix my_matrix <- matrix(my_file);\n```\n\nYou can try to read the following csv :\n```\n0,0,0,0,0,0,0,0,0,0,0\n0,0,0,1,1,1,1,1,0,0,0\n0,0,1,1,0,0,0,1,1,0,0\n0,1,1,0,0,0,0,0,0,0,0\n0,1,1,0,0,1,1,1,1,0,0\n0,0,1,1,0,0,1,1,1,0,0\n0,0,0,1,1,1,1,0,1,0,0\n0,0,0,0,0,0,0,0,0,0,0\n```\n\nWith the following model :\n\n```\nmodel import_csv\n\nglobal {\n  file my_csv_file <- csv_file(\"../includes/test.csv\",\",\");\n  init {\n    matrix data <- matrix(my_csv_file);\n    ask my_gama_grid {\n      grid_value <- float(data[grid_x,grid_y]);\n      write data[grid_x,grid_y];\n    }\n  }\n}\n\ngrid my_gama_grid width: 11 height: 8 {\n  reflex update_color {\n    write grid_value;\n    color <- (grid_value = 1) ? #blue : #white;\n  }\n}\n\nexperiment main type: gui{\n  output {\n    display display_grid {\n      grid my_gama_grid;\n    }\n  }\n}\n```\n\nFor more complicated models, you can read some other files, such as ASCII files (asc), DEM files...\n\n[//]: # (endConcept|grid)\n\n## Example\n\nTo practice a bit those notions, we will build a quick model. A \"regular\" species will move randomly on the environment. A grid is displayed, and its cells becomes red when an instance of the regular species is waking inside this cell, and yellow when the regular agent is in the surrounding of this cell. If no regular agent is on the surrounding, the cell turns green.\n\n![images/my_grid_model.png](resources/images/definingAdvancedSpecies/my_grid_model.png)\n\nHere is an example of implementation:\n\n```\nmodel my_grid_model\n\nglobal{\n\tfloat max_range <- 5.0;\n\tint number_of_agents <- 5;\n\tinit {\n\t\tcreate my_species number:number_of_agents;\n\t}\n\treflex update {\n\t\task my_species {\n\t\t\tdo wander amplitude:180;\t\n\t\t\task my_grid at_distance(max_range)\n\t\t\t{\n\t\t\t\tif(self overlaps myself)\n\t\t\t\t{\n\t\t\t\t\tself.color_value <- 2;\n\t\t\t\t}\n\t\t\t\telse if (self.color_value != 2)\n\t\t\t\t{\n\t\t\t\t\tself.color_value <- 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\task my_grid {\n\t\t\tdo update_color;\n\t\t}\t\n\t}\n}\n\nspecies my_species skills:[moving] {\n\tfloat speed <- 2.0;\n\taspect default {\n\t\tdraw circle(1) color:#blue;\n\t}\n}\n\ngrid my_grid width:30 height:30 {\n\tint color_value <- 0;\n\taction update_color {\n\t\tif (color_value = 0) {\n\t\t\tcolor <- #green;\n\t\t}\n\t\telse if (color_value = 1) {\n\t\t\tcolor <- #yellow;\n\t\t}\n\t\telse if (color_value = 2) {\n\t\t\tcolor <- #red;\n\t\t}\n\t\tcolor_value <- 0;\n\t}\n}\n\nexperiment MyExperiment type: gui {\n    output {\n        display MyDisplay type: java2D {\n            grid my_grid lines:#black;\n            species my_species aspect:default; \n        }\n    }\n}\n```","url":"wiki/GridSpecies.md"},"MirrorSpecies.md":{"title":" Mirror species","content":"[//]: # (startConcept|mirror_species)\n[//]: # (keyword|concept_mirror)\n# Mirror species\n\nA mirror species is a species whose population is automatically managed with respect to another species. Whenever an agent is created or destroyed from the other species, an instance of the mirror species is created or destroyed. Each of these 'mirror agents' has access to its reference agent (called its target).\nMirror species can be used in different situations but the one we describe here is more oriented towards visualization purposes.\n\n## Index\n\n* [Declaration](#declaration)\n* [Example](#example)\n\n## Declaration\n\nA mirror species can be defined using the `mirrors` keyword as following:\n\n```\nspecies B mirrors: A{\n}\n```\n\nIn this case the species B mirrors the species A.\n\nBy default the location of the species B will be random but in many cases, once want to place the mirror agent at the same location of the reference species. This can be achieve by simply adding the following lines in the mirror species : \n\n```\nspecies B mirrors: A{\n    point location <- target.location update: target.location;\n}\n```\n\n**`target`** is a built-in attribute of a mirror species. It refers to the instance of the species tracked.\n\nIn the same spirit any attribute of a reference species can be reach using the same syntax. For instance if the species A has an attribute called `attribute1` of type `int` is is possible to get this attribute from the mirror species B using the following syntax: \n\n```\nint value <- target.attribute1;\n```\n[//]: # (endConcept|mirror_species)\n\n## Example\n\nTo practice a bit with the mirror notion, we will now build a simple model displaying a species A (aspect: white circle) moving randomly, and another species B (aspect: blue sphere) with the species A location on x and y, with an upper value for the z axis.\n\n![images/mirror_model.png](resources/images/definingAdvancedSpecies/mirror_model.png)\n\nHere is an example of implementation for this model:\n\n```\nmodel Mirror\n\nglobal {\n  init{\n    create A number:100;    \n  }\n}\n\nspecies A skills:[moving]{\n    reflex update{\n        do wander;\n    }\n    aspect base{\n        draw circle(1) color: #white;\n    }\n}\nspecies B mirrors: A{\n    point location <- target.location update: point(target.location.x,target.location.y,target.location.z+5);\n    aspect base {\n        draw sphere(2) color: #blue;\n    }\n}\n\nexperiment mirroExp type: gui {\n    output {\n        display superposedView type: opengl{ \n          species A aspect: base;\n          species B aspect: base transparency:0.5;\n        }\n    }\n}\n```","url":"wiki/MirrorSpecies.md"},"MultiLevelArchitecture.md":{"title":" Multi-level architecture","content":"[//]: # (startConcept|multi_level)\n[//]: # (keyword|concept_multi_level)\n# Multi-level architecture\n\nThe multi-level architecture offers the modeler the following possibilities: the declaration of a species as a micro-species of another species, the representation of an entity as different types of agent (i.e., GAML species), the dynamic migration of agents between populations.\n\n## Index\n\n* [Declaration of micro-species](#declaration-of-micro-species)\n* [Access to micro-agents / host agent](#access-to-micro-agents-host-agent)\n* [Representation of an entity as different types of agent](#representation-of-an-entity-as-different-types-of-agent)\n* [Dynamic migration of agents](#dynamic-migration-of-agents)\n* [Example](#example)\n\n## Declaration of micro-species\n\nA species can have other species as micro-species. The micro-species of a species is declared inside the species' declaration.\n\n```\nspecies macro_species {\n      species micro_species_in_group {\n      }\n}\n```\n\nIn the above example, \"micro_species_in_group\" is a micro-species of \"macro_species\". An agent of \"macro_species\" can have agents \"micro_species_in_group\" as micro-agents. Agents of \"micro_species_in_group\" have an agent of \"macro_species\" as \"host\" agent.\n\nAs the species \"micro_species_in_group\" is declared inside the species \"macro_species\", \"micro_species_in_group\" will return a list of \"micro_species_in_group\" agent inside the given \"macro_species\" agent.\n\n```\nglobal\n{\n\tinit {\n\t\tcreate macro_species number:5;\n\t}\n}\n\nspecies macro_species \n{\t\n\tinit {\n\t\tcreate micro_species_in_group number:rnd(10);\n\t\twrite \"the macro species named \"+name+\" contains \"+length(micro_species_in_group)+\" micro-species.\";\n\t}\n\t\n    species micro_species_in_group {\n    }\n}\n\nexperiment my_experiment type: gui {\n}\n```\n\nIn this above example, we create 5 macro-species, and each one of these macro-species create a random number of inner micro-species. We can see that \"micro_species_in_group\" refers to the list of micro-species inside the given macro-species.\n\n## Access to micro-agents, host agent\n\nTo access to micro-agents (from a macro-agent), and to host agent (from a micro-agents), you have to use two built-in attributes.\n\nThe `members` built-in attribute is used inside the macro-agent, to get the list of all its micro-agents.\n\n```\nspecies macro_species \n{\n\tinit {\n\t\tcreate first_micro_species number:3;\n\t\tcreate second_micro_species number:6;\n\t\twrite \"the macro species named \"+name+\" contains \"+length(members)+\" micro-species.\";\n\t}\n\t\n    species first_micro_species {\n    }\n    \n    species second_micro_species {\n    }\n}\n```\n\nThe `host` built-in attribute is used inside the micro-agent to get the host macro-agent.\n\n```\nspecies macro_species {\n\t\n\tmicro_species_in_group micro_agent;\n\t\n\tinit {\n\t\tcreate micro_species_in_group number:rnd(10);\n\t\twrite \"the macro species named \"+name+\" contains \"+length(members)+\" micro-species.\";\n\t}\n\t\n    species micro_species_in_group {\n    \tinit {\n    \t\twrite \"the micro species named \"+name+\" is hosted by \"+host;\n    \t}\n    }\n}\n```\n\nNB: We already said that the world agent is a particular agent, instantiated just once. In fact, the world agent is the host of all the agents. You can try to get the host for a regular species, you will get the world agent itself (named as you named your model). You can also try to get the members of your world (from the global scope for example), and you will get the list of the agents presents in the world.\n\n```\nglobal\n{\n\tinit {\n\t\tcreate macro_species number:5;\n\t\twrite \"the world has \"+length(members)+\" members.\";\n\t}\n}\n\nspecies macro_species \n{\t\n\tinit {\n\t\twrite \"the macro species named \"+name+\" is hosted by \"+host;\n\t}\n}\n```\n\n## Representation of an entity as different types of agent\n\nThe multi-level architecture is often used in order to represent an entity through different types of agent. For example, an agent \"bee\" can have a behavior when it is alone, but when the agent is near from a lot of agents, he can changes his type to \"bee_in_swarm\", defined as a micro-species of a macro-species \"swarm\". Other example: an agent \"pedestrian\" can have a certain behavior when walking on the street, and then change his type to \"pedestrian_in_building\" when he is in a macro-species \"building\".\nYou have then to distinguish two different species to define your micro-species:\n-\tThe first can be seen as a regular species (it is the \"bee\" or the \"pedestrian\" for instance). We will name this species as \"micro_species\".\n-\tThe second is the real micro-species, defined inside the macro-species (it is the \"bee_in_swarm\" or the \"pedestrian_in_building\" for instance). We will name this species as \"micro_species_in_group\". This species has to inherit from the \"micro_species\".\n\n```\nspecies micro_species {\n}\n\nspecies macro_species \n{\t\n\tspecies micro_species_in_group parent: micro_species {\n\t}\n}\n```\n\n## Dynamic migration of agents\n\nIn our example about bees, a \"swarm\" entity is composed of nearby flying \"bee\" entities. When a \"bee\" entity approaches a \"swarm\" entity, this \"bee\" entity will become a member of the group. To represent this, the modeler lets the \"bee\" agent change its species to \"bee_in_swarm\" species. The \"bee\" agent hence becomes a \"bee_in_swarm\" agent. To change species of agent, we can use one of the following statements: `capture`, `release`, `migrate`.\n\n[//]: # (keyword|statement_capture)\nThe statement `capture` is used by the \"macro_species\" to capture one (or several) \"micro_species\" agent(s), and turn it (them) to a \"micro_species_in_group\". You can specify which agent (or list of agents) you want to capture by using the facet `target`. The facet `as` is used to cast the agent from \"micro_species\" to \"micro_species_in_group\". You can use the facet `return` to get the newly captured agent(s).\n\n```\ncapture target:micro_species as:micro_species_in_group;\n```\n\n[//]: # (keyword|statement_release)\nThe statement `release` is used by the \"macro_species\" to release one (or several) \"micro_species_in_group\" agent(s), and turn it (them) to a \"micro_species\". You can specify which agent (or list of agents) you want to release by using the facet `target`. The facet `as` is used to cast the agent from \"micro_species_in_group\" to \"micro_species\". The facet `in` is used to specify the new host (by default, it is the host of the \"macro_species\"). You can use the facet `return` to get the newly released agent(s).\n\n```\nrelease target:list(micro_species_in_group) as:micro_species in:world;\n```\n\n[//]: # (keyword|statement_migrate)\nThe statement `migrate`, less used, permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Read the GAML Reference to learn more about this statement.\n[//]: # (endConcept|multi_level)\n\n## Example:\n\nHere is an example of micro_species that gather together in macro_species when they are close enough.\n\n![images/multilevel_model.png](resources/images/definingAdvancedSpecies/multilevel_model.png)\n\n```\nmodel multilevel\n\nglobal {\n\tint release_time <- 20;\n\tint capture_time <- 100;\n\tint remaining_release_time <- 0;\n\tint remaining_capture_time <- capture_time;\n\tinit {\n\t\tcreate micro_species number:200;\n\t}\n\treflex reflex_timer {\n\t\tif (remaining_release_time=1)\n\t\t{\n\t\t\tremaining_release_time <- 0;\n\t\t\tremaining_capture_time <- capture_time;\n\t\t}\n\t\telse if (remaining_capture_time=1)\n\t\t{\n\t\t\tremaining_capture_time <- 0;\n\t\t\tremaining_release_time <- release_time;\n\t\t}\n\t\tremaining_release_time <- remaining_release_time - 1;\n\t\tremaining_capture_time <- remaining_capture_time - 1;\n\t}\n\treflex capture_micro_species when:(remaining_capture_time>0 and flip(0.1)) {\n\t\task macro_species {\n\t\t\tlist<micro_species> micro_species_in_range <- micro_species at_distance 1;\n\t\t\tif (micro_species_in_range != []) {\n\t\t\t\tdo capture_micro_species(micro_species_in_range);\n\t\t\t}\n\t\t}\n\t\task micro_species {\n\t\t\tlist<micro_species> micro_species_list_to_be_captured <- micro_species at_distance 1;\n\t\t\tif(micro_species_list_to_be_captured != []) {\n\t\t\t\tcreate macro_species {\n\t\t\t\t\tlocation <- myself.location;\n\t\t\t\t\tadd item:myself to:micro_species_list_to_be_captured;\n\t\t\t\t\tdo capture_micro_species(micro_species_list_to_be_captured);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies micro_species skills:[moving] {\n\tgeometry shape <- circle(1);\n\taspect base {\n\t\tdraw shape;\n\t}\n\treflex move{\n\t\tdo wander;\n\t}\n}\n\nspecies macro_species {\n\tgeometry shape <- circle(1) update:circle(length(members));\n\t\n\tspecies micro_species_in_group parent:micro_species {\n\t}\n\t\n\taction capture_micro_species(list<micro_species> micro_list) {\n\t\tloop mic_sp over:micro_list {\n\t\t\tcapture mic_sp as:micro_species_in_group;\n\t\t}\n\t}\n\t\n\treflex release_reflex when:(remaining_release_time>0 and flip(0.1)) {\n\t\trelease members as:micro_species /*in:world*/;\n\t\tdo die;\n\t}\n\t\n\taspect base {\n\t\tdraw shape;\n\t\tdraw text:string(length(members)) color:#black size:4;\n\t}\n}\n\nexperiment MyExperiment type: gui {\n\toutput {\n\t\tdisplay MyDisplay type: java2D {\n\t\t\tspecies macro_species aspect: base;\n\t\t\tspecies micro_species aspect: base;\n\t\t}\n\t}\n}\n```","url":"wiki/MultiLevelArchitecture.md"},"Defining3DDisplays.md":{"title":" Defining 3D Displays","content":"[//]: # (startConcept|3d_displays)\n[//]: # (keyword|concept_3d)\n# Defining 3D Displays\n\n## Table of contents \n\n* [OpenGL display](#opengl-display)\n\t* [Position](#position)\n\t* [Size](#size)\n* [Camera](#camera)\n* [Dynamic camera](#dynamic-camera)\n\t* [Camera position](#camera-position)\n\t* [Camera direction (Look Position)](#camera-direction-look-position)\n\t* [Camera orientation (Up Vector)](#camera-orientation-up-vector)\n\t\t* [Default view](#default-view)\n\t\t* [First person view](#first-person-view)\n\t\t* [Third Person view](#third-person-view)\n* [Lighting](#lighting)\n\n[//]: # (keyword|concept_opengl)\n## OpenGL display\n\n* Define the attribute type of the display with `type:opengl` in the output of your model (or use the preferences->display windows to use it by default):\n```\noutput {\n  display DisplayName type:opengl {\n    species mySpecies;\n  }\n```\n\nThe opengl display share most of the feature that the java2D offers and that are described [here](DefiningDisplaysGeneralities).\n\nUsing 3D display offers many way to represent a simulation. A layer can be positioned and scaled in a 3D world. It is possible to superpose layer on different z value and display different information on the model at different position on the screen.\n\n### Position\nLayer can be drawn on different position (x,y and z)  value using the _position_ facet\n\n### Size\nLayer can be drawn with different size (x,y and z) using the _size_ facet\n\nHere is an example of display using all the previous facet (experiment factice to add to the model _Incremental Model 5_). You can also dynamically change those value by showing the side bar in the display.\n\n```\nexperiment expe_test type:gui {\n\toutput {\n\t\tdisplay city_display type: opengl{\n\t\t\tspecies road aspect: geom refresh:false;\n\t\t\tspecies building aspect: geom transparency:0.5 ;\n\t\t\tspecies people aspect: sphere3D position:{0,0,0.1};\n\t\t\tspecies road aspect: geom size:{0.3,0.3,0.3};\n\t\t}\n\t}\n}\n```\n\n![images/species_layer.png](resources/images/definingGUIExperiment/species_layer.png)\n\n\n[//]: # (keyword|concept_camera)\n## Camera\n\n<a href='http://www.youtube.com/watch?feature=player_embedded&v=rMIVQlul1Ag' target='_blank'><img src='http://img.youtube.com/vi/rMIVQlul1Ag/0.jpg' width='425' height=344 /></a>\n\n[Arcball Camera](Displays#arcball-camera-commands)\n\n[FreeFly Camera](Displays#freefly-camera-commands)\n\n\n## Dynamic camera\n\nUser have the possibility to set dynamically the parameter of the camera (observer). The basic camera properties are its **position**, the **direction** in which is pointing, and its **orientation**. Those 3 parameters can be set dynamically at each iteration of the simulation.\n\n### Camera position\nThe facet `camera_pos(x,y,z)` places the camera at the given position.\nThe default camera positon is _(world.width/2,world/height/2,world.maxDim`*`1.5)_ to place the camera at the middle of the environement at an altitude that enables to see the entire environment.\n\n### Camera direction (Look Position)\nThe facet `camera_look_pos(x,y,z)` points the camera toward the given position.  The default look position is _(world.width/2,world/height/2,0)_ to look at the center of the environment.\n\n### Camera orientation (Up Vector)\nThe camera `camera_up_vector(x,y,z)` sets the _up vector_ of the camera.\nThe _up vector_ direction in your scene is the _up_ direction on your display screen.\nThe default value is (0,1,0)\n\nHere are some examples that can be done using those 3 parameters. You can test it by running the following model:\n\n\n<a href='http://www.youtube.com/watch?feature=player_embedded&v=lQVGD8aDKZY' target='_blank'><img src='http://img.youtube.com/vi/lQVGD8aDKZY/0.jpg' width='425' height=344 /></a>\n\n[Boids 3D Camera movement](https://code.google.com/p/gama-platform/source/browse/branches/GAMA_CURRENT/msi.gama.models/models/Features/3D Visualization/Toy Models/Boids 3D Camera movement.gaml)\n\n#### Default view\n```\ndisplay RealBoids   type:opengl{\n...\t\t\n}\n```\n\n#### First person view\nYou can set the position as a first person shooter video game using:\n```\ndisplay FirstPerson  type:opengl \ncamera_pos:{boids(1).location.x,-boids(1).location.y,10} \ncamera_look_pos:{cos(boids(1).heading)*world.shape.width,-sin(boids(1).heading)*world.shape.height,0} \ncamera_up_vector:{0.0,0.0,1.0}{\n...\n}\n```\n\n#### Third Person view\nYou can follow an agent during a simulation by positioning the camera above it using:\n\n```\ndisplay ThirdPerson  type:opengl camera_pos:{boids(1).location.x,-boids(1).location.y,250}  camera_look_pos:{boids(1).location.x,-boids(1).location.y,boids(1).location.z}{\n...\n} \n```\n\n\n[//]: # (keyword|concept_light)\n## Lighting\n\nIn a 3D scene once can define light sources. The way how light sources and 3D object interact is called lighting. Lighting is an important factor to render realistic scenes.\n\nIn a real world, the color that we see depend on the interaction between color material surfaces, the light sources and the position of the viewer. There are four kinds of lighting called _ambient_, _diffuse_, _specular_ and _emissive_.\n\nGama handle _ambient_ and _diffuse_ light.\n\n\n\n* **ambient\\_light**: Allows to define the value of the ambient light either using an int (ambient\\_light:(125)) or a rgb color ((ambient\\_light:rgb(255,255,255)). default is rgb(125,125,125).\n* **diffuse\\_light**: Allows to define the value of the diffuse light either using an int (diffuse\\_light:(125)) or a rgb color ((diffuse\\_light:rgb(255,255,255)). default is rgb(125,125,125).\n* **diffuse\\_light\\_pos**: Allows to define the position of the diffuse light either using an point (diffuse\\_light\\_pos:{x,y,z}). default is {world.shape.width/2,world.shape.height/2,world.shape.width`*`2}.\n* **is\\_light\\_on**: Allows to enable/disable the light. Default is true.\n* **draw\\_diffuse\\_light**: Allows to enable/disable the drawing of the diffuse light. Default is false\")),\n\n\nHere is an example using all the available facet to define a diffuse light that rotate around the world.\n\n<a href='http://www.youtube.com/watch?feature=player_embedded&v=op56elmEEYs' target='_blank'><img src='http://img.youtube.com/vi/op56elmEEYs/0.jpg' width='425' height=344 /></a>\n\n```\ndisplay View1  type:opengl draw_diffuse_light:true ambient_light:(0) diffuse_light:(255) diffuse_light_pos:{50+ 150*sin(time*2),50,150*cos(time*2){\n...\n}\n```\n[//]: # (endConcept|3d_displays)","url":"wiki/Defining3DDisplays.md"},"DefiningCharts.md":{"title":" Defining Charts","content":"[//]: # (startConcept|defining_charts)\n# Defining Charts\n\nTo visualize result and make analysis about you model, you will certainly have to use charts. You can define 3 types of charts in GAML: histograms, pie, and series. For each type, you will have to determine the data you want to highlight.\n\n## Index\n\n* [Define a chart](#define-a-chart)\n* [Data definition](#data-definition)\n* [Different types of charts](#different-type-of-charts)\n\n## Define a chart\n\nTo define a chart, we have to use the `chart` statement. A chart has to be named (with the `name` facet), and the type has to be specified (with the `type` facet). The value of the `type` facet can be `histogram`, `pie`, `series`, `scatter`, `xy`. A chart has to be defined inside a display.\n\n```\nexperiment my_experiment type: gui {\n\toutput {\n\t\tdisplay \"my_display\" {\n\t\t\tchart \"my_chart\" type:pie {\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\nAfter declaring your chart, you have to define the data you want to display in your chart.\n\n## Data definition\n\nData can be specified with:\n* several data statements to specify each series\n* one datalist statement to give a list of series. It can be useful if the number of series is unknown, variable or too high.\n \nThe `data` statement is used to specify which variable will be displayed. You have to give your data a name (that will be displayed in your chart), the value of the variable you want to follow (using the `value` facet). You can add come optional facets such as `color` to specify the color of your data.\n\n``` \nglobal\n{\n\tint numberA <- 2 update:numberA*2;\n\tint numberB <- 10000 update:numberB-1000;\n}\n\nexperiment my_experiment type: gui {\n\toutput {\n\t\tdisplay \"my_display\" {\n\t\t\tchart \"my_chart\" type:pie {\n\t\t\t\tdata \"numberA\" value:numberA color:#red;\n\t\t\t\tdata \"numberB\" value:numberB color:#blue;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n(TODO_IMAGE)\n\nThe `datalist` statement is used several variables in one statement.  Instead of giving simple values, datalist is used with lists. \n\n```\ndatalist [\"numberA\",\"numberB\"] value:[numberA,numberB] color:[#red,#blue];\n```\n[TODO]\nDatalist provides you some additional facets you can use. If you want to learn more about them, please read the documentation [URL]\n\n## Different types of chart\n\nAs we already said, you can display 3 types of graphs: the histograms, the pies and the series.\n\nThe histograms\n\n\n[TODO]\n\n[//]: # (endConcept|defining_charts)","url":"wiki/DefiningCharts.md"},"DefiningDisplaysGeneralities.md":{"title":" Defining displays (Generalities)","content":"[//]: # (startConcept|2d_displays)\n# Defining displays (Generalities)\n[//]: # (keyword|concept_display)\n[//]: # (keyword|concept_layer)\n[//]: # (keyword|concept_output)\n\n## Index\n\n* [Displays and layers](#displays-and-layers)\n* [Organize your layers](#organize-your-layers)\n* [Example of layers](#example-of-layers)\n  * [agents layer](#agents-layer)\n  * [species layer](#species-layer)\n  * [image layer](#image-layer)\n  * [text layer](#text-layer)\n  * [graphics layer](#graphics-layer)\n\n## Displays and layers\n\n[//]: # (keyword|statement_display)\n[//]: # (keyword|statement_output)\nA display is the graphical output of your simulation. You can define several displays related with what you want to represent from your model execution. To define a display, use the keyword `display` inside the `output` scope, and specify a name (`name` facet).\n\n```\nexperiment my_experiment type: gui {\n\toutput {\n\t\tdisplay \"display1\" {\n\t\t}\n\t\tdisplay name:\"display2\" {\n\t\t}\n\t}\n}\n```\n\n[//]: # (keyword|concept_background)\nOther facets are available when defining your display:\n* Use `background` to define a color for your background\n```\ndisplay \"my_display\" background:#red\n```\n[//]: # (keyword|concept_refresh)\n* Use `refresh` if you want to refresh the display when a condition is true (to refresh your display every number of steps, use the operator `every`)\n```\ndisplay \"my_display\" refresh:every(10)\n```\n\nYou can choose between two types of displays, by using the facet type:\n* java2D displays will be used when you want to have 2D visualization. It is used for example when you manipulate charts. This is the default value for the facet type. \n* opengl displays allows you to have 3D visualization.\n\n[//]: # (keyword|concept_autosave)\n[//]: # (keyword|concept_graphic)\n[//]: # (keyword|concept_graphic_unit)\nYou can save the display on the disk, as a png file, in the folder name_of_model/models/snapshots, by using the facet `autosave`. This facet takes one a boolean as argument (to allow or not to save each frame) or a point (to define the size of your image). By default, the resolution of the output image is 500x500px (note that when no unit is provided, the unit is `#px` (pixel) ).\n\n```\ndisplay my_display autosave:true type:java2D {}\n```\n\nis equivalent to :\n\n``` \ndisplay my_display autosave:{500,500} type:java2D {}\n```\n\nEach display can be decomposed in one or several layers. Here is a screenshot (from the Toy Model Ant) to better understand those different notions we are about to tackle in this session.\n\n![images/difference_layer_display.png](resources/images/definingGUIExperiment/difference_layer_display.png)\n\n## Organize your layers\n\nIn one 2D display, you will have several types of layers, giving what you want to display in your model. You have a large number of layers available. You already know some of them, such as `species`, `agents`, `grid`, but other specific layers such as `image` (to display image) and `graphics` (to freely draw shapes/geometries/texts without having to define a species) are also available\n\nEach layer will be displayed in the same order as you declare them. The last declared layer will be above the others.\n\nThus, the following code:\n\n```\nexperiment expe type:gui {\n    output {\n        display my_display {\n            graphics \"layer1\" {\n                draw square(20) at:{10,10} color:#gold;\n            }\n            graphics \"layer2\" {\n                draw square(20) at:{15,15} color:#darkorange;\n            }\n            graphics \"layer3\" {\n                draw square(20) at:{20,20} color:#cornflowerblue;\n            }\n        }\n    }\n}\n```\n\nWill have this output:\n\n![images/layers_order.png](resources/images/definingGUIExperiment/layers_order.png)\n\nMost of the layers have the `transparency` facet in order to see the layers which are under.\n\n```\nexperiment expe type:gui {\n\toutput {\n\t\tdisplay my_display {\n\t\t\tgraphics \"layer1\" {\n\t\t\t\tdraw square(20) at:{10,10} color:#darkorange;\n\t\t\t}\n\t\t\tgraphics \"layer2\" transparency:0.5 {\n\t\t\t\tdraw square(20) at:{15,15} color:#cornflowerblue;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n![images/layers_transparency.png](resources/images/definingGUIExperiment/layers_transparency.png)\n\nTo specify a position and a size for your layer, you can use the `position` and the `size` facets.\nThe `position` facet is used with a point type, between {0,0} and {1,1}, which corresponds to the position of the upper left corner of your layer in percentage. Then, if you choose the point {0.5,0.5}, the upper left corner of your layer will be in the center of your display. By default, this value is {0,0}.\nThe `size` facet is used with a point type, between {0,0} and {1,1} also. It corresponds to the size occupied by the layer in percentage. By default, this value is {1,1}.\n\n```\nexperiment expe type:gui {\n\toutput {\n\t\tdisplay my_display {\n\t\t\tgraphics \"layer1\" position:{0,0} size:{0.5,0.8} {\n\t\t\t\tdraw shape color:#darkorange;\n\t\t\t}\n\t\t\tgraphics \"layer2\" position:{0.3,0.1} size:{0.6,0.2} {\n\t\t\t\tdraw shape color:#cornflowerblue;\n\t\t\t}\n\t\t\tgraphics \"layer3\" position:{0.4,0.2} size:{0.3,0.8} {\n\t\t\t\tdraw shape color:#gold;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n![images/layers_size_position.png](resources/images/definingGUIExperiment/layers_size_position.png)\n\nNB : `displays` can have background, while `graphics` can't. If you want to put a background for your `graphics`, a solution can be to draw the `shape` of the world (which is, by default, a square 100m*100m).\n\nA lot of other facets are available for the different layers. Please read the documentation of [`graphics`](Statements#graphics) for more information.\n\n## Example of layers\n\n### agents layer\n`agents` allows the modeler to display only the agents that fulfill a given condition. \n\nPlease read the documentation about [`agents` statement](Statements#agents) if you are interested.\n\n### species layer\n`species` allows modeler to display all the agent of a given species in the current display. In particular, modeler can choose the aspect used to display them.\n\nPlease read the documentation about [`species` statement](Statements#species) if you are interested.\n\n### image layer\n`image` allows modeler to display an image (e.g. as background of a simulation).\n\nPlease read the documentation about [`image` statement](Statements#image) if you are interested.\n\n[//]: # (keyword|concept_text)\n### graphics layer\n`graphics` allows the modeler to freely draw shapes/geometries/texts without having to define a species.\n\nPlease read the documentation about [`graphics` statement](Statements#graphics) if you are interested.\n\n[//]: # (endConcept|2d_displays)","url":"wiki/DefiningDisplaysGeneralities.md"},"DefiningExportFiles.md":{"title":" Defining export files","content":"[//]: # (startConcept|export_files)\n[//]: # (keyword|concept_file)\n[//]: # (keyword|concept_load_file)\n# Defining export files\n\n## Index\n\n* [The Save Statement](#the-save-statement)\n* [Export files in experiment](#export-files-in-experiment)\n* [Autosave](#autosave)\n\n## The Save Statement\n\n[//]: # (keyword|statement_save)\nAllows to save data in a file. The type of file can be \"shp\", \"text\" or \"csv\". The **`save`** statement can be use in an init block, a reflex, an action or in a user command. Do not use it in experiments.\n\n### Facets \n\n  * **`to`** (string): an expression that evaluates to an string, the path to the file\n  * `data` (any type), (omissible) : any expression, that will be saved in the file\n  * `crs` (any type): the name of the projectsion, e.g. crs:\"EPSG:4326\" or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id): http://spatialreference.org\n  * `rewrite` (boolean): an expression that evaluates to a boolean, specifying whether the save will ecrase the file or append data at the end of it\n  * `type` (an identifier): an expression that evaluates to an string, the type of the output file (it can be only \"shp\", \"text\" or \"csv\")\n  * `with` (map):  \n\n### Usages\n\n* Its simple syntax is:\n\n```\nsave data to: output_file type: a_type_file;\n```\n\n[//]: # (keyword|concept_text)\n* To save data in a text file:\n\n```\nsave (string(cycle) + \"->\"  + name + \":\" + location) to: \"save_data.txt\" type: \"text\";\n```\n\n[//]: # (keyword|concept_csv)\n* To save the values of some attributes of the current agent in csv file:\n\n```\nsave [name, location, host] to: \"save_data.csv\" type: \"csv\";\n```\n\n[//]: # (keyword|concept_shapefile)\n* To save the geometries of all the agents of a species into a shapefile (with optional attributes):\n\n```\nsave species_of(self) to: \"save_shapefile.shp\" type: \"shp\" with: [name::\"nameAgent\", location::\"locationAgent\"] crs: \"EPSG:4326\";\n```\n\n## Export files in experiment\n\n[//]: # (keyword|statement_output_file)\nDisplays are not the only output you can manage in GAMA. Saving data to a file during an experiment can also be achieved in several ways, depending on the needs of the modeler. One way is provided by the `save` statement, which can be used everywhere in a model or a species. The other way, described here, is to include an **`output_file`** statement in the output section.\n\n```\noutput_file name:\"file_name\" type:file_type data:data_to_write; \n```\n\nwith:\n\n`file_type`: text, csv or xml\n`file_name`: string\n`data_to_write`: string\n\n### Example:\n\n```\nfile name: \"results\" type: text data: time + \"; \" + nb_preys + \";\" + nb_predators refresh:every(2);  \n```\n\nEach time step (or according to the frequency defined in the `refresh` facet of the file output), a new line will be added at the end of the file. If `rewrite: false` is defined in its facets, a new file will be created for each simulation (identified by a timestamp in its name).\n\nOptionally, a `footer` and a `header` can also be described with the corresponding facets (of type string).\n\n## Autosave\n\n[//]: # (keyword|concept_autosave)\nImage files can be exported also through the `autosave` facet of the display, as explained in [this previous part](DefiningDisplaysGeneralities#displays-and-layers).\n[//]: # (endConcept|export_files)","url":"wiki/DefiningExportFiles.md"},"DefiningMonitorsAndInspectors.md":{"title":" Defining monitors and inspectors","content":"[//]: # (startConcept|monitors_and_inspectors)\n# Defining monitors and inspectors\n\nOther outputs can be very useful to study better the behavior of your agents.\n\n## Index\n\n* [Define a monitor](#define-a-monitor)\n* [Define an inspector](#define-an-inspector)\n\n[//]: # (keyword|concept_monitor)\n## Define a monitor\n\n[//]: # (keyword|statement_monitor)\nA [monitor](InspectorsAndMonitors#monitor) allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its refresh facet). \n\nDefinition of a monitor: \n\n```\nmonitor monitor_name value: an_expression refresh:boolean_statement;\n```\n\nwith:\n* `value:` mandatory, the expression whose value will be displayed by the monitor.\n* `refresh:` bool statement, optional : the new value is computed if the bool statement returns true.\n\nExample:\n\n```\nexperiment my_experiment type: gui {\n\toutput {\n\t\tmonitor monitor_name value: cycle refresh:every(1);\n\t}\n}\n```\n\nNB : you can also declare monitors during the simulation, by clicking on the button \"Add new monitor\", and specifying the name of the variable you want to follow.\n\n[//]: # (keyword|concept_inspector)\n## Define an inspector\n\n[//]: # (keyword|statement_inspector)\nDuring the simulation, the user interface of GAMA provides the user the possibility to [inspect an agent](InspectorsAndMonitors), or a group of agents. But you can also define the inspector you want directly from your model, as an output of the experiment.\n\nUse the statement `inspect` to define your inspector, in the output scope of your gui experiment. The inspector has to be named (using the facet `name`), a value has to be specified (with the `value` facet).\n\n```\ninspect name:\"inspector_name\" value:the_value_you_want_to_display;\n```\n\nNote that you can inspect any type of species (regular species, grid species, even the world...).\n\nThe optional facet `type` is used to specify the type of your inspector. 2 values are possible : \n* _agent_ (default value) if you want to display the information as a regular [agent inspector](InspectorsAndMonitors#agent-inspector). Note that if you want to inspect a large number of agents, this can take a lot of time. In this case, prefer the other type _table_\n* _table_ if you want to display the information as an [agent browser](InspectorsAndMonitors#agent-browser)\n\nThe optional facet `attribute` is used to filter the attributes you want to be displayed in your inspector.\n\n**Beware** : only one agent inspector (`type:agent`) can be used for an experiment. Beside, you can add as many agent browser (`type:table`) as you want for your experiment.\n\nExample of implementation :\n\n```\nmodel new\n\nglobal {\n\tinit {\n\t\tcreate my_species number:3;\n\t}\n}\n\nspecies my_species {\n\tint int_attr <- 6;\n\tstring str_attr <- \"my_value\";\n\tstring str_attr_not_important <- \"blabla\";\n}\n\ngrid my_grid_species width: 10 height: 10 {\n\tint rnd_value <- rnd(5);\n}\n\nexperiment my_experiment type:gui {\n\toutput {\n\t\tinspect name:\"my_species_inspector\" value:my_species attributes:[\"int_attr\",\"str_attr\"];\n\t\tinspect name:\"my_species_browser\" value:my_species type:table;\n\t\tinspect name:\"my_grid_species_browser\" value:5 among my_grid_species type:table;\n\t}\n}\n```\n\nAnother statement, `browse`, is doing a similar thing, but preferring the _table_ type (if you want to browse an agent species, the default type will be the _table_ type).\n[//]: # (endConcept|monitors_and_inspectors)","url":"wiki/DefiningMonitorsAndInspectors.md"},"DefiningParameters.md":{"title":" Defining Parameters","content":"[//]: # (startConcept|define_parameters)\n[//]: # (keyword|concept_parameter)\n# Defining Parameters\n[//]: # (keyword|concept_gui)\n\nWhen playing simulation, you have the possibility to define input parameters, in order to change them and replay the simulation. Defining parameters allows to make the value of a global variable definable by the user through the user graphic interface.\n\n## Index\n\n* [Defining parameters](#defining-parameters)\n* [Additional facets](#additional-facets)\n\n## Defining parameters\n\nYou can define parameters inside the global scope, when defining your global variables with the facet `parameter`:\n\n```\nglobal\n{\n\tint my_integer_global_value <- 5 parameter: \"My integer global value\";\n}\n```\n\nWhen launching your experiment, the parameter will appear in your \"Parameters\" panel, with the name you chose for the `parameter` facet.\n\n![images/parameter1.png](resources/images/definingGUIExperiment/parameter1.png)\n\nYou can also define your parameter inside the experiment, using the statement parameter. You have to specify first the name of your parameter, then the name of the global variable through the facet `var`.\n\n```\nglobal\n{\n\tint my_integer_global_value <- 5;\n}\n```\n\nexperiment MyExperiment type: gui {\n\tparameter \"My integer global value\" var:my_integer_global_value;\n}\n\nNB: This variable has to be initialized with a value. If you don't want to initialize your value on the `global` scope, you can initialize the value directly on the parameter statement, using the facet `init`.\n\n```\nglobal\n{\n\tint my_integer_global_value;\n}\n\nexperiment MyExperiment type: gui {\n\tparameter \"My integer global value\" var:my_integer_global_value init:5;\n}\n```\n\n## Additional facets\n\nYou can use some facets to arrange your parameters. For example, you can categorize your parameters under a label, using the facet `category`:\n\n```\nglobal\n{\n\tint attr_1 <- 5 parameter:\"attr 1\" category:\"category 1\";\n\tint attr_2 <- 5 parameter:\"attr 2\" category:\"category 1\";\n\tint attr_3 <- 5 parameter:\"attr 3\" category:\"category 2\";\n}\n```\n\n![images/parameter2.png](resources/images/definingGUIExperiment/parameter2.png)\n\nYou also can add some facets such as `min`, `max` or `among` to improve the declaration of the parameter.\n\n```\nglobal\n{\n\tstring fruit <- \"none\" among:[\"none\",\"apple\",\"banana\"] parameter:\"fruit\" category:\"food\";\n\tstring vegetable <- \"none\" among:[\"none\",\"cabbage\",\"carrot\"] parameter:\"vegetable\" category:\"food\";\n\tint integer_variable <- 5 parameter:\"integer variable\" min:0 max:100  category:\"other\";\n}\n\nexperiment MyExperiment type: gui {\n}\n```\n\n![images/parameter3.png](resources/images/definingGUIExperiment/parameter3.png)\n[//]: # (endConcept|define_parameters)","url":"wiki/DefiningParameters.md"},"DefiningUserInteraction.md":{"title":" Defining user interaction","content":"[//]: # (keyword|concept_gui)\n# Defining user interaction\n\nDuring the simulation, GAML provides you the possibility to define some function the user can execute during the execution. In this chapter, we will see how to define buttons to execute action during the simulation, how to catch click event, and how to use the user control architecture.\n\n## Index\n\n* [Catch Mouse Event](#catch-mouse-event)\n* [Define User command](#define-user-command)\n  * [... in the GUI Experiment scope](#defining-user-command-in-gui-experiment-scope)\n  * [... in global or regular species](#defining-user-command-in-a-global-or-regular-species)\n  * [user_location](#user_location)\n  * [user_input](#user_input)\n* [User Control Architecture](#user-control-architecture)\n\n## Catch Mouse Event\n\n[//]: # (keyword|statement_event)\nYou can catch mouse event during the simulation using the statement `event`. This statement has 2 required facets:\n* **`name`** (identifier) : Specify which event do you want to trigger (among the following values : `mouse_down`, `mouse_down`, `mouse_move`, `mouse_enter`, `mouse_exit`).\n* **`action`** (identifier) : Specify the name of the global action to call.\n\n```\nevent mouse_down action: my_action;\n```\n\nThe `event` statement has to be defined in the `experiment`/`output`/`display` scope. Once the event is triggered, the global action linked will be called. The action linked has to have 2 arguments : the location of the click (type `point`) and the list of agents which are displayed at this position.\n\n```\nglobal\n{\n\taction my_action (point loc, list<my_species> selected_agents)\n\t{\n\t\twrite \"do action\";\n\t}\n\n}\n\nspecies my_species\n{\n}\n\nexperiment my_experiment type: gui\n{\n\toutput\n\t{\n\t\tdisplay my_display\n\t\t{\n\t\t\tspecies my_species;\n\t\t\tevent mouse_down action: my_action;\n\t\t}\n\t}\n}\n```\n\n## Define User command\n\n[//]: # (keyword|statement_user_command)\nAnywhere in the global block, in a species or in an (GUI) experiment, `user_command` statements can be implemented. They can either call directly an existing action (with or without arguments) or be followed by a block that describes what to do when this command is run.\n\nTheir syntax can be (depending of the modeler needs) either:\n\n```\nuser_command cmd_name action: action_without_arg_name;\n//or\nuser_command cmd_name action: action_name with: [arg1::val1, arg2::val2];\n//or\nuser_command cmd_name {\n   // statements\n}\n```\n\nFor instance:\n\n```\nuser_command kill_myself action: die;\n//or\nuser_command kill_myself action: some_action with: [arg1::5, arg2::3];\n//or\nuser_command kill_myself {\n    do die;\n}\n```\n\n### Defining User command in GUI Experiment scope\n\nThe user command can be defined directly inside the GUI experiment scope. In that case, the implemented action appears as a button in the top of the parameter view.\n\nHere is a very short code example :\n\n```\nmodel quick_user_command_model\n\nglobal {\n\taction createAgent\n\t{\n\t\tcreate my_species;\n\t}\n}\n\nspecies my_species {\n\taspect base {\n\t\tdraw circle(1) color:#blue;\n\t}\n}\n\nexperiment expe type:gui {\n\tuser_command cmd_inside_experiment action:createAgent;\n\toutput {\n\t\tdisplay my_display {\n\t\t\tspecies my_species aspect:base;\n\t\t}\n\t}\n}\n```\n\nAnd here is screenshots of the execution :\n\n![images/user_command_inside_expe.png](resources/images/definingGUIExperiment/user_command_inside_expe.png)\n\n### Defining User command in a global or regular species\n\nThe user command can also be defined inside a species scope (either global or regular one). Here is a quick example of model :\n\n```\nmodel quick_user_command_model\n\nglobal {\n\tinit {\n\t\tcreate my_species number:10;\n\t}\n}\n\nspecies my_species {\n\tuser_command cmd_inside_experiment action:die;\n\taspect base {\n\t\tdraw circle(1) color:#blue;\n\t}\n}\n\nexperiment expe type:gui {\n\toutput {\n\t\tdisplay my_display {\n\t\t\tspecies my_species aspect:base;\n\t\t}\n\t}\n}\n```\n\nDuring the execution, you have 2 ways to access to the action :\n* When the agent is inspected, they appear as buttons above the agents' attributes\n\n![images/user_command_inside_species1.png](resources/images/definingGUIExperiment/user_command_inside_species1.png)\n* When the agent is selected by a right-click in a display, these command appear under the usual \"Inspect\", \"Focus\" and \"Highlight\" commands in the pop-up menu.\n\n![images/user_command_inside_species2.png](resources/images/definingGUIExperiment/user_command_inside_species2.png)\n\n\nRemark: The execution of a command obeys the following rules:\n* when the command is called from right-click pop-menu, it is executed immediately\n* when the command is called from panels, its execution is postponed until the end of the current step and then executed at that time.\n\n### user_location\n\nIn the special case when the `user_command` is called from the pop-up menu (from a right-click on an agent in a display), the location chosen by the user (translated into the model coordinates) is passed to the execution scope under the name `user_location`.\n\nExample:\n\n```\nglobal {\n   user_command \"Create agents here\" {\n      create my_species number: 10 with: [location::user_location];\n   }\n}\n```\n\nThis will allow the user to click on a display, choose the world (always present now), and select the menu item \"Create agents here\".\n\nNote that if the world is inspected (this `user_command` appears thus as a button) and the user chooses to push the button, the agent will be created at a random location.\n\n### user_input\n\n[//]: # (keyword|operator_user_input)\nAs it is also, sometimes, necessary to ask the user for some values (not defined as parameters), the `user_input` unary operator has been introduced. This operator takes a map [string::value] as argument (the key is the name of the chosen parameter, the value is the default value), displays a dialog asking the user for these values, and returns the same map with the modified values (if any). You can also add a text as first argument of the operator, which will be displayed as a title for your dialog popup. The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section like the following one to force the user to input new values instead of relying on the initial values of parameters.\n\nHere is an example of implementation:\n\n```\nmodel quick_user_command_model\n\nglobal {\n   init {\n      map values <- user_input(\"choose a number of agent to create\",[\"Number\" :: 100]);\n      create my_species number : int(values at \"Number\");\n   }\n}\n\nspecies my_species {\n\taspect base {\n\t\tdraw circle(1) color:#blue;\n\t}\n}\n\nexperiment expe type:gui {\n\toutput {\n\t\tdisplay my_display {\n\t\t\tspecies my_species aspect:base;\n\t\t}\n\t}\n}\n```\n\nWhen running this model, you will first have to input a number:\n\n![images/input_cmd.png](resources/images/definingGUIExperiment/input_cmd.png)\n\n## User Control Architecture\n\nAn other way to define user interaction is to use the user control architecture. Please jump directly to the section [user control architecture](ControlArchitecture#user-control-architecture) if you want to learn more about this point.","url":"wiki/DefiningUserInteraction.md"},"BatchExperiments.md":{"title":" Defining Batch Experiments","content":"[//]: # (keyword|concept_batch)\n# Defining Batch Experiments\n\nBatch experiments allows to execute numerous successive simulation runs.They are used to explore the parameter space of a model or to optimize a set of model parameters.\n\nA Batch experiment is defined by:\n\n```\nexperiment exp_title type: batch {\n   [parameter to explore]\n   [exploration method]\n   [reflex]\n   [permanent]\n}\n```\n\n## Table of contents \n\n* [The batch experiment facets](#the-batch-experiment-facets)\n* [Action _step](#action-step)\n* [Reflexes](#reflexes)\n* [Permanent](#permanent)\n\n\n\n## The batch experiment facets\nBatch experiment have the following three facets:\n* until: (expression) Specifies when to stop each simulations. Its value is a condition on variables defined in the model. The run will stop when the condition is evaluated to true. If omitted, the first simulation run will go forever, preventing any subsequent run to take place (unless a halt command is used in the model itself).\n* repeat: (integer) A parameter configuration corresponds to a set of values assigned to each parameter. The attribute repeat specifies the number of times each configuration will be repeated, meaning that as many simulations will be run with the same parameter values. Different random seeds are given to the pseudo-random number generator. This allows to get some statistical power from the experiments conducted. Default value is 1.\n* keep\\_seed: (boolean) If true, the same series of random seeds will be used from one parameter configuration to another. Default value is false.\n\n```\nexperiment my_batch_experiment type: batch repeat: 5 keep_seed: true until: time = 300 {\n   [parameter to explore]\n   [exploration method]\n}\n```\n\n\n## Action _step\nThe_step_action of an experiment is called at the end of a simulation. It is possible to override this action to apply a specific action at the end of each simulation. Note that at the experiment level, you have access to all the species and all the global variables._\n\nFor instance, the following experiment runs the simulation 5 times, and, at the end of each simulation, saves the people agents in a shapefile.\n```\nexperiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {\n\tint cpt <- 0;\n\taction _step_ {\n\t\tsave people type:\"shp\" to:\"people_shape\" + cpt + \".shp\" with: [is_infected::\"INFECTED\",is_immune::\"IMMUNE\"];\n\t\tcpt <- cpt + 1;\n\t}\n}\n\nA second solution to achieve the same result is to use reflexes (see below).\n```\n\n\n## Reflexes\nIt is possible to write reflexes inside a batch experiment. This reflex will be executed at the end of each simulation. For instance, the following reflex writes at the end of each simulation the value of the variable _food\\_gathered_:\n\n```\nreflex info_sim {\n\twrite \"Running a new simulation \" + simulation + \" -> \" + food_gathered;\n}\n```\n\n[//]: # (keyword|concept_output)\n[//]: # (keyword|concept_permanent)\n## Permanent\nThe **permanent** section allows to define a output block that will not be re-initialized at the beginning of each simulation but will be filled at the end of each simulation.\nFor instance, this **permanent** section will allows to display for each simulation the end value of the _food\\_gathered_ variable.\n```\npermanent {\n\tdisplay Ants background: rgb('white') refresh:every(1) {\n\t\tchart \"Food Gathered\" type: series {\n\t\t\tdata \"Food\" value: food_gathered;\n\t\t}\n\t}\n}\n```","url":"wiki/BatchExperiments.md"},"ExplorationMethods.md":{"title":" Exploration Methods","content":"[//]: # (startConcept|exploration_methods)\n[//]: # (keyword|concept_batch)\n# Exploration Methods\n\nSeveral batch methods are currently available. Each is described below.\n\n\n## Table of contents \n\n* [The method element](#the-method-element)\n* [Exhaustive exploration of the parameter space](#exhaustive-exploration-of-the-parameter-space)\n* [Hill Climbing](#hill-climbing)\n* [Simulated Annealing](#simulated-annealing)\n* [Tabu Search](#tabu-search)\n* [Reactive Tabu Search](#reactive-tabu-search)\n* [Genetic Algorithm](#genetic-algorithm)\n\n[//]: # (keyword|concept_algorithm)\n## The method element\nThe optional method element controls the algorithm which drives the batch.\n\nIf this element is omitted, the batch will run in a classical way, changing one parameter value at each step until all the possible combinations of parameter values have been covered. See the Exhaustive exploration of the parameter space for more details.\n\nWhen used, this element must contain at least a name attribute to specify the algorithm to use. It has theses facets:\n* minimize or a maximize (mandatory for optimization method): a attribute defining the expression to be optimized.\n* aggregation (optional): possible values (\"min\", \"max\"). Each combination of parameter values is tested **repeat** times. The aggregated fitness of one combination is by default the average of fitness values obtained with those repetitions. This facet can be used to tune this aggregation function and to choose to compute the aggregated fitness value as the minimum or the maximum of the obtained fitness values.\n* other parameters linked to exploration method (optional) : see below for a description of these parameters.\n\nExemples of use of the method elements:\n```\nmethod exhaustive minimize: nb_infected ;\n\nmethod genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 5  minimize: nb_infected aggregation: \"max\";\n```\n\n[//]: # (keyword|concept_parameter)\n## Exhaustive exploration of the parameter space\n\nParameter definitions accepted: List with step and Explicit List.\nParameter type accepted: all.\n\nThis is the standard batch method. The exhaustive mode is defined by default when there is no method element present in the batch section. It explores all the combination of parameter values in a sequential way.\n\nExample (models/ants/batch/ant\\_exhaustive\\_batch.xml):\n\n```\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n}\n```\n\nThe order of the simulations depends on the order of the param. In our example, the first combinations will be the followings:\n* evaporation\\_rate = 0.1, diffusion\\_rate = 0.1, (2 times)\n* evaporation\\_rate = 0.1, diffusion\\_rate = 0.4, (2 times)\n* evaporation\\_rate = 0.1, diffusion\\_rate = 0.7, (2 times)\n* evaporation\\_rate = 0.1, diffusion\\_rate = 1.0, (2 times)\n* evaporation\\_rate = 0.2, diffusion\\_rate = 0.1, (2 times)\n* ...\n\nNote: this method can also be used for optimization by adding an method element with maximize or a minimize attribute:\n\n```\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\tmethod exhaustive maximize: food_gathered;\n}\n```\n\n\n## Hill Climbing\n\nName: hill\\_climbing\nParameter definitions accepted: List with step and Explicit List.\nParameter type accepted: all.\n\nThis algorithm is an implementation of the Hill Climbing algorithm. See the wikipedia article.\n\nAlgorithm:\n\n```\n Initialization of an initial solution s \n iter = 0\n While iter <= iter_max, do:\n   Choice of the solution s' in the neighborhood of s that maximize the fitness function\n   If f(s') > f(s)\n     s = s'\n   Else\n     end of the search process\n   EndIf\n   iter = iter + 1\n EndWhile\n```\n\nMethod parameters:\n* iter\\_max: number of iterations\n\nExample (models/ants/batch/ant\\_hill\\_climbing\\_batch.xml):\n\n```\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\tmethod hill_climbing iter_max: 50 maximize : food_gathered;\n}\n```\n\n\n## Simulated Annealing\nName: annealing\nParameter definitions accepted: List with step and Explicit List.\nParameter type accepted: all.\n\nThis algorithm is an implementation of the Simulated Annealing algorithm. See the wikipedia article.\n\nAlgorithm:\n\n```\n Initialization of an initial solution s \n temp = temp_init\n While temp > temp_end, do:\n   iter = 0\n   While iter < nb_iter_cst_temp, do:\n     Random choice of a solution s2 in the neighborhood of s  \n     df = f(s2)-f(s)\n     If df > 0 \n       s = s2\n     Else,\n       rand = random number between 0 and 1\n       If rand < exp(df/T)\n         s = s2\n       EndIf\n     EndIf\n     iter = iter + 1\n   EndWhile\n   temp = temp * nb_iter_cst_temp\n EndWhile\n```\n\nMethod parameters:\n* temp\\_init: Initial temperature\n* temp\\_end: Final temperature\n* temp\\_decrease: Temperature decrease coefficient\n* nb\\_iter\\_cst\\_temp: Number of iterations per level of temperature\n\nExample (models/ants/batch/ant\\_simulated\\_annealing\\_batch.xml):\n\n\n```\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\tmethod annealing temp_init: 100  temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered;\n}\n```\n\n\n## Tabu Search\nName: tabu\nParameter definitions accepted: List with step and Explicit List.\nParameter type accepted: all.\n\nThis algorithm is an implementation of the Tabu Search algorithm. See the wikipedia article.\n\nAlgorithm:\n\n```\n Initialization of an initial solution s \n tabuList = {}\n iter = 0\n While iter <= iter_max, do:\n   Choice of the solution s2 in the neighborhood of s such that:\n     s2 is not in tabuList\n     the fitness function is maximal for s2\n   s = s2\n   If size of tabuList = tabu_list_size\n     removing of the oldest solution in tabuList \n   EndIf\n   tabuList = tabuList + s\n   iter = iter + 1\n EndWhile\n```\n\nMethod parameters:\n* iter\\_max: number of iterations\n* tabu\\_list\\_size: size of the tabu list\n\n\n```\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\tmethod tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered;\n}\n```\n\n\n\n\n## Reactive Tabu Search\n\nName: reactive\\_tabu\nParameter definitions accepted: List with step and Explicit List.\nParameter type accepted: all.\n\nThis algorithm is a simple implementation of the Reactive Tabu Search algorithm ((Battiti et al., 1993)). This Reactive Tabu Search is an enhance version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle.\n\nMethod parameters:\n* iter\\_max: number of iterations\n* tabu\\_list\\_size\\_init: initial size of the tabu list\n* tabu\\_list\\_size\\_min: minimal size of the tabu list\n* tabu\\_list\\_size\\_max: maximal size of the tabu list\n* nb\\_tests\\_wthout\\_col\\_max: number of movements without collision before shortening the tabu list\n* cycle\\_size\\_min: minimal size of the considered cycles\n* cycle\\_size\\_max: maximal size of the considered cycles\n\n```\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\tmethod reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered;\n}\n```\n\n\n## Genetic Algorithm\nName: genetic\nParameter definitions accepted: List with step and Explicit List.\nParameter type accepted: all.\n\nThis is a simple implementation of Genetic Algorithms (GA). See the wikipedia article. The principle of GA is to search an optimal solution by applying evolution operators on an initial population of solutions There are three types of evolution operators:\n* Crossover: Two solutions are combined in order to produce new solutions\n* Mutation: a solution is modified\n* Selection: only a part of the population is kept. Different techniques can be applied for this selection. Most of them are based on the solution quality (fitness).\n\nRepresentation of the solutions:\n* Individual solution: {Param1 = val1; Param2 = val2; ...}\n* Gene: Parami = vali\n\nInitial population building: the system builds nb\\_prelim\\_gen random initial populations composed of pop\\_dim individual solutions. Then, the best pop\\_dim solutions are selected to be part of the initial population.\n\nSelection operator: roulette-wheel selection: the probability to choose a solution is equals to: fitness(solution)/ Sum of the population fitness. A solution can be selected several times. Ex: population composed of 3 solutions with fitness (that we want to maximize) 1, 4 and 5. Their probability to be chosen is equals to 0.1, 0.4 and 0.5.\n\nMutation operator: The value of one parameter is modified. Ex: The solution {Param1 = 3; Param2 = 2} can mute to {Param1 = 3; Param2 = 4}\n\nCrossover operator: A cut point is randomly selected and two new solutions are built by taking the half of each parent solution. Ex: let {Param1 = 4; Param2 = 1} and {Param1 = 2; Param2 = 3} be two solutions. The crossover operator builds two new solutions: {Param1 = 2; Param2 = 1} and {Param1 = 4; Param2 = 3}.\n\nMethod parameters:\n* pop\\_dim: size of the population (number of individual solutions)\n* crossover\\_prob: crossover probability between two individual solutions\n* mutation\\_prob: mutation probability for an individual solution\n* nb\\_prelim\\_gen: number of random populations used to build the initial population\n* max\\_gen: number of generations\n\n```\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\tmethod genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20; \n}\n```\n[//]: # (endConcept|exploration_methods)","url":"wiki/ExplorationMethods.md"},"RunSeveralSimulations.md":{"title":" Run Several Simulations","content":"[//]: # (startConcept|run_simulations_as_agents)\n# Run Several Simulations\n\nTo explore a model, the easiest and the most intuitive way to proceed is running several simulations with several parameter value, and see the differences from the output. GAMA provides you the possibility to launch several simulations from the GUI.\n\n## Index\n\n* [Create a simulation](#create-a-simulation)\n* [Manipulate simulations](#manipulate-simulations)\n* [Random seed](#random-seed)\n  * [Defining the seed from the model](#defining-the-seed-from-the-model)\n  * [Defining the seed from the experiment](#defining-the-seed-from-the-experiment)\n  * [Run several simulations with the same random numbers](#run-several-simulations-with-the-same-random-numbers)\n  * [Change the RNG](#change-the-rng)\n\n## Create a simulation\n\n[//]: # (keyword|concept_world)\nLet's remind you that in GAMA, everything is an **agent**. We already saw that the **\"world\" agent** is the **agent of the model**. The model is thus a **species**, called modelName_model :\n\n```\nmodel toto // <- the name of the species is \"toto_model\"\n```\n\n[//]: # (keyword|statement_create)\n[//]: # (keyword|concept_experiment)\n[//]: # (keyword|concept_multi_simulation)\nNew highlight of the day : an **Experiment** is also an agent ! It's a special agent which will instantiate automatically an agent from the model species. You can then perfectly create agents (_model_ agents) from your experiment, using the statement `create` :\n\n```\nmodel multi_simulations // the \"world\" is an instance of the \"multi_simulations_model\"\n\nglobal {\n}\n\nexperiment my_experiment type:gui  {\n\tinit {\n\t\tcreate multi_simulations_model;\n\t}\n}\n```\n\nThis sort model will instantiate 2 simulations (two instance of the model) : one is created automatically by the experiment, and the second one is explicitly created through the statement `create`.\n\nTo simplify the syntax, you can use the built-in attribute `simulation` of your **experiment**. When you have a model called \"multi_simulations\", the two following lines are strictly equal :\n\n```\ncreate multi_simulations_model;\ncreate simulation;\n```\n\nAs it was the case for creating regular species, you can specify the parameters of your agent during the creation through the facet `with:` :\n\n```\nmodel multi_simulations\n\nglobal {\n\trgb bgd_color;\n}\n\nexperiment my_experiment type:gui  {\n\tparameter name:\"background color:\" var:bgd_color init:#blue;\n\tinit {\n\t\tcreate simulation with:[bgd_color::#red];\n\t}\n\toutput {\n\t\tdisplay \"my_display\" background:bgd_color{}\n\t}\n}\n```\n\n## Manipulate simulations\n\nWhen you think the simulations as agents, it gives you a lot of new possibilities. You can for example create a reflex from your experiment, asking to create simulations **during the experiment execution** !\n\nThe following short model for example will create a new simulation at each 10 cycles :\n\n```\nmodel multi_simulations\n\nglobal {\n\tinit {\n\t\twrite \"new simulation created ! Its name is \"+name;\n\t}\n}\n\nexperiment my_experiment type:gui  {\n\tinit {\n\t}\n\treflex when:(mod(cycle,10)=0 and cycle!=0) {\n\t\tcreate simulation;\n\t}\n\toutput {\n\t}\n}\n```\n\nYou may ask, what is the purpose of such a thing ? Well, with such a short model, it is not very interesting, for sure. But you can imagine running a simulation, and if the simulation reaches a certain state, it can be closed, and another simulation can be run instead with different parameters (a simulation can be closed by doing a \"do die\" on itself). You can also imagine to run two simulations, and to communicate from one to an other through the experiment, as it is shown in this easy model, where agents can move from one simulation to another :\n\n![resources/images/exploringModel/change_world.png](resources/images/exploringModel/change_world.png)\n\n```\nmodel smallWorld\n\nglobal {\n\tint grid_size <- 10;\n\tbool modelleft <- true;\n\tint id<- 0;\n\tint nb_agents <- 50;\n\t\n\tinit {\n\t\tcreate people number: nb_agents {\n\t\t\tmy_cell <- one_of(cell);\n\t\t\tlocation <- my_cell.location;\n\t\t}\n\t\tif (modelleft) {\n\t\t\task cell where (each.grid_x = (grid_size - 1))  {\n\t\t\t\tcolor <- #red;\t\n\t\t\t}\n\t\t} else {\n\t\t\task cell where (each.grid_x = 0)  {\n\t\t\t\tcolor <- #red;\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction changeWorld(rgb color, point loc) {\n\t\tcreate people with:[color::color, location::loc] {\n\t\t\tmy_cell <- cell(location);\n\t\t}\n\t}\n}\n\nspecies people {\n\trgb color <- rnd_color(255);\n\tcell my_cell;\n\n\treflex move {\n\t\tif (modelleft and my_cell.color = #red) {\n\t\t\task smallWorld_model[1] {\n\t\t\t\tdo changeWorld(myself.color, {100 - myself.location.x,myself.location.y});\n\t\t \t}\n\t\t \tdo die;\n\t\t} else {\n\t\t\tlist<cell> free_cells <- list<cell> (my_cell.neighbors) where empty(people inside each);\n\t\t\tif not empty(free_cells) {\n\t\t\t\tmy_cell <- one_of(free_cells);\n\t\t\t\tlocation <- my_cell.location;\n\t\t\t}\n\t\t}\n\t\t\n\t} \n\taspect default {\n\t\tdraw circle(50/grid_size) color: color;\n\t}\t\n}\n\ngrid cell width: grid_size height: grid_size;\n\nexperiment fromWorldToWorld type: gui {\n\tinit {\n\t\t create simulation with:[grid_size::20, modelleft::false, id::1, nb_agents::0];\n\t}\n\t\n\toutput {\n\t\tdisplay map {\n\t\t\tgrid cell lines: #black;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n```\n\nHere is an other example of application of application, available in the model library. Here we run 4 times the Ant Foraging model, with different parameters.\n\n![resources/images/exploringModel/multi_foraging.jpg](resources/images/exploringModel/multi_foraging.jpg)\n\n[//]: # (endConcept|run_simulations_as_agents)\n[//]: # (startConcept|control_randomness)\n\n[//]: # (keyword|concept_random)\n## Random seed\n\n### Defining the seed from the model\n\nIf you run several simulations, you may want to use the same seed for each one of those simulations (to compare the influence of a certain parameter, in exactly the same conditions).\n\nLet's remind you that `seed` is a built-in attribute of the model. You than just need to specify the value of your seed during the creation of the simulation if you want to fix the seed :\n\n```\ncreate simulation with:[seed::10.0];\n```\n\nYou can also specify the seed if you are inside the `init` scope of your `global` agent.\n\n```\nglobal {\n\tinit {\n\t\tseed<-10.0;\n\t}\n}\n```\n\nNotice that if you affect the value of your seed built-in directly in the global scope, the affectation of the parameters (for instance specified with the facet `with` of the statement `create`), and the \"init\" will be done after  will be done at the end. \n\n### Defining the seed from the experiment\n\nThe experiment agent also have a built-in attribute `seed`. The value of this seed is defined in your [simulation preferences](Preferences#simulation). The first simulation created is created **with the seed value of the experiment**.\n\nThe following sequence diagram can explain you better how the affectation of the seed attribute works :\n\n![resources/images/exploringModel/sequence_diagram_seed_affectation.png](resources/images/exploringModel/sequence_diagram_seed_affectation.png)\n\nThe affectation of an attribute is always done in this order :\n(1) the attribute is affected with a specific value in the species scope. If no attribute value is specified, the value is a default value.\n(2) if a value is specified for this attribute in the `create` statement, then the attribute value is affected again.\n(3) the attribute value can be changed again in the `init` scope.\n\n### Run several simulations with the same random numbers\n\nThe following code shows how to run several simulations with a specific seed, determined from the experiment agent :\n\n```\nmodel multi_simulations\n\nglobal {\n\tinit {\n\t\tcreate my_species;\n\t}\n}\n\nspecies my_species skills:[moving] {\n\treflex update {\n\t\tdo wander;\n\t}\n\taspect base {\n\t\tdraw circle(2) color:#green;\n\t}\n}\n\nexperiment my_experiment type:gui  {\n\tfloat seedValue <- 10.0;\n\tfloat seed <- seedValue; // force the value of the seed.\n\tinit {\n\t\t// create a second simulation with the same seed as the main simulation\n\t\tcreate simulation with:[seed::seedValue];\n\t}\n\toutput {\n\t\tdisplay my_display {\n\t\t\tspecies my_species aspect:base;\n\t\t}\n\t}\n}\n```\n\nWhen you run this simulation, their execution is exactly similar.\n\n![resources/images/exploringModel/same_simulation_one_agent.png](resources/images/exploringModel/same_simulation_one_agent.png)\n\nLet's try now to add a new species in this model, and to add a parameter to the simulation for the number of agents created for this species.\n\n```\nmodel multi_simulations\n\nglobal {\n\tint number_of_speciesB <- 1;\n\tinit {\n\t\tcreate my_speciesA;\n\t\tcreate my_speciesB number:number_of_speciesB;\n\t}\n}\n\nspecies my_speciesA skills:[moving] {\n\treflex update {\n\t\tdo wander;\n\t}\n\taspect base {\n\t\tdraw circle(2) color:#green;\n\t}\n}\n\nspecies my_speciesB skills:[moving] {\n\treflex update {\n\t\tdo wander;\n\t}\n\taspect base {\n\t\tdraw circle(2) color:#red;\n\t}\n}\n\nexperiment my_experiment type:gui  {\n\tfloat seedValue <- 10.0;\n\tfloat seed <- seedValue; // force the value of the seed.\n\tinit {\n\t\tcreate simulation with:[seed::seedValue,number_of_speciesB::2];\n\t}\n\toutput {\n\t\tdisplay my_display {\n\t\t\tspecies my_speciesA aspect:base;\n\t\t\tspecies my_speciesB aspect:base;\n\t\t}\n\t}\n}\n```\n\nThen you run the experiment, you may find something strange...\n\n![resources/images/exploringModel/same_simulation_2_species.png](resources/images/exploringModel/same_simulation_2_species.png)\n\nEven if the first step seems ok (the greed agent and one of the two red agent is initialized with the same location), the simulation differs completly. You should have expected to have the same behavior for the greed agent in both of the simulation, but it is not the case. The explaination of this behavior is that a random number generator has generated more random numbers in the second simulation than in the first one.\n\nIf you don't understand, here is a short example that may help you to understand better :\n\n```\nmodel multi_simulations\n\nglobal {\n\tint iteration_number <- 1;\n\treflex update {\n\t\tfloat value;\n\t\tloop times:iteration_number {\n\t\t\tvalue<-rnd(10.0);\n\t\t\twrite value;\n\t\t}\n\t\twrite \"cycle \"+cycle+\" in experiment \"+name+\" : \"+value;\n\t}\n}\n\nexperiment my_experiment type:gui  {\n\tfloat seedValue <- 10.0;\n\tfloat seed <- seedValue; // force the value of the seed.\n\tinit {\n\t\tcreate simulation with:[seed::seedValue,iteration_number::2];\n\t}\n\toutput {\n\t}\n}\n```\n\nThe output will be something like that :\n\n```\n7.67003069780383\ncycle 0 in experiment multi_simulations_model0 : 7.67003069780383\n7.67003069780383\n0.22889843360303863\ncycle 0 in experiment multi_simulations_model1 : 0.22889843360303863\n0.22889843360303863\ncycle 1 in experiment multi_simulations_model0 : 0.22889843360303863\n4.5220913306263855\n0.8363180333035425\ncycle 1 in experiment multi_simulations_model1 : 0.8363180333035425\n4.5220913306263855\ncycle 2 in experiment multi_simulations_model0 : 4.5220913306263855\n5.460148568140819\n4.158355846617511\ncycle 2 in experiment multi_simulations_model1 : 4.158355846617511\n0.8363180333035425\ncycle 3 in experiment multi_simulations_model0 : 0.8363180333035425\n1.886091659169562\n4.371253083874633\ncycle 3 in experiment multi_simulations_model1 : 4.371253083874633\n```\n\nWhich means :\n\n| **Cycle** | **Value generated in simulation 0** | **Value generated in simulation 1** \n|:----------|:--------------------------------------------|:--------------------------------------------|\n| **1** | 7.67003069780383     | 7.67003069780383     |\n|  |     | 0.22889843360303863     |\n| **2** | 0.22889843360303863     | 4.5220913306263855     |\n|  |     | 0.8363180333035425     |\n| **3** | 4.5220913306263855     | 5.460148568140819     |\n|  |     | 4.158355846617511     |\n\nWhen writing your models, you have to be aware of this behavior. Remember that each simulation has it's own random number generator.\n\n### Change the RNG\n\nThe RNG (random number generator) can also be changed : `rng` is a string built-in attribute of the experiment (and also of the model). You can choose among the following rng :\n- mersenne (by default)\n- cellular\n- java\n\nThe following model shows how to run 4 simulations with the same seed but with some different RNG :\n\n```\nmodel multi_simulations\n\nglobal {\n\tinit {\n\t\tcreate my_species number:50;\n\t}\n}\n\nspecies my_species skills:[moving] {\n\treflex update {\n\t\tdo wander;\n\t}\n\taspect base {\n\t\tdraw square(2) color:#blue;\n\t}\n}\n\nexperiment my_experiment type:gui  {\n\tfloat seed <- 10.0;\n\tinit {\n\t\tcreate simulation with:[rng::\"cellular\",seed::10.0];\n\t\tcreate simulation with:[rng::\"java\",seed::10.0];\n\t}\n\toutput {\n\t\tdisplay my_display {\n\t\t\tspecies my_species aspect:base;\n\t\t\tgraphics \"my_graphic\" {\n\t\t\t\tdraw rectangle(35,10) at:{0,0} color:#lightgrey;\n\t\t\t\tdraw rng at:{3,3} font:font(\"Helvetica\", 20 , #plain) color:#black;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n[//]: # (endConcept|control_randomness)","url":"wiki/RunSeveralSimulations.md"},"AttachingSkills.md":{"title":" Attaching Skills","content":"[//]: # (startConcept|attaching_skills)\n[//]: # (keyword|concept_skill)\n# Attaching Skills\n\nGAMA allows to attach skills to agents through the facet `skills`. Skills are built-in modules that provide a set of related built-in attributes and built-in actions (in addition to those already proposed by GAMA) to the species that declare them.\n\n## Index\n\n* [The moving skill](#the-moving-skill)\n* [Other skills](#other-skills)\n* [Example of implementation](#example-of-implementation)\n\n## Skills\n\nA declaration of skill is done by filling the `skills` facet in the species definition:\n\n```\nspecies my_species skills: [skill1,skill2] {\n}\n```\n\n[//]: # (keyword|skill_moving)\nA very useful and common skill is the `moving` skill.\n\n```\nspecies my_species skills: [moving] {\n}\n```\n\nOnce your species has the moving skill, it earns automatically the following attributes: `speed`, `heading`, `destination` and the following actions: `move`, `goto`, `follow`, `wander` and `wander_3D`.\n\n### Attributes:\n\n* **`speed`** (float) designs the speed of the agent, in m/s.\n* **`heading`** (int) designs the heading of an agent in degrees, which means that is the maximum angle the agent can turn around each step.\n* **`destination`** (point) is the updated destination of the agent, with respect to its speed and heading. It's a read-only attribute, you can't change its value.\n\n### Actions:\n\n#### **`follow`**\nmoves the agent along a given path passed in the arguments.\n\n* returns: path \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`path`** (path): a path to be followed. \t\t\t\n* **`move_weights`** (map): Weights used for the moving. \t\t\t\n* **`return_path`** (boolean): if true, return the path followed (by default: false)  \n\t \n#### **`goto`**\nmoves the agent towards the target passed in the arguments.\n\n* returns: path \t\t\t\n* **`target`** (agent,point,geometry): the location or entity towards which to move. \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`on`** (graph): graph that restrains this move \t\t\t\n* **`recompute_path`** (boolean): if false, the path is not recompute even if the graph is modified (by default: true) \t\t\t\n* **`return_path`** (boolean): if true, return the path followed (by default: false) \t\t\t\n* **`move_weights`** (map): Weights used for the moving.  \n\t \n#### **`move`**\nmoves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.\n\n* returns: path \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`heading`** (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2) \t\t\t\n* **`bounds`** (geometry,agent): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry  \n\t \n#### **`wander`**\nMoves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.\n\n* returns: void \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`amplitude`** (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2) \t\t\t\n* **`bounds`** (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry  \n\t \n#### **`wander_3D`**\nMoves the agent towards a random location (3D point) at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.\n\n* returns: path \t\t\t\n* **`speed`** (float): the speed to use for this move (replaces the current value of speed) \t\t\t\n* **`amplitude`** (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2) \t\t\t\n* **`z_max`** (int): the maximum altitude (z) the geometry can reach \t\t\t\n* **`bounds`** (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry\t\n\n### Other skills\n\nA lot of other skills are available. Some of them can be [built in skills](BuiltInSkills), integrated by default in GAMA, other are linked to [additional plugins](Extension).\n\nThis is the list of skills:\n`Advanced_driving`, `communication`, `driving`, `GAMASQL`, `graphic`, `grid`, `MDXSKILL`, `moving`, `moving3D`, `physical3D`, `skill_road`, `skill_road`, `skill_road_node`, `SQLSKILL`\n\n### Example\n\nWe can now build a model using the skill moving. Let's design 2 species, one is \"species_red\", the other is \"species_green\". \nSpecies_green agents are moving randomly with a certain speed and a certain heading.\nSpecies_red agents wait for a species_green agent to be in a certain range of distance. Once it is the case, the agent move toward the species_green agent. A line link the red_species agent and its target.\n\n![images/green_and_red_species.png](resources/images/manipulateBasicSpecies/green_and_red_species.png) \n\nHere is an example of implementation:\n\n```\nmodel green_and_red_species\n\nglobal{\n\tfloat distance_to_intercept <- 10.0;\n\tint number_of_green_species <- 50;\n\tint number_of_red_species <- 50;\n\tinit {\n\t\tcreate speciesA number:number_of_green_species;\n\t\tcreate speciesB number:number_of_red_species;\n\t}\n}\n\nspecies speciesA skills:[moving] {\n\tinit {\n\t\tspeed <- 1.0;\n\t}\n\treflex move {\n\t\tdo wander amplitude:90;\n\t}\n\taspect default {\n\t\tdraw circle(1) color:#green;\n\t}\n}\n\nspecies speciesB skills:[moving] {\n\tspeciesA target;\n\tinit {\n\t\tspeed <- 0.0;\n\t\theading <- 90;\n\t}\n\treflex search_target when:target=nil {\n\t\task speciesA at_distance(distance_to_intercept) {\n\t\t\tmyself.target <- self;\n\t\t}\n\t}\n\treflex follow when:target!=nil {\n\t\tspeed <- 0.8;\n\t\tdo goto target:target;\n\t}\n\taspect default {\n\t\tdraw circle(1) color:#red;\n\t\tif (target!=nil) {\n\t\t\tdraw polyline([self.location,target.location]) color:#black;\n\t\t}\n\t}\n}\n\nexperiment my_experiment type:gui\n{\n\toutput{\n\t\tdisplay myDisplay {\n\t\t\tspecies speciesA aspect:default;\n\t\t\tspecies speciesB aspect:default;\n\t\t}\n\t}\n}\n```\n[//]: # (endConcept|attaching_skills)","url":"wiki/AttachingSkills.md"},"DefiningActionsAndBehaviors.md":{"title":" Defining actions and behaviors","content":"[//]: # (startConcept|actions_and_behaviors)\n[//]: # (keyword|concept_action)\n[//]: # (keyword|concept_reflex)\n# Defining actions and behaviors\n[//]: # (keyword|concept_behavior)\n\nBoth actions and behaviors can be seen as methods in OOP. They can be defined in any species.\n\n## Index\n\n* [Action](#action)\n  * [Declare an action](#declare-an-action)\n  * [Call an action](#call-an-action)\n* [Behavior](#behavior)\n* [Example](#example)\n\n## Action\n\n### Declare an action\n\n[//]: # (keyword|statement_action)\nAn action is a function run by an instance of species. An action can return a value (in that case, the type of return has to be specify just before the name of the action), or not (in that case, you just have to put the keyword `action` before the name of the action).\n\n```\nspecies my_species {\n\tint action_with_return_value {\n\t\t// statements...\n\t\treturn 1;\n\t}\n\taction action_without_return_value {\n\t\t// statements...\n\t}\n}\n```\n\nArguments can also be mandated in your action. You have to specify the type and the name of the argument:\n\n```\naction action_without_return_value (int argA, float argB) {\n\t// statements...\n}\n```\n\nIf you want to have some optional arguments in the list, you can give some by default values to turn them optional. Nb: it is better to define the optional arguments at the end of the list of argument.\n\n```\naction my_action (int argA, float argB <- 5.1, point argC <- {0,0}) {\n\t// statements...\n}\n```\n\n### Call an action\n\n[//]: # (keyword|statement_do)\nTo call an action, you have to use the statement `do`. You can use the statement do different ways:\n\n* With facets : after specifying the name of your action, you can specify the values of your arguments as if the name of your arguments were facets:\n\n```\ndo my_action argA:5 argB:5.1;\n```\n\n* With parenthesis : after specifying the name of your action, you can specify the values of your arguments in the same order they were declared, between parenthesis:\n\n```\ndo my_action (5,5.1);\n```\n\nWe incite you to promote the second writing. To catch the returned value, you can also skip the do statement, and store the value directly in a temporary variable:\n\n```\nint var1 <- my_action(5,5.1);\n```\n\n## Behavior\n\n[//]: # (keyword|statement_reflex)\nA behavior, or reflex, is an action which is called automatically at each time step by an agent.\n\n```\nreflex my_reflex {\n\twrite (\"Executing the inconditional reflex\");\n// statements...\n}\n```\n\nWith the facet when, this reflex is only executed when the boolean expression evaluates to true. It is a convenient way to specify the behavior of agents.\n\n```\nreflex my_reflex when:flip(0.5) {\n\twrite (\"Executing the conditional reflex\");\n// statements...\n}\n```\n\nReflex, unlike actions, cannot be called from another context. But a reflex can, of course, call actions.\n\nNb : Init is a special reflex, that occurs only when the agent is created.\n\n## Example\n\nTo practice a bit with those notions, we will build an easy example. Let's build a model with a species balloon that has 2 attributes: balloon_size (float) and balloon_color (rgb). Each balloon has a random position and color, his aspect is a sphere. Each step, a balloon has a probability to spawn in the environment. Once a balloon is created, its size is 10cm, and each step, the size increases by 1cm. Once the balloon size reaches 50cm, the balloon has a probability to burst. Once 10 balloons are destroyed, the simulation stops. The volume of each balloon is displayed in the balloon position.\n\n![images/burst_the_baloon.png](resources/images/manipulateBasicSpecies/burst_the_baloon.png) \n\nHere is one of the multiple possible implementation:\n\n```\nmodel burst_the_baloon\n\nglobal{\n\tfloat worldDimension <- 5#m;\n\tgeometry shape <- square(worldDimension);\n\tint nbBaloonDead <- 0;\n\n\treflex buildBaloon when:(flip(0.1)) {\n\t\tcreate species:balloon number:1;\n\t}\n\t\n\treflex endSimulation when:nbBaloonDead>10 {\n\t\tdo halt;\n\t}\n}\n\nspecies balloon {\n\tfloat balloon_size;\n\trgb balloon_color;\n\tinit {\n\t\tballoon_size <- 0.1;\n\t\tballoon_color <- rgb(rnd(255),rnd(255),rnd(255));\n\t}\n\n\treflex balloon_grow {\n\t\tballoon_size <- balloon_size + 0.01;\n\t\tif (balloon_size > 0.5) {\n\t\t\tif (flip(0.2)) {\n\t\t\t\tdo balloon_burst;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfloat balloon_volume (float diameter) {\n\t\tfloat exact_value <- 2/3*#pi*diameter^3;\n\t\tfloat round_value <- (round(exact_value*1000))/1000;\n\t\treturn round_value;\n\t}\n\t\n\taction balloon_burst {\n\t\twrite \"the baloon is dead !\";\n\t\tnbBaloonDead <- nbBaloonDead + 1;\n\t\tdo die;\n\t}\n\t\n\taspect balloon_aspect {\n\t\tdraw circle(balloon_size) color:balloon_color;\n\t\tdraw text:string(balloon_volume(balloon_size)) color:#black;\n\t}\n}\n\nexperiment my_experiment type:gui\n{\n\toutput{\n\t\tdisplay myDisplay {\n\t\t\tspecies balloon aspect:balloon_aspect;\n\t\t}\n\t}\n}\n```\n[//]: # (endConcept|actions_and_behaviors)","url":"wiki/DefiningActionsAndBehaviors.md"},"GlobalSpecies.md":{"title":" The global species","content":"[//]: # (startConcept|global_species)\n# The global species\n[//]: # (keyword|concept_global)\n\nWe will start this chapter by studying a special species: the global species. \nIn the global species you can define the attributes, actions and behaviors that describe the world agent. There is one unique world agent per simulation: it is this agent that is created when a user runs an experiment and that initializes the simulation through its **init** scope. The global species is a species like other and can be manipulated as them. In addition, the global species automatically inherits from several of built-in variables and actions. Note that a specificity of the global species is that all its attributes can be referred by all agents of the simulation.\n\n## Index\n\n* [Declaration](#declaration)\n* [Environment Size](#environment-size)\n* [Built-in Attributes](#built-in-attributes)\n* [Built-in Actions](#built-in-actions)\n* [The init statement](#the-init-statement)\n\n## Declaration\n\nA GAMA model contains a unique global section that defines the global species.\n\n```\nglobal {\n\t// definition of global attributes, actions, behaviours\n}\n```\n\n[//]: # (keyword|concept_torus)\n`global` can use facets, such as the `torus` facet, to make the environment a torus or not (if it is a torus, all the agents going out of the environment will appear in the other side. If it's not, the agents won't be able to go out of the environment). By default, the environment is not a torus.\n\n![images/torus.png](resources/images/manipulateBasicSpecies/torus.png) \n\n```\nglobal torus:true {\n\t// definition of global attributes, actions, behaviours\n}\n```\n\nOther facets such as `control` or `schedules` are also available, but we will explain them later.\n\nDirectly in the `global` scope, you have to declare all your global attributes (can be seen as \"static members\" in Java or C++). To declare them, proceed exactly as for declaring basic variables. Those attributes are accessible wherever you want inside the species scope.\n\n## Environment size\n\n[//]: # (keyword|concept_shape)\n[//]: # (keyword|concept_geometry)\n[//]: # (keyword|type_geometry)\n[//]: # (keyword|concept_dimension)\nIn the global context, you have to define a size and a shape for your environment. In fact, an attribute already exists for the global species: it's called shape, and its type is a geometry. By default, shape is equal to a 100m*100m square. You can change the geometry of the shape by affecting another value:\n\n```\ngeometry shape <- circle(50#mm);\ngeometry shape <- rectangle(10#m,20#m);\ngeometry shape <- polygon([{1°m,2°m},{3°m,50°cm},{3.4°m,60°dm}]);\n```\n\nnb: there are just examples. Try to avoid mixing dimensions! If no dimensions are specify, it'll be meter by default.\n\n## Built-in attributes\n\n[//]: # (keyword|concept_attribute)\nSome attributes exist by default for the global species. The attribute shape is one of them (refers to the shape of the environment). Here is the list of the other built-in attributes:\n\nLike the other attributes of the global species, global built-in attributes can be accessed (and sometimes modified) by the world agent and every other agents in the model.\n\n### world\n* represents the sole instance of the model species (i.e. the one defined in the `global` section). It is accessible from everywhere (including experiments) and gives access to built-in or user-defined global attributes and actions.\n\n[//]: # (keyword|concept_cycle)\n### cycle\n* integer, read-only, designates the (integer) number of executions of the simulation cycles. Note that the first cycle is the cycle with number 0.\n\nTo learn more about time, please read the [recipe about dates](ManipulateDates).\n\n### step\n* float,  is the length, in model time, of an interval between two cycles, in seconds. Its default value is 1 (second). Each turn, the value of time is incremented by the value of step. The definition of step must be coherent with that of the agents' variables like speed. The use of time unit is particularly relevant for its definition.\n\nTo learn more about time, please read the [recipe about dates](ManipulateDates).\n\n```\nglobal {\n...\n    float step <- 10°h;\n...\n}\n```\n\n[//]: # (keyword|concept_time)\n### time\n* float, read-only, represents the current simulated time in seconds (the default unit). It is time in the model time. Begins at zero. Basically, we have:   **time = cycle `*` step**  .\n\n```\nglobal {\n...\n    int nb_minutes function: { int(time / 60)};\n...\n}\n```\n\nTo learn more about time, please read the [recipe about dates](ManipulateDates).\n\n### duration\n* string, read-only, represents the value that is equal to the duration **in real machine time** of the last cycle.\n\n### total\\_duration\n* string, read-only, represents the sum of duration since the beginning of the simulation.\n\n### average\\_duration\n* string, read-only, represents the average of duration since the beginning of the simulation.\n\n[//]: # (keyword|concept_system)\n### machine\\_time\n* float, read-only, represents the current machine time in milliseconds.\n\n### agents\n* list, read-only, returns a list of all the agents of the model that are considered as \"active\" (i.e. all the agents with behaviors, excluding the places). Note that obtaining this list can be quite time consuming, as the world has to go through all the species and get their agents before assembling the result. For instance, instead of writing something like:\n\n```\nask agents of_species my_species {\n...\n}\n```\n\none would prefer to write (which is much faster):\n\n```\nask my_species {\n...\n}\n```\nNote that any agent has the `agents` attribute, representing the agents it contains. So to get all the agents of the simulation, we need to access the `agents` of the world using: `world.agents`.\n\n\n\n\n[//]: # (keyword|concept_action)\n## Built-in Actions\nThe global species is provided with two specific actions.\n\n[//]: # (keyword|concept_halt)\n### halt\n* stops the simulation.\n\n```\nglobal {\n     ...\n     reflex halting when: empty (agents) {\n            do halt;\n     }\n}\n```\n\n[//]: # (keyword|concept_pause)\n### pause\n* pauses the simulation, which can then be continued by the user.\n\n```\nglobal {\n     ...\n     reflex toto when: time = 100 {\n            do pause;\n     }\n}\n```\n\n[//]: # (keyword|concept_init)\n## The init statement\n\nAfter declaring all the global attributes and defining your environment size, you can define an initial state (before launching the simulation). Here, you normally initialize your global variables, and you instantiate your species. We will see in the next session how to initialize a regular species. \n[//]: # (endConcept|global_species)","url":"wiki/GlobalSpecies.md"},"Inheritance.md":{"title":" Inheritance","content":"[//]: # (startConcept|inheritance)\n[//]: # (keyword|concept_inheritance)\n# Inheritance\n\nAs for multiple programming language, inheritance can be used in GAML. It is used to structure better your code, when you have some complex models.\n\n## Index\n\n* [Mother species / child species](#mother-species-/-child-species)\n* [Virtual actions](#virtual-actions)\n* [Get all the subspecies from a species](#get-all-the-subspecies-from-a-species)\n\n## Mother species / child species\n\nTo make a species inherit from a mother species, you have to add the facet `parent`, and specify the mother species.\n\n```\nspecies mother_species {\n}\n\nspecies child_species parent:mother_species {\n}\n```\n\nThus, all the attributes, actions and reflex of the mother species are inherited to the child species.\n\n```\nspecies mother_species {\n\tint attribute_A;\n\taction action_A {}\n}\n\nspecies child_species parent:mother_species {\n\tinit {\n\t\tattribute_A <- 5;\n\t\tdo action_A;\n\t}\n}\n```\n\nIf the mother species has a particular skill, its children will inherit all the attributes and actions.\n\n```\nspecies mother_species skills:[moving] {\n}\n\nspecies child_species parent:mother_species {\n\tinit {\n\t\tspeed <- 2.0;\n\t}\n\treflex update {\n\t\tdo wander;\n\t}\n}\n```\n\nYou can redefine an action or a reflex by declaring an action or a reflex with the same name.\n\n## Virtual action\n\nYou have also the possibility to declare a virtual action in the mother species, which means an action without implementation, by using the facet `virtual`:\n\n```\naction virtual_action virtual:true;\n```\n\nWhen you declare an action as virtual in a species, this species becomes abstract, which means you cannot instantiate agent from it. All the children of this species has to implement this virtual action.\n\n```\nspecies virtual_mother_species {\n\taction my_action virtual:true;\n}\n\nspecies child_species parent:virtual_mother_species {\n\taction my_action {\n\t\t// some statements\n\t}\n}\n```\n\n## Get all the subspecies from a species\n\nIf you declare a \"mother\" species, you create a \"child\" agent, then \"mother\" will return the population of agents \"mother\" and **not** the population of agents \"child\", as it is shown in the following example : \n```\nglobal\n{\n    init {\n        create child number:2;\n        create mother number:1;\n    }\n    reflex update {\n        write length(mother); // will write 1 and not 3\n    }\n}\n\nspecies mother {}\n\nspecies child parent:mother {}\n```\n\nWe reminds you that \"subspecies\" is a built-in attribute of the agent. Using this attribute, you can easily get all the subspecies agents of the mother species by writing the following gaml function : \n\n```\nglobal\n{\n    init {\n        create child number:2;\n        create mother number:1;\n    }\n    reflex update {\n        write length(get_all_instances(mother)); // will write 3 (1+2)\n    }\n    list<agent> get_all_instances(species<agent> spec) {\n        return spec.population +  spec.subspecies accumulate (get_all_instances(each));\n    }\n}\n\nspecies mother {}\n\nspecies child parent:mother {}\n```\n[//]: # (endConcept|inheritance)","url":"wiki/Inheritance.md"},"InteractionBetweenAgents.md":{"title":" Interaction between agents","content":"[//]: # (startConcept|interaction_between_agents)\n# Interaction between agents\n\nIn this part, we will learn how interaction between agents works. We will also present you a bunch of operators useful for your modelling. \n\n## Index\n\n* [The ask statement](#the-ask-statement)\n* [Pseudo variables](#pseudo-variables)\n* [Some useful interaction operators](#some-useful-interaction-operators)\n* [Example](#example)\n\n## The ask statement\n\n[//]: # (keyword|statement_ask)\nThe `ask` statement can be used in any reflex or action scope. It is used to specify the interaction between the instances of your species and the other agents. You only have to specify the species of the agents you want to interact with. Here are the different ways of calling the ask statement:\n\n-\tIf you want to interact with one particular agent (for example, defined as an attribute of your species):\n\n```\nspecies my_species {\n\tagent target;\n\treflex update {\n\t\task target {\n\t\t\t// statements\n\t\t}\n\t}\n}\n```\n\n-\tIf you want to interact with a group of agents:\n\n```\nspecies my_species {\n\tlist<agent> targets;\n\treflex update {\n\t\task targets {\n\t\t\t// statements\n\t\t}\n\t}\n}\n```\n\n-\tIf you want to interact with agents, as if they were instance of a certain species (can raise an error if it's not the case!):\n\n```\nspecies my_species {\n\tlist<agent> targets;\n\treflex update {\n\t\task targets as:my_species {\n\t\t\t// statements\n\t\t}\n\t}\n}\n```\n\n-\tIf you want to interact with all the agent of a species:\n\n```\nspecies my_species {\n\tlist<agent> targets;\n\treflex update {\n\t\task other_species {\n\t\t\t// statements\n\t\t}\n\t}\n}\n\nspecies other_species {\n}\n```\n\nNote that you can use the attribute _population_ of `species` if you find it more explicit:\n\n```\nask other_species.population\n```\n\n-\tIf you want to interact with all the agent of a particular species from a list of agents (for example, using the global variable \"agents\"):\n\n```\nspecies my_specie {\n\treflex update {\n\t\task species of_species my_specie {\n\t\t\t// statements\n\t\t}\n\t}\n}\n```\n\n## Pseudo variables\n\n[//]: # (keyword|concept_pseudo_variable)\nOnce you are in the ask scope, you can use some pseudo variables to refer to the receiver agent (the one specify just after the ask statement) or the transmitter agent (the agent which is asking). \nWe use the pseudo variable `self` to refer to the receiver agent, and the pseudo variable `myself` to refer to the transmitter agent. The pseudo variable `self` can be omitted when calling actions or attributes.\n\n```\nspecies speciesA {\n\tinit {\n\t\tname <- \"speciesA\";\n\t}\n\treflex update {\n\t\task speciesB {\nwrite name; // output : \"speciesB\"\t\t\t\nwrite self.name; // output : \"speciesB\"\n\t\t\twrite myself.name; // output : \"speciesA\"\n\t\t}\n\t}\n}\n\nspecies speciesB {\n\tinit {\n\t\tname <- \"speciesB\";\n\t}\n}\n```\n\nNow, if we introduce a third species, we can write an `ask` statement inside another. \n\n```\nspecies speciesA {\n\tinit {\n\t\tname <- \"speciesA\";\n\t}\n\treflex update {\n\t\task speciesB {\n\t\t\twrite self.name; // output : \"speciesB\"\n\t\t\twrite myself.name; // output : \"speciesA\"\n\t\t\task speciesC {\n\t\t\t\twrite self.name; // output : \"speciesC\"\n\t\t\t\twrite myself.name; // output : \"speciesB\"\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies speciesB {\n\tinit {\n\t\tname <- \"speciesB\";\n\t}\n}\n\nspecies speciesC {\n\tinit {\n\t\tname <- \"speciesC\";\n\t}\n}\n```\n\nNb: try to avoid multiple imbrications of ask statements. Most of the time, there is another way to do the same thing.\n\n## Some useful interaction operators\n\n[//]: # (keyword|operator_at_distance)\nThe operator `at_distance` can be used to know the list of agents that are in a certain distance from another agent.\n\n```\nspecies my_species {\n\treflex update {\n\t\tlist<agent> neighbours <- agents at_distance(5);\n\t\t// neighbours contains the list of all the agents located at a distance <= 5 from the caller agent.\n\t}\n}\n```\n\n[//]: # (keyword|operator_closest_to)\nThe operator `closest_to` returns the closest agent of a position among a container.\n\n```\nspecies my_species {\n\treflex update {\n\t\tagent agentA <- agents closest_to(self);\n\t\t// agentA contains the closest agent from the caller agent.\n\t\tagent agentB <- other_specie closest_to({2,3});\n\t\t// agentB contains the closest instance of other_specie from the location {2,3}.\n\t}\n}\n\nspecies other_specie {\n}\n```\n\n## Example\n\n[//]: # (keyword|operator_polyline)\nTo practice those notions, here is a short basic example. Let's build a model with a fix number of agents with a circle shape. They can move randomly on the environment, and when they are close enough from another agent, a line is displayed between them. This line is destroyed when the distance between the two agents is too important.\nHint: use the operator `polyline` to construct a line. List the points between angle brackets `[]`.\n\n![images/connect_the_neighbours.png](resources/images/manipulateBasicSpecies/connect_the_neighbours.png) \n\nHere is one example of implementation:\n\n```\nmodel connect_the_neighbours\n\nglobal{\n\tfloat speed <- 0.2;\n\tfloat distance_to_intercept <- 10.0;\n\tint number_of_circle <- 100;\n\tinit {\n\t\tcreate my_species number:number_of_circle;\n\t}\n}\n\nspecies my_species {\n\treflex move {\n\t\tlocation <- {location.x+rnd(-speed,speed),location.y+rnd(-speed,speed)};\n\t}\n\taspect default {\n\t\tdraw circle(1);\n\t\task my_species at_distance(distance_to_intercept) {\n\t\t\tdraw polyline([self.location,myself.location]) color:#black;\n\t\t}\n\t}\n}\n\nexperiment my_experiment type:gui\n{\n\toutput{\n\t\tdisplay myDisplay {\n\t\t\tspecies my_species aspect:default;\n\t\t}\n\t}\n}\n```\n[//]: # (endConcept|interaction_between_agents)","url":"wiki/InteractionBetweenAgents.md"},"RegularSpecies.md":{"title":" Regular species","content":"[//]: # (startConcept|regular_species)\n[//]: # (keyword|concept_species)\n# Regular species\n\nRegular species are composed of attributes, actions, reflex, aspect etc... They describes the behavior of our agents. You can instantiate as much as you want agents from a regular species, and you can define as much as you want different regular species. You can see a species as a \"class\" in OOP.\n\n## Index\n\n* [Declaration](#declaration)\n* [Built-in Attributes](#built-in-attributes)\n* [Built-in Actions](#built-in-actions)\n* [The init statement](#the-init-statement)\n* [The aspect statement](#the-aspect-statement)\n* [Instantiate an agent](#instantiate-an-agent)\n\n## Declaration\n\nThe regular species declaration starts with the keyword `species` followed by the name (or followed by the facet `name:`) :\n\n```\nspecies my_specie {\n}\n```\n\nor:\n\n```\nspecies name:my_specie {\n}\n```\n\n[//]: # (keyword|concept_attribute)\nDirectly in the \"species\" scope, you have to declare all your attributes (or \"member\" in OOP). You declare them exactly the way you declare basic variables. Those attributes are accessible wherever you want inside the species scope.\n\n```\nspecies my_specie {\n\tint variableA;\n}\n```\n\n## Built-in attributes\n\n[//]: # (keyword|concept_agent_location)\n[//]: # (keyword|concept_shape)\nAs for the global species, some attributes exist already by default in a regular species. Here is the list of built-in attributes:\n\n* **name** (type: string) is used to name your agent. By default, the name is equal to the name of your species + an incremental number. This name is the one visible on the species inspector.\n* **location** (type: point) is used to control the position of your agent. It refers to the center of the envelop of the shape associated to the agent.\n* **shape** (type: geometry) is used to describe the geometry of your agent. If you want to use some intersection operator between agents for instance, it is this geometry that is computed (nb : it can be totally different from the aspect you want to display for your agent !). By default, the shape is a point.\n* **host** (type: agent) is used when your agent is part of another agent. We will see this concept a bit further, in the topic [multi-level architecture](MultiLevelArchitecture).\n\nAll those 4 built-in attributes can be accessed in both reading and writing very easily:\n\n```\nspecies my_species {\n\tinit {\n\t\tname <- \"custom_name\";\n\t\tlocation <- {0,1};\n\t\tshape <- rectangle(5,1);\n\t}\n}\n```\n\nAll those built-in attributes are attributes of an agent (an instance of a species). Species has also their own attributes, which can be accessed with the following syntax (read only) :\n\n```\nname_of_your_species.attribute_you_want\n```\n\nNotice that the world agent is also an agent ! It has all the built-in attributes declared above. The world agent is defined inside the `global` scope. From the `global` scope then, you can for example access to the center of the envelop of the world shape :\n\n```\nglobal\n{\n    init {\n    \twrite location; // writes {50.0,50.0,0.0}\n    }\n}\n```\n\nHere is the list of those attributes:\n\n* **name** (type: string) returns the name of your species\n* **attributes** (type: list of string) returns the list of the names of the attributes of your species\n* **population** (type: list) returns the list of agent that belong to it \n* **subspecies** (type: list of string) returns the list of species that inherit directly from this species (we will talk about the concept of [inheritance](Inheritance) later)\n* **parent** (type: species) returns its parent species if it belongs to the model, or `nil` otherwise (we will talk about the concept of [inheritance](Inheritance) later)\n\n[//]: # (keyword|concept_action)\n## Built-in action\n\nSome actions are define by default for a minimal agent. We already saw quickly the action `write`, used to display a message in the console.\nAnother very useful built-in action is the action `die`, used to destroy an agent.\n\n```\nspecies my_species{\n    reflex being_killed {\n        do die;\n    }\n}\n```\n\nHere is the list of the other built-in actions which you can find in the documentation: debug, message, tell.\n\n[//]: # (keyword|concept_init)\n## The init statement\n\nAfter declaring all the attributes of your species, you can define an initial state (before launching the simulation). It can be seen as the \"constructor of the class\" in OOP.\n\n```\nspecies my_species {\n\tint variableA;\n\tinit {\n\t\tvariableA <- 5;\n\t}\n}\n```\n\n[//]: # (keyword|statement_aspect)\n## The aspect statement\n\nInside each species, you can define one or several aspects. This scope allows you to define how you want your species to be represented in the simulation.\nEach aspect has a special name (so that they can be called from the experiment). Once again, you can name your aspect by using the facet `name:`, or simply by naming it just after the `aspect` keyword.\n\n```\nspecies my_species {\n\taspect standard_aspect { // or \"aspect name:standard_aspect\"\n\t}\n}\n```\n\n[//]: # (keyword|statement_draw)\nYou can then define your aspect by using the statement `draw`. You can then choose a geometry for your aspect (facet `geometry`), a color (facet `color`), an image (facet `image`), a text (facet `text`)... We invite you to read the documentation about the draw statement to know more about.\n\n```\nspecies name:my_species {\n\taspect name:standard_aspect {\n\t\tdraw geometry:circle(1) color:#blue;\n\t}\n}\n```\n\nIn the experiment scope, you have to tell the program to display a particular species with a particular aspect (nb : you can also choose to display your species with several aspect in the same display). \n\n```\nexperiment my_experiment type:gui\n{\n\toutput{\n\t\tdisplay my_display {\n\t\t\tspecies my_species aspect:standard_aspect;\n\t\t}\n\t}\n}\n```\n\nNow there is only one thing missing to display our agent: we have to instantiate them.\n\n## Instantiate an agent\n\n[//]: # (keyword|statement_create)\nAs already said quickly in the last session, the instantiation of the agents is most often in the init scope of the global species (this is not mandatory of course. You can instantiate your agents from an action / behavior of any specie). Use the statement `create` to instantiate an agent. \nThe facet species is used to specify which species you want to instantiate. \nThe facet number is used to tell how many instantiation you want. \nThe facet with is used to specify some default values for some attributes of your instance. For example, you can specify the location.\n\n```\nglobal{\n\tinit{\n\t\tcreate species:my_species number:1 with:(location:{0,0},vA:8);\n\t}\n}\n\n\nspecies name:my_specie {\n\tint vA;\n}\n```\n\nHere is an example of model that display an agent with a circle aspect in the center of the environment:\n\n```\nmodel display_one_agent\n\nglobal{\n\tfloat worldDimension <- 50#m;\n\tgeometry shape <- square(worldDimension);\n\tinit{\n\t\tpoint center <- {(worldDimension/2),(worldDimension/2)};\n\t\tcreate species:my_species number:1 with:(location:center);\n\t}\n}\n\nspecies name:my_species {\n\taspect name:standard_aspect {\n\t\tdraw geometry:circle(1#m);\n\t}\n}\n\nexperiment my_experiment type:gui\n{\n\toutput{\n\t\tdisplay myDisplay {\n\t\t\tspecies my_species aspect:standard_aspect;\n\t\t}\n\t}\n}\n```\n[//]: # (endConcept|regular_species)","url":"wiki/RegularSpecies.md"},"ControlArchitecture.md":{"title":" Control Architectures","content":"[//]: # (keyword|concept_architecture)\n# Control Architectures\n\nGAMA allows to attach built-in control architecture to agents.\n\n[//]: # (keyword|concept_behavior)\nThese control architectures will give the possibility to the modeler to use for a species a specific control architecture in addition to the [common behavior structure](DefiningActionsAndBehaviors#Behaviour). Note that only one control architecture can be used per species.\n\nThe attachment of a control architecture to a species is done through the facets `control`.\n\nFor example, the given code allows to attach the `fsm` control architecture to the dummy species.\n```\nspecies dummy control: fsm {\n}\n```\n\nGAMA integrates several agent control architectures that can be used in addition to the common behavior structure:\n\n  * [fsm](#finite-state-machine): finite state machine based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization)\n  * [weighted\\_tasks](#task-based): task-based control architecture. At any given time, only the task only the task with the maximal weight is executed.\n  * [sorted\\_tasks](#task-based): task-based control architecture. At any given time, the tasks are all executed in the order specified by their weights (highest first).\n  * [probabilistic\\_tasks](#task-based): task-based control architecture. This architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen at each step.\n  * [user\\_only](DefiningUserInteraction#user-control-architecture): allows users to take control over an agent during the course of the simulation. With this architecture, only the user control the agents (no reflexes).\n  * [user\\_first](user-control-architecture): allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed before the agent reflexes.\n  * [user\\_last](user-control-architecture): allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed after the agent reflexes.\n  \n## Index\n\n* [Finite State Machine](#finite-state-machine)\n  * [Declaration](#declaration)\n  * [State](#state)\n* [Task Based](#task-based)\n  * [Declaration](#declaration)\n  * [Task](#task)\n* [User Control Architecture](#user-control-architectures)\n  * [user_only, user_first, user_last](#user_only-user_first-user_last)\n  * [user_panel](#user_panel)\n  * [user_controlled](#user_controlled)\n* [Other Control Architectures](#other-control-architectures)\n\n[//]: # (startConcept|finite_state_machine)\n[//]: # (keyword|architecture_fsm)\n[//]: # (keyword|concept_fsm)\n## Finite State Machine\n\n**FSM (Finite State Machine)** is a finite state machine based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization).\n\nAt each time step, the agent will:\n\n  * first (only if he just entered in its current state) execute statement embedded in the `enter` statement,\n  * then all the statements in the state statement\n  * it will evaluate the condition of each embedded transition statements. If one condition is fulfilled, the agent execute the embedded statements\n\nNote that an agent executes only one state at each step.\n\n### Declaration\n\nUsing the FSM architecture for a species require to use the **control** facet:\n\n```\nspecies dummy control: fsm {\n   ...\n}\n```\n\n### State\n\n#### Attributes\n* initial: a boolean expression, indicates the initial state of agent.\n* final: a boolean expression, indicates the final state of agent.\n\n#### Sub Statements\n* enter: a sequence of statements to execute upon entering the state.\n* exit: a sequence of statements to execute right before exiting the state. Note that the `exit` statement will be executed even if the fired transition points to the same state (the FSM architecture in GAMA does not implement 'internal transitions' like the ones found in UML state charts: all transitions, even \"self-transitions\", follow the same rules).\n* transition: allows to define a condition that, when evaluated to true, will designate the next state of the life cycle. Note that the evaluation of transitions is short-circuited: the first one that evaluates to true, in the order in which they have been defined, will be followed. I.e., if two transitions evaluate to true during the same time step, only the first one will be triggered.\n\nThings worth to be mentioned regarding these sub-statements:\n\n* Obviously, only one definition of exit and enter is accepted in a given state\n* Transition statements written in the middle of the state statements will only be evaluated at the end, so, even if it evaluates to true, the remaining of the statements found after the definition of the transition will be nevertheless executed. So, despite the appearance, a transition written somewhere in the sequence will \"not stop\" the state at that point (but only at the end).\n\n#### Definition\nA state can contain several statements that will be executed, at each time step, by the agent. There are three exceptions to this rule:\n\n1. statements enclosed in `enter` will only be executed when the state is entered (after a transition, or because it is the initial state).\n1. Those enclosed in `exit` will be executed when leaving the state as a result of a successful transition (and before the statements enclosed in the transition).\n1. Those enclosed in a transition will be executed when performing this transition (but after the `exit` sequence has been executed).\n\nFor example, consider the following example:\n\n```\nspecies dummy control: fsm {       \n\tstate state1 initial: true { \n\t\twrite string(cycle) + \":\" + name + \"->\" + \"state1\";\n\t\ttransition to: state2 when: flip(0.5) {\n\t\t\twrite string(cycle) + \":\" + name + \"->\" + \"transition to state1\";\n\t\t}\n\t\ttransition to: state3 when: flip(0.2) ; \n\t}\n\n\tstate state2 {\n\t\twrite string(cycle) + \":\" + name + \"->\" + \"state2\";\n\t\ttransition to: state1 when: flip(0.5) { \n\t\t\twrite string(cycle) + \":\" + name + \"->\" + \"transition to state1\";\n\t\t}\n\t\texit {\n\t\t\twrite string(cycle) + \":\" + name + \"->\" + \"leave state2\";\n\t\t}\n\t}\n\t\n\tstate state3 {\n\t\twrite string(cycle) + \":\" + name + \"->\" + \"state3\";\n\t\ttransition to: state1 when: flip(0.5)  {\n\t\t\twrite string(cycle) + \":\" + name + \"->\" + \"transition to state1\";\n\t\t}\n\t\ttransition to: state2 when: flip(0.2)  ;\n\t}   \n}\n```\n\nthe dummy agents start at _state1_. At each simulation step they have a probability of 0.5 to change their state to _state2_. If they do not change their state to _state2_, they have a probability of 0.2 to change their state to _state3_. In _state2_, at each simulation step, they have a probability of 0.5 to change their state to _state1_. At last, in _step3_, at each simulation step they have a probability of 0.5 to change their state to _state1_. If they do not change their state to _state1_, they have a probability of 0.2 to change their state to _state2_.\n\nHere a possible result that can be obtained with one dummy agent:\n\n```\n0:dummy0->state1\n0:dummy0->transition to state1\n1:dummy0->state2\n2:dummy0->state2\n2:dummy0->leave state2\n2:dummy0->transition to state1\n3:dummy0->state1\n3:dummy0->transition to state1\n4:dummy0->state2\n5:dummy0->state2\n5:dummy0->leave state2\n5:dummy0->transition to state1\n6:dummy0->state1\n7:dummy0->state3\n8:dummy0->state2\n```\n[//]: # (endConcept|finite_state_machine)\n\n[//]: # (startConcept|task_based)\n[//]: # (keyword|concept_task_based)\n[//]: # (keyword|architecture_probabilistic_tasks)\n[//]: # (keyword|architecture_weighted_tasks)\n[//]: # (keyword|architecture_sorted_tasks)\n## Task Based\n\nGAMA integrated several **task-based** control architectures. Species can define any number of tasks within their body. At any given time, only one or several tasks are executed according to the architecture chosen:\n\n  * **weighted\\_tasks** : in this architecture, only the task with the maximal weight is executed.\n  * **sorted\\_tasks** : in this architecture, the tasks are all executed in the order specified by their weights (biggest first)\n  * **probabilistic\\_tasks**: this architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen each step.\n\n\n### Declaration\n\n\nUsing the Task architectures for a species require to use the **control** facet:\n\n```\nspecies dummy control: weighted_tasks {\n   ...\n}\n```\n\n\n```\nspecies dummy control: sorted_tasks {\n   ...\n}\n```\n\n\n```\nspecies dummy control: probabilistic_tasks {\n   ...\n}\n```\n\n\n\n### Task\n\n#### Sub elements\nBesides a sequence of statements like reflex, a task contains the following sub elements:\n  * weight: Mandatory. The priority level of the task.\n\n#### Definition\nAs reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.\n\n\nFor example, consider the following example:\n```\nspecies dummy control: weighted_tasks {   \n\ttask task1 weight: cycle mod 3 { \n\t\twrite string(cycle) + \":\" + name + \"->\" + \"task1\";\n\t}\n\ttask task2 weight: 2 { \n\t\twrite string(cycle) + \":\" + name + \"->\" + \"task2\";\n\t}\n}\n```\n\nAs the **weighted\\_tasks** control architecture was chosen, at each simulation step, the dummy agents execute only the task with the highest behavior. Thus,  when _cycle modulo 3_ is higher to 2, task1 is executed; when _cycle modulo 3_ is lower than 2, task2 is executed. In case when _cycle modulo 3_ is equal 2 (at cycle 2, 5, ...), the only the first task defined (here task1) is executed.\n\nHere the result obtained with one dummy agent:\n```\n0:dummy0->task2\n1:dummy0->task2\n2:dummy0->task1\n3:dummy0->task2\n4:dummy0->task2\n5:dummy0->task1\n6:dummy0->task2\n```\n[//]: # (endConcept|task_based)\n\n[//]: # (startConcept|user_control_architecture)\n[//]: # (keyword|concept_gui)\n[//]: # (keyword|architecture_user_first)\n[//]: # (keyword|architecture_user_last)\n[//]: # (keyword|architecture_user_only)\n## User Control Architecture\n\n### user\\_only, user\\_first, user\\_last\n\nA specific type of control architecture has been introduced to allow users to take control over an agent during the course of the simulation. It can be invoked using three different keywords: `user_only`, `user_first`, `user_last`.\n```\nspecies user control: user_only {\n   ...\n}\n```\n\nIf the control chosen is `user_first`, it means that the user controlled panel is opened first, and then the agent has a chance to run its \"own\" behaviors (reflexes, essentially, or \"init\" in the case of a \"user\\_init\" panel).\nIf the control chosen is `user_last`, it is the contrary.\n\n\n### user\\_panel\n\nThis control architecture is a specialization of the Finite State Machine Architecture where the \"behaviors\" of agents can be defined by using new constructs called `user_panel` (and one `user_init`), mixed with \"states\" or \"reflexes\". This `user_panel` translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each `user_panel`, like a `state` in FSM, can have a `enter` and `exit` sections, but it is only defined in terms of a set of `user_command`s which describe the different action buttons present in the panel.\n\nuser\\_commands can also accept inputs, in order to create more interesting commands for the user. This uses the `user_input` statement (and not operator), which is basically the same as a temporary variable declaration whose value is asked to the user. Example:\n\nAs `user_panel` is a specialization of `state`, the modeler has the possibility to describe several panels and choose the one to open depending on some condition, using the same syntax than for finite state machines :\n  * either adding `transitions` to the user\\_panels,\n  * or setting the `state` attribute to a new value, from inside or from another agent.\n\nThis ensures a great flexibility for the design of the user interface proposed to the user, as it can be adapted to the different stages of the simulation, etc...\n\nFollows a simple example, where, every 10 steps, and depending on the value of an attribute called \"advanced\", either the basic or the advanced panel is proposed.\n\n```\nspecies user control:user_only {\n   user_panel default initial: true {\n      transition to: \"Basic Control\" when: every (10) and !advanced_user_control;\n      transition to: \"Advanced Control\" when: every(10) and advanced_user_control;\n   }\n   \n   user_panel \"Basic Control\" {\n      user_command \"Kill one cell\" {\n         ask (one_of(cell)){\n            do die;\n         }\n      }\n      user_command \"Create one cell\" {\n        create cell ;\n      } \n      transition to: default when: true;\n   }\n   user_panel \"Advanced Control\" {\n      user_command \"Kill cells\" {\n        user_input \"Number\" returns: number type: int <- 10;\n        ask (number among cell){\n           do die;\n        }\n      }\n      user_command \"Create cells\" {\n        user_input \"Number\" returns: number type: int <- 10;\n        create cell number: number ;\n      } \n      transition to: default when: true;\n   }\n}\n```\n\n\nThe panel marked with the \"_initial: true_\" facet will be the one run first when the agent is supposed to run. If none is marked, the first panel (in their definition order) is chosen.\n\nA special panel called user\\_init will be invoked only once when initializing the agent if it is defined.\nIf no panel is described or if all panels are empty (i.e. no user\\_commands), the control view is never invoked. If the control is said to be \"user\\_only\", the agent will then not run any of its behaviors.\n\n\n### user\\_controlled\n\nFinally, each agent provided with this architecture inherits a boolean attribute called `user_controlled`. If this attribute becomes false, no panels will be displayed and the agent will run \"normally\" unless its species is defined with a `user_only` control.\n[//]: # (endConcept|user_control_architecture)\n\n## Other Control Architectures\n\nSome other control architectures are available in additional plugins. For instance, [BDI (Belief, desire, intention) architecture](UsingBDI) is available. Feel free to read about it if you want to learn more.\n\nYou need some other control architectures for your model ? Feel free to make your suggestion to the team of developer through the [mailing list](https://groups.google.com/forum/#!forum/gama-platform). Remember also that GAMA is an open-source platform, you can design your own control architecture easily. Go to the section Community/contribute if you want to jump into coding !","url":"wiki/ControlArchitecture.md"},"Equations.md":{"title":" Using Equations","content":"[//]: # (startConcept|equation)\n[//]: # (keyword|concept_equation)\n# Using Equations\n[//]: # (endConcept|concept_math)\n\n## Introduction\n\nODEs (Ordinary Differential Equations) are often used in ecology or in epidemiology to describe the macroscopic evolution over time of a population. Generally the whole population is split into several compartments. The state of the population is described by the number of individuals in each compartment. Each equation of the ODE system describes the evolution of the number of individual in a compartment. In such an approach individuals are not taken into account individually, with own features and behaviors. In contrary they are aggregated in a compartment and reduced to a number.\n\nA classical example is the SIR epidemic model representing the spreading of a disease in a population. The population is split into 3 compartments: S (Susceptible), I (Infected), R (Recovered). (see below for the equation)\n\nIn general the ODE systems cannot be analytically solved, i.e. it is not possible to find the equation describing the evolution of the number of S, I or R. But these systems can be numerically integrated in order to get the evolution. A numerical integration computes step after step the value of S, I and R. Several integration methods exist (e.g. Euler, Runge-Kutta...), each of them being a compromise between accuracy and computation time. The length of the integration step has also a huge impact on precision. These models are deterministic.\n\nThis approach makes a lot of strong hypotheses. The model does not take into account space. The population is considered has infinite and homogeneously mixed, so that any agent can interact with any other one.\n\n## Example of a SIR model \n\nIn the SIR model, the population is split into 3 compartments: S (Susceptible), I (Infected), R (Recovered). This can be represented by the following Forrester diagram: boxes represent stocks (i.e. compartments) and arrows are flows. Arrows hold the rate of a compartment population flowing to another compartment.\n\n![SIR-compartment.png](resources/images/multiParadigmModeling/SIR-compartment.png)\n\nThe corresponding ODE system contains one equation per stock. For example, the I compartment evolution is influenced by an inner (so positive) flow from the S compartment and an outer (so negative) flow to the R compartment.\n\n![SIR-equations.png](resources/images/multiParadigmModeling/SIR-equations.png)\n\nIntegrating this system using the Runge-Kutta 4 method provides the evolution of S, I and R over time. The initial values are:\n* S = 499\n* I = 1\n* R = 0\n* beta = 0.4\n* gamma = 0.1 \n* h = 0.1\n\n![SIR-result.png](resources/images/multiParadigmModeling/SIR-result.png)\n\n\n## Why and when can we use ODE in agent-based models ?\n\nThese hypotheses are very strong and cannot be fulfilled in agent-based models. \n\nBut in some multi-scale models, some entities can be close. For example if we want to implement a model describing the worldwide epidemic spread and the impact of air traffic on it, we cannot simulate the 7 billions people. But we can represent only cities with airports and airplanes as agents. In this case, cities are entities with a population of millions inhabitants, that will not been spatially located. As we are only interested in the disease spread, we are only interested in the number of infected people in the cities (and susceptibles and recovered too). As a consequence, it appears particularly relevant to describe the evolution of the disease in the city using a ODE system.\n\nIn addition these models have the advantage to not be sensible to population size in the integration process. Dozens or billions people does not bring a computation time increase, contrarily to agent-based models.\n\n## Use of ODE in a GAML model\n\nA stereotypical use of ODE in a GAMA agent-based model is to describe species where some agents attributes evolution is described using an ODE system.\n\nAs a consequence, the GAML language has been increased by two main concepts (as two statements):\n* equations can be written with the ``equation`` statement. An ``equation`` block is composed of a set of ``diff`` statement describing the evolution of species attributes.\n* an equation can be numerically integrated using the ``solve`` statement\n\n## ``equation``\n### Defining an ODE system\nDefining a new ODE system needs to define a new ``equation`` block in a species. As example, the following ``eqSI`` system describes the evolution of a population with 2 compartments (S and I) and the flow from S to I compartment: \n``` \nspecies userSI {\n\tfloat t ;\n\tfloat I ; \n\tfloat S ; \n\tint N ;\n\tfloat beta<-0.4 ;\n\tfloat h ;\n\t\n\tequation eqSI {\n\t\tdiff(S,t) = -beta * S * I / N ;\n\t\tdiff(I,t) = beta * S * I / N ;\n\t}\n}\t\t\t\n```\nThis equation has to be defined in a species with ``t``, ``S`` and ``I`` attributes. ``beta`` (and other similar parameters) can be defined either in the specific species (if it is specific to each agents) or in the ``global`` if it is a constant.\n\nNote: the ``t`` attribute will be automatically updated using the ``solve`` statement ; it contains the time elapsed in the equation integration.\n\n### Using a built-in ODE system\nIn order to ease the use of very classical ODE system, some built-in systems have been implemented in GAMA. For example, the previous SI system can be written as follows. Three additional facets are used to define the system:\n* `type`: the identifier of the built-in system (here SI) (the list of all built-in systems are described below),\n* `vars`: this facet is expecting a list of variables of the species, that will be matched with the variables of the system,\n* `params`: this facet is expecting a list of variables of the species (of of the global), that will be matched with the parameters of the system.\n```\nequation eqBuiltInSI type: SI vars: [S,I,t] params: [N,beta] ;\n```\n\n### Split a system into several agents\n\nAn equation system can be split into several species and each part of the system are synchronized using the `simultaneously` facet of `equation`. The system split into several agents can be integrated using a single call to the `solve` statement. Notice that all the `equation` definition must have the same name.\n\nFor example the SI system presented above can be defined in two different species `S_agt` (containing the equation defining the evolution of the S value) and `I_agt` (containing the equation defining the evolution of the I value). These two equations are linked using the `simultaneously` facet of the `equation` statement. This facet expects a set of agents. The integration is called only once in a simulation step, e.g. in the `S_agt` agent.\n```\nspecies S_agt {\n\tfloat t ;\t\t\n\tfloat Ssize ;\n\t\n\tequation evol simultaneously: [ I_agt ] {\n\t\tdiff(Ssize, t) = (- sum(I_agt accumulate [each.beta * each.Isize]) * self.Ssize / N);\n\t}\n\t\n\treflex solving {solve evol method : rk4 step : hKR4 ;}\t\n}\n\nspecies I_agt {\n\tfloat t ;\n\tfloat Isize ; // number of infected\t\n\tfloat beta ;\n\n\tequation evol simultaneously : [ S_agt ] {\n\t\tdiff(Isize, t) = (beta * first(S_agt).Ssize * Isize / N);\n\t}\n}\n```\nThe interest is that the modeler can create several agents for each compartment, which different values. For example in the SI model, the modeler can choose to create 1 agent `S_agt` and 2 agents `I_agt`. The `beta` attribute will have different values in the two agents, in order to represent 2 different strains.\n\n```\nglobal {\n\tint number_S <- 495 ; // The number of susceptible\n\tint number_I <- 5   ; // The number of infected\n\tint nb_I <- 2;\n\tfloat gbeta  <- 0.3  ; // The parameter Beta\n\t\n\tint N <- number_S + nb_I * number_I ;\n\tfloat hKR4 <- 0.1 ;\n\n\tinit {\n\t\tcreate S_agt {\n\t\t\tSsize <- float(number_S) ;\n\t\t}\n\t\tcreate I_agt number: nb_I {\n\t\t\tIsize <- float(number_I) ;\n\t\t\tself.beta <- myself.gbeta + rnd(0.5) ;\n\t\t}\n\t}\n}\n``` \n\nThe results are computed using the RK4 method with:\n* number_S = 495 \n* number_I = 5  \n* nb_I = 2\n* gbeta = 0.3 \n* hKR4 = 0.1 \n\n![SI-split-results.png](resources/images/multiParadigmModeling/SI-split-results.png)\n\n\n## ``solve`` an equation\nThe `solve` statement has been added in order to integrate numerically the equation system. It should be add into a reflex. At each simulation step, a step of the integration is executed, the length of the integration step is defined in the `step` facet. The `solve` statement will update the variables used in the equation system. The chosen integration method (defined in `method`) is Runge-Kutta 4 (which is very often a good choice of integration method in terms of accuracy).\n```\nreflex solving {\n\tsolve eqSI method:rk4 step:h;\n}\n```\nWith a smaller integration step, the integration will be faster but less accurate.\n\n\n## More details\n\n### Details about the `solve` statement\n\nThe `solve` statement can have a huge set of facets (see [S_Statements#solve] for more details). The basic use of the `solve` statement requiers only the equation identifier. By default, the integration method is Runge-Kutta 4 with an integration step of `1`, which means that at each simulation step the equation integration is made over 1 unit of time (which is implicitly defined by the system parameter value).\n\n``` \nsolve eqSI ;\n```\n\n2 integration methods can be used: \n* `method: rk4` will use [the Runge-Kutta 4 integration method](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods)\n* `method: dp853` will use [the Dorman-Prince 8(5,3) integration method](https://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method). The advantage of this method compared to Runge-Kutta is that it has an evaluation of the error and can use it to adapt the integration step size.\n\nIn order to synchronize the simulation step and the equation integration step, 2 facets can be used:\n* `step: number`\n* `cycle_length: number` \n\n\ncycle_length (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1)\nstep (float): integration step, use with most integrator methods (default value: 1)\n\ntime_final (float): target time for the integration (can be set to a value smaller than t0 for backward integration)\ntime_initial (float): initial time\ndiscretizing_step (int): number of discret beside 2 step of simulation (default value: 0)\nintegrated_times (list): time interval inside integration process\nintegrated_values (list): list of variables's value inside integration process\n\n\nSome facets are specific to the DP853 integration methods: `max_step`, `min_step`, `scalAbsoluteTolerance` and `scalRelativeTolerance`.\n\n### Example of the influence of the integration step\n\nThe `step` and `cycle_length` facets of the integration method may have a huge influence on the results. `step` has an impact on the result accuracy. In addition, it is possible to synchronize the step of the (agent-based) simulation and the (equation) integration step in various ways (depending on the modeler purpose) using the `cycle_length` facet: e.g. `cycle_length: 10` means that 10 simulation steps are equivalent to 1 unit of time of the integration method.\n\n* `solve SIR method: \"rk4\" step: 1.0 cycle_length: 1.0 ; `\n![SIR-results-h1.png](resources/images/multiParadigmModeling/SIR-results-h1.png)\n\n* `solve SIR method: \"rk4\" step: 0.1 cycle_length: 10.0 ; `\n![SIR-results-h0.1.png](resources/images/multiParadigmModeling/SIR-results-h0.1.png)\n\n* `solve SIR method: \"rk4\" step: 0.01 cycle_length: 100.0 ; `\n![SIR-results-h0.01.png](resources/images/multiParadigmModeling/SIR-results-h0.01.png)\n\n### List of built-in ODE systems\nSeveral built-in equations have been defined.\n#### `equation eqBuiltInSI type: SI vars: [S,I,t] params: [N,beta];`\n\nThis system is equivalent to:\n```\nequation eqSI {\n\tdiff(S,t) = -beta * S * I / N ;\n\tdiff(I,t) = beta * S * I / N ;\n}\n```\t\n\n![SI-compartment.png](resources/images/multiParadigmModeling/SI-compartment.png)\n\n![SI-equations.png](resources/images/multiParadigmModeling/SI-equations.png)\n\nThe results are provided using the Runge-Kutta 4 method using following initial values:\n* S = 499\n* I = 1\n* beta = 0.4\n* h = 0.1\n\n![SI-result.png](resources/images/multiParadigmModeling/SI-result.png)\n\n#### `equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma];`\n\nThis system is equivalent to:\n```\nequation eqSIS {\n\tdiff(S,t) = -beta * S * I / N + gamma * I;\n\tdiff(I,t) = beta * S * I / N - gamma * I;\n}\n```\n![SIS-compartment.png](resources/images/multiParadigmModeling//SIS-compartment.png)\n\n![SIS-equations.png](resources/images/multiParadigmModeling/SIS-equations.png)\n\nThe results are provided using the Runge-Kutta 4 method using following initial values:\n* S = 499\n* I = 1\n* beta = 0.4\n* gamma = 0.1 \n* h = 0.1\n\n![SIS-result.png](resources/images/multiParadigmModeling/SIS-result.png)\n\n#### `equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma] ;`\n\nThis system is equivalent to:\n```\nequation eqSIR {\n\tdiff(S,t) = (- beta * S * I / N);\n\tdiff(I,t) = (beta * S * I / N) - (gamma * I);\n\tdiff(R,t) = (gamma * I);\n}\n```\n\n![SIR-compartment.png](resources/images/multiParadigmModeling/SIR-compartment.png)\n\n![SIR-equations.png](resources/images/multiParadigmModeling/SIR-equations.png)\n\nThe results are provided using the Runge-Kutta 4 method using following initial values:\n* S = 499\n* I = 1\n* R = 0\n* beta = 0.4\n* gamma = 0.1 \n* h = 0.1\n\n![SIR-result.png](resources/images/multiParadigmModeling/SIR-result.png)\n\n\n#### `equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu] ;`\n\nThis system is equivalent to:\n```\nequation eqSIRS {\n\t diff(S,t) = mu * N + omega * R + - beta * S * I / N - mu * S ;\n\t diff(I,t) = beta * S * I / N - gamma * I - mu * I ;\n\t diff(R,t) = gamma * I - omega * R - mu * R ;\n}\n```\n\n![SIRS-compartment.png](resources/images/multiParadigmModeling/SIRS-compartment.png)\n\n![SIRS-equations.png](resources/images/multiParadigmModeling/SIRS-equations.png)\n\nThe results are provided using the Runge-Kutta 4 method using following initial values:\n* S = 499\n* I = 1\n* R = 0\n* beta = 0.4\n* gamma = 0.01\n* omega = 0.05\n* mu = 0.01 \n* h = 0.1\n\n![SIRS-result.png](resources/images/multiParadigmModeling/SIRS-result.png)\n\n\n#### `equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu] ;`\n\nThis system is equivalent to:\n```\nequation eqSEIR {\n\tdiff(S,t) = mu * N - beta * S * I / N - mu * S ;\n\tdiff(E,t) = beta * S * I / N - mu * E - sigma * E ;\n\tdiff(I,t) = sigma * E - mu * I - gamma * I;\n\tdiff(R,t) = gamma * I - mu * R ;\n}\n```\n\n![SEIR-compartment.png](resources/images/multiParadigmModeling/SEIR-compartment.png)\n\n![SEIR-equations.png](resources/images/multiParadigmModeling/SEIR-equations.png)\n\nThe results are provided using the Runge-Kutta 4 method using following initial values:\n* S = 499\n* E = 0\n* I = 1\n* R = 0\n* beta = 0.4\n* gamma = 0.01\n* sigma = 0.05\n* mu = 0.01 \n* h = 0.1\n\n![SEIR-result.png](resources/images/multiParadigmModeling/SEIR-result.png)\n\n\n#### `equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;`\n\nThis system is equivalent to:\n```\nequation eqLV { \n\tdiff(x,t) =   x * (alpha - beta * y);\n\tdiff(y,t) = - y * (delta - gamma * x);\n}\t\n```\n\n![LV-equations.png](resources/images/multiParadigmModeling/LV-equations.png)\n\nThe results are provided using the Runge-Kutta 4 method using following initial values:\n* x = 2\n* y = 2\n* alpha = 0.8\n* beta = 0.3\n* gamma = 0.2\n* delta = 0.85\n* h = 0.1\n\n![LV-result.png](resources/images/multiParadigmModeling/LV-result.png)\n[//]: # (endConcept|equation)\n","url":"wiki/Equations.md"},"OptimizingModels.md":{"title":" Optimizing Models","content":"[//]: # (startConcept|optimizing_tips)\n[//]: # (keyword|concept_optimization)\n# Optimizing Models\n\n\nThis page aims at presenting some tips to optimize the memory footprint or the execution time of a model in GAMA.\n\n_Note:  since GAMA 1.6.1, some optimizations have become obsolete because they have been included in the compiler. They have, then, been removed from this page. For instance, writing 'rgb(0,0,0)' is now compiled directly as '#black'._\n\n\n## Table of contents \n\n* [machine_time](#machinetime)\n* [Scheduling](#scheduling)\n* [Grid](#grid)\n\t* [Optimization Facets](#optimization-facets)\n\t\t* [use_regular_agents](#useregularagents)\n\t\t* [use_individual_shapes](#useindividualshapes)\n* [Operators](#operators)\n\t* [List operators](#list-operators)\n\t\t* [first_with](#firstwith)\n\t\t* [where / count](#where--count)\n\t* [Spatial operators](#spatial-operators)\n\t\t* [container of agents in closest_to, at_distance, overlapping, inside](#container-of-agents-in-closestto-atdistance-overlapping-inside)\n\t\t* [Accelerate  with a first spatial filtering](#accelerate--with-a-first-spatial-filtering)\n* [Displays](#displays)\n\t* [shape](#shape)\n\t* [circle vs square / sphere vs cube](#circle-vs-square--sphere-vs-cube)\n\t* [OpenGL refresh facets](#opengl-refresh-facets)\n\n\n\n[//]: # (keyword|attribute_machine_time)\n## machine\\_time\n\nIn order to optimize a model, it is important to exactly know which part of the model take times. The simplest to do that is to use the **machine\\_time** built-in global variable that gives the current time in milliseconds. Then to compute the time taken by a statement, a possible way is to write:\n\n```\nfloat t <- machine_time;\n// here a block of instructions that you consider as \"critical\"\n// ...\nwrite \"duration of the last instructions: \" + (machine_time - t);\n```\n\n\n\n[//]: # (keyword|concept_scheduler)\n## Scheduling\n\nIf you have a species of agents that, once created, are not supposed to do anything more (i.e. no behavior, no reflex, their actions triggered by other agents, their attributes being simply read and written by other agents), such as a \"data\" grid, or agents representing a \"background\" (from a shape file, etc.), consider using the `schedules: []` facet on the definition of their species. This trick allows to tell GAMA to not schedule any of these agents.\n\n```\ngrid my_grid height: 100 width: 100 schedules: [] \n{\n      ...\n}\n```\n\nThe `schedules:` facet is dynamically computed (even if the agents are not scheduled), so, if you happen to define agents that only need to be scheduled every x cycles, or depending on a condition, you can also write `schedules:` to implement this. For instance, the following species will see its instances scheduled every 10 steps and only if a certain condition is met:\n\n```\nspecies my_species schedules: (every 10) ? (condition ? my_species : []) : [] \n{\n     ...\n}\n```\n\nIn the same way, modelers can use the frequency facet to define when the agents of a species are going to be activated. By setting this facet to 0, the agents are never activated.\n```\nspecies my_species frequency: 0\n{\n     ...\n}\n```\n\n\n[//]: # (keyword|concept_grid)\n## Grid\n\n### Optimization Facets\nIn this section, we present some facets that allow to optimize the use of grid (in particular in terms of memories). Note that all these facet can be combined (see the Life model from the Models library).\n\n#### use\\_regular\\_agents\nIf false, then a special class of agents is used. This special class of agents used less memories but has some limitation: the agents cannot inherit from a \"normal\" species, they cannot have sub-populations, their name cannot be modified, etc.\n```\ngrid cell width: 50 height: 50 use_regular_agents: false ;\n```\n\n#### use\\_individual\\_shapes\nIf false, then only one geometry is used for all agents. This facet allows to gain a lot of memory, but should not be used if the geometries of the agents are often activated (for instance, by an aspect).\n\n```\ngrid cell width: 50 height: 50 use_individual_shapes: false ;\t\n```\n\n\n## Operators\n\n### List operators\n[//]: # (keyword|operator_first_with)\n[//]: # (keyword|operator_shuffle)\n[//]: # (keyword|one_of)\n#### first\\_with\nIt is sometimes necessary to randomly select an element of a list that verifies a certain condition.\nMany modelers use the **one\\_of** and the **where** operators to do this:\n```\nbug one_big_bug <- one_of (bug where (each.size > 10));\n```\nWhereas it is often more optimized to use the **shuffle** operator to shuffle the list, then the **first\\_with** operator to select the first element that verifies the condition:\n```\nbug one_big_bug <- shuffle(bug) first_with (each.size > 10);\n```\n[//]: # (keyword|operator_where)\n[//]: # (keyword|operator_count)\n#### where / count\nIt is quite common to want to count the number of elements of a list or a container that verify a condition.\nThe obvious to do it is :\n```\nint n <- length(my_container where (each.size > 10));\n```\nThis will however create an intermediary list before counting it, and this operation can be time consuming if the number of elements is important. To alleviate this problem, GAMA includes an operator called **count** that will count the elements that verify the condition by iterating directly on the container (no useless list created) :\n```\nint n <- my_container count (each.size > 10);\n```\n### Spatial operators\n[//]: # (keyword|operator_closest_to)\n[//]: # (keyword|operator_at_distance)\n[//]: # (keyword|operator_overlapping)\n[//]: # (keyword|operator_inside)\n#### container of agents in closest\\_to, at\\_distance, overlapping, inside\nSeveral spatial query operators (such as **closest\\_to**, **at\\_distance**, **overlapping** or **inside**) allow to restrict the agents being queried to a container of agents. For instance, one can write:\n```\nagent closest_agent <- a_container_containing_agents closest_to self;\n```\nThis expression is formally equivalent to :\n```\nagent closest_agent <- a_container_containing_agent with_min_of (each distance_to self);\n```\nBut it is much faster **if your container is large**, as it will query the agents using a spatial index (instead of browsing through the whole container). Note that in some cases, when you have a small number of agents, the first syntax will be faster. The same applies for the other operators. \n\nNow consider a very common case: you need to restrict the agents being queried, not to a container, but to a species (which, actually, acts as a container in most cases). For instance, you want to know which predator is the closest to the current agent. If we apply the pattern above, we would write:\n```\npredator closest_predator <- predator with_min_of (each distance_to self);\n```\nor\n```\npredator closest_predator <- list(predator) closest_to self;\n```\n\nBut these two operators can be painfully slow if your species has many instances (even in the second form). In that case, always prefer using **directly** the species as the left member:\n```\npredator closest_ predator <- predator closest_to self;\n```\nNot only is the syntax clearer, but the speed gain can be phenomenal because, in that case, the list of instances is not used (we just check if the agent is an instance of the left species).\n\nHowever, what happens if one wants to query instances belonging to 2 or more species ? If we follow our reasoning, the immediate way to write it would be (if predator 1 and predator 2 are two species):\n```\nagent closest_agent <- (list(predator1) + list(predator2)) closest_to self; \n```\nor, more simply:\n```\nagent closest_agent <- (predator1 + predator2) closest_to self;\n```\nThe first syntax suffers from the same problem than the previous syntax: GAMA has to browse through the list (created by the concatenation of the species populations) to filter agents. The solution, then, is again to use directly the species, as GAMA is clever enough to create a temporary \"fake\" population out of the concatenation of several species, which can be used exactly like a list of agents, but provides the advantages of a species population (no iteration made during filtering).\n\n#### Accelerate **closest\\_to** with a first spatial filtering\nThe **closest\\_to** operator can sometimes be slow if numerous agents are concerned by this query. If the modeler is just interested by a small subset of agents, it is possible to apply a first spatial filtering on the agent list by using the **at\\_distance** operator.\nFor example, if the modeler wants first to do a spatial filtering of 10m:\n```\nagent closest_agent <- (predator1 at_distance 10) closest_to self;\n```\n\nTo be sure to find an agent, the modeler can use a test statement:\n```\nagent closest_agent <- (predator1 at_distance 10) closest_to self;\nif (closest_agent = nil) {closest_agent  <- predator1 closest_to self;}\n```\n\n\n\n\n[//]: # (keyword|concept_display)\n## Displays\n\n[//]: # (keyword|concept_geometry)\n[//]: # (keyword|concept_shape)\n[//]: # (keyword|statement_draw)\n### shape\nIt is quite common to want to display an agent as a circle or a square. A common mistake is to mix up the shape to draw and the geometry of the agent in the model. If the modeler just wants to display a particular shape, he/she should not modify the agent geometry (which is a point by default), but just specify the shape to draw in the agent aspect.\n\n```\nspecies bug {\n     int size <- rnd(100);\n\t\n      aspect circle {\n          draw circle(2) color: °blue;\n      }\n}\n```\n\n[//]: # (keyword|operator_circle)\n[//]: # (keyword|operator_sphere)\n[//]: # (keyword|operator_rectangle)\n[//]: # (keyword|operator_cube)\n### circle vs square / sphere vs cube\nNote that in OpenGL and Java2D (the two rendering subsystems used in GAMA), creating and drawing a circle geometry is more time consuming than creating and drawing a square (or a rectangle). In the same way, drawing a sphere is more time consuming than drawing a cube. Hence, if you want to optimize your model displays and if the rendering does not explicitly need \"rounded\" agents, try to use squares/cubes rather than circles/spheres.\n\n[//]: # (keyword|concept_opengl)\n[//]: # (keyword|concept_refresh)\n### OpenGL refresh facets\nIn OpenGL display, it is possible to specify that it is not necessary to refresh a layer with the facet **refresh**. If a species of agents is never modified in terms of visualization (location, shape or color), you can set **refresh** to false. Example:\n```\ndisplay city_display_opengl type: opengl{\n     species building aspect: base refresh: false;\n     species road aspect: base refresh: false;\n     species people aspect: base;\n}\n```\n[//]: # (endConcept|optimizing_tips)","url":"wiki/OptimizingModels.md"},"RuntimeConcepts.md":{"title":" Runtime Concepts","content":"[//]: # (startConcept|runtime_and_schedulers)\n[//]: # (keyword|concept_scheduler)\n# Runtime Concepts\n\nWhen a model is being simulated, a number of algorithms are applied, for instance to determine the order in which to run the different agents, or the order in which the initialization of agents is performed, etc. This section details some of them, which can be important when building models and understanding how they will be effectively simulated.\n\n\n## Table of contents \n\n* [Simulation initialization](#simulation-initialization)\n* [Agents Creation](#agents-creation)\n* [Agents Step](#agents-step)\n* [Schedule Agents](#schedule-agents)\n\n\n## Simulation initialization\nOnce the user launches an experiment, GAMA starts the initialization of the simulation.\nFirst it creates a [`world` agent](GlobalSpecies).\n\nIt initializes all its attributes with their init values. This includes its shape (that will be used as environment of the simulation).\n\nIf a species of type [grid](GridSpecies) exists in the model, agents of species are created.\n\nFinally the `init` statement is executed. It should include the creation of all the other agents of [regular species](RegularSpecies) of the simulation. After their creation and initialization, they are added in the list `members` the `world` (that contains all the micro-agent of the `world`).\n\n[//]: # (keyword|concept_optimization)\n[//]: # (keyword|statement_create)\n[//]: # (keyword|concept_init)\n## Agents Creation\nExcept [`grid`](GridSpecies) agents, other agents are created using the [`create` statement](Statements#create). It is used to allocate memory for each agent and to initialize all its attributes.\n\nIf no explicit initialization exists for an attribute, it will get the default value corresponding to its [type](DataTypes).\n\nThe initialization of an attribute can be located at several places in the code; they are executed in the following order (which means that, if several ways are used, the attribute will finally have the value of the last applied one):\n* using the `from:` facet of the `create` statement;\n* in the embedded block of the `create` statement;\n* in the attribute declaration, using the `init` facet;\n* in the `init` block of the species.\n\n[//]: # (keyword|concept_cycle)\n## Agents Step\nWhen an agent is asked to _step_, it means that it is expected to update its variables, run its behaviors and then _step_ its micro-agents (if any).\n\n```\nstep of agent agent_a\n    {\n        species_a <- agent_a.species\n        architecture_a <- species_a.architecture\n        ask architecture_a to step agent_a {\n             ask agent_a to update species_a.variables\n             ask agent_a to run architecture_a.behaviors\n        }\n\n        ask each micro-population mp of agent_a to step {\n            list<agent> sub-agents <- mp.compute_agents_to_schedule\n            ask each agent_b of sub-agents to step //... recursive call...\n        }\n    }\n\n```\n\n## Schedule Agents\n\nThe global scheduling of agents is then simply the application of this previous _step_ to the _experiment agent_, keeping in mind that this agent has only one micro-population (of simulation agents, each instance of the model species), and that the simulation(s) inside this population contain(s), in turn, all the \"regular\" populations of agents of the model.\n\nTo influence this schedule, then, one possible way is to change the way populations compute their lists of agents to schedule, which can be done in a model by providing custom definitions to the \"schedules:\" facet of one or several species.\n\n[//]: # (keyword|concept_random)\nA practical application of this facet is to reduce simulation artifacts created by the default scheduling of populations, which is sequential (i.e. their agents are executed in turn in their order of creation). To enable a pseudo-parallel scheduling based on a random scheduling recomputed at each step, one has simply to define the corresponding species like in the following example:\n\n```\nspecies A schedules: shuffle(A) {...}\n```\n\nMoving further, it is possible to enable a completely random scheduling that will eliminate the sequential scheduling of populations:\n\n```\nglobal schedules: [world] + shuffle(A + B + C) {...}\n\nspecies A schedules: [] {...}\nspecies B schedules: [] {...}\nspecies C schedules: [] {...}\n```\n\nIt is important to (1) explicitly invoke the scheduling of the world (although it doesn't have to be the first); (2) suppress the population-based scheduling to avoid having agent being scheduled 2 times (one time in the custom definition, one time by their population).\n\nOther schemes are possible. For instance, the following definition will completely suppress the default scheduling mechanism to replace it with a custom scheduler that will execute the world, then all agents of species A in a random way and then all agents of species B in their order of creation:\n\n```\nglobal schedules: [world] + shuffle(A) + B {...} // explicit scheduling in the world\n\nspecies A schedules [];\n\nspecies B schedules: [];\n\n```\n\nComplex conditions can be used to express which agents need to be scheduled each step. For instance, in the following definition, only agents of A that return true to a particular condition are scheduled:\n\n```\nspecies A schedules: A where each.can_be_scheduled() {\n\n    bool can_be_scheduled() {\n         ...\n         returns true_or_false;\n    }\n}\n```\n\nBe aware that enabling a custom scheduling can potentially end up in non-functional simulations. For example, the following definitions will result in a simulation that will **never be executed**:\n\n```\nglobal schedules: [] {}; // the world is NEVER scheduled\n \nspecies my_scheduler schedules: [world] ; // so its micro-species 'my_scheduler' is NOT scheduled either. \n```\n\nand this one will result in an **infinite loop** (which will trigger a stack overflow at some point):\n\n```\nglobal {} // The world is normally scheduled...\n\nspecies my_scheduler schedules: [world]; // ... but schedules itself again as a consequence of scheduling the micro-species 'my_scheduler'\n```\n[//]: # (endConcept|runtime_and_schedulers)","url":"wiki/RuntimeConcepts.md"},"BasicProgrammingConceptsInGAML.md":{"title":" Basic programming concepts in GAML","content":"[//]: # (startConcept|programming_basis)\n# Basic programming concepts in GAML\n\nIn this part, we will focus on the very basic structures in GAML, such as how to declare a variable, how to use loops, or how to manipulate lists. \nWe will overfly quickly all those basic programming concepts, admitting that you already have some basics in coding.\n\n## Index\n\t\n* [Variables](#variables)\n  * [Basic types](#basic-types)\n  * [The point type](#the-point-type)\n  * [A word about dimensions](#a-word-about-dimensions)\n* [Declare variables using facet](#declare-variables-using-facet)\n* [Operators in GAMA](#operators-in-gama)\n  * [Logical operators](#logical-operators)\n  * [Comparison operators](#comparison-operators)\n  * [Type casting operators](#type-casting-operators)\n  * [Other operators](#other-operators)\n* [Conditional structures](#conditional-structures)\n* [Loop](#loop)\n* [Manipulate containers](#manipulate-containers)\n* [Random values](#random-values)\n\n## Variables\n\nVariables are declared very easily in GAML, starting with the keyword for the type, following by the name you want for your variable. \nNB: The declaration has to be inside the `global` scope, or inside the `species` scope.\n\n```\ntypeName myVariableName;\n```\n\n### Basic types\n\n[//]: # (keyword|type_int)\n[//]: # (keyword|type_float)\n[//]: # (keyword|type_string)\n[//]: # (keyword|type_bool)\n[//]: # (keyword|operator_<-)\nAll the \"basic\" types are present in GAML:`int`, `float`, `string`, `bool`.\nThe operator for the affectation in GAML is `<-` (the operator `=` is used to test the equality).\n\n```\nint integerVariable <- 3;\nfloat floatVariable <- 2.5;\nstring stringVariable <- \"test\"; // you can also write simple ' : <- 'test'\nbool booleanVariable <- true; // or false\n```\n\n[//]: # (keyword|concept_write)\nTo follow the behavior of variable, we can write their value in the console. Let's go back to our basic skeleton of a model, and let's create a reflex in the global scope (to be short, a reflex is a function that is executed in each step. We will come back to this concept later). The `write` function works very easily, simply writing down the keyword `write` and the name of the variable we want to be displayed.\n\n```\nmodel firstModel\n\nglobal {\n\tint integerVariable <- 3;\n\tfloat floatVariable <- 2.5;\n\tstring stringVariable <- \"test\"; // you can also write simple ' : <- 'test'\n\tbool booleanVariable <- true; // or false\n\treflex writeDebug {\n\t\twrite integerVariable;\n\t\twrite floatVariable;\n\t\twrite stringVariable;\n\t\twrite booleanVariable;\n\t}\n}\n\nexperiment myExperiment\n{\n}\n```\n\nThe function `write` is overloaded for each type of variable (even for the more complex type, such as containers).\n\n[//]: # (keyword|concept_nil)\nNote that before being initialized, a variable has the value `nil`.\n\n```\nreflex update {\n\tstring my_string;\n\twrite my_string; // this will write \"nil\".\n\tint my_int;\n\twrite my_int; // this will write \"0\", which is the default value for int.\n}\n```\n\n`nil` is also a literal you can use to initialize your variable (you can learn more about the concept of literal in this [page](Literals)).\n\n```\nreflex update {\n\tstring my_string <- \"a string\";\n\tmy_string <- nil;\n\twrite my_string; // this will write \"nil\".\n\tint my_int <- 6;\n\tmy_int <- nil;\n\twrite my_int; // this will write \"0\", which is the default value for int.\n}\n```\n\n[//]: # (keyword|type_point)\n### The point type\n\nAnother variable type you should know is the point variable. This type of variable is used to describe coordinates. It is in fact a complex variable, composed of two float variables (or three if you are working in 3D). To declare it, you have to use the curly bracket `{`:\n\n```\npoint p <- {0.2,2.4};\n```\n\nThe first field is related to the x value, and the second, to the y value. You can easily get this value as following:\n\n```\npoint p <- {0.2,2.4};\nwrite p.x; // the output will be 0.2\nwrite p.y; // the output will be 2.4\n```\n\nYou can't modify directly the value. But if you want, you can do a simple operation to get what you want:\n\n```\npoint p <- {0.2,2.4};\np <- p + {0.0,1.0};\nwrite p.y; // the output will be 3.4\n```\n\n[//]: # (keyword|concept_dimension)\n### A world about dimensions\n\nWhen manipulating float values, you can specify the dimension of your value. Dimensions are preceded by # or ° (exactly the same).\n\n```\nfloat a <- 5°m;\nfloat b <- 4#cm;\nfloat c <- a + b; // c is equal to 5.0399999 (it's not equal to 5.04 because it is a float value, not as precise as int)\n```\n\n[//]: # (keyword|concept_facet)\n## Declare variables using facet\n\nFacets are used to describe the behavior of a variable during its declaration, by adding the keyword `facet` just after the variable name, followed by the value you want for the facet (or also just after the initial value).\n\n```\ntype variableName <- initialValue facet1:valueForFacet1 facet2:valueForFacet2;\n// or:\ntype variableName facet1:valueForFacet1 facet2:valueForFacet2;\nvariableName <- initialValue;\n```\n\n[//]: # (keyword|concept_update)\nYou can use the facet `update` if you want to change the value of your variable. For example, to increment your integer variable each step, you can do as follow:\n\n```\nint integerVariable <- 3 min:0 max:10 update:integerVariable+1;\n// nb: the operator \"++\" doesn't exist in gaml.\n```\n\nYou can use the facet `min` and `max` to constraint the value in a specific range of values:\n\n```\nint integerVariable <- 3 min:0 max:10 update:integerVariable+1;\n// the result will be 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 10 - 10 - ...\n```\n\n[//]: # (keyword|concept_enumeration)\nThe facet `among` can also be useful (that can be seen as an enum):\n\n```\nstring fruits <- \"banana\" among:[\"pear\",\"apple\",\"banana\"];\n```\n\n[//]: # (keyword|concept_operator)\n## Operators in GAMA\n\nIn GAML language, you can use a lot of different operators. They are all listed in this [page](Operators), but here are the most useful ones:\n\n[//]: # (keyword|operator_+)\n[//]: # (keyword|operator_-)\n[//]: # (keyword|operator_*)\n[//]: # (keyword|operator_/)\n[//]: # (keyword|operator_^)\n**-\tMathematical operators**\n\nThe basic arithmetical operators, such as `+`(add), `-`(substract), `*`(multiply), `/`(divide), `^`(power) are used this way: \n\nFirstOperand Operator SecondOperand --> ex: 5 * 3; // return 15\n\n[//]: # (keyword|operator_cos)\n[//]: # (keyword|operator_sin)\n[//]: # (keyword|operator_tan)\n[//]: # (keyword|operator_sqrt)\n[//]: # (keyword|operator_round)\nSome other operators, such as `cos`(cosinus), `sin`(sinus), `tan`(tangent), `sqrt`(square root), `round`(rounding) etc... are used this way:\n\n```\nOperator(Operand) --> ex: sqrt(49); // return 7\n```\n\n###\tLogical operators\n\n[//]: # (keyword|concept_logical)\n[//]: # (keyword|operator_and)\n[//]: # (keyword|operator_or)\n[//]: # (keyword|operator_!)\nLogical operators such as `and`(and), `or`(inclusive or) are used the same way as basic arithmetical operators. The operator `!`(negation) has to be placed just before the operand. They return a boolean result.\n\n```\nFirstOperand Operator SecondOperand --> ex: true or false; // return true\nNegationOperator Operand --> ex: !(true or false); // return false\n```\n\n[//]: # (keyword|operator_!=)\n[//]: # (keyword|operator_<)\n[//]: # (keyword|operator_>)\n[//]: # (keyword|operator_=)\n### Comparison operators\n\nThe comparison operators `!=`(different than), `<`(smaller than), `<=`(smaller of equal), `=`(equal), `>`(bigger than), `>=`(bigger or equal) are used the same way as basic arithmetical operators:\n\n```\nFirstOperand Operator SecondOperand --> ex: 5 < 3; // return false\n```\n\n[//]: # (keyword|concept_cast)\n[//]: # (keyword|operator_int)\n### Type casting operators\n\nYou can cast an operand to a special type using casting operator:\n\t\n```\nOperator(Operand); --> ex: int(2.1); // return 2\n```\n\n### Other operators\n\nA lot of other operators exist in GAML. The standard way to use those operators is as followed:\n\n```\nOperator(FirstOperand,SecondOperand,...) --> ex: rnd(1,8);\n```\n\nSome others are used in a more intuitive way:\n\n```\nFirstOperand Operator SecondOperand --> ex: 2[6,4,5] contains(5);\n```\n\n[//]: # (keyword|concept_condition)\n[//]: # (keyword|statement_if)\n[//]: # (keyword|statement_else)\n## Conditional structures\n\nYou can write if/else if/else in GAML:\n\n```\nif (integerVariable<0) {\n\twrite \"my value is negative !! The exact value is \" + integerVariable;\n}\nelse if (integerVariable>0) {\n\twrite \"my value is positive !! The exact value is \" + integerVariable;\n}\nelse if (integerVariable=0) {\n\twrite \"my value is equal to 0 !!\";\n}\nelse {\n\twrite \"hey... This is not possible, right ?\";\n}\n```\n\n[//]: # (keyword|concept_ternary)\nGAML also accepts ternary operator:\n\n```\nstringVariable <- (booleanVariable) ? \"booleanVariable = true\" : \"booleanVariable = false\";\n```\n\n[//]: # (keyword|concept_loop)\n[//]: # (keyword|statement_loop)\n## Loop\n\nLoops in GAML are designed by the keyword `loop`. As for variables, a loop have multiple facet to determine its behavior:\n\n-\tThe facet `times`, to repeat a fixed number of times a set of statements:\n\n```\nloop times: 2 {\nwrite \"helloWorld\";\n} \n// the output will be helloWorld - helloWorld\n```\n\n-\tThe facet `while`, to repeat a set of statements while a condition is true:\n\n```\nloop while: (true) {\n}\n// infinity loop\n```\n\n-\tThe facet `from` / `to`, to repeat a set of statements while an index iterates over a range of values with a fixed step of 1:\n\n```\nloop i from:0 to: 5 { // or loop name:i from:0 to:5 -> the name is also a facet\n\twrite i;\n}\n// the output will be 0 - 1 - 2 - 3 - 4 - 5\n```\n\n-\tThe facet `from` / `to` combine with the facet `step` to choose the step:\n\n```\nloop i from:0 to: 5 step: 2 {\n\twrite i;\n}\n// the output will be 0 - 2 - 4\n```\n\n-\tThe facet over to browse containers, as we will see in the next part.\n\n[//]: # (keyword|statement_break)\nNb: you can interrupt a loop at any time by using the `break` statement.\n\n[//]: # (keyword|concept_container)\n[//]: # (keyword|type_list)\n## Manipulate containers\n\nWe saw in the previous parts \"simple\" types of variable. You also have a multiple containers types, such as list, matrix, map, pair... In this section, we will only focus on the container `list` (you can learn the other by reading the [section about datatypes](DataTypes#complex-built-in-types)).\n\n**How to declare a list?**\n\nTo declare a list, you can either or not specify the type of the data of its elements:\n\n```\nlist<int> listOfInt <- [5,4,9,8];\nlist listWithoutType <- [2,4.6,\"oij\",[\"hoh\",0.0]];\n```\n\n[//]: # (keyword|operator_length)\n[//]: # (keyword|operator_empty)\n**How to know the number of elements of a list?**\n\nTo know the number of element of a list, you can use the operator `length` that returns the number of elements (note that this operator also works with strings).\n\n```\nint numberOfElements <- length([12,13]); // will return 2\nint numberOfElements <- length([]); // will return 0\nint numberOfElements <- length(\"stuff\"); // will return 5\n```\n\nThere is an other operator, `empty`, that returns you a boolean telling you if the list is empty or not.\n\n```\nbool isEmpty <- empty([12,13]); // will return false\nbool isEmpty <- empty([]); // will return true\nbool isEmpty <- empty(\"stuff\"); // will return false\n```\n\n[//]: # (keyword|operator_at)\n**How to get an element from a list?**\n\nTo get an element from a list by its index, you have to use the operator `at` (nb: it is indeed an operator, and not a facet, so no \":\" after the keyword).\n\n```\nint theFirstElementOfTheList <- [5,4,9,8] at 0; // this will return 5\nint theThirdElementOfTheList <- [5,4,9,8] at 2; // this will return 9\n```\n\n[//]: # (keyword|operator_last_index)\n[//]: # (keyword|operator_index_of)\n**How to know the index of an element of a list?**\n\nYou can know the index of the first occurrence of a value in a list using the operator `index_of`.\nYou can know the index of the last occurrence of a value in a list using the operator `last_index_of`.\n\n```\nint result <- [4,2,3,4,5,4] last_index_of 4;  // result equals 5\nint result <- [4,2,3,4,5,4] index_of 4;  // result equals 0\n```\n\n[//]: # (keyword|operator_contains)\n**How to know if an element exists in a list?**\n\nYou can use the operator `contains` (return a boolean):\n\n```\nbool result <- [{1,2}, {3,4}, {5,6}] contains {3,4};  // result equals true\n```\n\n[//]: # (keyword|statement_remove)\n[//]: # (keyword|statement_add)\n[//]: # (keyword|statement_put)\n**How to insert/remove an element to/from a list?**\n\nFor those operation, no operator are available, but you can use a statement instead. The statements `add` and `put` are used to insert/modify an element, while the statement `remove` is used to remove an element. Here are some example of how to use those 3 statements with the most common facets:\n\n```\nlist<int> list_int <- [1,5,7,6,7];\nremove from:list_int index:1; // remove the 2nd element of the list\nwrite list_int; // the output is : [1,7,6,7]\nremove item:7 from:list_int; // remove the 1st occurrence of 7\nwrite list_int; // the output is : [1,6,7]\nadd item:9 to: list_int at: 2; // add 9 in the 3rd position\nwrite list_int; // the output is : [1,6,9,7]\nadd 0 to: list_int; // add 0 in the last position\nwrite list_int; // the output is : [1,6,9,7,0]\nput 3 in: list_int at: 0; // put 3 in the 1st position\nwrite list_int; // the output is : [3,6,9,7,0]\nput 2 in: list_int key: 2; // put 2 in the 3rd position\nwrite list_int; // the output is : [3,6,2,7,0]\n```\n\n**How to add 2 lists?**\n\nYou can add 2 lists by creating a third one and browsing the 2 first one, but you can do it much easily by using the operator `+` : \n\n```\nlist<int> list_int1 <- [1,5,7,6,7];\nlist<int> list_int2 <- [6,9];\nlist<int> list_int_result <- list_int1 + list_int2;\n```\n\n\n**How to browse a list?**\n\nYou can use the facet `over` of a loop:\n\n```\nlist<int> exampleOfList <- [4,2,3,4,5,4];\nloop i over:exampleOfList {\n\twrite i;\n}\n// the output will be 4 - 2 - 3 - 4 - 5 - 4\n```\n\n[//]: # (keyword|concept_filter)\n**How to filter a list?**\n\nIf you want to get all the elements of a list that fulfill a particular condition, you need the operator where. In the condition, you can design all the element of a particular list by using the pseudo variable **`each`** as followed:\n\n```\nlist<int> exampleOfList <- [4,2,3,4,5,4] where (each <= 3); \n// the list is now [2,3]\n```\n\nOther useful operators for the manipulation of lists:\n\nHere are some other operators which can be useful to manipulate lists: `sort`, `sort_by`, `shuffle`, `reverse`, `collect`, `accumulate`, `among`. Please read the GAML Reference if you want to know more about those operators.\n\n[//]: # (keyword|concept_random)\n[//]: # (keyword|concept_probability)\n## Random values\n\nWhen you will implement your model, you will have to manipulate some random values quite often. \n\n[//]: # (keyword|operator_rnd)\nTo get a random value in a range of value, use the operator [`rnd`](Operators#rnd). You can use this operator in many ways:\n\n```\nint var0 <- rnd (2);    // var0 equals 0, 1 or 2\nfloat var1 <- rnd (1000) / 1000;    // var1 equals a float between 0 and 1 with a precision of 0.001\npoint var2 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1);    // var2 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0\nfloat var3 <- rnd (2.0, 4.0, 0.5);  // var3 equals a float number between 2.0 and 4.0 every 0.5\nfloat var4 <- rnd(3.4);     // var4 equals a random float between 0.0 and 3.4\nint var5 <- rnd (2, 12, 4);     // var5 equals 2, 6 or 10\npoint var6 <- rnd ({2.5,3, 0.0});   // var6 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0\nint var7 <- rnd (2, 4);     // var7 equals 2, 3 or 4\npoint var8 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0});   // var8 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0\nfloat var9 <- rnd (2.0, 4.0);   // var9 equals a float number between 2.0 and 4.0\n```\n\n[//]: # (keyword|operator_flip)\nUse the operator [`flip`](Operators#flip) if you want to pick a boolean value with a certain probability:\n\n```\nbool result <- flip(0.2); // result will have 20% of chance to be true\n```\n\n[//]: # (keyword|operator_shuffle)\nYou can use randomness in list, by using the operator [`shuffle`](Operators#shuffle), or also by using the operator [`among`](Operators#among) to pick randomly one (or several) element of your list:\n\n```\nlist TwoRandomValuesFromTheList <- 2 among [5,4,9,8];\n// the list will be for example [5,9].\n```\n\n[//]: # (keyword|concept_distribution)\nYou can use probabilistic laws, using operators such as [`gauss`](Operators#gauss), [`poisson`](Operators#poisson), [`binomial`](Operators#binomial), or [`truncated_gauss`](Operators#truncated_gauss) (we invite you to read the documentation for those operators).\n\n[//]: # (endConcept|programming_basis)","url":"wiki/BasicProgrammingConceptsInGAML.md"},"ModelOrganization.md":{"title":" Organization of a model","content":"[//]: # (startConcept|model_structure)\n# Organization of a model\n\nAs already extensively detailed in the [introduction page](Introduction), defining a model in GAML amounts to defining a _model species_, which later allows to instantiate a _model agent_ (aka a _simulation_), which may or may not contain micro-species, and which can be flanked by _experiment plans_ in order to be simulated.\n\nThis conceptual structure is respected in the definition of model files, which follows a similar pattern:\n\n1. Definition of the _global species_, preceded by a _header_, in order to represent the _model species_\n1. Definition of the different micro-species (either nested inside the _global species_ or at the same level)\n1. Definition of the different _experiment plans_ that target this model\n\n\n## Table of contents \n\n* [Model Header (model species)](#model-header-model-species)\n* [Species declarations](#species-declarations)\n* [Experiment declarations](#experiment-declarations)\n* [Basic skeleton of a model](#basic-skeleton-of_a_model)\n\n\n[//]: # (keyword|concept_model)\n## Model Header (_model species_)\n\nThe header of a model file begins with the declaration of the name of the model. Contrarily to other statements, this declaration **does not** end with a semi-colon.\n```\nmodel name_of_the_model\n```\nThe name of the model is not necessarily the same as the name of the file. It must conform to the general rule for naming species, i.e. be a valid identifier (beginning with a letter, containing only letters, digits and dashes). This name will be used for building the name of the model species, from which _simulations_ will be instantiated. For instance, the following declaration:\n```\nmodel dummy\n```\nwill internally create a species called `dummy_model`, child of the abstract species `model`, from which simulations (called `dummy_model0`, `dummy_model1`, etc.) will be instantiated.\n\n[//]: # (keyword|concept_import)\nThis declaration is followed by optional import statements that indicate which other models this model is importing. Import statements **do not** end with a semi-colon.\n\nImporting a model can take two forms. The first one, called _inheritance import_, is declared as follows:\n```\nimport \"relative_path_to_a_model_file\"\nimport \"relative_path_to_another_model_file\"\n```\nThe second one, called _usage import_, is declared as follows:\n```\nimport \"relative_path_to_a_model_file\" as model_identifier\n```\nWhen importing models using the first form, all the declarations of the model(s) imported will be merged with those of the current model (in the order with which the import statements are declared, i.e. the latest definitions of global attributes or behaviors superseding the previous ones).\nThe second form is reserved for using models as _micro-models_ of the current model. This possibility is still experimental in the current version of GAMA.\n\nThe last part of the _header_ is the definition of the [`global` species](GlobalSpecies), which is the actual definition of the _model species_ itself.\n```\nglobal {\n    // Definition of [global attributes](GlobalSpecies#declaration), [actions and behaviors](DefiningActionsAndBehaviors)\n}\n```\n\nNote that neither the imports nor the definition of `global` are mandatory. Only the `model` statement is.\n\n\n\n## Species declarations\n\nThe header is followed by the declaration of the different species of agents that populate the model.\n\nThe [special species `global`](GlobalSpecies) is the world species. You will declare here all the global attributes/actions/behaviors. The global species does not have name, and is unique in your model.\n```\nglobal {\n    // definition of global attributes, actions, behaviors\n}\n```\n[Regular species](RegularSpecies) can be declared with the keyword `species`. You can declare several regular species, and they all have to be named.\n```\nspecies nameOfSpecies {\n\t// definition of your [species attributes](RegularSpecies#declaration), [actions and behaviors](DefiningActionsAndBehaviors)\n}\n```\nNote that the possibility to define the species _after_ the `global` definition is actually a convenience: these species are micro-species of the model species and, hence, could be perfectly defined as nested species of `global`. For instance:\n```\nglobal {\n    // definition of global attributes, actions, behaviors\n}\n\nspecies A {...}\n\nspecies B {...}\n```\nis completely equivalent to:\n```\nglobal {\n    // definition of [global attributes](GlobalSpecies#declaration), actions, behaviors\n\n    species A {...}\n\n    species B {...}\n}\n```\n\n\n## Experiment declarations\n\nExperiments are usually declared at the end of the file. They start with the keyword `experiment`. They contains the [simulation parameters](DefiningParameters), and the definition of the output (such as [displays](DefiningDisplaysGeneralities), [monitors or inspectors](DefiningMonitorsAndInspectors)). You can declare as much experiments as you want.\n\n```\nexperiment first_experiment {\n    // definition of parameters (intputs)\n\n    // definition of output\n    output {...}\n}\n\nexperiment second_experiment {\n    // definition of parameters (inputs)\n\n    // definition of output\n}\n```\n\nNote that you have two types of experiments:\nA [GUI experiment](DefiningGUIExperiment) allows to display a graphical interface with input parameters and outputs. It is declared with the following structure :\n```\nexperiment gui_experiment type:gui {\n\t[...]\n}\n```\nA [Batch experiment](BatchExperiments) allows to execute numerous successive simulation runs (often used for model exploration). It is declared with the following structure :\n```\nexperiment batch_experiment type:batch {\n\t[...]\n}\n``` \n\n## Basic skeleton of a model\n\nHere is the basic skeleton of a model :\n```\nmodel name_of_the_model\n\nglobal {\n\t// definition of [global attributes](GlobalSpecies#declaration), actions, behaviours\n}\n\nspecies my_specie {\n\t// definition of attributes, actions, behaviours\n}\n\nexperiment my_experiment /* + specify the type : \"type:gui\" or \"type:batch\" */\n{\n\t// here the definition of your experiment, with...\n\t// ... your inputs\n\toutput {\n\t\t// ... and your outputs\n\t}\n}\n```\nDon't forget this structure ! This will be the basis for all the models you will create from now.\n\n[//]: # (endConcept|model_structure)","url":"wiki/ModelOrganization.md"},"DefiningAdvancedSpecies.md":{"title":" Defining advanced species","content":"# Defining advanced species\n\nIn the previous chapter, we saw how to declare and manipulate [**regular species**](RegularSpecies) and the [**global species**](GlobalSpecies) (as a reminder, the instance of the **global species** is the **world agent**). \n\nWe will now see that GAMA provides you the possibility to declare some special species, such as [**grids**](GridSpecies) or [**graphs**](GraphSpecies), with their own built-in attributes and their own built-in actions. We will also see how to declare [**mirror species**](MirrorSpecies), which is a \"copy\" of a regular species, in order to give it an other representation. Finally, we will learn how to represent several agents through one unique agent, with [**multi-level architecture**](MultiLevelArchitecture).","url":"wiki/DefiningAdvancedSpecies.md"},"DefiningGUIExperiment.md":{"title":" Defining GUI Experiment","content":"[//]: # (startConcept|gui_experiments)\n# Defining GUI Experiment\n\nWhen you execute your simulation, you will often need to display some information. For each simulation, you can define some inputs and outputs:\n* The inputs will be composed of parameters manipulated by the user for each simulation.\n* The outputs will be composed of displays, monitors or output files. They will be define inside the scope `output`.\n\n```\nexperiment exp_name type: gui {\n   [input]\n   output {\n     [display statements]\n     [monitor statements]\n     [file statements]\n   }\n}\n```\n\nYou can define two types of experiment (through the facet `type`):\n* **`gui`** experiments (the default type) are used to play an experiment, and interpret its outputs.\n* **`batch`** experiments are used to play an experiment several times (usually with other input values), used for model exploration. We will come back to this notion a bit further in the tutorial.\n\nInside experiment scope, you can access to some built-ins which can be useful, such as `minimum_cycle_duration`, to force the duration of one cycle.\n\n```\nexperiment my_experiment type: gui {\n\tfloat minimum_cycle_duration <- 2.0#minute;\n}\n```\n\nOther built-ins are available, to learn more about, go to the page **[experiment built-in](ExperimentBuiltIn)**.\n\nIn this part, we will focus on the **gui experiments**. We will start with learning how to **[define input parameters](DefiningParameters)**, then we will study the outputs, such as **[displays](DefiningDisplaysGeneralities)**, **[monitors and inspectors](DefiningMonitorsAndInspectors)**, and **[export files](DefiningExportFiles)**. We will finish this part with how to define **[user commands](DefiningUserInteraction)**.\n[//]: # (endConcept|gui_experiments)","url":"wiki/DefiningGUIExperiment.md"},"ExploringModels.md":{"title":" Exploring Models","content":"[//]: # (keyword|concept_experiment)\n[//]: # (keyword|concept_batch)\n# Exploring Models\n\nWe just learnt how to launch GUI Experiments from GAMA. A GUI Experiment will start with a particular set of input, compute several outputs, and will stop at the end (if asked).\n\nIn order to explore models (by automatically running the Experiment using several configurations to analyze the outputs), a first approach is to run several simulations from the same experiment, considering each simulation as an agent. A second approach, much more efficient for larger explorations, is to run an other type of experiment : the **Batch Experiment**.\n\nWe will start this part by learning how to [**run several simulations**](RunSeveralSimulations) from the same experiment. Then, we will see how [**batch experiments**](BatchExperiments) work, and we will focus on how to use those batch experiments to explore models by using [**exploration methods**](ExplorationMethods).","url":"wiki/ExploringModels.md"},"Introduction.md":{"title":" Introduction","content":"# Introduction\n\nGAML is an _agent-oriented_ language dedicated to the definition of _agent-based_ simulations. It takes its roots in _object-oriented_ languages like Java or Smalltalk, but extends the object-oriented programming approach with powerful concepts (like skills, declarative definitions or agent migration) to allow for a better expressivity in models.\n\nIt is of course very close to _agent\\_based_ modeling languages like, e.g., [NetLogo](http://ccl.northwestern.edu/netlogo/), but, in addition to enriching the traditional representation of agents with modern computing notions like inheritance, type safety or multi-level agency, and providing the possibility to use different behavioral architectures for programming agents, GAML extends the agent-based paradigm to eliminate the boundaries between the domain of a model (which, in ABM, is represented with agents) and the experimental processes surrounding its simulations (which are usually not represented with agents), including, for example, _visualization_ processes. This [paper](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.7241&rep=rep1&type=pdf) (_Drogoul A., Vanbergue D., Meurisse T., Multi-Agent Based Simulation: Where are the Agents ?, Multi-Agent Based Simulation 3, pp. 1-15, LNCS, Springer-Verlag. 2003_) was in particular foundational in the definition of the concepts on which GAMA (and GAML) are based today.\n\nThis orientation has several conceptual consequences among which at least two are of immediate practical interest for modelers:\n* Since simulations, or experiments, are represented by agents, GAMA is bound to support high-level _model compositionality_, i.e. the definition of models that can use other models as _inner agents_, leveraging multi-modeling or multi-paradigm modeling as particular cases of composition.\n* The _visualization_ of models can be expressed by _models of visualization_, composed of agents entirely dedicated to visually represent other agents, allowing for a clear _separation of concerns_ between a simulation and its representation and, hence, the possibility to play with multiple representations of the same model at once.\n\n\n## Table of contents \n\n* [Key Concepts (Under construction)](#key-concepts-under-construction)\n\t* [Lexical semantics of GAML](#lexical-semantics-of-gaml)\n\t* [Translation into a concrete syntax](#translation-into-a-concrete-syntax)\n\t* [Vocabulary correspondance with the object-oriented paradigm as in Java](#vocabulary-correspondance-with-the-object-oriented-paradigm-as-in-java)\n\t* [Vocabulary correspondance with the agent-based paradigm as in NetLogo](#vocabulary-correspondance-with-the-agent-based-paradigm-as-in-netlogo)\n\n\n\n## Lexical semantics of GAML\nThe vocabulary of GAML is described in the following sentences, in which the meaning and relationships of the important _words_ of the language (in **bold face**) are summarized.\n\n1. The role of GAML is to support modelers in writing **models**, which are specifications of **simulations** that can be executed and controlled during **experiments**, themselves specified by **experiment plans**.\n1. The **agent-oriented** modeling paradigm means that everything \"active\" (entities of a model, systems, processes, activities, like simulations and experiments) can be represented in GAML as an **agent** (which can be thought of as a computational component owning its own data and executing its own behavior, alone or in interaction with other agents).\n1. Like in the object-oriented paradigm, where the notion of _class_ is used to supply a specification for _objects_, agents in GAML are specified by their **species**, which provide them with a set of **attributes** (_what they know_), **actions** (_what they can do_), **behaviors** (_what they actually do_) and also specifies properties of their **population**, for instance its **topology** (_how they are connected_) or **schedule** (_in which order and when they should execute_).\n1. Any **species** can be nested in another **species** (called its _macro-species_), in which case the **populations** of its instances will imperatively be hosted by an instance of this _macro-species_. A **species** can also inherit its properties from another **species** (called its _parent species_), creating a relationship similar to _specialization_ in object-oriented design. In addition to this, **species** can be constructed in a compositional way with the notion of **skills**, bundles of **attributes** and **actions** that can be shared between different species and inherited by their children.\n1. Given that all **agents** are specified by a **species**, **simulations** and **experiments** are then instances of two species which are, respectively, called **model** and **experiment plan**. Think of them as \"specialized\" categories of species.\n1. The relationships between **species**, **models** and **experiment plans** are codified in the meta-model of GAML in the form of a framework composed of three abstract species respectively called **agent** (direct or indirect parent of all **species**), **model** (parent of all **species** that define a model) and **experiment** (parent of all **species** that define an experiment plan). In this meta-model, instances of the children of **agent** know the instance of the child of **model** in which they are hosted as their **world**, while the instance of **experiment plan** identifies the same agent as one of the **simulations** it is in charge of. The following diagram summarizes this framework:\n\n![framework.png](resources/images/introduction/framework.png)\n\nPutting this all together, writing a model in GAML then consists in defining a species which inherits from **model**, in which other **species**, inheriting (directly or not) from **agent** and representing the entities that populate this model, will be nested, and which is itself nested in one or several **experiment plans** among which a user will be able to choose which **experiment** he/she wants to execute.\n\n![user_model.png](resources/images/introduction/user_model.png)\n\nAt the operational level, i.e. when _running_ an experiment in GAMA,\n\n## Translation into a concrete syntax\nThe concepts presented above are expressed in GAML using a syntax which bears resemblances with mainstream programming languages like Java, while reusing some structures from Smalltalk (namely, the syntax of _facets_ or the infix notation of _operators_). While this syntax is fully described in the subsequent sections of the documentation, we summarize here the meaning of its most prominent structures and their correspondance (when it exists) with the ones used in Java and NetLogo.\n\n1. A **model** is composed of a **header**, in which it can refer to other **models**, and a sequence of **species** and **experiments** declarations, in the form of special **declarative statements** of the language.\n1. A **statement** can be either a **declaration** or a **command**. It is always composed of a **keyword** followed by an optional **expression**, followed by a sequence of **facets**, each of them composed of a **keyword** (terminated by a ‘:’) and an **expression**.\n1. **facets** allow to pass arguments to **statements**. Their **value** is an **expression** of a given **type**. An **expression** can be a literary constant, the name of an **attribute**, **variable** or **pseudo-variable**, the name of a **unit** or **constant** of the language, or the application of an **operator**.\n1. A **type** can be a **primitive type**, a **species type** or a **parametric type** (i.e. a composition of **types**).\n1. Some **statements** can include sub-statements in a **block** (sequence of **statements** enclosed in curly brackets).\n1. **declarative statements** support the definition of special constructs of the language: for instance, **species** (including **global** and **experiment** species), **attributes**, **actions**, **behaviors**, **aspects**, **variables**, **parameters** and **outputs** of **experiments**.\n1. **imperative statements** that execute something or control the flow of execution of **actions**, **behaviors** and **aspects** are called **commands**.\n1. A **species** declaration (**global**, **species** or **grid** keywords) can only include 6 types of declarative statements : **attributes**, **actions**, **behaviors**, **aspects**, **equations** and (nested) **species**. In addition, **experiment** species allow to declare **parameters**, **outputs** and batch **methods**.\n\n\n\n## Vocabulary correspondance with the object-oriented paradigm as in Java\n| GAML | Java |\n|:--|:--|\n| species | class |\n| micro-species | nested class |\n| parent species | superclass |\n| child species | subclass |\n| model | program |\n| experiment | (main) class |\n| agent | object |\n| attribute | member |\n| action | method |\n| behavior | collection of methods |\n| aspect | collection of methods, mixed with the behavior |\n| skill | interface (on steroids) |\n| statement | statement |\n| type | type |\n| parametric type | generics |\n\n\n\n\n\n## Vocabulary correspondance with the agent-based paradigm as in NetLogo\n| GAML | NetLogo |\n|:--|:--|\n| species | breed   |\n| micro-species | -       |\n| parent species | -       |\n| child species | - (only from 'turtle') |\n| model | model   |\n| experiment | observer |\n| agent | turtle/observer |\n| attribute | 'breed'-own |\n| action | global function applied only to one breed |\n| behavior | collection of global functions applied to one breed |\n| aspect | only one, mixed with the behavior |\n| skill | -       |\n| statement | primitive |\n| type | type    |\n| parametric type | -       |","url":"wiki/Introduction.md"},"ManipulateBasicSpecies.md":{"title":" Manipulate basic species","content":"# Manipulate basic species\n\nIn this chapter, we will learn how to manipulate some basic species. As you already know, a species can be seen as the definition of a type of **agent** (we call agent the instance of a species). In OOP (Object-Oriented Programming), a **species** can be seen as the class. Each species is then defined by some **attributes** (\"member\" in OOP), **actions** (\"method\" in OOP) and **behavior** (\"method\" in OOP).\n\nIn this section, we will first learn how to declare the **world agent**, using the [**global species**](GlobalSpecies). We will then learn how to declare [**regular species**](RegularSpecies) which will populate our world. The following lesson will be dedicated to learn how to [**define actions and behaviors**](DefiningActionsAndBehaviors) for all those species. We will then learn how [**agents can interact between each other**](InteractionBetweenAgents), especially with the statement `ask`. In the next chapter then, we will see how to [**attach skills**](AttachingSkills) to our species, giving them new attributes and actions. This section will be closed with a last lesson dealing with how [**inheritence**](Inheritance) works in GAML.","url":"wiki/ManipulateBasicSpecies.md"},"MultiParadigmModeling.md":{"title":" Multi-Paradigm Modeling","content":"[//]: # (keyword|concept_architecture)\n[//]: # (keyword|concept_equation)\n# Multi-Paradigm Modeling\n\n![images/multiParadigmModeling/equation.png](resources/images/multiParadigmModeling/equation.png)\n![images/fsm.png](resources/images/multiParadigmModeling/fsm.png)\n\n[//]: # (keyword|concept_behavior)\nMulti-paradigm modeling is a research field focused on how to define a model semantically. From the beginning of this step by step tutorial, our approach is based on [behavior](DefiningActionsAndBehaviors#behaviors) (or reflex), for each agents. In this part, we will see that GAMA provides other ways to implement your model, using several control architectures. Sometime, it will be easier to implement your models choosing other paradigms.\n\nIn a first part, we will see how to use some [**control architectures**](ControlArchitecture) which already exist in GAML, such as [finite state machine architecture](ControlArchitecture#finite-state-machine), [task based architecture](ControlArchitecture#task-based) or [user control architecture](#user-control-architecture). In a second part, we will see an other approach, a math approach, through [**equations**](Equations). ","url":"wiki/MultiParadigmModeling.md"},"OptimizingModelsSection.md":{"title":" Optimizing Models","content":"[//]: # (keyword|concept_optimization)\n# Optimizing Models\n\nNow you are becoming more comfortable with GAML, it is time to think about how the runtime works, to be able to run some more optimized models. Indeed, if you already tried to write some models by yourself using GAML, you could have notice that the execution time depends a lot of how you implemented your model !\n\nWe will first present you in this part some [**runtime concepts**](RuntimeConcepts) (and present you the species facet [`scheduler`](RuntimeConcepts#schedule-agents)), and we will then show you some [**tips to optimize your models**](OptimizingModels) (how to increase performances using [scheduler](OptimizingModels#scheduling), [grids](OptimizingModels#grid), [displays](OptimizingModels#displays) and how to [choose your operators](OptimizingModels#operators)). ","url":"wiki/OptimizingModelsSection.md"},"StartWithGAML.md":{"title":" Start with GAML","content":"# Start with GAML\n\nIn this part, we will present you some basic concepts of GAML that will help you a lot for the next pages. \n\nYou will first learn how to [**organize a standard model**](ModelOrganization), then you will learn about some [**basis about GAML**](BasicProgrammingConceptsInGAML), such as how to declare a variable, how to use the basic operators, how to write a conditional structure or a loop, how to manipulate containers and how to generate random values.","url":"wiki/StartWithGAML.md"},"CallingR.md":{"title":" Calling R","content":"[//]: # (startConcept|call_r)\n[//]: # (keyword|concept_r)\n# Calling R\n\n\n## Introduction\n\n\n\nR language is one of powerful data mining tools, and its community is very large in the world (See the website: http://www.r-project.org/). Adding the R language into GAMA is our strong endeavors to accelerate many statistical, data mining tools into GAMA.\n\nRCaller 2.0 package (Website: http://code.google.com/p/rcaller/) is used for GAMA 1.6.1.\n\n\n## Table of contents \n\n* [Introduction](#introduction)\n\t* [Configuration in GAMA](#configuration-in-gama)\n\t* [Calling R from GAML](#calling-r-from-gaml)\n\t\t* [Calling the built-in operators](#calling-the-built-in-operators)\n\t\t\t* [Example 1](#example-1)\n\t\t* [Calling R codes from a text file (.txt) WITHOUT the parameters](#calling-r-codes-from-a-text-file-txt-without-the-parameters)\n\t\t\t* [Example 2](#example-2)\n\t\t\t* [Correlation.R file](#correlationr-file)\n\t\t* [Output](#output)\n\t\t\t* [Example 3](#example-3)\n\t\t\t* [RandomForest.R file](#randomforestr-file)\n* [Load the package:](#load-the-package)\n* [Read data from iris:](#read-data-from-iris)\n* [Build the decision tree:](#build-the-decision-tree)\n* [Build the random forest of 50 decision trees:](#build-the-random-forest-of-50-decision-trees)\n* [Predict the acceptance of test set:](#predict-the-acceptance-of-test-set)\n* [Calculate the accuracy:](#calculate-the-accuracy)\n\t\t\t* [Output](#output)\n\t\t* [Calling R codes from a text file (.R, .txt) WITH the parameters](#calling-r-codes-from-a-text-file-r-txt-with-the-parameters)\n\t\t\t* [Example 4](#example-4)\n\t\t\t* [Mean.R file](#meanr-file)\n\t\t* [Output](#output)\n\t\t\t* [Example 5](#example-5)\n\t\t\t* [AddParam.R file](#addparamr-file)\n\t\t\t* [Output](#output)\n\n\n\n\n## Configuration in GAMA\n1) Install R language into your computer.\n\n2) In GAMA, select menu option: **Edit/Preferences**.\n\n3) In \"**Config RScript's path**\", browse to your \"**Rscript**\" file (R language installed in your system).\n\n**Notes**: Ensure that install.packages(\"Runiversal\") is already applied in R environment.\n\n\n\n\n\n## Calling R from GAML\n\n### Calling the built-in operators\n\n#### Example 1\n\n```\nmodel CallingR\n\nglobal {\n\tlist X <- [2, 3, 1];\n\tlist Y <- [2, 12, 4]; \n\n\tlist result;\n\t\n\tinit{\n\t\twrite corR(X, Y); // -> 0.755928946018454\n\t\twrite meanR(X); // -> 2.0\n\t}\n}\n```\n\n\n### Calling R codes from a text file (**.R,**.txt) WITHOUT the parameters\n\nUsing **R\\_compute(String RFile)** operator. This operator DOESN’T ALLOW to add any parameters form the GAML code. All inputs is directly added into the R codes.\n**Remarks**: Don’t let any white lines at the end of R codes. **R\\_compute** will return the last variable of R file, this parameter can be a basic type or a list.  Please ensure that the called packages must be installed before using.\n\n#### Example 2 \n```\nmodel CallingR\n\nglobal\n{\n\tlist result;\n\n\tinit{\n\t\tresult <- R_compute(\"C:/YourPath/Correlation.R\");\n\t\twrite result at 0;\n\t}\n}\n```\nAbove syntax is deprecated, use following syntax with R_file instead of R_compute:\n\n```\nmodel CallingR\n\nglobal\n{\n\tfile result;\n\n\tinit{\n\t\tresult <- R_file(\"C:/YourPath/Correlation.R\");\n\t\twrite result.contents;\n\t}\n}\n```\n#### Correlation.R file\n```\nx <- c(1, 2, 3)\n\ny <- c(1, 2, 4)\n\nresult <- cor(x, y, method = \"pearson\")\n```\n\n### Output\n\n`result::[0.981980506061966]`\n\n\n#### Example 3\n```\nmodel CallingR\n\nglobal\n{\n\tlist result;\n\n\tinit{\n\t\tresult <- R_compute(\"C:/YourPath/RandomForest.R\");\n\n\t\twrite result at 0;\n\t}\n}\n```\n\n#### RandomForest.R file\n\n```\n# Load the package:\n\nlibrary(randomForest)\n\n# Read data from iris:\n\ndata(iris)\n\nnrow<-length(iris[,1])\n\nncol<-length(iris[1,])\n\nidx<-sample(nrow,replace=FALSE)\n\ntrainrow<-round(2*nrow/3)\n\ntrainset<-iris[idx[1:trainrow],]\n\n# Build the decision tree:\n\ntrainset<-iris[idx[1:trainrow],]\n\ntestset<-iris[idx[(trainrow+1):nrow],]\n\n# Build the random forest of 50 decision trees:\n\nmodel<-randomForest(x= trainset[,-ncol], y= trainset[,ncol], mtry=3, ntree=50)\n\n# Predict the acceptance of test set: \n\npred<-predict(model, testset[,-ncol], type=\"class\")\n\n# Calculate the accuracy:\n\nacc<-sum(pred==testset[, ncol])/(nrow-trainrow)\n```\n\n#### Output\n\n`acc::[0.98]`\n\n### Calling R codes from a text file (.R, .txt) WITH the parameters\n\nUsing **R\\_compute\\_param(String RFile, List vectorParam)** operator. This operator ALLOWS to add the parameters from the GAML code.\n\n**Remarks**: Don’t let any white lines at the end of R codes. **R\\_compute\\_param** will return the last variable of R file, this parameter can be a basic type or a list. Please ensure that the called packages must be installed before using.\n\n#### Example 4\n\n```\nmodel CallingR\n\nglobal\n{\n\tlist X <- [2, 3, 1];\n\tlist result;\n\n\tinit{\n\t\tresult <- R_compute_param(\"C:/YourPath/Mean.R\", X);\n\t\twrite result at 0;\n\t}\n}\n```\n\n#### Mean.R file\n\n`result <- mean(vectorParam)`\n\n### Output\n\n`result::[3.33333333333333]`\n\n#### Example 5\n\n```\nmodel CallingR\n\nglobal {\n\tlist X <- [2, 3, 1];\n\tlist result;\n\t\n        init{\n\t\tresult <- R_compute_param(\"C:/YourPath/AddParam.R\", X);\n\t\twrite result at 0;\n\t}\n}\n```\n\n#### AddParam.R file\n\n`v1 <- vectorParam[1]`\n\n`v2<-vectorParam[2]`\n\n`v3<-vectorParam[3]`\n\n`result<-v1+v2+v3`\n\n#### Output\n\n`result::[10]`\n[//]: # (endConcept|call_r)","url":"wiki/CallingR.md"},"Comodel.md":{"title":" Using Comodel","content":"# Using Comodel\n\n## Introduction\nIn the trend of developing complex system of multi-disciplinary, composing and coupling models are days by days become the most attractive research objectives. \nGAMA is supporting the co-modelling and co-simulation which are suppose to be the common coupling infrastructure.\n\n\n## Example of a Comodel \n\nA Comodel is a model, especially an multi-agent-based, compose several sub-model, called micro-model. A comodel itself could be also a micro-model of an other comodel. From the view of a micro-model, comodel is called a macro-model.\n\nA micro-model must be import, instantiate, and life-control by macro-model.\n\n![](resources/images/comodel/concepts.png)\n\n\n## Why and when can we use Comodel ?\n\nto be completed...\n\n## Use of Comodel in a GAML model\n\n\nThe GAML language has been evolve by extend the import section. The old importation tell the compiler to merge all imported elements into as one model, but the new one allows modellers to keep the elements come from imported models separately with the caller model.\n\n### Defining a micro-model\nDefining a micro-model of comodel is to import an existing model with an alias name. The syntax is: \n``` \nimport <path to the GAML model> as <identifier>\n```\nThe identifier is then become the new name of the micro-model.\n\n\n### Instantiate a micro-model\nAfter the importation and giving an identifier, micro-model must be explicitly instantiated. It could be done by create statement. \n```\ncreate <micro-model identifier> . <experiment name> [optional parameter];\n```\nTHe <exeperiment name> is an expriment inside micro-model. This syntax will generate an experiment agent and attach an implicitly simulation. \n\nNote: Creation of multi-instant is not create multi-simulation, but multi-experiment. Modellers could create a experiment with multi-simulation by explicitly do the init inside the experiment scope.\n\n### Control micro-model life-cycle\nA micro-model can be control as the normal agent by asking the correspond identifier, and also be destroy by the 'o die' statement. As fact, it can be recreate any time we need.\n\n\n```\nask (<micro-model identifier> . <experiment name>  at <number> ) . simulation {\n\t\t...\n}\n```\n\n\n## Visualize micro-model\n\nThe micro-model species could display in comodel with the support of agent layer\n\n```\nagents \"name of layer\" value: (<micro-model> . <experiment name> at <number>).<get List of agents>;\n```\n\n\n\n## More details\n\n\n## Example of the comodel\n\n### Urbanization model with Traffic model\n\n![](resources/images/comodel/comodel_urban_traffic.png)\n\n### Flood model with Evacuation model\nReusing of  two existing models:Flood Simulation and Evacuation.\n\nToy Models/Evacuation/models/continuous_move.gaml\n\n![](resources/images/comodel/continuous_move_model_display.png)\n\nToy Models/Flood Simulation/models/Hydrological Model.gaml\n\n![](resources/images/comodel/hydro_model_display.png)\n\nThe comodel explore the effect of flood on evacuation plan:\n\n![](resources/images/comodel/comodel_disp_Flood_Evacuation.png)\n\nSimulation results:\n\n![](resources/images/comodel/comodel_Flood_Evacuation.png)\n","url":"wiki/Comodel.md"},"Diffusion.md":{"title":" Implementing diffusion","content":"[//]: # (startConcept|diffusion)\n[//]: # (keyword|concept_diffusion)\n# Implementing diffusion\n[//]: # (keyword|concept_grid)\n[//]: # (keyword|concept_math)\n[//]: # (keyword|concept_topology)\n\nGAMA provides you the possibility to represent and simulate the diffusion of a variable through a grid topology. \n\n## Index\n\n* [Diffuse statement](#diffuse-statement)\n* [Diffusion with matrix](#diffusion-with-matrix)\n  * [Diffusion matrix](#diffusion-matrix)\n  * [Gradient matrix](#gradient-matrix)\n  * [Compute multiple propagations at the same step](#compute-multiple-propagations-at-the-same-step)\n  * [Executing several diffusion matrix](#execution-several-diffusion-matrix)\n* [Diffusion with parameters](#diffusion-with-parameters)\n* [Computation methods](#computation-methods)\n  * [Convolution](#convolution)\n  * [Dot Product](#dot-product)\n* [Use mask](#using-mask)\n  * [Generalities](#generalities)\n  * [Tips](#tips)\n* [Pseudo code](#pseudo-code)\n\n## Diffuse statement\n\n[//]: # (keyword|statement_diffuse)\nThe statement to use for the diffusion is `diffuse`. It has to be used in a `grid` species. The `diffuse` uses the following facets:\n\n  * **`var`** (an identifier), (omissible) : the variable to be diffused  \n  * **`on`** (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occur\n  * `avoid_mask` (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the variation value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won't diffuse the value afterward (lost of signal). (default value : false)\n  * `cycle_length` (int): the number of diffusion operation applied in one simulation step\n  * `mask` (matrix): a matrix masking the diffusion (matrix created from a image for example). The cells corresponding to the values smaller than \"-1\" in the mask matrix will not diffuse, and the other will diffuse.\n  * `matrix` (matrix): the diffusion matrix (\"kernel\" or \"filter\" in image processing). Can have any size, as long as dimensions are odd values.\n  * `method` (an identifier), takes values in: {convolution, dot_product}: the diffusion method\n  * `min_value` (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.\n  * `propagation` (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals 'diffusion', the intensity of a signal is shared between its neighbors with respect to 'proportion', 'variation' and the number of neighbours of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S' = (S / N / proportion) - variation. The intensity of S is then diminished by S `*` proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals 'gradient', the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If 'propagation' is not defined, it is assumed that it is equal to 'diffusion'.\n  * `proportion` (float): a diffusion rate\n  * `radius` (int): a diffusion radius (in number of cells from the center)\n  * `variation` (float): an absolute value to decrease at each neighbors \n\nTo write a diffusion, you first have to declare a grid, and declare a special attribute for the diffusion. You will then have to write the `diffuse` statement in an other scope (such as the `global` scope for instance), which will permit the values to be diffused at each step. There, you will specify which variable you want to diffuse (through the **`var`** facet), on which species or list of agents you want the diffusion (through the **`on`** facet), and how you want this value to be diffused (through all the other facets, we will see how it works [with matrix](#diffusion-with-matrix) and [with special parameters](#diffusion-with-parameters) just after).\n\nHere is the template of code we will use for the next following part of this page:\n\n```\nglobal {\n\tint size <- 64; // the size has to be a power of 2.\n  \tcells selected_cells;\n\n\t// Initialize the emiter cell as the cell at the center of the word\n\tinit {\n\t\tselected_cells <- location as cells;\n\t}\n\t// Affecting \"1\" to each step\n\treflex new_Value {\n\t\task(selected_cells){\n\t\t\tphero <- 1.0;\n\t\t}\t\n\t}\n\n\treflex diff {\n\t\t// Declare a diffusion on the grid \"cells\" and on \"quick_cells\". The diffusion declared on \"quick_cells\" will make 10 computations at each step to accelerate the process. \n\t\t// The value of the diffusion will be store in the new variable \"phero\" of the cell.\n\t\tdiffuse var: phero on: cells /*HERE WRITE DOWN THE DIFFUSION PROPERTIES*/;\t\t\t\n\t}\n}\n\n\ngrid cells height: size width: size {\n\t// \"phero\" is the variable storing the value of the diffusion\n\tfloat phero  <- 0.0;\n\t// The color of the cell is linked to the value of \"phero\".\n\trgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\n}\n\n\nexperiment diffusion type: gui {\n\toutput {\n\t\tdisplay a type: opengl {\n\t\t\t// Display the grid with elevation\n\t\t\tgrid cells elevation: phero * 10 triangulation: true;\n\t\t}\n\t}\n}\n```\n\nThis model will simulate a diffusion through a grid at each step, affecting 1 to the center cell diffusing variable value. The diffusion will be seen during the simulation through a color code, and through the elevation of the cell.\n\n## Diffusion with matrix\n\n[//]: # (keyword|concept_matrix)\nA first way of specifying the behavior of your diffusion is using diffusion matrix. A diffusion matrix is a 2 dimension matrix `[n][m]` with `float` values, where both `n` and `m` have to be **pair values**. The most often, diffusion matrix are square matrix, but you can also declare rectangular matrix.\n\nExample of matrix:\n\n```\nmatrix<float> mat_diff <- matrix([\n\t\t[1/9,1/9,1/9],\n\t\t[1/9,1/9,1/9],\n\t\t[1/9,1/9,1/9]]);\n```\n\nIn the `diffuse` statement, you than have to specify the matrix of diffusion you want in the facet `matrix`.\n\n```\ndiffuse var: phero on: cells matrix:mat_diff;\n```\n\nUsing the facet `propagation`, you can specify if you want the value to be propagated as a _diffusion_ or as a _gratient_.\n\n### Diffusion matrix\n\nA _diffusion_ (the default value of the facet `propagation`) will spread the values to the neighbors cells according to the diffusion matrix, and all those values will be added together, as it is the case in the following example :\n\n![resources/images/recipes/diffusion_computation.png](resources/images/recipes/diffusion_computation.png)\n\nNote that the sum of all the values diffused at the next step is equal to the sum of the values that will be diffused multiply by the sum of the values of the diffusion matrix. That means that if the sum of the values of your diffusion matrix is larger than 1, the values will increase exponentially at each step. The sum of the value of a diffusion matrix is usually equal to 1.\n\nHere are some example of matrix you can use, played with the template model:\n\n![resources/images/recipes/uniform_diffusion.png](resources/images/recipes/uniform_diffusion.png)\n\n![resources/images/recipes/anisotropic_diffusion.png](resources/images/recipes/anisotropic_diffusion.png)\n\n### Gradient matrix\n\nA `gradient` (use facet : `propagation:gradient`) is an other type of propagation. This time, only the larger value diffused will be chosen as the new one.\n\n![resources/images/recipes/gradient_computation.png](resources/images/recipes/gradient_computation.png)\n\nNote that unlike the _diffusion_ propagation, the sum of your matrix can be greater than 1 (and it is the case, most often !).\n\nHere are some example of matrix with gradient propagation:\n\n![resources/images/recipes/uniform_gradient.png](resources/images/recipes/uniform_gradient.png)\n\n![resources/images/recipes/irregular_gradient.png](resources/images/recipes/irregular_gradient.png)\n\n### Compute multiple propagations at the same step\n\nYou can compute several times the propagation you want by using the facet `cycle_length`. GAMA will compute for you the corresponding new matrix, and will apply it.\n\n![resources/images/recipes/cycle_length.png](resources/images/recipes/cycle_length.png)\n\nWriting those two thinks are exactly equivalent (for diffusion):\n\n```\n\tmatrix<float> mat_diff <- matrix([\n\t\t\t[1/81,2/81,3/81,2/81,1/81],\n\t\t\t[2/81,4/81,6/81,4/81,2/81],\n\t\t\t[3/81,6/81,1/9,6/81,3/81],\n\t\t\t[2/81,4/81,6/81,4/81,2/81],\n\t\t\t[1/81,2/81,3/81,2/81,1/81]]);\n\treflex diff {\n\t\tdiffuse var: phero on: cells matrix:mat_diff;\n```\n```\n\tmatrix<float> mat_diff <- matrix([\n\t\t\t[1/9,1/9,1/9],\n\t\t\t[1/9,1/9,1/9],\n\t\t\t[1/9,1/9,1/9]]);\n\treflex diff {\n\t\tdiffuse var: phero on: cells matrix:mat_diff cycle_length:2;\n```\n\n### Executing several diffusion matrix\n\nIf you execute several times the statement `diffuse` with different matrix on the same variable, their values will be added (and centered if their dimension is not equal).\n\nThus, the following 3 matrix will be combined to create one unique matrix:\n\n![resources/images/recipes/addition_matrix.png](resources/images/recipes/addition_matrix.png)\n\n## Diffusion with parameters\n\nSometimes writing diffusion matrix is not exactly what you want, and you may prefer to just give some parameters to compute the correct diffusion matrix. You can use the following facets in order to do that : `propagation`, `variation` and `radius`.\n\nDepending on which `propagation` you choose, and how many neighbors your grid have, the propagation matrix will be compute differently. The propagation matrix will have the size : range*2+1.\n\nLet's note **P** for the propagation value, **V** for the variation, **R** for the range and **N** for the number of neighbors.\n\n* **With diffusion propagation**\n\nFor diffusion propagation, we compute following the following steps:\n\n(1) We determine the \"minimale\" matrix according to N (if N = 8, the matrix will be `[[P/9,P/9,P/9][P/9,1/9,P/9][P/9,P/9,P/9]]`. if N = 4, the matrix will be `[[0,P/5,0][P/5,1/5,P/5][0,P/5,0]]`).\n\n(2) If R != 1, we propagate the matrix R times to obtain a `[2*R+1][2*R+1]` matrix (same computation as for `cycle_length`).\n\n(3) If V != 0, we substract each value by V*DistanceFromCenter (DistanceFromCenter depends on N).\n\nEx with the default values (P=1, R=1, V=0, N=8):\n\n* **With gradient propagation**\n\nThe value of each cell will be equal to **P/POW(N,DistanceFromCenter)-DistanceFromCenter*V**. (DistanceFromCenter depends on N).\n\nEx with R=2, other parameters default values (R=2, P=1, V=0, N=8):\n\n![resources/images/recipes/gradient_computation_from_parameters.png](resources/images/recipes/gradient_computation_from_parameters.png)\n\nNote that if you declared a diffusion matrix, you cannot use those 3 facets (it will raise a warning). Note also that if you use parameters, you will only have uniform matrix.\n\n## Computation methods\n\nYou can compute the output matrix using two computation methods by using the facet `method` : the dot product and the convolution. Note that the result of those two methods is exactly the same (except if you use the `avoid_mask` facet, the results can be slightly differents between the two computations).\n\n### Convolution\n\n`convolution` is the default computation method for the diffusion. For every output cells, we will multiply the input values and the flipped kernel together, as shown in the following image :\n\n![resources/images/recipes/convolution.png](resources/images/recipes/convolution.png)\n\nPseudo-code (`k` the kernel, `x` the input matrix, `y` the output matrix) :\n\n```\nfor (i = 0 ; i < y.nbRows ; i++)\n  for (j = 0 ; j < y.nbCols ; j++)\n    for (m = 0 ; m < k.nbRows ; m++)\n      for (n = 0 ; n < k.nbCols ; n++)\n        y[i,j] += k[k.nbRows - m - 1, k.nbCols - n - 1] \n            * x[i - k.nbRows/2 + m, j - k.nbCols/2 + n]\n```\n\n### Dot Product\n\n`dot_product` method will compute the matrix using a simple dot product between the matrix. For every input cells, we multiply the cell by the kernel matrix, as shown in the following image :\n\n![resources/images/recipes/dot_product.png](resources/images/recipes/dot_product.png)\n\nPseudo-code (`k` the kernel, `x` the input matrix, `y` the output matrix) :\n\n```\nfor (i = 0 ; i < y.nbRows ; i++)\n  for (j = 0 ; j < y.nbCols ; j++)\n    for (m = 0 ; m < k.nbRows ; m++)\n      for (n = 0 ; n < k.nbCols ; n++)\n        y[i - k.nbRows/2 + m, j - k.nbCols/2 + n] += k[m, n] * x[i, j]\n```\n\n## Using mask\n\n### Generalities\n\nIf you want to propagate some values in an heterogeneous grid, you can use some mask to forbid some cells to propagate their values.\n\nYou can pass a matrix to the facet `mask`. All the values smaller than `-1` will not propagate, and all the values greater or equal to `-1` will propagate.\n\nA simple way to use mask is by loading an image :\n\n![resources/images/recipes/simple_mask.png](resources/images/recipes/simple_mask.png)\n\nNote that when you use the `on` facet for the `diffuse` statement, you can choose only some cells, and not every cells. In fact, when you restrain the values to be diffuse, it is exactly the same process as if you were defining a mask.\n\n![resources/images/recipes/mask_with_on_facet.png](resources/images/recipes/mask_with_on_facet.png)\n\nWhen your diffusion is combined with a mask, the default behavior is that the non-masked cells will diffuse their values in **all** existing cells (that means, even the masked cells !). To change this behavior, you can use the facet `avoid_mask`. In that case, the value which was supposed to be affected to the masked cell will be redistributed to the neighboring non-masked cells.\n\n### Tips\n\nMasks can be used to simulate a lot of environments. Here are some ideas for your models:\n\n#### Wall blocking the diffusion\n\nIf you want to simulate a wall blocking a uniform diffusion, you can declare a second diffusion matrix that will be applied only on the cells where your wall will be. This diffusion matrix will \"push\" the values outside from himself, but conserving the values (the sum of the values of the diffusion still have to be equal to 1) :\n\n```\nmatrix<float> mat_diff <- matrix([\n\t\t\t[1/9,1/9,1/9],\n\t\t\t[1/9,1/9,1/9],\n\t\t\t[1/9,1/9,1/9]]);\n\t\t\t\t\t\t\t\t\nmatrix<float> mat_diff_left_wall <- matrix([\n\t\t\t[0.0,0.0,2/9],\n\t\t\t[0.0,0.0,4/9],\n\t\t\t[0.0,0.0,2/9]]);\n\nreflex diff { \n\tdiffuse var: phero on: (cells where(each.grid_x>30)) matrix:mat_diff;\n\tdiffuse var: phero on: (cells where(each.grid_x=30)) matrix:mat_diff_left_wall;\n}\n```\n\n![resources/images/recipes/wall_simulation.png](resources/images/recipes/wall_simulation.png)\n\nNote that almost the same result can be obtained by using the facet `avoid_mask` : the value of all masked cells will remain at 0, and the value which was supposed to be affected to the masked cell will be distributed to the neighboring cells. Notice that the results can be slightly different if you are using the `convolution` or the `dot_product` method : the algorithm of redistribution of the value to the neighboring cells is a bit different. We advise you to use the `dot_product` with the `avoid_mask` facet, the results are more accurates.\n\n#### Wind pushing the diffusion\n\nLet's simulate a uniform diffusion that is pushed by a wind from \"north\" everywhere in the grid. A wind from \"west\" as blowing at the top side of the grid. We will here have to build 2 matrix : one for the uniform diffusion, one for the \"north\" wind and one for the \"west\" wind. The sum of the values for the 2 matrix meant to simulate the wind will be equal to 0 (as it will be add to the diffusion matrix).\n\n```\nmatrix<float> mat_diff <- matrix([\n\t\t[1/9,1/9,1/9],\n\t\t[1/9,1/9,1/9],\n\t\t[1/9,1/9,1/9]]);\n\t\t\t\t\t\t\t\t\nmatrix<float> mat_wind_from_west <- matrix([\n\t\t[-1/9,0.0,1/9],\n\t\t[-1/9,0.0,1/9],\n\t\t[-1/9,0.0,1/9]]);\n\t\t\t\t\t\t\t\t\nmatrix<float> mat_wind_from_north <- matrix([\n\t\t[-1/9,-1/9,-1/9],\n\t\t[0.0,0.0,0.0],\n\t\t[1/9,1/9,1/9]]);\n\nreflex diff { \n\tdiffuse var: phero on: cells matrix:mat_diff;\n\tdiffuse var: phero on: cells matrix:mat_wind_from_north;\n\tdiffuse var: phero on: (cells where (each.grid_y>=32)) matrix:mat_wind_from_west;\n}\n```\n\n![resources/images/recipes/diffusion_with_wind.png](resources/images/recipes/diffusion_with_wind.png)\n\n#### Endless world\n\nNote that when your world is not a torus, it has the same effect as a _mask_, since all the values outside from the world cannot diffuse some values back :\n\n![resources/images/recipes/uniform_diffusion_near_edge.png](resources/images/recipes/uniform_diffusion_near_edge.png)\n\nYou can \"fake\" the fact that your world is endless by adding a different diffusion for the cells with `grid_x=0` to have almost the same result :\n\n![resources/images/recipes/uniform_diffusion_near_edge_with_mask.png](resources/images/recipes/uniform_diffusion_near_edge_with_mask.png)\n\n```\nmatrix<float> mat_diff <- matrix([\n\t\t\t[1/9,1/9,1/9],\n\t\t\t[1/9,1/9,1/9],\n\t\t\t[1/9,1/9,1/9]]);\n\t\t\t\t\t\t\t\t\nmatrix<float> mat_diff_upper_edge <- matrix([\n\t\t\t[0.0,0.0,0.0],\n\t\t\t[1/9+7/81,2/9+1/81,1/9+7/81],\n\t\t\t[1/9,1/9,1/9]]);\n\nreflex diff { \n\tdiffuse var: phero on: (cells where(each.grid_y>0)) matrix:mat_diff;\n\tdiffuse var: phero on: (cells where(each.grid_y=0)) matrix:mat_diff_upper_edge;\n}\n```\n\n## Pseudo code\n\n_This section is more for a better understanding of the source code._\n\nHere is the pseudo code for the computation of diffusion :\n\n1) : Execute the statement `diffuse`, store the diffusions in a map (from class _DiffusionStatement_ to class _GridDiffuser_) :\n\n```\n- Get all the facet values\n- Compute the \"real\" mask, from the facet \"mask:\" and the facet \"on:\".\n  - If no value for \"mask:\" and \"on:\" all the grid, the mask is equal to null.\n- Compute the matrix of diffusion\n  - If no value for \"matrix:\", compute with \"nb_neighbors\", \"is_gradient\", \"proportion\", \"propagation\", \"variation\", \"range\".\n  - Then, compute the matrix of diffusion with \"cycle_length\".\n- Store the diffusion properties in a map\n  - Map : [\"method_diffu\", \"is_gradient\", \"matrix\", \"mask\", \"min_value\"] is value, [\"var_diffu\", \"grid_name\"] is key.\n  - If the key exists in the map, try to \"mix\" the diffusions\n    - If \"method_diffu\", \"mask\" and \"is_gradient\" equal for the 2 diffusions, mix the diffusion matrix.\n```\n\n2) : At the end of the step, execute the diffusions (class _GridDiffuser_) :\n\n```\n- For each key of the map,\n  - Load the couple \"var_diffu\" / \"grid_name\"\n  - Build the \"output\" and \"input\" array with the dimension of the grid. \n  - Initialize the \"output\" array with -Double.MAX_VALUE.\n  - For each value of the map for that key,\n    - Load all the properties : \"method_diffu\", \"is_gradient\", \"matrix\", \"mask\", \"min_value\"\n    - Compute :\n      - If the cell is not masked, if the value of input is > min_value, diffuse to the neighbors.\n        - If the value of the cell is equal to -Double.MAX_VALUE, remplace it by input[idx] * matDiffu[i][j].\n        - Else, do the computation (gradient or diffusion).\n    - Finish the diffusion :\n      - If output[idx] > -Double.MAX_VALUE, write the new value in the cell.\n```\n[//]: # (endConcept|diffusion)","url":"wiki/Diffusion.md"},"FAQ.md":{"title":" FAQ (Frequently Asked Questions)","content":"# FAQ (Frequently Asked Questions)\n\n[//]: # (concept|video)\n## Can we record a video from an experiment ?\n\nNo, we cannot directly. But you have two alternatives :\n- With the set of images generated with the `autosave` facet of an experiment, you can construct your own video file using powerful software such as [ffmpeg](https://www.ffmpeg.org/).\n- You can directly record the video stream using software such as [VLC Media Player](http://www.videolan.org/vlc/index.html) or [QuickTime](http://www.apple.com/quicktime/download/).","url":"wiki/FAQ.md"},"GamAnalyzer.md":{"title":" Using GAMAnalyzer","content":"[//]: # (startConcept|run_several_models_using_gamanalyzer)\n# Using GAMAnalyzer\n\n## Install\n\nGo to Git View -> Click on Import Projects\nAdd the dependencies in ummisco.gama.feature.dependencies\n\nGamAnalyzer is a tool to monitor several multi-agents simulation\n\nThe \"agent_group_follower\" goal is to monitor and analyze a group of agent during several simulation. This group of agent can be chosen by the user according to criteria chosen by the user. The monitoring process and analysis of these agents involves the extraction, processing and visualization of their data at every step of the simulation.  The data for each simulation are pooled and treated commonly for their graphic representation or clusters.\n\n## Built-in Variable\n\n\n\n\n* **varmap**: All variable that can be analyzed or displayed in a graph.\n\n* **numvarmap**: Numerical variable (on this variable all the aggregator numeric are computed). \n\n* **qualivarmap**: All non numerical variable. Could be used for BDI to analyze beliefs.\n\n* **metadatahistory**: See updateMetaDataHistory. This matrice store all the metadata like getSimulationScope(), getClock().getCycle(), getUniqueSimName(scope), rule, scope.getAgentScope().getName(), this.getName(), this.agentsCourants.copy(scope), this.agentsCourants.size(), this.getGeometry().\n\n\n* **lastdetailedvarvalues**: store all the value (in varmap) for all the followed agent for the last iteration.\n\n\n\n* **averagehistory**: Average value for each of the numvar \n* **stdevhistory**: Std deviation value for each of the numvar \n* **minhistory**: Min deviation value for each of the numvar \n* **maxhistory**: Max deviation value for each of the numvar\n* **distribhistoryparams**: Gives the interval of the distribution described in distribhistory\n* **distribhistory**: Distribution of numvarmap\n\n* **multi_metadatahistory**: Aggregate each metadatahistory for each experiment \n\n\n## Example \n\nThis example is based on a toy model which is only composed of wandering people. In this example we will use GamAnalyzer to follow the agent people. \n\n### \n```\nagent_group_follower peoplefollower;\n```\n```\ncreate agentfollower \n{\n  do analyse_cluster species_to_analyse:\"people\";\n  peoplefollower<-self;\n}\n```\n\n### expGlobalNone\nNo clustering only the current agent follower is displayed\n```\naspect base {\n  display_mode <-\"global\";\n  clustering_mode <-\"none\";\n  draw shape color: #red;\n}\n```\n\n### expSimGlobalNone \nThe agent_group_follower corresponding to the current iteration and all the already launch experiments are displayed. \n```\naspect simglobal{\n  display_mode <-\"simglobal\";\n  clustering_mode <-\"none\";\n  draw shape color: #red;\n  int curColor <-0;\n  loop geom over: allSimShape{\n    draw geom color:SequentialColors[curColor] at:{location.x,location.y,curColor*10};\n    curColor <- curColor+1;\n  }\n}\n```\n### expCluster\nThe agent group follower is divided in cluster computed thanks to a dbscan algorithm. Only the current agent_group_follower is displayed\n```\naspect cluster {\n  display_mode <-\"global\";\n  clustering_mode <-\"dbscan\";\n  draw shape color: #red;\n}\n```\n### expClusterSimGlobal\nThe agent_group_follower (made of different cluster) corresponding to the current iteration and all the already launch experiments are displayed. \n\n```\naspect clusterSimGlobal {\n  display_mode <-\"simglobal\";\n  clustering_mode <-\"dbscan\";\n  draw shape color: #red;\n  int curColor <-0;\n  loop geom over: allSimShape{\n    draw geom color:SequentialColors[curColor] at:{location.x,location.y,curColor*10};\n    curColor <- curColor+1;\n  } \n}\n```\n[//]: # (endConcept|run_several_models_using_gamanalyzer)","url":"wiki/GamAnalyzer.md"},"Headless-mode-for-dummies.md":{"title":" Overview","content":"# Overview\n\nThis tutorial presents the headless mode usage of GAMA. We will execute the Predator-Prey model, already presented in [this tutorial](PredatorPrey_step1).\nHeadless mode is documented [here](Headless), with the same model as an example. Here, we focus on the definition of an experiment plan, where the model is run several times. We only consider the shell script execution, not the java command execution.\n\nIn headless-mode, GAMA can be seen as any shell command, whose behavior is controlled by passing arguments to it.\nYou must provide 2 arguments : \n\n* an **input experiment file **, used to describe the execution plan of your model, its inputs and the expected outputs.\n* an ** output directory **, where the results of the execution are stored\n \nHeadless-mode is a little bit more technical to handle than the general GAMA use-case, and the following commands and code have been solely tested on a Linux Ubuntu 15.04 machine, x86_64 architecture, with kernel 3.19.0-82-generic.\nJava version is 1.8.0_121 (java version \"1.8.0_121\")\n\nYou may have to perform some adjustments (such as paths definition) according to your machine, OS, java and GAMA versions and so on.\n\n\n\n# Setup \n\n## GAMA version\n\nHeadless mode is frequently updated by GAMA developers, so you have to get the very latest build version of GAMA. You can download it here  [https://github.com/gama-platform/gama/releases](https://github.com/gama-platform/gama/releases) Be sure to pick the ** Continuous build **  version (The name looks like `GAMA1.7_Linux_64_02.26.17_da33f5b.zip`) and ** not ** the major release, e.g. `GAMA1.7_Linux_64.zip`.\n\n\n## gama-headless.sh script setup\n\n\nThe `gama-headless.sh` script can be found under the `headless` directory, in GAMA installation directory e.g. : `~/GAMA/headless/\n\n\n## Modifying the script (a little bit)\n\nThe original script looks like this : \n\n\t#! /bin/bash\n\tmemory=2048m\n\tdeclare -i i\t\n\n\ti=0\n\techo ${!i}\t\n\n\tfor ((i=1;i<=$#;i=$i+1))\n\tdo\n\tif test ${!i} = \"-m\"\n\tthen\n\t    i=$i+1\n\t    memory=${!i}\n\telse\n\t    PARAM=$PARAM\\ ${!i}\n\t    i=$i+1\n\t    PARAM=$PARAM\\ ${!i}\n\tfi\n\tdone\t\n\n\techo \"******************************************************************\"\n\techo \"* GAMA version 1.7.0 V7                                          *\"\n\techo \"* http://gama-platform.org                                       *\"\n\techo \"* (c) 2007-2016 UMI 209 UMMISCO IRD/UPMC & Partners              *\"\n\techo \"******************************************************************\"\n\tpassWork=.work$RANDOM\t\n\n\tjava -cp ../plugins/org.eclipse.equinox.launcher*.jar -Xms512m -Xmx$memory  -Djava.awt.headless=true org.eclipse.core.launcher.Main  -application msi.gama.headless.id4 -data $passWork $PARAM $mfull $outputFile\n\trm -rf $passWork\n\n\nNotice the final command of the script `rm -rf $passWork`. It is intended to remove the temporary file used during the execution of the script. For now, we should comment this commmand, in order to check the logs if an error appears : `#rm -rf $passWork`\n\n## Setting the experiment file\n\n\nHeadless mode uses a XML file to describe the execution plan of a model. An example is given in the [headless mode documentation page](Headless).\n\nThe script looks like this :\n** N.B. this version of the script, given as an example, is deprecated**\n\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<Experiment_plan>\n\t<Simulation id=\"2\" sourcePath=\"./predatorPrey/predatorPrey.gaml\" finalStep=\"1000\" experiment=\"predPrey\">\n\t\t<Parameters>\n\t\t\t<Parameter name=\"nb_predator_init\" type=\"INT\" value=\"53\" />\n\t\t\t<Parameter name=\"nb_preys_init\" type=\"INT\" value=\"621\" />\n\t\t</Parameters>\n\t\t<Outputs>\n\t\t\t<Output id=\"1\" name=\"main_display\" framerate=\"10\" />\n\t\t\t<Output id=\"2\" name=\"number_of_preys\" framerate=\"1\" />\n\t\t\t<Output id=\"3\" name=\"number_of_predators\" framerate=\"1\" />\n\t\t\t<Output id=\"4\" name=\"duration\" framerate=\"1\" />\n\t\t</Outputs>\n\t</Simulation>\n\t</Experiment_plan>\n\n\nAs you can see, you need to define 3 things in this minimal example :\n* Simulation:  its id, path to the model , finalStep (or stop condition), and name of the experiment\n* Parameters name, of the model for * this * simulation (i.e. Simulation of id= 2)\n* Outputs of the model: their id, name, type, and the rate (expressed in cycles) at which they are logged in the results file during the simulation\n\n\nWe now describe how to constitute your experiment file.\n\n# Experiment File : Simulation\n\n## id\n\nFor now, we only consider one single execution of the model, so the simulation `id` is not critical, let it unchanged.\nLater example will include different simulations in the same experiment file.\nSimulation `id` is a string. Don't introduce weird symbols into it. \n\n## sourcePath \n\n`sourcePath` is the relative (or absolute) path to the model file you want to execute headlessly.\n\nHere we want to execute the [fourth model of the Predator Prey tutorial suite](PredatorPrey_step4), located in `~/GAMA/plugins/msi.gama.models_1.7.0.XXXXXXXXXXXX/models/Tutorials/Predator Prey/models` (with XXXXXXXXXXXX replaced by the number of the release you downloaded)\n  \nSo we set sourcePath=\"../plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 07.gaml\"  (Remember that the headless script is located in `~/GAMA/headless/`)\n \nDepending on the directory you want to run the `gama-headless.sh` script, sourcePath must me modified accordingly.\nAnother workaround for shell more advanced users is to define a  `$GAMA_PATH`, `$MODEL_PATH` and `$OUPUT_PATH` in `gama-headless.sh` script.\nDon't forget the quotes `\"` around your path.\n\n## finalStep\n\nThe duration, in cycles, of the simulation. \n\n## experiment\n\nThis is the name of (one of) the experiment statement at the end of the model code.\n\nIn our case there is only one, called `prey_predator` and  it looks like this :\n\n\texperiment prey_predator type: gui {\n\t\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n\t\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\t\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\t\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\t\toutput {\n\t\t\tdisplay main_display {\n\t\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\t\tspecies prey aspect: base ;\n\t\t\t}\n\t\t\tmonitor \"Number of preys\" value: nb_preys ;\n\t\t}\n\t}  \n\nSo we are now able to constitute the entire Simulation tag : \n\n`<Simulation id=\"2\" sourcePath=\"~/GAMA/plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 01.gaml\" finalStep=\"1000\" experiment=\"prey_predator\">`\n\t\n\nN.B. the numbers after `msi.gama.models` (the number of your GAMA release actually) have to be adapted to your own release of GAMA number.\nThe path to the GAMA installation directory has also to be adapted of course.\n\n\n# Experiment File : Parameters\n\nThe parameters section of the experiment file describes the parameters names, types and values to be passed to the model for its execution.\n\nLet's say we want to fix the number of preys and their max energy  for this simulation.\nWe look at the experiment section of the model code and use their ** title **. \nThe title of a parameter is the name that comes right after the `parameter` statement. In our case,  the strings \"Initial number of preys: \" and \"Prey max energy: \" (Mind the spaces, quotes and colon)\n\n\n\nThe parameters section of the file would look like :\n\n\t<Parameters>\n\t\t<Parameter name=\"Initial number of preys: \" type=\"INT\" value=\"621\" />\n\t\t<Parameter name=\"Prey max energy: \" type=\"FLOAT\" value=\"1.0\" />\n\t</Parameters>\n\n\nAny declared parameter can be set this way, yet you don't have to set all of them, provided they are initialized with a default value in the model (see the global statement part of the model code).\n\n\n\n# Experiment File : Outputs\n\n\nOutput section of the experiment file is pretty similar to the previous one, except for the `id` that have to be set for each of the outputs .\n\nWe can log some of the declared outputs  : `main_display` and `number_of_preys`.\n\nThe outputs section would look like the following:\n\n\t<Outputs>\n\t\t<Output id=\"1\" name=\"main_display\" framerate=\"10\" />\n\t\t<Output id=\"2\" name=\"Number of preys\" framerate=\"1\" />\n\t</Outputs>\n\nOutputs must have an id, a name, and a framerate.\n\n* `id` is a number that identifies the output\n* framerate is the rate at which the output is written in the result file. It's a number of cycle of simulation (integer). In this example the display is saved every 10 cycle\n* `name` is either the \"title\" of the corresponding monitor. In our case, the second output's is the title of the monitor `\"Number of preys\"`, i.e. \"Number of preys\"\n\nWe also save a **display ** output, that is an image of the simulation graphical display named `main_display` in the code of the model. Theses images is what you would have seen if you had run the model in the traditional GUI mode.\n\n\n\n\n# Execution and results\n\nOur new version of the experiment file is ready : \n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Experiment_plan>\n\t<Simulation id=\"2\" sourcePath=\"/absolute/path/to/your/model/file/Model 04.gaml\" finalStep=\"1000\" experiment=\"prey_predator\">\n\t\t<Parameters>\n\t\t\t<Parameter name=\"Initial number of preys: \" type=\"INT\" value=\"621\" />\n\t\t\t<Parameter name=\"Prey max energy: \" type=\"FLOAT\" value=\"1.0\" />\n\t\t</Parameters>\n\t\t<Outputs>\n\t\t\t<Output id=\"1\" name=\"main_display\" framerate=\"10\" />\n\t\t\t<Output id=\"2\" name=\"Number of preys\" framerate=\"1\" />\n\t\t</Outputs>\n\t</Simulation>\n</Experiment_plan>\n\n\n\n\n## Execution \n\n\nWe have to launch the `gama-headless.sh` script and provide two arguments : the experiment file we just completed and the path of a directory where the results will be written.\n\n** Warning ** In this example ,we are lazy and define the source path as the absolute path to the model we want to execute. If you want to use a relative path, note that it has to be define relatively to the location of your ** ExperimentFile.xml location ** (and the location where you launched the script)\n\n\n\nIn a terminal, position yourself in the headless directory : `~/GAMA/headless/'.\n\nThen type the following command :  \n\t\n\tbash gama-headless.sh -v ~/a/path/to/MyExperimentFile.xml  /path/to/the/desired/output/directory  \n\nAnd replace paths by the location of your ExperimentFile and output directory\n\nYou should obtain the following output in the terminal : \n\n\n\t******************************************************************\n\t* GAMA version 1.7.0 V7                                          *\n\t* http://gama-platform.org                                       *\n\t* (c) 2007-2016 UMI 209 UMMISCO IRD/UPMC & Partners              *\n\t******************************************************************\n\t>GAMA plugin loaded in 2927 ms: \tmsi.gama.core\n\t>GAMA plugin loaded in 67 ms: \tummisco.gama.network\n\t>GAMA plugin loaded in 56 ms: \tsimtools.gaml.extensions.traffic\n\t>GAMA plugin loaded in 75 ms: \tsimtools.gaml.extensions.physics\n\t>GAMA plugin loaded in 1 ms: \tirit.gaml.extensions.test\n\t>GAMA plugin loaded in 75 ms: \tummisco.gaml.extensions.maths\n\t>GAMA plugin loaded in 47 ms: \tmsi.gaml.extensions.fipa\n\t>GAMA plugin loaded in 92 ms: \tummisco.gama.serialize\n\t>GAMA plugin loaded in 49 ms: \tirit.gaml.extensions.database\n\t>GAMA plugin loaded in 2 ms: \tmsi.gama.lang.gaml\n\t>GAMA plugin loaded in 1 ms: \tmsi.gama.headless\n\t>GAMA plugin loaded in 103 ms: \tummisco.gama.java2d\n\t>GAMA plugin loaded in 189 ms: \tmsi.gaml.architecture.simplebdi\n\t>GAMA plugin loaded in 129 ms: \tummisco.gama.opengl\n\t>GAMA building GAML artefacts>GAMA total load time 4502 ms.\n\t in 714 ms\n\tcpus :8\n\tSimulation is running...\n\t....................................................................................................\n\tSimulation duration: 7089ms\n\n\n\t\n\n\n\n\n## Results \n\nThe results are stored in the output directory you provided as the second argument of the script.\n\n3 items have appeared :\n\n* A `console_output.txt` file, containing the output of the GAMA console of the model execution if any\n* a XML file `simulation-outputXX.xml`, where XX is the `id` number of your simulation. In our case it should be 2.\n* the folder `snapshots` containing the screenshots coming from the second declared output : `main_display`. image name format is `main_display[id]_[cycle].png`.\n\nThe values of the monitor \"Number of preys\" are stored in the xml file `simulation-outputXX.xml`\n\n\n\n\n\n\n# Common error messages \n\n\n`Exception in thread \"Thread-7\" No parameter named prey_max_energy in experiment prey_predator`\nProbably a typo in the name or the title of a parameter. check spaces, capital letters, symbols and so on.\n\n\njava.io.IOException: Model file does not exist: /home/ubuntu/dev/tutoGamaHeadless/../plugins/msi.gama.models_1\nThis may be a relative path mistake; try with absolute path.\n\njava.lang.NumberFormatException: For input string: \"1.0\"\nThis may be a problem of type declaration in the parameter section. \n\n\n# Going further \n\n## Experiments of several simulation\n\nYou can launch several simulation by replicating the simulation declaration in your ExperimentFile.xml and varying the values of the parameters.\nSince you will have to edit the experiment file by hand, you should do that only for a reasonable number of simulations (e.g. <10 )\n\n\n\n## Design of experiments plans\n\nFor more systematic parameter values samples, you should turn towards a more adapted tool such as GAMAR, to generate a `ExperimentFile.xml` with a huge number of simulations.\n\n\n","url":"wiki/Headless-mode-for-dummies.md"},"KnownIssues.md":{"title":" Known issues","content":"# Known issues\n\n[//]: # (keyword|concept_opengl)\n## Crash when using openGL on Windows\n\nIf you are using GAMA with Windows, and your video card is a Radeon AMD, then GAMA can crash while running a simulation using OpenGL. To avoid this issue, you have to disable your video card. This will slow down a bit the performances, but at least you will be able to run GAMA without those annoying crashes.\n\nTo disable your video card, open the control panel, click on Hardware and Sound / Devices and Printers / Device manager, and then right click on your video card (as shown in the following image)\n\n![resources/images/recipes/disable_amd_radeon.png](resources/images/recipes/disable_amd_radeon.png)\n\n[//]: # (keyword|concept_grid)\n## Grid not displayed right using openGL\n\nWhen you try to display a grid with opengl, the cells have not a regular shape (as it is shown in the following image)\n\n![resources/images/recipes/grid_display_problem.png](resources/images/recipes/grid_display_problem.png)\n\nThe reason of this problem is that we can only map a grid of 2^n*2^n cells in the plan. Here are some solutions for this problem :\n- Choose a grid with 2^n*2^n dimension (such as 16x16, or 32x32)\n- Display the grid in java2D\n- Display the grid as _species_, and not as _grid_ (note that the difference in term of performance between displaying a grid as a _grid_ and as a _species_ is not so important for opengl displays. It has originally been done for java2D displays)","url":"wiki/KnownIssues.md"},"ManipulateDates.md":{"title":" Manipulate Dates","content":"[//]: # (keyword|concept_date)\n# Manipulate Dates\n\n[//]: # (keyword|type_date) \n[//]: # (keyword|concept_time)\n## Managing Time in Models\n\nIf some models are based on a abstract time - only the number of cycles is important - others are based on a real time. In order to manage the time, GAMA provides some tools to manage time.\n\nFirst, GAMA allows to define the duration of a simulation step. It provides access to different time variables. At last, since GAMA 1.7, it provides a date variable type and some global variables allowing to use a real calendar to manage time.\n\n## Definition of the step and use of temporal unity values\nGAMA provides three important [global variables to manage time](GlobalSpecies#cycle):\n\n* `cycle` (int - not modifiable): the current simulation step - this variable is incremented by 1 at each simulation step\n* `step` (float - can be modified): the duration of a simulation step (in seconds). By default the duration is one second.\n* `time` (float - not modifiable): the current time spent since the beginning of the simulation - this variable is computed at each simulation step by: time = cycle * step. \n\nThe value of the cycle and time variables are shown in the top left (green rectangle) of the simulation interface. Clicking on the green rectangle allows to display either the number cycles or the time variable. Concerning this variable, it is presented following a years - month - days - hours - minutes - seconds format. In this presentation, every months are considered as being composed of 30 days (the different number of days of months are not taken into account).\n\nConcerning the step facet, the variable can be modified by the modeler. A classic way of doing it consists in reediting the variable in the global section:\n\n```\nglobal {\n       float step <- 1 #hour;\n}\n```\n\nIn this example, each simulation step will represent 1 hour. This time will be taken into account for all actions based on time (e.g. moving actions).\n\nNote that the value of the step variable should be given in seconds. To facilitate the definition of the step value and of all expressions based on time, GAMA provides [different built-in constant variables accessible with the \"`#`\" symbol](UnitsAndConstants#time-units): \n\n * `#s` : second - 1 second\n * `#mn` : minute - 60 seconds\n * `#hour` : hour - 60 minutes - 3600 seconds\n * `#day` : day - 24 hours - 86400 seconds\n * `#month` : month - 30 days - 2592000 seconds\n * `#year` : year - 12 month - 3.1104E7\n\t\n\n## The date variable type and the use of a real calendar\nSince GAMA 1.7, it is possible to use a real calendar to manage the time. For that, the modeler have just to define the starting date of the simulation. This variable is of type date which allow to represent a date and time. \nA date variable has several attributes:\n\n* `year` (int): the year component of the date\n* `month` (int): the month component of the date\n* `day` (int): the day component of the date\n* `hour` (int): the hour component of the date\n* `minute` (int): the minute component of the date\n* `second` (int): the second component of the date\n* `day_of_week` (int): the day of the week\n* `week_of_year` (int): the week of the year\n\nSeveral ways can be used to define a date. The simplest consists in using a list of int values: [year,month of the year,day of the month, hour of the day, minute of the hour, second of the minute]\n```\ndate my_date <- date([2010,3,23,17,30,10]); // the 23th of March 2010, at 17:30:10\n```\nAnother way consists in using a string with the good format:\n```\ndate my_date <- date(\"2010-3-23T17:30:10+07:00\"); \n```\n\t\t\nNote that the current date can be access through the #now built-in variable (variable of type date).\n\nIn addition, GAMA provides different useful operators working on dates. For instance, it is possible to compute the duration in seconds between 2 dates using the \"`-`\" operator. The result is given in seconds:\n```\nfloat d <- starting_date - my_date;\n```\n\nIt is also possible to add or subtract a duration (in seconds) to a date:\n```\nwrite \"my_date + 10: \" + (my_date + 10);\nwrite \"my_date - 10: \" + (my_date - 10);\n```\n\t\t \nAt last, it is possible to add or subtract a duration (in years, months, weeks, days, hours, minutes,  seconds) to a date:\n```\nwrite \"my_date add_years 1: \" + (my_date add_years 1);\nwrite \"my_date add_months 1: \" + (my_date add_months 1);\nwrite \"my_date add_weeks 1: \" + (my_date add_weeks 1);\nwrite \"my_date add_days 1: \" + (my_date add_days 1);\nwrite \"my_date add_hours 1: \" + (my_date add_hours 1);\nwrite \"my_date add_minutes 1: \" + (my_date add_minutes 1);\nwrite \"my_date add_seconds 1: \" + (my_date add_seconds 1);\n\t\t  \nwrite \"my_date subtract_years 1: \" + (my_date subtract_years 1);\nwrite \"my_date subtract_months 1: \" + (my_date subtract_months 1);\nwrite \"my_date subtract_weeks 1: \" + (my_date subtract_weeks 1);\nwrite \"my_date subtract_days 1: \" + (my_date subtract_days 1);\nwrite \"my_date subtract_hours 1: \" + (my_date subtract_hours 1);\nwrite \"my_date subtract_minutes 1: \" + (my_date subtract_minutes 1);\nwrite \"my_date subtract_seconds 1: \" + (my_date subtract_seconds 1);\n```\nFor the modelers, two global date variable are available:\n* `starting_date`: date considered as the beginning of the simulation\n* `current_date`: current date of the simulation\n\nBy default, these variables are nil. Defining a value of the starting_date allows to change the normal time management of the simulation by a more realistic one (using calendar): \n```\nglobal {\n     date starting_date <- date([1979,12,17,19,45,10]);\n}\n```\n\nWhen a variable is set to this variable, the current_date variable is automatically initialized with the same value. However, at each simulation step, the current_date variable is incremented by the step variable. The value of the current_date will replace the value of the time variable in the top left green panel.\n\nNote that you have to be careful, when a real calendar is used, the built-in constants `#month` and `#year` should not be used as there are not consistent with the calendar (where month can be composed of 28, 29, 30 or 31 days).\n","url":"wiki/ManipulateDates.md"},"ManipulateLight.md":{"title":" Implementing light","content":"[//]: # (startConcept|light)\n[//]: # (keyword|concept_3d)\n[//]: # (keyword|concept_light)\n# Implementing light\n\nWhen using opengl display, GAMA provides you the possibility to manipulate one or several lights, making your display more realistic.\nMost of the following screenshots will be taken with the following short example gaml : \n```\nmodel test_light\n\ngrid cells {\n\taspect base {\n\t\tdraw square(1) at:{grid_x,grid_y} color:#white;\n\t}\n}\nexperiment my_experiment type:gui{\n\toutput {\n\t\tdisplay my_display type:opengl background:#darkblue {\n\t\t\tspecies cells aspect:base;\n\t\t\tgraphics \"my_layer\" {\n\t\t\t\tdraw square(100) color:#white at:{50,50};\n\t\t\t\tdraw cube(5) color:#lightgrey at:{50,30};\n\t\t\t\tdraw cube(5) color:#lightgrey at:{30,35};\n\t\t\t\tdraw cube(5) color:#lightgrey at:{60,35};\n\t\t\t\tdraw sphere(5) color:#lightgrey at:{10,10,2.5};\n\t\t\t\tdraw sphere(5) color:#lightgrey at:{20,30,2.5};\n\t\t\t\tdraw sphere(5) color:#lightgrey at:{40,30,2.5};\n\t\t\t\tdraw sphere(5) color:#lightgrey at:{40,60,2.5};\n\t\t\t\tdraw cone3D(5,5) color:#lightgrey at:{55,10,0};\n\t\t\t\tdraw cylinder(5,5) color:#lightgrey at:{10,60,0};\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## Index\n\n* [Light generalities](#light-generalities)\n* [Default light](#default-light)\n* [Custom lights](#custom-lights)\n\n## Light generalities\n\nBefore going deep into the code, here is a quick explanation about how light works in opengl.\nFirst of all, you need to know that there are 3 types of lights you can manipulate : the **ambient light**, the **diffuse light** and the **specular light**. Each \"light\" in opengl is in fact composed of those 3 types of lights.\n\n### Ambient light\n\nThe **ambient light** is the light of your world without any lighting. If a face of a cube is not stricken by the light rays for instance, this face will appear totally black if there is no ambient light. To make your world more realistic, it is better to have an ambient light.\nAn ambient light has then no position or direction. It is equally distributed to all the objects of your scene.\n\nHere is an example of our GAML scene using only ambient light (color red) : \n\n![resources/images/lightRecipes/ambient_light.png](resources/images/lightRecipes/ambient_light.png)\n\n### Diffuse light\n\nThe **diffuse light** can be seen as the light rays : if a face of a cube is stricken by the diffuse light, it will take the color of this diffuse light. You have to know that the more perpendicular the face of your object will be to the light ray, the more lightened the face will be.\n\nA diffuse light has then a direction. It can have also a position.\nYour have 2 categories of diffuse light : the **positional lights**, and the **directional lights**.\n\n#### Positional lights\n\nThose lights have a position in your world. It is the case of **point lights** and **spot lights**.\n\n- Point lights\n\nPoints lights can be seen as a candle in your world, diffusing the light equally in all the direction.\n\nHere is an example of our GAML scene using only diffuse light, with a point light (color red, the light source is displayed as a red sphere) : \n\n![resources/images/lightRecipes/point_light.png](resources/images/lightRecipes/point_light.png)\n\n- Spot lights\n\nSpot lights can be seen as a torch light in your world. It needs a position, and also a direction and an angle.\n\nHere is an example of our GAML scene using only diffusion light, with a spot light (color red, the light source is displayed as a red cone) : \n\n![resources/images/lightRecipes/spot_light.png](resources/images/lightRecipes/spot_light.png)\n\nPositional lights, as they have a position, can also have an attenuation according to the distance between the light source and the object. The value of positional lights are computed with the following formula :\ndiffuse_light = diffuse_light * ( 1 / (1 + constante_attenuation + linear_attenuation * d + quadratic_attenuation * d))\nBy changing those 3 values (constante_attenuation, linear_attenuation and quadratic_attenuation), you can control the way light is diffused over your world (if your world is \"foggy\" for instance, you may turn your linear and quadratic attenuation on). Note that by default, all those attenuation are equal to 0.\n\nHere is an example of our GAML scene using only diffusion light, with a point light with linear attenuation (color red, the light source is displayed as a red sphere) : \n\n![resources/images/lightRecipes/point_light_with_attenuation.png](resources/images/lightRecipes/point_light_with_attenuation.png)\n\n#### Directional lights\n\nDirectional lights have no real \"position\" : they only have a direction. A directional light will strike all the objects of your world with the same direction. An example of directional light you have in the real world would be the light of the sun : the sun is so far away from us that you can consider that the rays have the same direction and the same intensity wherever they strike.\nSince there is no position for directional lights, there is no attenuation either.\n\nHere is an example of our GAML scene using only diffusion light, with a directional light (color red) : \n\n![resources/images/lightRecipes/direction_light.png](resources/images/lightRecipes/direction_light.png)\n\n### Specular light\n\nThis is a more advanced concept, giving an aspect a little bit \"shinny\" to the objects stricken by the specular light. It is used to simulate the interaction between the light and a special material (ex : wood, steel, rubber...).\nThis specular light is not implemented yet in gama, only the two others are.\n\n## Default light\n\nIn your opengl display, without specifying any light, you will have only one light, with those following properties :\n\nThose values have been chosen in order to have the same visual effect in both opengl and java2D displays, when you display 2D objects, and also to have a nice \"3D effect\" when using the opengl displays. We chose the following setting by default : \n* The ambient light value : rgb(127,127,127,255)\n* diffuse light value : rgb(127,127,127,255)\n* type of light : direction\n* direction of the light : (0.5,0.5,-1);\n\nHere is an example of our GAML scene using the default light : \n\n![resources/images/lightRecipes/default_light.png](resources/images/lightRecipes/default_light.png)\n\n## Custom lights\n\nIn your opengl display, you can create up to 8 lights, giving them the properties you want.\n\n### Ambient light\n\nIn order to keep it simple, the ambient light can be set directly when you are declaring your display, through the facet `ambient_light`. You will have one only ambient light.\n\n```\nexperiment my_experiment type:gui {\n\toutput {\n\t\tdisplay \"my_display\" type:opengl ambient_light:100 {\n\t\t}\n\t}\n}\n```\n\n_Note for developers_ : Note that this ambient light is set to the GL_LIGHT0. This GL_LIGHT0 only contains an ambient light, and no either diffuse nor specular light.\n\n### Diffuse light\n\n[//]: # (keyword|statement_light)\nIn order to add lights, or modifying the existing lights, you can use the statement `light`, inside your `display` scope : \n\n```\nexperiment my_experiment type:gui {\n\toutput {\n\t\tdisplay \"my_display\" type:opengl {\n\t\t\tlight id:0;\n\t\t}\n\t}\n}\n```\n\nThis statement has just one non-optional facet : the facet \"id\". Through this facet, you can specify which light you want. You can control 7 lights, through an integer value between 1 and 7.\nOnce you are manipulating a light through the `light` statement, the light is turned on. To switch off the light, you have to add the facet `active`, and turn it to `false`.\nThe light you are declaring through the `light` statement is in fact a \"diffuse\" light. You can specify the color of the diffuse light through the facet `color` (by default, the color will be turn to white).\nAn other very important facet is the `type` facet. This facet accepts a value among `direction`, `point` and `spot`.\n\n#### Declaring direction light\n\nA direction light, as explained in the first part, is a light without any position. Instead of the facet `position`, you will use the facet `direction`, giving a 3D vector.\n\nExample of implementation : \n\n```\nlight id:1 type:direction direction:{1,1,1} color:rgb(255,0,0);\n```\n\n#### Declaring point light\n\nA point light will need a facet `position`, in order to give the position of the light source.\n\nExample of implementation of a basic point light : \n\n```\nlight id:1 type:point position:{10,20,10} color:rgb(255,0,0);\n```\n\nYou can add, if you want, a custom attenuation of the light, through the facets `linear_attenuation` or `quadratic_attenuation`.\n\nExample of implementation of a point light with attenuation : \n\n```\nlight id:1 type:point position:{10,20,10} color:rgb(255,0,0) linear_attenuation:0.1;\n```\n\n#### Declaring spot light\n\nA spot light will need the facet `position` (a spot light is a positionnal light) and the facet `direction`. A spot light will also need a special facet `spot_angle` to determine the angle of the spot (by default, this value is set to 45 degree).\n\nExample of implementation of a basic spot light : \n\n```\nlight id:1 type:spot position:{0,0,10} direction:{1,1,1} color:rgb(255,0,0) spot_angle:20;\n```\n\nSame as for point light, you can specify an attenuation for a spot light.\n\nExample of implementation of a spot light with attenuation : \n\n```\nlight id:1 type:spot position:{0,0,10} direction:{1,1,1} color:rgb(255,0,0) spot_angle:20;\n```\n\nNote that when you are working with lights, you can display your lights through the facet `draw light` to help you implementing your model. The three types of lights are displayed differently :\n- The **point** light is represented by a sphere with the color of the diffuse light you specified, in the position of your light source.\n- The **spot** light is represented by a cone with the color of the diffuse light you specified, in the position of your light source, the orientation of your light source. The size of the base of the cone will depend of the angle you specified.\n- The **direction** light, as it has no real position, is represented with arrows a bit above the world, with the direction of your direction light, and the color of the diffuse light you specified.\n\n![resources/images/lightRecipes/draw_light.png](resources/images/lightRecipes/draw_light.png)\n\n_Note for developers_ : Note that, since the GL_LIGHT0 is already reserved for the ambient light (only !), all the other lights (from 1 to 7) are the lights from GL_LIGHT1 to GL_LIGHT7.\n\n[//]: # (endConcept|light)","url":"wiki/ManipulateLight.md"},"ManipulateOSMDatas.md":{"title":" Manipulate OSM Datas","content":"[//]: # (startConcept|use_osm_datas)\n[//]: # (keyword|concept_osm)\n# Manipulate OSM Datas\n\n[//]: # (keyword|concept_load_file)\nThis section will be presented as a quick tutorial, showing how to proceed to manipulate OSM (Open street map) datas, and load them into GAMA. We will use the software [QGIS](http://www.qgis.org/en/site/) to change the attributes of the OSM file.\n\n\nFrom the website [openstreetmap.org](https://www.openstreetmap.org/), we will chose a place (in this example, we will take a neighborhood in New York City). Directly from the website, you can export the chosen area in the osm format.\n\n![images/manipulate_OSM_file_1.png](resources/images/recipes/manipulate_OSM_file_1.png)\n\nWe have now to manipulate the attributes for the exported osm file.\nSeveral software are possible to use, but we will focus on [QGIS](http://www.qgis.org/en/site/), which is totally free and provides a lot of possibilities in term of manipulation of data.\n\nOnce you have installed correctly QGIS, launch QGIS Desktop, and start to import the topology from the osm file.\n\n![images/manipulate_OSM_file_2.png](resources/images/recipes/manipulate_OSM_file_2.png)\n\n![images/manipulate_OSM_file_3.png](resources/images/recipes/manipulate_OSM_file_3.png)\n\nA message indicates that the import was successful. An output file .osm.db is created. You have now to export the topology to SpatiaLite.\n\n![images/manipulate_OSM_file_4.png](resources/images/recipes/manipulate_OSM_file_4.png)\n\nSpecify the path for your DataBase file, then choose the export type (in your case, we will choose the type \"Polygons (closed ways)\"), choose an output layer name. If you want to use the open street maps attributes values, click on \"Load from DB\", and select the attributes you want to keep. Click OK then.\n\n![images/manipulate_OSM_file_5.png](resources/images/recipes/manipulate_OSM_file_5.png)\n\nA message indicates that the export was successful, and you have now a new layer created.\n\n![images/manipulate_OSM_file_6.png](resources/images/recipes/manipulate_OSM_file_6.png)\n\nWe will now manipulate the attributes of your datafile. Right click on the layer, and select \"Open Attribute Table\".\n\n![images/manipulate_OSM_file_7.png](resources/images/recipes/manipulate_OSM_file_7.png)\n\nThe table of attribute appears. Select the little pencil on the top-left corner of the window to modify the table.\n\n![images/manipulate_OSM_file_8.png](resources/images/recipes/manipulate_OSM_file_8.png)\n\nWe will add an attribute manually. Click on the button \"new column\", choose a name and a type (we will choose the type \"text\").\n\n![images/manipulate_OSM_file_9.png](resources/images/recipes/manipulate_OSM_file_9.png)\n\nA new column appears at the end of the table. Let's fill some values (for instance blue / red). Once you finishes, click on the \"save edit\" button.\n\n![images/manipulate_OSM_file_10.png](resources/images/recipes/manipulate_OSM_file_10.png)\n\nOur file is now ready to be exported. Right click on the layer, and click on \"Save As\".\n\n![images/manipulate_OSM_file_11.png](resources/images/recipes/manipulate_OSM_file_11.png)\n\nChoose \"shapefile\" as format, choose a save path and click ok.\n\n![images/manipulate_OSM_file_12.png](resources/images/recipes/manipulate_OSM_file_12.png)\n\nCopy passed all the .shp created in the include folder of your GAMA project. You are now ready to write the model.\n\n[//]: # (keyword|concept_shapefile)\n```\nmodel HowToUseOpenStreetMap\n\nglobal {\n\t// Global variables related to the Management units\t\n\tfile shapeFile <- file('../includes/new_york.shp'); \n\t\n\t//definition of the environment size from the shapefile. \n\t//Note that is possible to define it from several files by using: geometry shape <- envelope(envelope(file1) + envelope(file2) + ...);\n\tgeometry shape <- envelope(shapeFile);\n\t\n\tinit {\n\t\t//Creation of elementOfNewYork agents from the shapefile (and reading some of the shapefile attributes)\n\t\tcreate elementOfNewYork from: shapeFile \n\t\t\twith: [elementId::int(read('id')), elementHeight::int(read('height')), elementColor::string(read('attrForGama'))] ;\n    }\n}\n\t\nspecies elementOfNewYork{\n\tint elementId;\n\tint elementHeight;\n\tstring elementColor;\n\t\n\taspect basic{\n\t\tdraw shape color: (elementColor = \"blue\") ? #blue : ( (elementColor = \"red\") ? #red : #yellow ) depth: elementHeight;\n\t}\n}\t\n\nexperiment main type: gui {\t\t\n\toutput {\n\t\tdisplay HowToUseOpenStreetMap type:opengl {\n\t   \t\tspecies elementOfNewYork aspect: basic; \n\t\t}\n\t}\n}\n```\n\nHere is the result, with a special colorization of the different elements regarding to the value of the attribute \"attrForGama\", and an elevation regarding to the value of the attribute \"height\".\n\n![images/manipulate_OSM_file_13.png](resources/images/recipes/manipulate_OSM_file_13.png)\n[//]: # (endConcept|use_osm_datas)","url":"wiki/ManipulateOSMDatas.md"},"UsingBDI.md":{"title":" Using BDI","content":"[//]: # (keyword|concept_bdi)\n# Using BDI\n\n## Install\nYou need to run the Git version.\n\nThe plugin need to be add with Eclipse doing the following:\n\n  * In ummisco.gama.feature.core open the feature.xml file.\n  * In plug-ins click add the msi.gaml.architecture.simplebdi\n\n## Acteur Projet\nA website (still in construction) of the ACTEUR project can be found here http://acteur-anr.fr/\n\n\n## An introduction to cognitive agent\n\nThe belief-desire-intention software model (usually referred to simply, but ambiguously, as BDI) is a software model developed for programming intelligent agents.\n\n  * **Belief**: State of the agent.\n  * **Desire**: Objectives that the agent would like to accomplish.\n  * **Intention**: What the agent has chosen to do.\n    * **Plan**: Sequences of actions that an agent can perform to achieve one or more of its intensions.\n\n## Basic Example: A fire rescue model using cognitive agent\n\nWe introduce a simple example to illustrate the use of the BDI architecture.\n\nThis simple model consists in creating \"cognitive\" agent whose goal is to extinguish a fire. In a first approximation we consider only one static water area and fire area. The aim is not to have a realistic model but to illustrate how to give a \"cognitive\" behavior to an agent using the BDI architecture.\n\nFirst let's create a BDI agent using the key control **simple\\_bdi** (A description of all existing control architectures is available [here](BuiltInArchitectures).)\n\n### Species Helicopter creation\n\n```\nspecies helicopter skills:[moving] control: simple_bdi{\n...\n}\n```\n\n#### Attributes\nThe species `helicopter` needs 2 attributes to represent the water value and its speed.\n```\nfloat waterValue;\nfloat speed <- 10.0;\n```\n\n#### Predicates\nThe predicate are the structure that are used to define a belief, a desire or an intention.\nIn this model we choose to declare 3 different predicates.\n\n\n```\npredicate patrol_desire <- new_predicate(\"patrol\") with_priority 1;\npredicate water_predicate <- new_predicate(\"has water\", true) with_priority 3;\npredicate no_water_predicate <- new_predicate(\"has water\", false) ;\n```\nThe **new_predicate()** tool creates a predicate. It needs a name (string type) and it can contain a map of values, a priority (double type) or a truth value (boolean type).\nThe **with_priority** tool add a priority to a predicate. The priority is used as an argument when the agent has to choose between two predicates (to choose an intention for example).\n\n#### Initialization\nThe initialization consists in setting the attribute **waterValue** to 1 and to add one desire. Three optional parameters are also set. The first desire added in the desire base is the **patrol\\_desire** saying that the helicopter wants to patrol. The optional parameters are specific to the BDI plug-in. You can specify the commitment of an agent to his intentions and his plans with the variables intention_persistence and plan_persistence that are floats between 0.0 (no commitment) and 1.0. The variable probabilistic_choice is a boolean that enables the agent to use a probabilistic choice (when true) or a deterministic choice (when false) when trying to find a plan or an intention.\n```\nwaterValue <-1.0;\ndo add_desire(patrol_desire);\nintention_persistence <- 1.0;\nplan_persistence <- 1.0;\nprobabilistic_choice <- false;\t\n```\n\n#### Perception\nAt each iteration, the helicopter has two perceptions to do. The first one is about itself. The helicopter needs to perceive if it has water or not. If it has water, it adds the belief corresponding belief and removes the belief that it does not have water. And if it does not have water, that is the contrary.\n```\nperceive target:self{\n\tif(waterValue>0){\n\t\tdo add_belief(water_predicate);\n\t\tdo remove_belief(no_water_predicate);\n\t}\n\tif(waterValue<=0){\n\t\tdo add_belief(no_water_predicate);\n\t\tdo remove_belief(water_predicate);\n\t}\n}\n```\nThe second perception is about the fires. Here, the fires are represented with the species **fireArea**. The helicopter has a radius of perception of 10 meters. If it perceives a fire, it will focus on the location of this fire. The **focus** tool create a belief with the same name as the focus (here, \"fireLocation\") and will store the value of the focused variable (here, the variable location from the specie fireArea) with a priority of 10 in this example. Once the fire is perceived, the helicopter removes its intention of patrolling.\n```\nperceive target:fireArea in: 10{\n\tfocus fireLocation var:location priority:10;\n\task myself{\n\t\tdo remove_intention(patrol_desire, true);\n\t}\n}\n```\n\n#### Rules\nThe agent can use rules to create desires from beliefs. In this example, the agent has two rules. The first **rule** is to have a desire corresponding to the belief of a location of a fire. It means that when the agent has the belief that there is a fire in a particular location, it will have the desire to extinguish it. This permits to have the location value in the desire base.\nThe second rule is to create the desire to have water when the agent has the belief that it not has water.\n\n```\nrule belief: new_predicate(\"fireLocation\") new_desire: get_belief_with_name(\"fireLocation\");\nrule belief: no_water_predicate new_desire: water_predicate;\n```\n\n#### Plan\n##### Patrolling\nThis plan will be used when the agent has the intention to patrol.\n```\nplan patrolling intention: patrol_desire{\n  do wander;\n}\n```\n##### stopFire\nThis plan is executed when the agent has the intention to extinguish a fire.\n```\nplan stopFire intention: new_predicate(\"fireLocation\") {\n\tpoint target_fire <- point(get_current_intention().values[\"location_value\"] );\n\tif(waterValue>0){\n\t\tif (self distance_to target_fire <= 1) {\n\t\t\tfireArea current_fire <- fireArea first_with (each.location = target_fire);\n\t\t\tif (current_fire != nil) {\n\t\t\t\t waterValue <- waterValue - 1.0;\n\t\t\t\t current_fire.size <-  current_fire.size - 1;\n\t\t\t\t if ( current_fire.size <= 0) {\n\t\t\t\t\task  current_fire {do die;}\n\t\t\t\t\tdo remove_belief(get_current_intention());\n\t\t\t\t\tdo remove_intention(get_current_intention(), true);\n\t\t\t\t\tdo add_desire(patrol_desire);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdo remove_belief(get_current_intention());\n\t\t\t\tdo remove_intention(get_current_intention(), true);\n\t\t\t\tdo add_desire(patrol_desire);\n\t\t\t}\n\t\t} else {\n\t\t\tdo goto target: target_fire;\n\t\t}\n\t} else {\n\t\tdo add_subintention(get_current_intention(),water_predicate,true);\n\t\tdo current_intention_on_hold();\n\t}\n}\n```\n##### gotoTakeWater\nThis plan is executed when the agent has the intention to have water.\n```\nplan gotoTakeWater intention: water_predicate {\n    \twaterArea wa <- first(waterArea);\n        do goto target: wa);\n    \tif (self distance_to wa <= 1) {\n    \t\twaterValue <- waterValue + 2.0;\n\t}\n}\n```\nPlans can have other options. They can have a priority (with the facet priority), a boolean condition to start (with the facet when) or a boolean condition to stop (with the facet finished_when).\n\n#### Rest of the code\n##### Aspect of the helicopter\n```\naspect base {\n\tdraw circle(1) color: #black;\t\n}\n```\n\n##### FireArea Species\n```\nspecies fireArea{\n        float size <-1.0;\t\n\n        aspect base {\n          draw circle(size) color: #red;\n        }\n}\n```\n\n##### WaterArea Species\n```\nspecies waterArea{\n\tfloat size <-10.0;\n\n\taspect base {\n\t  draw circle(size) color: #blue;\t\t\n\t}\n}\n```","url":"wiki/UsingBDI.md"},"UsingDatabase.md":{"title":" Using Database Access","content":"[//]: # (startConcept|use_database)\n[//]: # (keyword|concept_database)\n# Using Database Access\n\nDatabase features of GAMA provide a set of actions on Database Management Systems (DBMS) and Multi-Dimensional Database for agents in GAMA. Database features are implemented in the irit.gaml.extensions.database plug-in with these features:\n  * Agents can execute SQL queries (create, Insert, select, update, drop, delete) to various kinds of DBMS.\n  * Agents can execute MDX (Multidimensional Expressions) queries to select multidimensional objects, such as cubes, and return multidimensional cellsets that contain the cube's data .\nThese features are implemented in two kinds of component: _skills_ (SQLSKILL, MDXSKILL) and agent (AgentDB)\n\nSQLSKILL and AgentDB provide almost the same features (a same set of actions on DBMS) but with certain slight differences:\n\n  * An agent of species AgentDB will maintain a unique connection to the database during the whole simulation. The connection is thus initialized when the agent is created.\n  * In contrast, an agent of a species with the SQLSKILL skill will open a connection each time he wants to execute a query. This means that each action will be composed of three running steps:\n    * Make a database connection.\n    * Execute SQL statement.\n    * Close database connection.\n> An agent with the SQLSKILL spends lot of time to create/close the connection each time it needs to send a query; it saves the database connection (DBMS often limit the number of simultaneous connections). In contrast, an AgentDB agent only needs to establish one database connection and it can be used for any actions. Because it does not need to create and close database connection for each action: therefore, actions of AgentDB agents are executed faster than actions of SQLSKILL ones but we must pay a connection for each agent.\n\n  * With an inheritance agent of species AgentDB  or an agent of a species using SQLSKILL, we can query data from relational database for creating species, defining environment or analyzing or storing simulation results into RDBMS. On the other hand, an agent of species with MDXKILL supports the OLAP technology to query data from data marts (multidimensional database).\nThe database features help us to have more flexibility in management of simulation models and analysis of simulation results.\n\n\n\n\n\n\n\n\n## Description\n\n  * **Plug-in**: _irit.gaml.extensions.database_\n  * **Author**: TRUONG Minh Thai, Frederic AMBLARD, Benoit GAUDOU, Christophe SIBERTIN-BLANC\n\n\n\n\n## Supported DBMS\n\nThe following DBMS are currently supported:\n  * SQLite\n  * MySQL Server\n  * PostgreSQL Server\n  * SQL Server\n  * Mondrian OLAP Server\n  * SQL Server Analysis Services\n\nNote that, other DBMSs require a dedicated server to work while SQLite on only needs a file to be accessed.\nAll the actions can be used independently from the chosen DBMS. Only the connection parameters are DBMS-dependent.\n\n\n\n\n## SQLSKILL\n### Define a species that uses the SQLSKILL skill\n\nExample of declaration:\n\n```\nspecies toto skills: [SQLSKILL] {\n\t//insert your descriptions here\n}\n```\n\nAgents with such a skill can use additional actions (defined in the skill)\n\n### Map of connection parameters for SQL\n\nIn the actions defined in the SQLSkill, a parameter containing the connection parameters is required. It is a map with the following _key::value_ pairs:\n\n| **Key** | **Optional** | **Description** |\n|:-------|:--------|:--------------------------------------------------------|\n| _dbtype_ | No | DBMS type value. Its value is a string. We must use \"mysql\" when we want to connect to a MySQL. That is the same for \"postgres\", \"sqlite\" or \"sqlserver\" (ignore case sensitive) |\n| _host_  | Yes | Host name or IP address of data server. It is absent when we work with SQlite. |\n| _port_  | Yes | Port of connection. It is not required when we work with SQLite.|\n| _database_ | No | Name of database. It is the file name including the path when we work with SQLite. |\n| _user_  | Yes | Username. It is not required when we work with SQLite. |\n| _passwd_ | Yes | Password. It is not required when we work with SQLite. |\n| srid    | Yes | srid (Spatial Reference Identifier)  corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in _Preferences->External_ configuration. |\n**Table 1**: Connection parameter description\n\n\n**Example**: Definitions of connection parameter\n\n```\n// POSTGRES connection parameter\nmap <string, string>  POSTGRES <- [\n     'host'::'localhost',\n     'dbtype'::'postgres',\n     'database'::'BPH',\n     'port'::'5433',\n     'user'::'postgres',\n     'passwd'::'abc'];\n\n//SQLite\nmap <string, string>  SQLITE <- [\n    'dbtype'::'sqlite',\n    'database'::'../includes/meteo.db'];\n\n// SQLSERVER connection parameter\nmap <string, string> SQLSERVER <- [\n    'host'::'localhost',\n    'dbtype'::'sqlserver',\n    'database'::'BPH',\n    'port'::'1433',\n    'user'::'sa',\n    'passwd'::'abc'];\n\n// MySQL connection parameter\nmap <string, string>  MySQL <- [\n    'host'::'localhost',\n    'dbtype'::'MySQL',\n    'database'::'', // it may be a null string\n    'port'::'3306',\n    'user'::'root',\n    'passwd'::'abc'];\n```\n\n### Test a connection to database\n**Syntax**:\n> _**testConnection** (params: connection`_`parameter)_\nThe action tests the connection to a given database.\n  * **Return**: boolean. It is:\n    * _true_: the agent can connect to the DBMS (to the given Database with given name and password)\n    * _false_: the agent cannot connect\n  * **Arguments**:\n    * _params_: (type = map) map of connection parameters\n  * **Exceptions**: _GamaRuntimeException_\n\n**Example**: Check a connection to MySQL\n\n```\nif (self testConnection(params:MySQL)){\n\twrite \"Connection is OK\" ;\n}else{\n\twrite \"Connection is false\" ;\n}\t\n\n```\n\n### Select data from database\n**Syntax**:\n> _**select** (param: connection`_`parameter, select: selection`_`string,values: value`_`list)_\nThe action creates a connection to a DBMS and executes the select statement. If the connection or selection fails then it throws a GamaRuntimeException.\n  * **Return**: list < list >. If the selection succeeds, it returns a list with three elements:\n    * The first element is a list of column name.\n    * The second element is a list of column type.\n    * The third element is a data set.\n  * **Arguments**:\n    * _params_: (type = map) map containing the connection parameters\n    * _select_: (type = string) select string. The selection string can contain question marks.\n    * _values_: List of values that are used to replace question marks in appropriate. This is an optional parameter.\n  * **Exceptions**: _GamaRuntimeException_\n\n**Example**: select data from table points\n\n```\nmap <string, string>   PARAMS <- ['dbtype'::'sqlite', 'database'::'../includes/meteo.db'];\nlist<list> t <- list<list> (self select(params:PARAMS, \n\t\t                 select:\"SELECT * FROM points ;\"));\n```\n\n**Example**: select data from table point with question marks from table points\n\n```\nmap <string, string>   PARAMS <- ['dbtype'::'sqlite', 'database'::'../includes/meteo.db'];\nlist<list> t <- list<list> (self select(params: PARAMS, \n                                           select: \"SELECT temp_min FROM points where (day>? and day<?);\"\n                                           values: [10,20] ));\n```\n\n### Insert data into database\n**Syntax**:\n> _**insert** (param: connection`_`parameter,  into:  table`_`name, columns: column`_`list, values: value`_list)_The action creates a connection to a DBMS and executes the insert statement. If the connection or insertion fails then it throws a_GamaRuntimeException_.\n  * **Return**: int\n> If the insertion succeeds, it returns a number of records inserted by the insert.\n  * **Arguments**:\n    *_params_: (type = map) map containing the connection parameters.\n    *_into_: (type = string) table name.\n    *_columns_: (type=list)  list of column names of table. It is an optional argument. If it is not applicable then all columns of table are selected.\n    *_values_: (type=list) list of values that are used to insert into table corresponding to columns. Hence the columns and values must have same size.\n  * **Exceptions**:_GamaRuntimeException\n\n**Example**: Insert data into table registration\n\n```\nmap<string, string> PARAMS <- ['dbtype'::'sqlite', 'database'::'../../includes/Student.db'];\n\ndo insert (params: PARAMS, \n               into: \"registration\", \n               values: [102, 'Mahnaz', 'Fatma', 25]);\n\ndo insert (params: PARAMS, \n                into: \"registration\", \n                columns: [\"id\", \"first\", \"last\"], \n                values: [103, 'Zaid tim', 'Kha']);\n\nint n <- insert (params: PARAMS, \n                        into: \"registration\", \n                       columns: [\"id\", \"first\", \"last\"], \n                       values: [104, 'Bill', 'Clark']);\n```\n\n### Execution update commands\n**Syntax**:\n> _**executeUpdate** (param: connection`_`parameter,  updateComm:  table`_`name, values: value`_`list)_\nThe action executeUpdate executes an update command (create/insert/delete/drop) by using the current database connection of the agent. If the database connection does not exist or the update command fails then it throws a GamaRuntimeException. Otherwise it returns an integer value.\n  * **Return**: int. If the insertion succeeds, it returns a number of records inserted by the insert.\n  * **Arguments**:\n    * _params_: (type = map) map containing the connection parameters\n    * _updateComm_: (type = string) SQL command string. It may be commands: _create_, _update_, _delete_ and _drop_ with or without question marks.\n    * _columns_: (type=list)  list of column names of table.\n    * _values_: (type=list) list of values that are used to replace question marks if appropriate. This is an optional parameter.\n  * **Exceptions**: _GamaRuntimeException_\n\n**Examples**: Using action executeUpdate do sql commands (create, insert, update, delete and drop).\n\n```\nmap<string, string> PARAMS <- ['dbtype'::'sqlite',  'database'::'../../includes/Student.db'];\n// Create table\ndo executeUpdate (params: PARAMS, \n                              updateComm: \"CREATE TABLE registration\" \n                                             + \"(id INTEGER PRIMARY KEY, \" \n                                             + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \" \n                                             + \" age INTEGER);\");\n\n// Insert into \ndo executeUpdate (params: PARAMS ,  \n                             updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\");\ndo insert (params: PARAMS, into: \"registration\", \n               columns: [\"id\", \"first\", \"last\"], \n               values: [103, 'Zaid tim', 'Kha']);\n\n// executeUpdate with question marks\ndo executeUpdate (params: PARAMS,\n                             updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" ,  \n                             values: [101, 'Mr', 'Mme', 45]);\n\n//update \nint n <-  executeUpdate (params: PARAMS, \n                                       updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\" );\n\n// delete\nint n <- executeUpdate (params: PARAMS, \n                                      updateComm: \"DELETE FROM registration where id=? \",  \n                                      values: [101] );\n\n// Drop table\ndo executeUpdate (params: PARAMS, updateComm: \"DROP TABLE registration\");\n```\n\n\n## MDXSKILL\nMDXSKILL plays the role of an OLAP tool using select to query data from OLAP server to GAMA environment and then species can use the queried data for any analysis purposes.\n### Define a species that uses the MDXSKILL skill\nExample of declaration:\n\n``` \n\tspecies olap skills: [MDXSKILL]\n\t {  \n\t\t//insert your descriptions here\n\t\t\n\t } \n      ...\n```\n\nAgents with such a skill can use additional actions (defined in the skill)\n\n### Map of connection parameters for MDX\nIn the actions defined in the SQLSkill, a parameter containing the connection parameters is required. It is a map with following key::value pairs:\n\n| **Key** | **Optional** | **Description** |\n|:-------|:--------|:--------------------------------------------------------|\n| _olaptype_ | No | OLAP Server type value. Its value is a string. We must use \"SSAS/XMLA\" when we want to connect to an SQL Server Analysis Services by using XML for Analysis. That is the same for \"MONDRIAN/XML\" or \"MONDRIAN\" (ignore case sensitive) |\n| _dbtype_ | No | DBMS type value. Its value is a string. We must use \"mysql\" when we want to connect to a MySQL. That is the same for \"postgres\" or \"sqlserver\" (ignore case sensitive) |\n| _host_ | No | Host name or IP address of data server. |\n| _port_ | No | Port of connection. It is no required when we work with SQLite. |\n| _database_ | No | Name of database. It is file name include path when we work with SQLite. |\n| _catalog_ | Yes | Name of catalog. It is an optional parameter. We do not need to use it when we connect to SSAS via XMLA and its file name includes the path when we connect a ROLAP database directly by using Mondrian API (see Example as below) |\n| _user_  | No | Username. |\n| _passwd_ | No | Password. |\n\n**Table 2**: OLAP Connection parameter description\n\n**Example**: Definitions of OLAP connection parameter\n\n```\n//Connect SQL Server Analysis Services via XMLA\n\tmap<string,string> SSAS <- [\n\t\t\t\t'olaptype'::'SSAS/XMLA',\n\t\t\t\t'dbtype'::'sqlserver',\n\t\t\t\t'host'::'172.17.88.166',\n\t\t\t\t'port'::'80',\n\t\t\t\t'database'::'olap',\n\t\t\t\t'user'::'test',\n\t\t\t\t'passwd'::'abc'];\n\n//Connect Mondriam server via XMLA\n\tmap<string,string>  MONDRIANXMLA <- [\n\t\t\t\t'olaptype'::\"MONDRIAN/XMLA\",\n\t\t\t\t'dbtype'::'postgres',\n\t\t\t\t'host'::'localhost',\n\t\t\t\t'port'::'8080',\n\t\t\t\t'database'::'MondrianFoodMart',\n\t\t\t\t'catalog'::'FoodMart',\n\t\t\t\t'user'::'test',\n\t\t\t\t'passwd'::'abc'];\n\n//Connect a ROLAP server using Mondriam API\t\n\tmap<string,string>  MONDRIAN <- [\n\t\t\t\t'olaptype'::'MONDRIAN',\n\t\t\t\t'dbtype'::'postgres',\n\t\t\t\t'host'::'localhost',\n\t\t\t\t'port'::'5433',\n\t\t\t\t'database'::'foodmart',\n\t\t\t\t'catalog'::'../includes/FoodMart.xml',\n\t\t\t\t'user'::'test',\n                                'passwd'::'abc'];\n```\n\n### Test a connection to OLAP database\n**Syntax**:\n> _**testConnection** (params: connection`_`parameter)_\nThe action tests the connection to a given OLAP database.\n  * **Return**: boolean.  It is:\n    * _true_: the agent can connect to the DBMS (to the given Database with given name and password)\n    * _false_: the agent cannot connect\n  * **Arguments**:\n    * _params_: (type = map) map of connection parameters\n  * **Exceptions**: _GamaRuntimeException_\n\n**Example**: Check a connection to MySQL\n\n```\nif (self testConnection(params:MONDIRANXMLA)){\n\twrite \"Connection is OK\";\n}else{\n\twrite \"Connection is false\";\n}\t\n```\n\n### Select data from OLAP database\n**Syntax**:\n> _**select** (param: connection`_`parameter, onColumns: column`_`string, onRows: row`_`string from: cube`_`string, where: condition`_`string, values: value`_`list)_\nThe action creates a connection to an OLAP database and executes the select statement. If the connection or selection fails then it throws a _GamaRuntimeException_.\n  * **Return**: list < list >.  If the selection succeeds, it returns a list with three elements:\n    * The first element is a list of column name.\n    * The second element is a list of column type.\n    * The third element is a data set.\n  * **Arguments**:\n    * _params_: (type = map) map containing the connection parameters\n    * _onColumns_: (type = string) declare  the select string on columns. The selection string can contain question marks.\n    * _onRows_: (type = string) declare the selection string on rows. The selection string can contain question marks.\n    * _from_: (type = string) specify cube where data is selected. The cube\\_string can contain question marks.\n    * where_: (type = string) specify the selection conditions. The condiction\\_string can contains question marks. This is an optional parameter.\n    *_values_: List of values that are used to replace question marks if appropriate. This is an optional parameter.\n  * **Exceptions**:_GamaRuntimeException\n\n**Example**: select data from SQL Server Analysis Service via XMLA\n\n```\nif (self testConnection[ params::SSAS]){\n\tlist l1  <- list(self select (params: SSAS ,\n\t\tonColumns: \" { [Measures].[Quantity], [Measures].[Price] }\",\n\t\tonRows:\" { { { [Time].[Year].[All].CHILDREN } * \"\n\t\t+ \" { [Product].[Product Category].[All].CHILDREN } * \"\n\t\t+\"{ [Customer].[Company Name].&[Alfreds Futterkiste], \" \n\t\t+\"[Customer].[Company Name].&[Ana Trujillo Emparedadosy helados], \" \n\t\t+ \"[Customer].[Company Name].&[Antonio Moreno Taquería] } } } \" ,\n\t\tfrom : \"FROM [Northwind Star] \"));\n\twrite \"result1:\"+ l1;\n}else {\n\twrite \"Connect error\";\n}\n```\n\n**Example**: select data from Mondrian via XMLA with question marks in selection\n\n```\nif (self testConnection(params:MONDRIANXMLA)){\n\tlist<list> l2  <- list<list> (self select(params: MONDRIANXMLA, \n\tonColumns:\" {[Measures].[Unit Sales], [Measures].[Store Cost], [Measures].[Store Sales]} \",\n\tonRows:\"  Hierarchize(Union(Union(Union({([Promotion Media].[All Media],\"\n \t+\" [Product].[All Products])}, \"\n\t+\" Crossjoin([Promotion Media].[All Media].Children, \"\n\t+\" {[Product].[All Products]})), \"\n\t+\" Crossjoin({[Promotion Media].[Daily Paper, Radio, TV]}, \"\n\t+\" [Product].[All Products].Children)), \"\n\t+\" Crossjoin({[Promotion Media].[Street Handout]}, \" \n\t+\" [Product].[All Products].Children)))  \",\n\tfrom:\" from [?] \" ,\n\twhere :\" where [Time].[?] \" ,\n\tvalues:[\"Sales\",1997]));\n\twrite \"result2:\"+ l2;\n}else {\n\twrite \"Connect error\";\n}\n```\n\n\n\n\n## AgentDB\n\nAgentBD is a built-in species, which supports behaviors that look like actions in SQLSKILL but differs slightly with SQLSKILL in that it uses  only one connection for several actions. It means that AgentDB makes a connection to DBMS and keeps that connection for its later operations with DBMS.\n### Define a species that is an inheritance of agentDB\nExample of declaration:\n\n```\nspecies agentDB parent: AgentDB {  \n\t//insert your descriptions here\n} \n```\n\n### Connect to database\n\n**Syntax**:\n\n> _**Connect** (param: connection`_`parameter)_\nThis action makes a connection to DBMS. If a connection is established then it will assign the connection object into a built-in attribute of species (conn) otherwise it throws a GamaRuntimeException.\n  * **Return**: connection\n  * **Arguments**:\n    * _params_: (type = map) map containing the connection parameters\n  * **Exceptions**: GamaRuntimeException\n**Example**: Connect to PostgreSQL\n\n```\n// POSTGRES connection parameter\nmap <string, string>  POSTGRES <- [\n                                        'host'::'localhost',\n                                        'dbtype'::'postgres',\n                                        'database'::'BPH',\n                                        'port'::'5433',\n                                        'user'::'postgres',\n                                        'passwd'::'abc'];\nask agentDB {\n      do connect (params: POSTGRES);\n}\n```\n\n### Check agent connected a database or not\n\n**Syntax**:\n\n> _**isConnected** (param: connection`_`parameter)_\nThis action checks if an agent is connecting to database or not.\n  * **Return**: Boolean.   If agent is connecting to a database then isConnected returns true; otherwise it returns false.\n  * **Arguments**:\n    * _params_: (type = map) map containing the connection parameters\n\n**Example**: Using action executeUpdate do sql commands (create, insert, update, delete and drop).\n\n```\nask agentDB {\n\tif (self isConnected){\n              write \"It already has a connection\";\n\t}else{\n              do connect (params: POSTGRES);\n        } \n}\n```\n\n### Close the current connection\n\n**Syntax**:\n\n> _**close**_\nThis action closes the current database connection of species. If species does not has a database connection then it throws a GamaRuntimeException.\n  * **Return**: null\nIf the current connection of species is close then the action return null value; otherwise it throws a GamaRuntimeException.\n\n**Example**:\n\n```\nask agentDB {\n\tif (self isConnected){\n\t      do close;\n\t}\n}\n```\n\n### Get connection parameter\n\n**Syntax**:\n\n> _**getParameter**_\nThis action returns the connection parameter of species.\n  * **Return**: map < string, string >\n\n**Example**:\n\n```\nask agentDB {\n\tif (self isConnected){\n\t\twrite \"the connection parameter: \" +(self getParameter);\n        }\n}\n```\n\n### Set connection parameter\n\n**Syntax**:\n\n> _**setParameter** (param: connection`_`parameter)_\nThis action sets the new values for connection parameter and closes the current connection of species. If it can not close the current connection then it will throw GamaRuntimeException. If the species wants to make the connection to database with the new values then action connect must be called.\n  * **Return**: null\n  * **Arguments**:\n    * _params_: (type = map) map containing the connection parameters\n  * **Exceptions**: _GamaRuntimeException_\n\n**Example**:\n\n```\nask agentDB {\n\tif (self isConnected){\n             do setParameter(params: MySQL);\n             do connect(params: (self getParameter));\n        }\n}\n```\n\n### Retrieve data from database by using AgentDB\nBecause of the connection to database of AgentDB is kept alive then AgentDB can execute several SQL queries with only one connection. Hence AgentDB can do actions such as **select**, **insert**, **executeUpdate** with the same parameters of those actions of SQLSKILL _except **params** parameter is always absent_.\n\n**Examples**:\n\n```\nmap<string, string> PARAMS <- ['dbtype'::'sqlite', 'database'::'../../includes/Student.db'];\nask agentDB {\n   do connect (params: PARAMS);\n   // Create table\n   do executeUpdate (updateComm: \"CREATE TABLE registration\" \n\t+ \"(id INTEGER PRIMARY KEY, \" \n        + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \" \n        + \" age INTEGER);\");\n   // Insert into \n   do executeUpdate ( updateComm: \"INSERT INTO registration \" \n        + \"VALUES(100, 'Zara', 'Ali', 18);\");\n   do insert (into: \"registration\", \n\t columns: [\"id\", \"first\", \"last\"], \n\t values: [103, 'Zaid tim', 'Kha']);\n   // executeUpdate with question marks\n   do executeUpdate (updateComm: \"INSERT INTO registration VALUES(?, ?, ?, ?);\",  \n\t values: [101, 'Mr', 'Mme', 45]);\n   //select\n    list<list> t <- list<list> (self select( \n\t select:\"SELECT * FROM registration;\"));\n    //update \n    int n <-  executeUpdate (updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\");\n     // delete\n     int n <- executeUpdate ( updateComm: \"DELETE FROM registration where id=? \",  values: [101] );\n     // Drop table\n      do executeUpdate (updateComm: \"DROP TABLE registration\");\n}\n```\n\n## Using database features to define environment or create species\n\nIn Gama, we can use results of select action of SQLSKILL or AgentDB to create species or define boundary of environment in the same way we do with shape files. Further more, we can also save simulation data that are generated by simulation including geometry data to database.\n\n### Define the boundary of the environment from database\n  * **Step 1**: specify select query by declaration a map object with keys as below:\n\n| **Key** | **Optional** | **Description** |\n|:-------|:--------|:--------------------------------------------------------|\n| _dbtype_ | No | DBMS type value. Its value is a string. We must use \"mysql\" when we want to connect to a MySQL. That is the same for \"postgres\", \"sqlite\" or \"sqlserver\" (ignore case sensitive) |\n| _host_  | Yes | Host name or IP address of data server. It is absent when we work with SQlite. |\n| _port_  | Yes | Port of connection. It is not required when we work with SQLite. |\n| _database_ | No | Name of database. It is the file name including the path when we work with SQLite. |\n| _user_  | Yes | Username. It is  not required when we work with SQLite. |\n| _passwd_ | Yes | Password. It is  not required when we work with SQLite. |\n| _srid_  | Yes | srid (Spatial Reference Identifier)  corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in Preferences->External configuration. |\n| _select_ | No |Selection string |\n\n**Table 3**: Select boundary parameter description\n\n**Example**:\n\n```\nmap<string,string> BOUNDS <- [\t\n\t//'srid'::'32648',\n\t'host'::'localhost',\t\t\t\t\t\t\t\t\n        'dbtype'::'postgres',\n\t'database'::'spatial_DB',\n\t'port'::'5433',\t\t\t\t\t\t\t\t\n        'user'::'postgres',\n\t'passwd'::'tmt',\n\t'select'::'SELECT ST_AsBinary(geom) as geom FROM bounds;' ];\n```\n\n  * **Step 2**: define boundary of environment by using the map object in first step.\n\n```\ngeometry shape <- envelope(BOUNDS);\n```\n\nNote: We can do the same way if we work with MySQL, SQLite, or SQLServer and we must convert Geometry format in GIS database to binary format.\n\n### Create agents from the result of a select action\n\nIf we are familiar with how to create agents from a shapefile then it becomes very simple to create agents from select result. We can do as below:\n\n  * **Step 1**: Define a species with SQLSKILL or AgentDB\n\n```\nspecies toto skills: SQLSKILL {\n\t//insert your descriptions here\t\n}\t\n```\n\n  * **Step 2**: Define a connection and selection parameters\n\n```\nglobal {\n\tmap<string,string>  PARAMS <- ['dbtype'::'sqlite','database'::'../includes/bph.sqlite'];\n\tstring location <- 'select ID_4, Name_4, ST_AsBinary(geometry) as geom from vnm_adm4 \n                                      where id_2=38253 or id_2=38254;';\n\t...\n}      \n```\n\n  * **Step 3**: Create species by using selected results\n\n```\ninit {\n   create toto { \n\t  create locations from: list(self select (params: PARAMS, \n\t\t                                                   select: LOCATIONS)) \n                                   with:[ id:: \"id_4\", custom_name:: \"name_4\", shape::\"geom\"];\n\t}\n   ...\n}\n```\n\n### Save Geometry data to database\nIf we are familiar with how to create agents from a shapefile then it becomes very simple to create agents from select result. We can do as below:\n\n  * **Step 1**: Define a species with SQLSKILL or AgentDB\n\n```\nspecies toto skills: SQLSKILL {  \n\t//insert your descriptions here\n} \n```\n\n  * **Step 2**: Define a connection and create GIS database and tables\n\n```\nglobal {\n\tmap<string,string> PARAMS <-  ['host'::'localhost', 'dbtype'::'Postgres', 'database'::'', \n                                                            'port'::'5433', 'user'::'postgres', 'passwd'::'tmt'];\n\n\tinit {\n\t\tcreate toto ;\n\t\task toto {\n\t\t\tif (self testConnection[ params::PARAMS]){\n\t\t\t    // create GIS database\t\n \t\t\t    do executeUpdate(params:PARAMS, \n\t\t                updateComm: \"CREATE DATABASE spatial_db with TEMPLATE = template_postgis;\"); \n \t\t\t    \tremove key: \"database\" from: PARAMS;\n\t\t\t\tput \"spatial_db\" key:\"database\" in: PARAMS;\n\t\t\t\t//create table\n                            do executeUpdate params: PARAMS \n\t\t\t\t  updateComm : \"CREATE TABLE buildings \"+\n\t\t\t\t  \"( \"  +\n                   \t               \" name character varying(255), \" + \n                                       \" type character varying(255), \" + \n                                       \" geom GEOMETRY \" + \n                                   \")\";\n\t\t\t}else {\n \t\t\t\twrite \"Connection to MySQL can not be established \";\n \t\t\t}\t\n\t\t}\n\t}\n}\n```\n\n  * **Step 3**: Insert geometry data to GIS database\n\n```\nask building {\n   ask DB_Accessor {\n\tdo insert(params: PARAMS, \n                        into: \"buildings\",\n\t\t\tcolumns: [\"name\", \"type\",\"geom\"],\n\t\t\tvalues: [myself.name,myself.type,myself.shape];\n   }\n}\n```\n[//]: # (endConcept|use_database)","url":"wiki/UsingDatabase.md"},"UsingDrivingSkill.md":{"title":" Advanced Driving Skill","content":"# Advanced Driving Skill\n[//]: # (keyword|concept_transport)\n[//]: # (keyword|concept_skill)\n[//]: # (keyword|skill_driving)\n\n\nThis page aims at presenting how to use the advanced driving skill in models.\n\nThe use of the advanced driving skill requires to use 3 skills:\n  * **Advanced driving skill**: dedicated to the definition of the driver species. It provides the driver agents with variables and actions allowing to move an agent on a graph network and to tune its behavior.\n  * **Road skill**: dedicated to the definition of roads. It provides the road agents with variables and actions allowing to registers agents on the road.\n  * **RoadNode skill**: dedicated to the definition of node. It provides the node agents with variables allowing to take into account the intersection of roads and the traffic signals.\n\n## Table of contents \n\n* [Advanced Driving Skill](#advanced-driving-skill)\n\t* [Structure of the network: road and roadNode skills](#structure-of-the-network-road-and-roadnode-skills)\n\t* [Advanced driving skill](#advanced-driving-skill)\n\t* [Application example](#application-example)\n\n\n## Structure of the network: road and roadNode skills\nThe advanced driving skill is versatile enough to be usable with most of classic road GIS data, in particular OSM data. We use a classic format for the roads and nodes. Each road is a polyline composed of road sections (segments). Each road has a target node and a source node. Each node knows all its input and output roads. A road is considered as directed. For bidirectional roads, 2 roads have to be defined corresponding to both directions. Each road will be the **linked\\_road** of the other. Note that for some GIS data, only one road is defined for bidirectional roads, and the nodes are not explicitly defined. In this case, it is very easy, using the GAML language, to create the reverse roads and the corresponding nodes (it only requires few lines of GAML).\n\n\n[images/roads_structure.PNG](resources/images/recipes/roads_structure.PNG) \n\nA lane can be composed of several lanes and the vehicles will be able to change at any time its lane. Another property of the road that will be taken into account is the maximal authorized speed on it. Note that even if the user of the plug-in has no information about these values for some of the roads (the OSM data are often incomplete), it is very easy using the GAML language to fill the missing value by a default value. It is also possible to change these values dynamically during the simulation (for example, to take into account that after an accident, a lane of a road is closed or that the speed of a road is decreased by the authorities).\n\n\n[images/roads.PNG](resources/images/recipes/roads.PNG) \n\nThe **road skill** provides the road agents with several variables that will define the road properties:\n  * **lanes**: integer, number of lanes.\n  * **maxspeed**: float; maximal authorized speed on the road.\n  * **linked\\_road**: road agent; reverse road (if there is one).\n  * **source\\_node**: node agent; source node of the road.\n  * **target\\_node**: node agent; target node of the road.\n\n\nIt provides as well the road agents with one read only variable:\n  * **agents\\_on**: list of list (of driver agents); for each lane, the list of driver agents on the road.\n\n\nThe\\*roadNode skill**provides the road agents with several variables that will define the road properties:\n  ***roads\\_in**: list of road agents; the list of road agents that have this node for target node.\n  ***roads\\_out**: list of road agents; the list of road agents that have this node for source node.\n  ***stop**: list of list of road agents; list of stop signals, and for each stop signal, the list of concerned roads.**\n\n\nIt provides as well the road agents with one read only variable:\n\n  * **block**: map: key: driver agent, value: list of road agents; the list of driver agents blocking the node, and for each agent, the list of concerned roads.\n\n\n## Advanced driving skill\nEach driver agent has a planned trajectory that consists in a succession of edges. When the driver agent enters a new edge, it first chooses its lane according to the traffic density, with a bias for the rightmost lane. The movement on an edge is inspired by the Intelligent Driver Model. The drivers have the possibility to change their lane at any time (and not only when entering a new edge).\n\nThe **advanced driving skill** provides the driver agents with several variables that will define the car properties and the personality of the driver:\n  * **final\\_target**: point; final location that the agent wants to reach (its goal).\n  * **vehicle\\_length**: float; length of the vehicle.\n  * **max\\_acceleration**: float; maximal acceleration of the vehicle.\n  * **max\\_speed**: float; maximal speed of the vehicle.\n  * **right\\_side\\_driving**: boolean; do drivers drive on the right side of the road?\n  * **speed\\_coef**: float; coefficient that defines if the driver will try to drive above or below the speed limits.\n  * **security\\_distance\\_coeff**: float; coefficient for the security distance. The security distance will depend on the driver speed and on this coefficient.\n  * **proba\\_lane\\_change\\_up**: float; probability to change lane to a upper lane if necessary (and if possible).\n  * **proba\\_lane\\_change\\_down**: float; probability to change lane to a lower lane if necessary (and if possible).\n  * **proba\\_use\\_linked\\_road**: float; probability to take the reverse road if necessary (if there is a reverse road).\n  * **proba\\_respect\\_priorities**: float; probability to respect left/right (according to the driving side) priority at intersections.\n  * **proba\\_respect\\_stops**: list of float; probabilities to respect each type of stop signals (traffic light, stop sign...).\n  * **proba\\_block\\_node**: float; probability to accept to block the intersecting roads to enter a new road.\n\n\nIt provides as well the driver agents with several read only variables:\n\n  * **speed**: float; speed expected according to the road **max\\_value**, the car properties, the personality of the driver and its **real\\_speed**.\n  * **real\\_speed**: float; real speed of the car (that takes into account the other drivers and the traffic signals).\n  * **current\\_path**: path (list of roads to follow); the path that the agent is currently following.\n  * **current\\_target**: point; the next target to reach (sub-goal). It corresponds to a node.\n  * **targets**: list of points; list of locations (sub-goals) to reach the final target.\n  * **current\\_index**: integer; the index of the current goal the agent has to reach.\n  * **on\\_linked\\_road**: boolean; is the agent on the linked road?\n\n\nOf course, the values of these variables can be modified at any time during the simulation. For example, the probability to take a reverse road (**proba\\_use\\_linked\\_road**) can be increased if the driver is stucked for several minutes behind a slow vehicle.\n\nIn addition, the advanced driving skill provides the driver agents with several actions:\n  * **compute\\_path**: arguments: a graph and a target node. This action computes from a graph the shortest path to reach a given node.\n  * **drive**: no argument. This action moves the driver on its current path according to the traffic condition and the driver properties (vehicle properties and driver personality).\n\n\nthe **drive** action works as follow: while the agent has the time to move (**remaining\\_time > 0**), it first defines the speed expected. This speed is computed from the **max\\_speed** of the road, the current **real\\_speed**, the **max\\_speed**, the **max\\_acceleration** and the **speed\\_coef** of the driver (see Equation 1).\n```\n\nspeed_driver = Min(max_speed_driver, Min(real_speed_driver + max_acceleration_driver,max_speed_road * speed_coef_driver))\n\n```\n\nThen, the agent moves toward the current target and compute the remaining time. During the movement, the agents can change lanes (see below). If the agent reaches its final target, it stops; if it reaches its current target (that is not the final target), it tests if it can cross the intersection to reach the next road of the current path. If it is possible, it defines its new target (target node of the next road) and continues to move.\n\n\n[images/drive_action.png](resources/images/recipes/drive_action.png) \n\nThe function that defines if the agent crosses or not the intersection to continue to move works as follow: first, it tests if the road is blocked by a driver at the intersection (if the road is blocked, the agent does not cross the intersection). Then, if there is at least one stop signal at the intersection (traffic signal, stop sign...), for each of these signals, the agent tests its probability to respect or not the signal (note that the agent has a specific probability to respect each type of signals). If there is no stopping signal or if the agent does not respect it, the agent checks if there is at least one vehicle coming from a right (or left if the agent drives on the left side) road at a distance lower than its security distance. If there is one, it tests its probability to respect this priority. If there is no vehicle from the right roads or if it chooses to do not respect the right priority, it tests if it is possible to cross the intersection to its target road without blocking the intersection (i.e. if there is enough space in the target road). If it can cross the intersection, it crosses it; otherwise, it tests its probability to block the node: if the agent decides nevertheless to cross the intersection, then the perpendicular roads will be blocked at the intersection level (these roads will be unblocked when the agent is going to move).\n\n\n\n[images/stop_at_intersection.png](resources/images/recipes/stop_at_intersection.png) \n\n\nConcerning the movement of the driver agents on the current road, the agent moves from a section of the road (i.e. segment composing the polyline) to another section according to the maximal distance that the agent can moves (that will depend on the remaining time). For each road section, the agent first computes the maximal distance it can travel according the remaining time and its speed. Then, the agent computes its security distance according to its speed and its **security\\_distance\\_coeff**. While its remaining distance is not null, the agent computes the maximal distance it can travel (and the corresponding lane), then it moves according to this distance (and update its current lane if necessary). If the agent is not blocked by another vehicle and can reach the end of the road section, it updates its current road section and continues to move.\n\n\n[images/follow_driving.png](resources/images/recipes/follow_driving.png) \n\nThe computation of the maximal distance an agent can move on a road section consists in computing for each possible lane the maximal distance the agent can move. First, if there is a lower lane, the agent tests the probability to change its lane to a lower one. If it decides to test the lower lane, the agent computes the distance to the next vehicle on this lane and memorizes it. If this distance corresponds to the maximal distance it can travel, it chooses this lane; otherwise it computes the distance to the next vehicle on its current lane and memorizes it if it is higher than the current memorized maximal distance. Then if the memorized distance is lower than the maximal distance the agent can travel and if there is an upper lane, the agents tests the probability to change its lane to a upper one. If it decides to test the upper lane, the agent computes the distance to the next vehicle on this lane and memorizes it if it is higher than the current memorized maximal distance. At last, if the memorized distance is still lower than the maximal distance it can travel, if the agent is on the highest lane and if there is a reverse road, the agent tests the probability to use the reverse road (linked road). If it decides to use the reverse road, the agent computes the distance to the next vehicle on the lane 0 of this road and memorizes the distance if it is higher than the current memorized maximal distance.\n\n\n[images/define_max_dist.png](resources/images/recipes/define_max_dist.png) \n\n## Application example\n\n\nWe propose a simple model to illustrate the driving skill. We define a driver species. When a driver agent reaches its destination, it just chooses a new random final target. In the same way, we did not define any specific behavior to avoid traffic jam for the driver agents: once they compute their path (all the driver agents use for that the same road graph with the same weights), they never re-compute it even if they are stucked in a traffic jam. Concerning the traffic signals, we just consider the traffic lights (without any pre-processing: we consider the raw OSM data). One step of the simulation represents 1 second. At last, in order to clarify the explanation of the model, we chose to do not present the parts of the GAML code that concern the simulation visualization.\n\n\n\n[images//sim_snapshot.png](resources/images/recipes/sim_snapshot.png) \n\nThe following code shows the definition of species to represent the road infrastructure:\n```\nspecies road skills: [skill_road] { \n  string oneway;\n}\n\nspecies node skills: [skill_road_node] {\n  bool is_traffic_signal;\n  int time_to_change <- 100;\n  int counter <- rnd (time_to_change) ;\n\t\n  reflex dynamic when: is_traffic_signal {\n    counter <- counter + 1;\n    if (counter >= time_to_change) { \n      counter <- 0;\n      stop[0] <-empty(stop[0])? roads_in : [];\n    } \n  }\n}\n```\n\nIn order to use our driving skill, we just have to add the **skill\\_road\\_node** to the **node** species and the **skill\\_road** to the **road** species. In addition, we added to the road species a variable called **oneway** that will be initialized from the OSM data and that represents the traffic direction (see the OSM map features for more details). Concerning the node, we defined 3 new attributes:\n\n  * **is\\_traffic\\_signal**: boolean; is the node a traffic light?\n  * **time\\_to\\_change**: integer; represents for the traffic lights the time to pass from the red light to the green light (and vice versa).\n  * **counter**: integer;  number of simulation steps since the last change of light color (used by the traffic light nodes).\n\nIn addition, we defined for the **node** species a reflex (behavior) called **dynamic** that will be activated only for traffic light nodes and that will increment the **counter** value. If this counter is higher than **time\\_to\\_change**, this variable is set to 0, and the node change the value of the **stop** variable: if the traffic light was green (i.e. there is no road concerns by this stop sign), the list of block roads is set by all the roads that enter the node; if the traffic light was red (i.e. there is at least one road concerns by this stop sign), the list of block roads is set to an empty list.\n\nThe following code shows the definition of driver species:\n```\n\nspecies driver skills: [advanced_driving] { \n  reflex time_to_go when: final_target = nil {\n    current_path <- compute_path(\n        graph: road_network, target: one_of(node));\n  }\n  reflex move when: final_target != nil {\n    do drive;\n  }\n} \n```\n\nIn order to use our driving plug-in, we just have to add the **advanced\\_driving** to the **driver** species. For this species, we defined two reflexes:\n  * **time\\_to\\_go**: activated when the agent has no final target. In this reflex, the agent will randomly choose one of the nodes as its final target, and computed the path to reach this target using the\n  * **road\\_network** graph. Note that it will have been possible to take into account the knowledge that each agent has concerning the road network by defining a new variable of type map (dictionary) containing for each road a given weight that will reflect the driver knowledge concerning the network (for example, the known traffic jams, its favorite roads....) and to use this map for the path computation.\n  * **move**: activated when the agent has a final target. In this reflex, the agent will drive in direction of its final target.\n\nWe describe in the following code how we initialize the simulation:\n```\ninit {  \n  create node from: file(\"nodes.shp\") with:[\n    is_traffic_signal::read(\"type\")=\"traffic_signals\"];\n    \n  create road from: file(\"roads.shp\") \n    with:[lanes::int(read(\"lanes\")), \n    maxspeed::float(read(\"maxspeed\")), \n    oneway::string(read(\"oneway\"))] \n    {\n      switch oneway {\n        match \"no\" {\n          create road {\n            lanes <- myself.lanes;\n            shape <- polyline(reverse\n              (myself.shape.points));\n            maxspeed <- myself.maxspeed;\n            linked_road <- myself;\n            myself.linked_road <- self;\n          }\n        }\n        match \"-1\" {\n          shape <- polyline(reverse(shape.points));\n        }\n      }\n    }\t\n  }    \n  map general_speed_map <-  road as_map  \n    (each::(each.shape.perimeter/(each.maxspeed)));\n      \n  road_network <-  (as_driving_graph(road, node))  \n     with_weights general_speed_map;\n   \n  create driver number: 10000 { \n    location <- one_of(node).location;\n    vehicle_length <- 3.0;\n    max_acceleration <- 0.5 + rnd(500) / 1000;\n    speed_coeff <- 1.2 - (rnd(400) / 1000);\n    right_side_driving <- true;\n    proba_lane_change_up <- rnd(500) / 500;\n    proba_lane_change_down <- 0.5+ (rnd(250) / 500);\n    security_distance_coeff <- 3 - rnd(2000) / 1000);  \n    proba_respect_priorities <- 1.0 - rnd(200/1000);\n    proba_respect_stops <- [1.0 - rnd(2) / 1000];\n    proba_block_node <- rnd(3) / 1000;\n    proba_use_linked_road <- rnd(10) / 1000;\n  }\t\n}\t\n```\n\nIn this code, we create the node agents from the node shapefile (while reading the attributes contained in the shapefile), then we create in the same way the road agents. However, for the road agents, we use the **oneway** variable to define if we should or not reverse their geometry (**oneway** = \"-1\") or create a reverse road (**oneway** = \"no\"). Then, from the road and node agents, we create a graph (while taking into account the **maxspeed** of the road for the weights of the edges). This graph is the one that will be used by all agents to compute their path to their final target. Finally, we create 1000 driver agents. At initialization, they are randomly placed on the nodes; their vehicle has a length of 3m; the maximal acceleration of their vehicle is randomly drawn between 0.5 and 1; the speed coefficient of the driver is randomly drawn between 0.8 and 1.2; they are driving on the right side of the road; their probability of changing lane for a upper lane is randomly drawn between 0 and 1.0; their probability of changing lane for a lower lane is randomly drawn between 0.5 and 1.0; the security distance coefficient is randomly drawn between 1 and 3; their probability to respect priorities is randomly drawn between 0.8 and 1; their probability to respect light signal is randomly drawn between 0.998 and 1; their probability to block a node is randomly drawn between 0 and 0.003;  their probability to use the reverse road is randomly drawn between 0 and 0.01;\n\nThe complete code of the model with the data can be found [here](resources/images/recipes/Rouentrafffic.zip)","url":"wiki/UsingDrivingSkill.md"},"UsingFIPAACL.md":{"title":" Using FIPA ACL","content":"[//]: # (keyword|concept_fipa)\n[//]: # (startConcept|fipa_acl)\n# Using FIPA ACL\n\n\nThe communicating skill offers some actions and built-in variables which enable agents to communicate with each other using the FIPA interaction protocol. This document describes the built-in variables and actions of this skill. Examples are found in the models library bundled with GAMA.\n\n##Variables\n\n* **accept_proposals (list)**: A list of 'accept_proposal' performative messages of the agent's mailbox having .\n* **agrees (list)**: A list of 'accept_proposal' performative messages.\n* **cancels (list)**: A list of 'cancel' performative messages.\n* **cfps (list)**: A list of 'cfp' (call for proposal) performative messages.\n* **conversations (list)**: A list containing the current conversations of agent. Ended conversations are automatically removed from this list.\n* **failures (list)**: A list of 'failure' performative messages.\n* **informs (list)**: A list of 'inform' performative messages.\n* **messages (list)**: The mailbox of the agent, a list of messages of all types of performatives.\n* **proposes (list)**: A list of 'propose' performative messages .\n* **queries (list)**: A list of 'query' performative messages.\n* **refuses (list)**: A list of 'propose' performative messages.\n* **reject_proposals (list)**: A list of 'reject_proposals' performative messages.\n* **requests (list)**: A list of 'request' performative messages.\n* **requestWhens (list)**: A list of 'request-when' performative messages.\n* **subscribes (list)**: A list of 'subscribe' performative messages.\n\n### Actions\n####accept_proposal\nReplies a message with an 'accept_proposal' performative message\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####agree\nReplies a message with an 'agree' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####cancel\nReplies a message with a 'cancel' peformative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####cfp\nReplies a message with a 'cfp' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####end_conversation\nReplies a message with an 'end_conversation' peprformative message. This message marks the end of a conversation. In a 'no-protocol' conversation, it is the responsible of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####failure\nReplies a message with a 'failure' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####inform\nReplies a message with an 'inform' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####propose\nReplies a message with a 'propose' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####query\nReplies a message with a 'query' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####refuse\nReplies a message with a 'refuse' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####reject_proposal\nReplies a message with a 'reject_proposal' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####reply\nReplies a message. This action should be only used to reply a message in a 'no-protocol' conversation and with a 'user defined performative'. For performatives supported by GAMA (i.e., standard FIPA performatives), please use the 'action' with the same name of 'performative'. For example, to reply a message with a 'request' performative message, the modeller should use the 'request' action.\n* returns: unknown\n* message (message): The message to be replied\n* performative (string): The performative of the replying message\n* content (list): The content of the replying message\n\n####request\nReplies a message with a 'request' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n####send\nStarts a conversation/interaction protocol.\n* returns: msi.gaml.extensions.fipa.Message\n* receivers (list): A list of receiver agents\n* content (list): The content of the message. A list of any GAML type\n* performative (string): A string, representing the message performative\n* protocol (string): A string representing the name of interaction protocol\n\n####start_conversation\nStarts a conversation/interaction protocol.\n* returns: msi.gaml.extensions.fipa.Message\n* receivers (list): A list of receiver agents\n* content (list): The content of the message. A list of any GAML type\n* performative (string): A string, representing the message performative\n* protocol (string): A string representing the name of interaction protocol\n\n####subscribe\nReplies a message with a 'subscribe' performative message.\n* returns: unknown\n* message (message): The message to be replied\n* content (list): The content of the replying message\n\n[//]: # (endConcept|fipa_acl)","url":"wiki/UsingFIPAACL.md"},"IncrementalModel_step1.md":{"title":" 1. Simple SI Model","content":"# 1. Simple SI Model\nThis first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models.\n\n\n\n\n\n\n## Formulation\n  * Definition of the **people** species with a variable (is\\_infected) , an aspect (base) and two behaviors (move and infect)\n  * Definition of **nb\\_infected\\_init**, **distance\\_infection** and **proba\\_infection** parameters\n  * Creation of **500** **people** agents randomly located in the environment (size: 500x500)\n  * Definition a display to visualize the people agents.\n\n![images/Incremental_model1.jpg](resources/images/tutorials/Incremental_model1.jpg)\n\n\n\n\n\n## Model Definition\n\n### model structure\nA GAMA model is composed of three type of sections:\n  * **global** : this section, that is unique, defines the \"world\" agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).\n  * **species** : these sections define the species of agents composing the model.\n  * **experiment** : these sections define a context of execution of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model.\n\nMore details about the different sections of a GAMA model can be found [here](ModelOrganization).\n\n### species\nA [species](RegularSpecies) represents a «prototype» of agents: it defines their common properties.\n\nA species includes several sub-definitions:\n  * the internal state of its agents (attributes)\n  * their behavior\n  * how they are displayed (aspects)\n\nGAMA provides as well the possibility to give **skills** to species of agents. A skillI is a module integrating variables and actions coded in Java.\n\nConcerning our model, we will give the **moving** skill to the **people** agents: it will give to the people agents supplementary variables (speed, heading, destination) and actions (follow, goto, move, wander).\n\n```\nspecies people skills:[moving]{\n}\n```\n\nConcerning the internal state, a [attribute](RegularSpecies#declaration) is defined as follows: type of the attribute (int (integer), float (floating point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, espèce d’agents, rgb (color), graph, path...) + name\n  * Optional facets: <- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max\n\nNote that all the species inherit from predefined built-in variables:\n  * A name (_name_)\n  * A shape (_shape_)\n  * A location (_location_) : the centroid of its shape.\n\nWe will give a variable to **people** agents: **is\\_infected** (bool):\n```\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n}\n```\n\nConcerning the display of an agent, [aspects](RegularSpecies#the-aspect-statement) have to be defined. An aspect represents a possible way to display the agents of a species : aspect aspect\\_name {...}\nIn the block of an aspect, it is possible to draw :\n  * A geometry :  for instance, the shape of the agent\n  * An image : to draw icons\n  * A text : to draw a text\n\nWe define an aspect for this species. In this model, we want to display for each people agent a circle of radius 5 and red or green according to the value of is\\_infected (if infected: red, green otherwise). We then use the keyword **draw** with a circle shape. To define the color that depends on is\\_infected, we use the tertiary operator **condition ? val1 : val2**. If the condition is true, this operator will return **val1**, otherwise **val2**. Note that it is possible to get a color value by using the symbol _#_ + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink...\n```\nspecies people skills:[moving]{\t\t\n\t...\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n```\nConcerning the behavior of agents, the simplest way to define it is through reflexes. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true. A reflex is defined as follows:\n```\n   reflex reflex_name when: condition {...}\n```\n\nThe **when** facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.\n\nWe define a first reflex called **move** that allows the people agents to move using the **wander** action (provided by the **moving** skill) that allows to randomly move (with taking into account the agent **speed**)\n```\nspecies people {\n        ...\n        reflex move{\n\t\tdo wander;\n\t}\n}\n```\n\nNote that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the **wander** action defined in the **moving** skill.\n  * An action can accept arguments. For instance, write takes an argument called message.\n  * An action can return a result.\n\nThere are two ways to call an action: using a statement or as part of an expression\n  * for actions that do not return a result:\n```\ndo action_name arg1: v1 arg2: v2;\n```\n\n  * for actions that return a result:\n```\nmy_var <- self action_name (arg1:v1, arg2:v2);\n```\n\nThe second reflex we have to define is the **infect** one. This reflex will be activated only if **is\\_infected** is true. This reflex consists is asking all the people agents at a distance lower or equal to **infection\\_distance** to become infected with a probability **proba\\_infection**.\n\n```\nspecies people skills:[moving]{\t\t\n\t...\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\t...\n}\n```\n\nNote that we used the **ask** statement. This statement allows to make a remote agent executes a list of statements. We used as well the **flip** operator that allows to test a probability.\n\n### global section\nThe global section represents the definition of the species of a specific agent (called world).\nThe world agent represents everything that is global to the model: dynamics, variables...\nIt allows to init simulations (init block): the world is always created and initialized first when a simulation is launched. The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary. In the same way, the modeler can redefined the **step** variable that represent the duration of a simulation step and that is by default 1 second.\n\n#### global variable\nFor our model, we define 4 global variables: **nb\\_people** (int, init value: 500), **infection distance** (float value, init value: 2 meters), **proba\\_infection** (float, init value: 0.05) and nb\\_infected\\_init (int, init value: 5). In addition, we redefine the geometry of the world by a square of 500 meters size and a simulation step of 1 minute.\n```\nglobal{ \n\tint nb_people <- 500;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #minutes;\n\tgeometry shape<-square(500 #m);\n}\n```\n\n#### Model initialization\nThe init section of the global block allows to initialize the model.\nThe statement _create_ allows to create agents of a specific species: **create** species\\_name + :\n  * number : number of agents to create (int, 1 by default)\n  * from : GIS file to use to create the agents (string or file)\n  * returns: list of created agents (list)\n\nFor our model, definition of the init block in order to create **nb\\_people** people agents. We set the init value of the **speed** variable (given by the **moving** skill) to 5km/h.\n> In addition we ask **nb\\_infected\\_init** people to become infected (use of the **nb among list** to randomly draw nb elements of the list).\n```\nglobal{ \n\t...\n\tinit{\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n}\n```\n\n### experiment\nAn experiment block defines how a model can be simulated (executed). Several experiments can be defined for a model. They are defined using : **experiment** exp\\_name type: gui/batch {`[input]` `[output]`}\n  * gui : experiment with a graphical interface, which displays its input parameters and outputs.\n  * batch : Allows to setup a series of simulations (w/o graphical interface).\n\nIn our model, we define a gui experiment called main_experiment :\n```\nexperiment main_experiment type: gui {\n}\n```\n\n#### input\nExperiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.\n\nA parameter is defined as follows:\n**parameter** title var: global\\_var category: cat;\n  * **title** : string to display\n  * **var** : reference to a global variable (defined in the global section)\n  * **category** : string used to «store» the operators on the UI - optional\n  * **<-** : init value - optional\n  * **min** : min value - optional\n  * **max** : min value - optional\n\nNote that the init, min and max values can be defined in the global variable definition.\n\nIn the experiment, definition of three parameters from the the global variable **infection\\_distance**, **proba\\_infection** and **nb\\_infected\\_init** :\n```\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\t...\n}\n```\n\n#### output\nOutput blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet **refresh\\_every:** nb (int) (the display will be refreshed every nb steps of the simulation).\n\nEach display can include different layers (like in a GIS) :\n  * Agents lists : **agents** layer\\_name value: agents\\_list aspect: my\\_aspect;\n  * Agents species : **species**  my\\_species aspect: my\\_aspect\n  * Images: **image** layer\\_name file: image\\_file;\n  * Texts : **texte** layer\\_name value: my\\_text;\n  * Charts : see later.\n\nNote that it is possible to define a [opengl display](G__3DSpecificInstructions) (for 3D display) by using the facet **type: opengl**.\n\nIn our model, we define a display to draw the **people** agents with their **circle** aspect.\n```\nexperiment main_experiment type:gui{\n\t...\n        output {\n\t\tdisplay map {\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel SI_city\n\nglobal{ \n\tint nb_people <- 500;\n\tfloat agent_speed <- 5.0 #km/#h;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #minutes;\n\tgeometry shape<-square(500 #m);\n\t\n\tinit{\n\t\tcreate people number:nb_people;\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\t\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- agent_speed;\n\tbool is_infected <- false;\n\treflex move{\n\t\tdo wander;\n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```","url":"wiki/IncrementalModel_step1.md"},"IncrementalModel_step2.md":{"title":" 2. Charts","content":"# 2. Charts\nThis step Illustrates how define monitors and charts in GAMA. In addition, it illustrates how to define a stopping condition for the simulation.\n\n\n\n\n\n\n\n## Formulation\n  * Definition of new global variables: current\\_hour, nb\\_people\\_infected, nb\\_people\\_not\\_infected, infected\\_rate\n  * Definition of a monitor to follow the current hour and the nb of people infected\n  * Definition of a series chart to follow the number of people infected and not infected\n  * Definition of a stopping condition (when infected rate = 1)\n\n![images/Incremental_model2.jpg](resources/images/tutorials/Incremental_model2.jpg)\n\n\n\n\n\n## Model Definition\n\n### global variables\nIn order to define dynamic variable able to update itself, we use the **update** facet of variable definition.\nIndeed, at each simulation step, all the agents (and the world agent) apply for each dynamic variable (in their definition order) its update expression.\nWe define 4 new variables:\n  * **current hour** (int) : current simulation step (**cycle**) / 60 mod 24\n  * **nb\\_people\\_infected** (int): nb of people with is\\_infected = true (use of the **list count condition** operator that count the number of elements of the list for which the condition is true)\n  * **nb\\_people\\_not\\_infected** (int): nb\\_people - nb of people infected\n  * **infected\\_rate** (float): nb of people infected / nb of people\n```\nglobal{\n\t...\n        int current_hour update: (cycle / 60) mod 24;\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t...\n}\n```\n### stopping condition\n\nWe add a new reflex that stops the simulation if the **infected\\_rate** is equal to 1. To stop the simulation, we apply the **halt** action.\n\n```\nglobal {\n   ...\n        reflex end_simulation when: infected_rate = 1.0 {\n\t\tdo halt;\n\t}\n}\n```\n\nNote that it would have been possible to use the **pause** action that pauses the simulation instead of the **halt** action that stops the simulation.\n\n### monitor\nA monitor allows to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows:\n```\n      monitor monitor_name value: an_expression refresh:every(nb_steps);\n```\n\nWith:\n  * value: mandatory, its value will be displayed in the monitor.\n  * refresh: bool, optional : if the expression is true, compute (default is true).\n\nIn this model, we define 2 monitors to follow the value of the variable **current\\_hour** and **infected\\_rate**:\n```\nexperiment main_experiment type:gui{\n\t...\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t...\n\t}\n}\n```\n\n### chart\n\nGAMA can display various chart types:\n  * Time series\n  * Pie charts\n  * Histograms\n\nA chart must be defined in a display : it behaves exactly like any other layer.\nDefinition of a chart :\n\n```\nchart chart_name type: chart_type  {\n     [data]\n}\n```\n\nThe data to draw are define inside the chart block:\n\n```\n     data data_legend value: data_value\n```\n\nWe add a new display called **chart** refresh every 10 simulation steps.\nInside this display, we define a chart of type _series_:\n  * \"Species evolution\"; background : white; size : {1, 0.5}; position : {0, 0}\n    * data1: susceptible; color : green\n    * data2: infected; color : red\n\n```\nexperiment main_experiment type:gui{\n\t...\n\toutput {\n\t\t...\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n## Complete Model\n\n```\nmodel SI_city\n\nglobal{\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tgeometry shape<-envelope(square(500 #m));\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tint current_hour update: (cycle / 60) mod 24;\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/length(people);\n\t\n\tinit{\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\treflex move{\n\t\tdo wander;\n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map {\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```","url":"wiki/IncrementalModel_step2.md"},"IncrementalModel_step3.md":{"title":" 3. Integration of GIS Data","content":"# 3. Integration of GIS Data\nThis step Illustrates how load and agentry GIS data.\n\n\n\n\n\n\n\n## Formulation\n  * Load, agentify and display two layers of GIS data (building and road)\n  * Modify the initialization of the people agents to put them inside buildings\n\n![resources/images/tutorials/Incremental_model3.jpg](resources/images/tutorials/Incremental_model3.jpg)\n\n\n\n\n\n## Model Definition\n\n### species\nWe have to define two species of agents: the **building** agents and the **road** ones. These agents will not have a particular behavior, they will just be displayed.\nWe define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use the keyword **draw** that allow to draw a given geometry. In order to draw the geometry of the agent we use the attribute **shape** (which is a built-in attribute of all agents).\n\n```\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n```\n\n\n### parameters\nGAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define two parameters. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile.\n\nDefinition of the two global variables of type _file_ concerning the GIS files:\n```\nglobal {\n   file shape_file_buildings <- file(\"../includes/building.shp\");\n   file shape_file_roads <- file(\"../includes/road.shp\");\n}\n```\n\n### agentification of GIS data\n\nIn GAMA, the agentification of GIS data is very straightforward: it only requires to use the **create** command with the **from** facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species.\n\nWe modify the init section of the global block in order to create road and building agents from the shape files. Then, we define the initial location of people as a point inside one of the building.\n```\nglobal {\n  ...\n       init {\n\t\tcreate road from: roads_shapefile;\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n        }\n} \n```\nWe defined here a local variable called **bd** of type building that is a one of the building (randomly chosen). Note that the name of a species can be used to obtain all the agents of this species (here **building** returns the list of all the buildings). The **any\\_location\\_in** returns a random point inside a geometry or an agent geometry.\n\n### environment\nBuilding a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use the road shapefile to define it.\n\n```\nglobal {\n  ...\n  geometry shape <- envelope(shape_file_roads); \n  ...\n}\n```\n\n### display\nWe add to the **map** display the road and building agents.\n\nIn the **experiment** block:\n```\noutput {\n   display map {\n\tspecies road aspect:geom;\n\tspecies building aspect:geom;\n\tspecies people aspect:circle;\t\t\t\n    }\n    ...\n}\n```\n\n\n\n\n\n\n## Complete Model\n\n```\nmodel model3 \n \nglobal {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tint current_hour update: (cycle / 60) mod 24;\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\t\n\tfloat infected_rate update: nb_people_infected/length(people);\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\t\t\n\treflex move{\n\t\tdo wander;\n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map {\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```","url":"wiki/IncrementalModel_step3.md"},"IncrementalModel_step4.md":{"title":" 4. Movement on Graph","content":"# 4. Movement on Graph\nThis step illustrates how load a graph and use it for the displacement of our species.\n\n\n\n\n\n\n\n## Formulation\n  * definition of a global graph to represent the road network\n  * definition of a new global variable: **staying\\_coeff** to represent the fact that people move more near 9h, 12h and 18h\n  * definition of two new variables for the people agents: **target** and **staying\\_counter**\n  * definition of a new reflex for people agents: **stay**\n  * modification of the **move** reflex of the people agents\n\n![images/Incremental_model4.jpg](resources/images/tutorials/Incremental_model4.jpg)\n\n\n\n\n\n## Model Definition\n\n### global variables\nWe define two new global variables:\n  * **road\\_network** (graph) : represents the graph that will be built from the road network\n  * **staying\\_coeff** (float) : represents the fact that people have more chance to move from their current building near 9h (go to work), 12h (lunch time) and 18h (go home). This variable is updated at each simulation step (use of the **update** facet).\n\n```\n global{\n\t....\n        graph road_network;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), \nabs(current_hour - 18)]));\n\t....\n}\n```\n\n### initialization\nWe need to compute from the **road** agents, a graph for the moving of the **people** agents. The operator **as\\_edge\\_graph** allows to do that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry. The weight of each edge corresponds to the length of the road.\n```\nglobal {\n   ...\n   init {\n      ...\n      create road from: roads_shapefile;\n      road_network <- as_edge_graph(road);\t\n      ...\n   }\n}\n```\n\n### people agent\nFirst, we add two new variables for the people agents:\n  * **target** (point): the target location that the people want to reach (a point inside a building)\n  * **staying\\_counter** (int): the number of cycles since the agent arrived at its building\n\nWe define a new reflex called **stay** that is activated when the agent has no target (target = nil), i.e. when the agent is inside a building. This reflex increments the **staying\\_counter**, then it test the probability to leave that is computed from the **staying\\_counter** (longer the agent is inside the building, more it has a chance to leave) and the staying\\_coeff (closer to 9h, 12h and 18h, more the agent has a chance to leave).\nIf the agents decide to leave, it computes a new target as a random point inside one of the buildings (randomly chosen).\n\n```\nspecies people skills:[moving]{\t\t\n\t...\n\treflex stay when: target = nil {\n\t\tstaying_counter <- staying_counter + 1;\n\t\tif flip(staying_counter / staying_coeff) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t...\n}\n```\n\nWe modify the **move** reflex. Now, this reflex is activated only when the agent has a target (target != nil). In this case the agent moves in direction to its target using the **goto** action. Note that we specified a graph (**road\\_network**) to constraint the moving of the agents on the road network with the facet **on**. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at destination (location = location), the target is set to nil (the agent will stop moving) and the staying\\_counter is set to 0.\n```\nspecies people skills:[moving]{\t\t\n\t...\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n}\n```\n\n\n\n\n## Complete Model\n\n```\nmodel model4 \n \nglobal {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tint current_hour update: (cycle / 60) mod 24;\n\tgraph road_network;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\t\n\tfloat infected_rate update: nb_people_infected/length(people);\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\treflex staying when: target = nil {\n\t\tstaying_counter <- staying_counter + 1;\n\t\tif flip(staying_counter / staying_coeff) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map {\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```","url":"wiki/IncrementalModel_step4.md"},"IncrementalModel_step5.md":{"title":" 5. Visualizing in 3D","content":"# 5. Visualizing in 3D\nThis step Illustrates how to define a 3D display\n\n\n\n\n\n\n\n## Formulation\n  * add a variable (height: int from 10m to 20m) and modify the aspect of buildings to display them in 3D\n  * add a variable (display\\_shape: geometry; shape with a buffer of 2m) and modify the aspect of the roads to display them with this new shape.\n  * add a new global variable that indicate if it is night or not (bool: night before 7h and after 20h).\n  * define a new aspect (sphere3D) for people to display them as sphere.\n  * modify the display to use this new aspect.\n\n![images/Incremental_model5.jpg](resources/images/tutorials/Incremental_model5.jpg)\n\n\n\n\n\n## Model Definition\n\n### building\nFirst, we add a new variable for buildings (**height**) of type float from 10m to 20m. Then we modify the aspect in order to specify a depth for the geometry (using the **depth** facet).\n```\nspecies building {\n\tfloat height <- 10#m + rnd(10) #m;\n\taspect geom {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n```\n\n### road\nConcerning the road,  we add a new variable (**display\\_shape**) of type geometry that correspond to the shape of the road with a buffer of 2 meters. Then we modify the aspect in order to display this geometry instead of the shape of the agent. In order to avoid \"z-fighting\" problems, we add a depth to the geometry (of 3 meters).\n```\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\taspect geom {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n```\n\n### global variable\nWe define a new global variable called **is\\_night** of type _bool_ to indicate if it is night or not. This variable will be update at each simulation step and will be _true_ if the **current\\_hour** is lower than 7h or higher than 20h.\n```\nglobal{\n\t...\n        bool is_night <- true update: current_hour < 7 or current_hour > 20;\n       ...\n}\n```\n\n### people\nWe define a new aspect for the people agent called **sphere3D**. This aspect draw people agent as a 3m sphere. In order to avoid to cut the sphere in half, we translate the centroid of the drawn sphere to 3m along the z axis.\n```\nspecies people skills:[moving]{\t\t\n\t...\n\taspect sphere3D{\n\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n\t}\n}\n```\n\n### display\nThe element that we have to modify is the display. We change its name to **map\\_3D** to better reflect its visual aspect.\n\nIn order to get a 3D aspect, we specify that this display will be an opengl one. For that, we just have to add the facet **type: opengl**. In addition, to get a different light between night and day : \nThe statement `light` allows us to declare a light. We can change up to 7 lights, called through the facet \"id\". The default light is a white light, directional, with the id=1. You can set the intensity of the light through the facet \"color\" (you can pass a color, or an integer between 0 and 255). To have a nice effect night / day, we will set the intensity of the light to 50 during the night, and 255 for the day. To learn more about light, please read this [page](ManipulateLight).\n\nThen, we add a new layer that consists in an image (soil.jpg) by using the **image** statement.\nIn order to see the people inside the building, we add transparency to the building (0.5). The transparency of a layer is a float value between 0 (solid) and 1 (totally transparent). In order to be able to manage this transparency aspect, opengl has to draw the people agents before the building, thus we modify the order of drawing of the different layers (people agents before building agents). At last, we modify the aspect of the people agents by the new one: **sphere3D**.\n\n```\nexperiment main_experiment type:gui{\n\t...\n\toutput {\n\t\t...\n\t\tdisplay map_3D type: opengl {\n\t\t\tlight 1 color:(is_night ? 50 : 255);\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies people aspect:sphere3D;\t\t\t\n\t\t\tspecies building aspect:geom transparency: 0.5;\n\t\t}\n\t\t...\n\t}\n}\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel model5 \n \nglobal {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tint current_hour update: (cycle / 60) mod 24;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tbool is_night <- true update: current_hour < 7 or current_hour > 20;\n\t\n\tfloat infected_rate update: nb_people_infected/length(people);\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\treflex stay when: target = nil {\n\t\tstaying_counter <- staying_counter + 1;\n\t\tif flip(staying_counter / staying_coeff) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n\taspect sphere3D{\n\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\taspect geom {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n\nspecies building {\n\tfloat height <- 10#m + rnd(10) #m;\n\taspect geom {\n\t\tdraw shape color: #gray depth: height;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map_3D type: opengl {\n\t\t\tlight 1 color:(is_night ? 50 : 255);\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies people aspect:sphere3D;\t\t\t\n\t\t\tspecies building aspect:geom transparency: 0.5;\n\t\t}\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```","url":"wiki/IncrementalModel_step5.md"},"IncrementalModel_step6.md":{"title":" 6. Multi-Level","content":"# 6. Multi-Level\nThis step Illustrates how to define a multi-level model\n\n\n\n\n\n\n\n## Formulation\nWe propose to let the buildings manage what happens when the people are inside buildings. In this context, we will use the multi-level properties of GAMA: when a people agent will be inside a building, it will be captured by it and its species will be modified. It will be not anymore the people agent that will decide when to leave the building, but the building itself.\n\nWe will need to:\n  * define a micro-species of people inside the building species (**people\\_in\\_buildings**)\n  * define a new variable for the building agent (_people\\_in**building**)\n  * define two new behaviors for building: **let\\_people\\_leave** and **let\\_people\\_enter**\n  * modify the aspect of the building\n  * modify some global variables for counting the number of infected people_\n\n![images/Incremental_model6.jpg](resources/images/tutorials/Incremental_model6.jpg)\n\n\n\n\n\n## Model Definition\n### building\nFirst, we define a new species called **people\\_in\\_building** inside the **building** species. Thus, a building could have agents of this species as **members** and control them. The **people\\_in\\_building** species has for parent the **people** species, which means that a **people\\_in\\_building** agent has all the properties, aspect and behaviors of a **people** agent.\nIn our case, we want the once a people agent inside a building, this people agent does nothing. Then, we use the **schedules** facet of the species to remove the **people\\_in\\_building** from the scheduler.\n\n```\nspecies building {\n\t...\n        species people_in_building parent: people schedules: [] {\n\t}\n\t...\n}\n```\n\nWe define a new dynamic variable for building agent: **people\\_inside** that will correspond to the list of **people\\_in\\_building** agents inside the building. Note that we use the syntax **-> {...}** to make the variable dynamic. However, instead of **update** that allows a variable to be recomputed at each simulation step, the syntax **-> {...}** allows the variable to be recomputed each time it is called (and thus avoid outdated problems). To compute this variable, we use the **members** built-in variable that corresponds to the list of micro-agents captured by the macro-agent.\n\n```\nspecies building {\n\t...\n        list<people_in_building> people_inside -> {members collect people_in_building(each)};\n\t...\n}\n```\n\n\nWe define a first reflex for the buildings that will be activated at each simulation step and that will allow the building to capture all the people that are inside its geometry and that are not moving (target = nil). Capturing agents means putting them inside its **members** list and changing their species: here the **people** agents become **people\\_in\\_building** agents.\n```\nspecies building {\n\t...\n      reflex let_people_enter {\n\t\tlist<people> entering_people <- people inside self where (each.target = nil);\n\t\tif not (empty (entering_people)) {\n\t\t\tcapture entering_people as: people_in_building ;\n \t\t}\n\t}\n        ....\n}\n```\n\nWe define a second reflex for the buildings that will be activated at each simulation step and that will allow the building to release some of the **people\\_in\\_building** agents. First, it increments the staying counter of all the **people\\_in\\_building** agents. Then it builds the list of leaving people by testing the same probability as before for all the **people\\_in\\_building** agents. Finally, if this list is not empty, it releases them as people agents (and gives them a new target point).\n\n```\nspecies building {\n\t...\n       reflex let_people_leave  {\n\t\task members as: people_in_building{\n\t\t\tstaying_counter <- staying_counter + 1;\n\t\t}\n\t\tlist<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\n\t\tif not (empty (leaving_people)) {\n\t\t\trelease leaving_people as: people in: world returns: released_people;\n\t\t\task released_people {\n\t\t\t\ttarget <- any_location_in (one_of(building));\n\t\t\t}\n\t\t}\n\t}\n        ....\n}\n```\n\nAt last, we refine the aspect of the buildings: if there is not people inside the building, we draw it with gray color. If the number of **people\\_in\\_building** infected is higher than the number of **people\\_in\\_building** not infected, we draw it in red; otherwise in green.\n\n```\nspecies building {\n\t...\n        aspect geom {\n\t \tint nbI <- members count people_in_building(each).is_infected;\n\t\tint nbT <- length(members);\n\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height;\n\t}\n}\n```\n\n### global variables\nIn order to take into account the people that are inside the buildings for the computation of **nb\\_people\\_infected**, we first build the list of **people\\_in\\_building**. As **people\\_in\\_building** is a macro species of **building**, we cannot compute it directly like for the other species, we then aggregate all the list **people\\_inside** of all building in a single list (**list\\_people\\_in\\_buildings**). Then, we compute the number of infected people as the number of people infected outside the building + the number of people infected inside them.\n\n```\nglobal  {\n\t...\n\tlist<people_in_building> list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));\n        ...\n}\n```\n\n\n\n\n\n## Complete Model\n\n```\n \nglobal  {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tint current_hour update: (cycle / 60) mod 24;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\n\t\n\tlist<people_in_building> list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));\n\t\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tbool is_night <- true update: current_hour < 7 or current_hour > 20;\n\t\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t\t\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\t\t\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n\taspect sphere3D{\n\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\taspect geom {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n\nspecies building {\n\tfloat height <- 10#m + rnd(10) #m;\n\tlist<people_in_building> people_inside -> {members collect people_in_building(each)};\n\t\n\taspect geom {\n\t\tint nbI <- members count people_in_building(each).is_infected;\n\t\tint nbT <- length(members);\n\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height;\n\t}\n\t\n\tspecies people_in_building parent: people schedules: [] {\n\t\taspect circle{}\n\t\taspect sphere3D{}\n\t}\n\t\n\tspecies people_in_2 parent: people schedules: [] {\n\t\taspect circle{}\n\t\taspect sphere3D{}\n\t}\n\t\n\treflex let_people_leave  {\n\t\task members as: people_in_building{\n\t\t\tstaying_counter <- staying_counter + 1;\n\t\t}\n\t\tlist<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\n\t\tif not (empty (leaving_people)) {\n\t\t\trelease leaving_people as: people in: world returns: released_people;\n\t\t\task released_people {\n\t\t\t\ttarget <- any_location_in (one_of(building));\n\t\t\t}\n\t\t}\n\t}\n\treflex let_people_enter {\n\t\tlist<people> entering_people <- people inside self where (each.target = nil);\n\t\tif not (empty (entering_people)) {\n\t\t\tcapture entering_people as: people_in_building ;\n \t\t}\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map_3D type: opengl {\n\t\t\tlight 1 color:(is_night ? 50 : 255);\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies people aspect:sphere3D;\t\t\t\n\t\t\tspecies building aspect:geom transparency: 0.5;\n\t\t}\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```","url":"wiki/IncrementalModel_step6.md"},"IncrementalModel_step7.md":{"title":" 7. Differential Equations","content":"# 7. Differential Equations\nThis step Illustrates how to use differential equations\n\n\n\n\n\n\n\n## Formulation\nWe are interested by the spreading of the disease inside the buildings. In order to model it, we will use differential equations. So, we will need to:\n\n  * add two global variables to define the building epidemic properties (**beta** and **h**).\n  * add new variables for the buildings (**I**, **S**, **T**, **t**, **I\\_to\\_1**);\n  * define differential equations for disease spreading inside buildings\n  * add a behavior for buildings for the spreading of the disease.\n\n![images/incremental_model.jpg](resources/images/tutorials/incremental_model.jpg)\n\n\n\n\n\n## Model Definition\n### global variables\nWe define two new global variables that will be used disease spreading dynamic inside the buildings.\n```\nglobal  {\n\t...\n\tfloat beta <- 0.01;\n\tfloat h<-0.1;\n        ...\n}\n```\n### building\nIn order to define the disease spreading dynamic, we define several variables that will be used by the differential equations:\n  * **I** : float, number of people infected in the building\n  * **S** : float, number of people not infected in the building\n  * **T** : float, total number of people in the building\n  * **t** : float, current time\n    * **I\\_to1** : float, remaining number of people infected (float number lower between 0 and 1 according to the differential equations).\n```\nspecies building {\n\t....\n\tfloat I;\n\tfloat S;\n\tfloat T;\n   \tfloat t;   \n   \tfloat I_to1; \n        ...\n}\n```\n\nThen, we define the differential equations that will use for the disease spreading dynamic. Note that to define a differential equation system we use the block **equation** + name. These equations are the classic ones used by SI mathematical models.\n```\nspecies building {\n\t....\n\tequation SI{ \n\t\tdiff(S,t) = (- beta * S * I / T) ;\n\t\tdiff(I,t) = (  beta * S * I / T) ;\n\t}\n       ...\n}\n```\n\nAt last, we define a new reflex for the building called **epidemic** that will be activated only when there is someone inside the building. This reflex first compute the number of people inside the building (**T**), then the number of not infected people (**S**) and finally the number of infected ones (**I**).\n\nIf there is at least one people infected and one people not infected, the differential equations is integrated (according to the discretisation step value **h**) with the method Runge-Kutta 4 to compute the new value of infected people. We then sum the old value of **I\\_to\\_1** with the number of people newly infected (this value is a float and not an integer). Finally, we cast this value as an integer, ask the corresponding number of not infected people to become infected, and decrement this integer value to **I\\_to1**.\n```\nspecies building {\n\t....\n\treflex epidemic when: not empty(members){ \t\n\t\tT <- float(length(members));\n\t\tlist<people_in_building> S_members <- list<people_in_building>(members where not (people_in_building(each).is_infected));\n    \t        S <- float(length(S_members));\n    \t        I <- T-S;\n    \t        float I0 <- I;\n    \t        if (I > 0 and S > 0) {\n    \t\t       solve SI method: \"rk4\" step: h;\n    \t\t       I_to1 <- I_to1 + (I - I0);\n    \t\t       int I_int <- min([int(S),int(I_to1)]);\n\t    \t       I_to1 <- I_to1 - I_int;\n\t    \t       ask(I_int among S_members){\n\t    \t\t     is_infected <- true;\n\t    \t      }\n               }\n    \t}\n       ...\n}\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel model7 \nglobal  {\n\tint nb_people <- 500;\n\tfloat step <- 1 #minutes;\n\tfloat infection_distance <- 2.0 #m;\n\tfloat proba_infection <- 0.05;\n\tint nb_infected_init <- 5;\n\tfile roads_shapefile <- file(\"../includes/road.shp\");\n\tfile buildings_shapefile <- file(\"../includes/building.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tgraph road_network;\n\tint current_hour update: (cycle / 60) mod 24;\n\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\n\tfloat beta <- 0.01;\n\tfloat h<-0.1;\n\tlist<people_in_building> list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));\n\t\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tbool is_night <- true update: current_hour < 7 or current_hour > 20;\n\t\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\tinit {\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tspeed <- 5.0 #km/#h;\n\t\t\tbuilding bd <- one_of(building);\n\t\t\tlocation <- any_location_in(bd);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t\t\n\t}\n\treflex end_simulation when: infected_rate = 1.0 {\t\t\n\t\tdo halt;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tbool is_infected <- false;\n\tpoint target;\n\tint staying_counter;\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- any_location_in (one_of(building));\n\t\t\ttarget <- nil;\n\t\t\tstaying_counter <- 0;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance infection_distance {\n\t\t\tif flip(proba_infection) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(5) color:is_infected ? #red : #green;\n\t}\n\taspect sphere3D{\n\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\tgeometry display_shape <- shape + 2.0;\n\taspect geom {\n\t\tdraw display_shape color: #black depth: 3.0;\n\t}\n}\n\nspecies building {\n\tfloat height <- 10#m + rnd(10) #m;\n\tlist<people_in_building> people_inside -> {members collect people_in_building(each)};\n\tfloat I;\n\tfloat S;\n\tfloat T;\n   \tfloat t;   \n   \tfloat I_to1; \n   \t\n\taspect geom {\n\t\tint nbI <- members count people_in_building(each).is_infected;\n\t\tint nbT <- length(members);\n\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height;\n\t}\n\t\n\tspecies people_in_building parent: people schedules: [] {\n\t}\n\t\n\treflex let_people_leave  {\n\t\task members as: people_in_building{\n\t\t\tstaying_counter <- staying_counter + 1;\n\t\t}\n\t\tlist<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\n\t\tif not (empty (leaving_people)) {\n\t\t\trelease leaving_people as: people in: world returns: released_people;\n\t\t\task released_people {\n\t\t\t\ttarget <- any_location_in (one_of(building));\n\t\t\t}\n\t\t}\n\t}\n\treflex let_people_enter {\n\t\tlist<people> entering_people <- people inside self where (each.target = nil);\n\t\tif not (empty (entering_people)) {\n\t\t\tcapture entering_people as: people_in_building ;\n \t\t}\n\t}\n\tequation SI{ \n\t\tdiff(S,t) = (- beta * S * I / T) ;\n\t\tdiff(I,t) = (  beta * S * I / T) ;\n\t}\n\n\treflex epidemic when: not empty(members){ \t\n\t\tT <- float(length(members));\n\t\tlist<people_in_building> S_members <- list<people_in_building>(members where not (people_in_building(each).is_infected));\n    \tS <- float(length(S_members));\n    \tI <- T-S;\n    \tfloat I0 <- I;\n    \tif (I > 0 and S > 0) {\n    \t\tsolve SI method: \"rk4\" step: h;\n    \t\tI_to1 <- I_to1 + (I - I0);\n    \t\tint I_int <- min([int(S),int(I_to1)]);\n\t    \tI_to1 <- I_to1 - I_int;\n\t    \task(I_int among S_members){\n\t    \t\tis_infected <- true;\n\t    \t}\n    \t}\n    }  \n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Infection distance\" var: infection_distance;\n\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\n\tparameter \"Nb people infected at init\" var: nb_infected_init ;\n\toutput {\n\t\tmonitor \"Current hour\" value: current_hour;\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\tdisplay map_3D type: opengl {\n\t\t\tlight 1 color:(is_night ? 50 : 255);\n\t\t\timage \"../includes/soil.jpg\";\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies people aspect:sphere3D;\t\t\t\n\t\t\tspecies building aspect:geom transparency: 0.5;\n\t\t}\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```","url":"wiki/IncrementalModel_step7.md"},"LuneraysFlu_step1.md":{"title":" 1. Creation of a first basic disease spreading model","content":"# 1. Creation of a first basic disease spreading model\nThis first step illustrates how to create simple agents and make them move in their environment.\n\n\n![images/luneray1.tiff](resources/images/tutorials/luneray1.tiff)\n\n\n\n\n## Formulation\n  * Set the time duration of a time step to 1 minutes\n  * Define the people species with a moving skill\n  * Define the move reflex that allow the people agent to move randomly and the infect reflex that allows them to infect other people agents.\n  * Define the aspect of the people species\n  * Add the people species to a display\n\n\n\n## Model Definition\n\n### Project and model\nThe first step of this tutorial consists in launching GAMA and choosing a workspace, then to define a new project or to import the existing one. For people that do not want to re-write all the models but just to follow the model construction, they can just download the model project here and the follow this [procedure](ImportingModels) to import it into GAMA. For the other, the project and model creation procedures are detailed [here](GamlEditorGeneralities). \n\nNote that the concepts of workspace and projects are explained [here](WorkspaceProjectsAndModels).\n\n\n### model structure\nA GAMA model is composed of three type of sections:\n  * **global** : this section, that is unique, defines the \"world\" agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).\n  * **species** and **grid**: these sections define the species of agents composing the model. Grid are defined in the following model step \"vegetation dynamic\";\n  * **experiment** : these sections define a context of execution of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model.\n\nMore details about the different sections of a GAMA model can be found [here](ModelOrganization).\n\n### species\nA [species](RegularSpecies) represents a «prototype» of agents: it defines their common properties.\n\nThree different elements can be defined in a species:\n  * the internal state of its agents (attributes)\n  * their behavior\n  * how they are displayed (aspects)\n\nIn our model, we define a people species:\n```\nspecies people {\n\t\t \n}\n```\n\nIn addition, we want add a new capability to our agent: the possibility to move randomly. for that, we add a specific skill to our people agents. A [skill](AttachingSkills) is a built-in module that provide the modeler a self-contain and relevant set of actions and variables. The [moving](__BuiltInSkills#moving) provides the agents with several attributes and actions related to movement. \n\n```\n   species people skills: [moving]{\n       ...\n   }\n```\n\n\n#### Internal state\nAn [attribute](RegularSpecies#declaration) is defined as follows: type of the attribute  and name. Numerous types of attributes are available: _int (integer), float (floating point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, espèce d’agents, rgb (color), graph, path..._\n  * Optional facets: <- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max\n\nIn addition to the attributes the modeler explicitly defines, species \"inherits\" other attributes called \"built-in\" variables:\n  * A name (_name_): the identifier of the species\n  * A shape (_shape_): the default shape of the agents to be construct after the species. It can be _a point, a polygon, etc._\n  * A location (_location_) : the centroid of its shape.\n\nIn our model, we define 2 new attribute to our people agents: \n  * **speed** of type float, with for initial value: a random value between 2 and 5 km/h\n  * **is_infected** of type bool, with for initial value: false\n\n```\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n}\n```\nNote we use the [rnd](Operators#rnd) operator to define a random value between 2 and 5 for the speed. In addition, we precise a unit for the speed value by using the # symbol. For more details about units, see [here](UnitsAndConstants).\n\n#### Behavior\nGAMA proposes several ways to define the behavior of a species: dynamic variables (update facet), reflexes....\n\nA [reflex](DefiningActionsAndBehaviors#behaviors) is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows:\n```\n   reflex reflex_name when: condition {...}\n```\n\nThe **when** facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.\n\nWe define a first reflex called **move** that is activated at each simulation step (no condition) and that makes the people move randomly using the wander action from the [moving](BuiltInSkills#moving) skill.\n```\nspecies people skills:[moving]{\t\t\n\t//variable definition\n\treflex move{\n\t\tdo wander;\n\t}\n}\n```\n\nWe define a second reflex called **infect** that is activated only when the agent is infected (is_infected = true) and that ask all the people at a distance of 10m to test a probability to be infected.\n```\nspecies people skills:[moving]{\t\t\n\t//variable definition and move reflex\n\t\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n}\n```\nThe [ask](Statements#ask) allows an agent to ask another agents to do something (i.e. to execute a sequence of statements). The [at_distance](Operators#at_distance) operator allows to get the list of agents (here of people agents) that are located at a distance lower or equal to the given distance (here 10m). The [flip](Operators#flip) operator allows to test a probability.\n\n#### Display\nAn agent [aspects](RegularSpecies#the-aspect-statement) have to be defined. An aspect is a way to display the agents of a species : aspect aspect\\_name {...}\nIn the block of an aspect, it is possible to draw :\n  * A geometry :  for instance, the shape of the agent (but it may be a different one, for instance a disk instead of a complex polygon)\n  * An image : to draw icons\n  * A text : to draw a text\n\nIn our model, we define an aspect for the people agent called **circle** that draw the agents as a circle of 10m radius with a color that depends on their **is_infected** attribute. If the people agent is infected, it will be draw in red, in green otherwise.\n\n```\nspecies people {\n\t...//variable and reflex definition\n\n\taspect circle {\n\t\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t\t}\n\t} \n}\n```\nThe **?** structure allows to return a different value (here red or green) according to a condition (here is_infected = true).\n\n### global section\nThe global section represents a specific agent, called [world](GlobalSpecies). Defining this agent follows the same principle as any agent and is, thus, defined after a species.\nThe world agent represents everything that is global to the model : dynamics, variables...\nIt allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary. The _step_ attribute of the world agent allows to specify the duration of one simulation step (by default, 1 step = 1 seconde).\n\n#### global variable\nIn the current model, we define 4 global attributes:\n   * nb_people: the number of people that we want to create (init value: 2147)\n   * nb_infected_init: the number of people infected at the initialization of the simulation (init value: 5)\n   * step: redefine in order to set the duration of a simulation step to 1 minute.\n   * shape: redefine in order to set the geometry of the world to a square of 1500 meters side size. \n```\nglobal {\n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #mn;\n\tgeometry shape<-square(1500 #m);\n}\n```\n\n#### Model initialization\n\nThe init section of the global block allows to initialize the define what will happen at the initialization of a simulation, for instance to create agents. We use the statement _create_  to create agents of a specific species: **create** species\\_name + :\n  * number : number of agents to create (int, 1 by default)\n  * from : GIS file to use to create the agents (optional, string or file)\n  * returns: list of created agents (list)\n\nFor our model, we define the init block in order to create _nb\\_people_ _people_ agents and ask _nb\\_infected\\_init_ of them to be infected:\n```\nglobal {\n\t// world variable definition\n\tinit{\n\t\tcreate people number:nb_people;\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n}\n```\n\n### experiment\nAn experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : **experiment** exp\\_name type: gui/batch {`[input]` `[output]`}\n  * gui : experiment with a graphical interface, which displays its input parameters and outputs.\n  * batch : Allows to setup a series of simulations (w/o graphical interface).\n\nIn our model, we define a gui experiment called _main\\_experiment_  :\n```\nexperiment main_experiment type: gui {\n}\n```\n\n#### input\nExperiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.\n\nA [parameter](DefiningParameters) is defined as follows:\n**parameter** title var: global\\_var category: cat;\n  * **title** : string to display\n  * **var** : reference to a global variable (defined in the global section)\n  * **category** : string used to «store» the operators on the UI - optional\n  * **<-** : init value - optional\n  * **min** : min value - optional\n  * **max** : min value - optional\n\nNote that the init, min and max values can be defined in the global variable definition.\n\nIn our model, we define one parameter:\n   * \"Nb people infected at init\" that will define the value of the global variable _nb\\_infected\\_init_ with a min value of 1 and a max value of 2147 (the number of people living in Luneray).\n\n```\nexperiment main_experiment type:gui{\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\t\n\toutput {\n\t}\n}\n```\n#### output\n[Output](DefiningGUIExperiment) blocks are defined in an experiment and define how to visualize a simulation (with one or more [display](DefiningDisplaysGeneralities) blocks that define separate windows). Each display can be refreshed independently by defining the facet **refresh\\_every:** nb (int) (the display will be refreshed every nb steps of the simulation).\n\nEach display can include different layers (like in a GIS) :\n  * Agents lists : **agents** layer\\_name value: agents\\_list aspect: my\\_aspect;\n  * Agents species : **species**  my\\_species aspect: my\\_aspect\n  * Images: **image** layer\\_name file: image\\_file;\n  * Texts : **texte** layer\\_name value: my\\_text;\n  * Charts : see later.\n\nNote that it is possible to define a [opengl display](G__3DSpecificInstructions) (for 3D display or just to optimize the display) by using the facet **type: opengl**.\n\nIn our model, we define an OpenGL display to draw the _people_ agents. \n```\noutput {\n\tdisplay map type: opengl{\n\t\tspecies people aspect:circle;\t\n\t}\n}\n```\n\n\n## Complete Model\n\n```\nmodel SI_city1\n\nglobal{ \n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #mn;\n\tgeometry shape<-square(1500 #m);\n\t\n\tinit{\n\t\tcreate people number:nb_people;\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\t\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\treflex move{\n\t\tdo wander;\n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\toutput {\n\t\tdisplay map type: opengl{\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t}\n}\n```\n[Next step: Definition of monitors and chart outputs](LuneraysFlu_step2)","url":"wiki/LuneraysFlu_step1.md"},"LuneraysFlu_step2.md":{"title":" 2. Definition of monitors and chart outputs","content":"# 2. Definition of monitors and chart outputs\nThis second step illustrates how to create monitors and charts to follows the evolution of variables and to add an ending condition to the simulation.\n\n\n![images/luneray2.tiff](resources/images/tutorials/luneray2.tiff)\n\n\n\n\n## Formulation\n  * Add three new global dynamic variables to follow the evolution of the number of infected people agents, of not infected people agents and of the rate of infected people.\n  * Define an ending condition for the simulation\n  * Define a monitor to follow the rate of infected people agents\n  * Define a chart to follow the rate of infected people agents\n\n\n\n## Model Definition\n\n\n### global section\n\n#### global variables\n\nGAMA offers the possibility to define dynamic variable that will be recomputed at each simulation step by using the _update_ facet when defining a variable. When an agent is activated, first, it recomputes each of its variables with a update facet (in their definition order), then it activates each of its reflexes (in their definition order).\n\nTo better follow the evolution of sick people, we add three new global variables to the model:\n  * nb_people_infected of type _int_ with _nb\\_infected\\_init_ as init value and updated at each simulation step by the number of infected people\n  * nb_people_not_infected of type _int_ with _(nb\\_people - nb\\_infected\\_init)_ as init value and updated at each simulation step by the number of not infected people\n  * infected_rate of type _float_ updated at each simulation step by the number of infected people divided by the number of people.\n\n```\nglobal{\n\t//... other attributes\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t//... init\n}\n```\n\nWe used the [count](Operators#count) operator that allows to count the number of elements of a list for which the left condition is true. The keyword _each_ represents each element of the list.\n\n#### ending condition\n\nThe simplest way to add an ending condition to a model is to add a global reflex that is activated at the end of the simulation that will pause the simulation (use of the _pause_ global action).\n\nIn our model, we add a new reflex called _end\\_simulation_ that will be activated when the infected rate is 1.0 (i.e. all the people agents are infected) and that will apply the _pause_ action. \n```\nglobal {\n\t//.. variable and init definition\n\t\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n} \n```\n### experiment\n\n#### monitor\nGAMA provides modelers with the possibility to define [monitors](DefiningMonitorsAndInspectors#monitors). A monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its 'refresh' facet). \n\nDefinition of a monitor:\n   * _value_: mandatory, the expression whose value will be displayed by the monitor.\n   * _refresh_: bool, optional : if the expression is true, compute (default is true).\n\nFor our model, we define a monitor to follow the value of the _infected\\_rate_ variable:\n```\nexperiment main_experiment type:gui{\n\t//...parameters\n\toutput {\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n               //...display\n\t}\n}\n```\n\n\n#### Chart\n\nIn GAMA, [charts](G__DefiningChartLayers) are considered as a display layer. \nGAMA can display 3 main types of charts using the _type_ facet:\n\n  * histogram\n  * pie\n  * series/xy/scatter: both display series with lines or dots, with 3 subtypes :\n    * series: to display the evolution of one/several variable (vs time or not).\n    * xy: to specify both x and y value. To allow stacked plots, only one y value for each x value.\n    * scatter: free x and y values for each serie.\n\nIn our model, we define a new display called _ chart\\_display_ that will be refresh every 10 simulation steps. In this display, we add a series charts with 2 layers of data:\n   * susceptible: the number of people that are not infected (in green)\n   * infected: the number of people that are infected (in red)\n```\nexperiment main_experiment type:gui{\n\t//...parameters\n\toutput {\n\t\t//...display and monitors\n\t\t\n\t\tdisplay chart_display refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n## Complete Model\n\n```\nmodel SI_city2\n\nglobal{ \n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #mn;\n\tgeometry shape<-square(1500 #m);\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t\n\t\n\tinit{\n\t\tcreate people number:nb_people;\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\t\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\treflex move{\n\t\tdo wander;\n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\toutput {\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n\t\tdisplay map type: opengl{\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\t\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n[Next step: Importation of GIS data](LuneraysFlu_step3)","url":"wiki/LuneraysFlu_step2.md"},"LuneraysFlu_step3.md":{"title":" 3. Importation of GIS data","content":"# 3. Importation of GIS data\nThis third step illustrates how load GIS data and to agentify them.\n\n![images/luneray3.tiff](resources/images/tutorials/luneray3.tiff)\n\n\n\n\n## Formulation\n  * Define 2 new species that will just be displayed: *road* and *building*.\n  * Add a new *my_building* attribute to the _people_ agents.\n  * Define new global attributes to load GIS data (shape file).\n  * Use the GIS data to create the _road_ and _building_ agents.\n  * Add the _road_ and _building_ agents to the display.\n\n## Model Definition\n\nFor this step, you will need to add the shapefiles of the roads and buildings inside the _includes_ folder of the project. The shapefiles (and all the other files) can be found [here](https://github.com/gama-platform/gama/wiki/images/Tutorials/Luneray's flu/Luneray's flu.zip). \n \n### species\nIn this model, we have to define two species of agents: the **road** agents and the **building** ones. These agents will not have a particular behavior, they will just be displayed.\nFor each of this species we define an aspect called _geom_. As we want to represent the geometry of the agent, we then use the keyword **draw** that allow to draw a given geometry. In order to draw the geometry of the agent we use the attribute **shape** (which is a built-in attribute of all agents). The road will be displayed in black and the building in gray.\n\n```\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\n```\n\nIn addition, we add an attribute to the people species called *my_builing* of type _building_. Note that agent species can be use as variable type.\n\n```\nspecies people skills:[moving]{\t\t\n\t//other attributes\n\tbuilding my_house; \n        //reflexes and aspect \n}\n```\n\n### global section\n\n#### global variables\n\nGAMA allows to automatically read GIS data that are formatted as shape files (or as OSM file). In our model, we define 2 shapefiles: one corresponding to the roads and the other ones to the buildings. Note that GAMA is able to manage the projection of the GIS data. \nIn order to set the right size (and position) of the world geometry, we define its value as the envelope of the road shapefile (and no more a square of 1500 meters).\n\n```\nglobal{\n\t//... other attributes\n\tfile roads_shapefile <- file(\"../includes/routes.shp\");\n\tfile buildings_shapefile <- file(\"../includes/batiments.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\t\n\t//... init\n}\n\n```\n\n### agentification of GIS data\n\nIn GAMA, the agentification of GIS data is very straightforward: it only requires to use the **create** command with the **from** facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the **with** facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the **read** command followed by the name of the shapefile attribute.\n\nIn our model, we modify the init section in order to first create the _road_ agents from the road shapefile, and the _building_ agents from the building shapefile. Then, when creating people agents, we choose for them one random building and a random location inside this building.\nNote that it is possible to execute a sequence of statements at the creation of agents by using a block ({...}) rather than a simple line (;) when using the _create_ statement. \n\n```\nglobal {\n\t// world variable definition\n\n\tinit{\n\t\tcreate road from: roads_shapefile;\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tmy_house <- one_of(building);\n\t\t\tlocation <- any_location_in(my_house);\t\t}\t\t\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n}\n```\n\nWe used here the [one_of](Operators#one_of) operator that returns a random element from a list and the [any_location_in](Operators#any_location_in) operator that returns a random location inside a geometry.\n\n### experiment\n\n\n#### Output\n\nIn the _map_ display, we add the _road_ and _building_ species with their _geom_ aspect just before the _people_ species (in order to draw the people agents on the top of the roads and buildings). \n```\nexperiment main_experiment type: gui {\n\t... //parameter definition\n\n\toutput {\n\t... //monitor definition\n\n\t\tdisplay map type: opengl{\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\t... //chart display definition\n\t}\n}\n```\n\n## Complete Model\n\n```\nmodel SI_city3 \n\nglobal{ \n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #mn;\n\tfile roads_shapefile <- file(\"../includes/roads.shp\");\n\tfile buildings_shapefile <- file(\"../includes/buildings.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tint current_hour update: (time /#h) mod 24;\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t\n\t\n\tinit{\n\t\tcreate road from: roads_shapefile;\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tmy_house <- one_of(building);\n\t\t\tlocation <- any_location_in(my_house);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\t\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\tbuilding my_house;\n\t\n\treflex move{\n\t\tdo wander;\n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\toutput {\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n\t\tdisplay map type: opengl {\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\t\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n[Next step: Use of a graph to constraint the movements of people](LuneraysFlu_step4)","url":"wiki/LuneraysFlu_step3.md"},"LuneraysFlu_step4.md":{"title":" 4. Use of a graph to constraint the movements of people]","content":"# 4. Use of a graph to constraint the movements of people]\nThis fourth step illustrates how to use a graph to constraint the movements of agents\n\n\n![images/luneray4.tiff](resources/images/tutorials/luneray4.tiff)\n\n\n\n\n## Formulation\n  * Define a new global variable: the road network (graph).\n  * Build the road network graph from the road agents\n  * Add new attribute to the people agents (target and in_my_house)\n  * Define a new reflex for people agents: stay.\n  * Modify the move reflex of the people agents.\n\n## Model Definition\n\n### global section\n\n#### global variables\n\nIn this model, we want that people agents move from buildings to buildings by using the shortest path in the road network. In order to compute this shortest path, we need to use a graph structure.\n\nWe thus define a new global variable called _road\\_network_ of type _graph_ that will represent the road network.\n\n```\nglobal{\n\t//... other attributes\n\tgraph road_network;\n\t\n\t//... init\n}\n```\n\nIn order to compute the graph from the road network, we use, just after having creating the road agents, the [as_edge_graph](Operators#as_edge_graph) operator. This operator automatically built a graph from a set of polylines. Each extremity point of the lines will become a node in the graph, and each polyline an edge. By default, the graph is not oriented and the weights of the edges are the perimeters of the polylines. It is of course possible to change through the use of some operators.  \n\n```\nglobal {\n\t// world variable definition\n\n\tinit{\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tmy_home <- one_of(building);\n\t\t\tlocation <- any_location_in(my_home);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\t\n\t}\n}\n```\n\n### people species\n\nWe want to modify the behavior of the people agents in order to make them move from buildings to buildings by using the shortest path in the road network. In addition, we want to integrate the fact that people will stay in the building a certain time before moving to another building. This staying time will depend if the agent is in its house or in another house (different probabilities of moving). \n\n### variables\nIn order to implement this behavior, we will add two variables to our people species:\n   * _target_ of type _point_ that will be the location where the agent wants to go\n   * _in\\_my\\_house_ of type _bool_ that will just say if the agent is in its house or not. At the beginning the agent will be in its house, so we initialize this variable by _true_.\n\n```\nspecies people skills:[moving]{\n\t//...the other attributes\n\tpoint target;\n\tbool in_my_house <- true;\n\t//....\n}\n```\n\n### behavior\n\nFirst, we add a new reflex called _stay_ that will be activated when the agent is in a house (i.e. its target is null) and that will define if the agent has to go or not. If the agent has to go, it will randomly choose a new target (a random location inside one of the building). We define two probabilities of moving: 0.01 if the agent is in its house, 0.1 otherwise (more chance to move if the agent is not in its house).\n```\nreflex stay when: target = nil {\n\tif flip(in_my_house ? 0.01 : 0.1) {\n\t\tbuilding bd_target <- in_my_house ? one_of(building) : my_house;\n\t\ttarget <- any_location_in (bd_target);\n\t\tin_my_house <- not in_my_house;\n\t}\n}\n```\n\nThen, we modify the _move_ reflex. This one will be only activated when the agent will have to move (target not null). Instead of using the _wander_ action of the _moving_ skill, we use the _goto_ one that allows to make an agent moves toward a given target. In addition, it is possible to add a facet _on_ to precise on which topology the agent will have to move on. In our case, the topology is the road network.\nWhen the agent reach its destination (location = target), it sets its target to null.\n\n```\nreflex move when: target != nil{\n\tdo goto target:target on: road_network;\n\tif (location = target) {\n\t\ttarget <- nil;\n\t} \n}\n```\n## Complete Model\n\n```\nmodel SI_city4 \n\nglobal{ \n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #mn;\n\tfile roads_shapefile <- file(\"../includes/roads.shp\");\n\tfile buildings_shapefile <- file(\"../includes/buildings.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t\n\tgraph road_network;\n\t\n\tinit{\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tmy_house <- one_of(building);\n\t\t\tlocation <- any_location_in(my_house);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\t\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\tbuilding my_house;\n\tpoint target;\n\tbool in_my_house <- true;\n\t\n\treflex stay when: target = nil {\n\t\tif flip(in_my_house ? 0.01 : 0.1) {\n\t\t\tbuilding bd_target <- in_my_house ? one_of(building) : my_house;\n\t\t\ttarget <- any_location_in (bd_target);\n\t\t\tin_my_house <- not in_my_house;\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n}\n\nspecies road {\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies building {\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\toutput {\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n\t\tdisplay map type: opengl{\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\t\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n[Next step: Definition of 3D displays](LuneraysFlu_step5)","url":"wiki/LuneraysFlu_step4.md"},"LuneraysFlu_step5.md":{"title":" 5. Definition of 3D displays","content":"# 5. Definition of 3D displays\nThis fifth step illustrates how to define 3D displays\n\n\n![images/Luneray_model.png](resources/images/tutorials/Luneray_model.png)\n\n\n\n\n## Formulation\n  * Define a new 3D aspect for roads.\n  * Define a new 3D aspect for buildings\n  * Define a new 3D aspect for people\n  * Define a new 3D display \n\n## Model Definition\n\n### species\n\nFirst, we add a new variable called _display\\_shape_ of type _geometry_ for road agent that is a tube of 2m radius built from its geometry. Note that it is possible to get the list of points composing a geometry by using the _points_ variable of the geometry. We define then an aspect called _geom3D_ that draws the previous geometry in black.\n\n![images/roads_display.tiff](resources/images/tutorials/roads_display.tiff)\n\n```\nspecies road {\n\tgeometry display_shape <- line(shape.points, 2.0);\n\t\n\t//....\n\taspect geom3D {\n\t\tdraw display_shape color: #black;\n\t}\n}\n```\n\nConcerning the building species, we add a new variable called _height_ of type _float_ that is initialized by a random value between 20 and 40 meters.\nWe define then an aspect called _geom3D_ that draws the shape of the building with a depth of height and with using a texture (\"texture.jpg\" that is located inside the includes folder).\n\n![images/buildings_display.tiff](resources/images/tutorials/buildings_display.tiff)\n\n```\nspecies building {\n\tfloat height <- 20#m + rnd(20) #m;\n\t//....\n\taspect geom3D {\n\t\tdraw shape depth: height texture:[\"../includes/texture.jpg\"];\n\t}\n}\n```\nAt last, we define a new aspect called _geom3D_ for the people species that draws first a pyramid of 5 meters size, then a sphere of radius 2 meters at a height of 5m (z = 5). Note that it is possible to access the coordinates of a point by using the _x_, _y_ and _z_ variables. In GAMA, a point can be defined by using the format _{x\\_value,y\\_value,z\\_value}_.\n\n![images/people_display.tiff](resources/images/tutorials/people_display.tiff)\n\n```\nspecies people skills:[moving]{\t\t\n\t//....\n\taspect geom3D{\n\t\tdraw pyramid(5) color: is_infected ? #red : #green;\n\t\tdraw sphere(2) at: {location.x,location.y,5} color: is_infected ? #red : #green;\t\n\t}\n}\n```\n\n### output\n\nWe define a new display called _map\\_3D_ of type _opengl_ with an _ambient\\_light_ of 120 that displays first a image (\"soil.jpg\"), then the road with the _geom3D_ aspect, then the building with the _geom3D_ aspect, and finally the people with the _geom3D_ aspect. All layers except the people's one will not be refreshed (refresh set to false).\n\n```\nexperiment main_experiment type: gui {\n\toutput {\n\t// monitor and other displays\t\n\t\tdisplay map_3D type: opengl ambient_light: 120 {\n\t\t\timage \"../includes/soil.jpg\" refresh: false;\n\t\t\tspecies road aspect:geom3D refresh: false;\n\t\t\tspecies building aspect:geom3D refresh: false;\n\t\t\tspecies people aspect:geom3D;\t\t\t\n\t\t}\n\t}\n}\n```\n## Complete Model\n\n```\nmodel SI_city5\n\nglobal{ \n\tint nb_people <- 2147;\n\tint nb_infected_init <- 5;\n\tfloat step <- 1 #mn;\n\tfile roads_shapefile <- file(\"../includes/roads.shp\");\n\tfile buildings_shapefile <- file(\"../includes/buildings.shp\");\n\tgeometry shape <- envelope(roads_shapefile);\n\tint nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n\tint nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n\tfloat infected_rate update: nb_people_infected/nb_people;\n\t\n\tgraph road_network;\n\t\n\tinit{\n\t\tcreate road from: roads_shapefile;\n\t\troad_network <- as_edge_graph(road);\n\t\tcreate building from: buildings_shapefile;\n\t\tcreate people number:nb_people {\n\t\t\tmy_house <- one_of(building);\n\t\t\tlocation <- any_location_in(my_house);\n\t\t}\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\t}\n\t\n\treflex end_simulation when: infected_rate = 1.0 {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills:[moving]{\t\t\n\tfloat speed <- (2 + rnd(3)) #km/#h;\n\tbool is_infected <- false;\n\tbuilding my_house;\n\tpoint target;\n\tbool in_my_house <- true;\n\t\n\treflex stay when: target = nil {\n\t\tif flip(in_my_house ? 0.01 : 0.1) {\n\t\t\tbuilding bd_target <- in_my_house ? one_of(building) : my_house;\n\t\t\ttarget <- any_location_in (bd_target);\n\t\t\tin_my_house <- not in_my_house;\n\t\t}\n\t}\n\t\t\n\treflex move when: target != nil{\n\t\tdo goto target:target on: road_network;\n\t\tif (location = target) {\n\t\t\ttarget <- nil;\n\t\t} \n\t}\n\treflex infect when: is_infected{\n\t\task people at_distance 10 #m {\n\t\t\tif flip(0.05) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\taspect circle{\n\t\tdraw circle(10) color:is_infected ? #red : #green;\n\t}\n\taspect geom3D{\n\t\tdraw pyramid(5) color: is_infected ? #red : #green;\n\t\tdraw sphere(2) at: {location.x,location.y,5} color: is_infected ? #red : #green;\t\n\t}\n\t\n}\n\nspecies road {\n\tgeometry display_shape <- line(shape.points, 2.0);\n\t\n\taspect geom {\n\t\tdraw shape color: #black;\n\t}\n\taspect geom3D {\n\t\tdraw display_shape color: #black;\n\t}\n}\n\nspecies building {\n\tfloat height <- 20#m + rnd(20) #m;\n\t\n\taspect geom {\n\t\tdraw shape color: #gray;\n\t}\n\taspect geom3D {\n\t\tdraw shape depth: height texture:[\"../includes/texture.jpg\"];\n\t}\n\t\n}\n\nexperiment main_experiment type:gui{\n\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\n\toutput {\n\t\tmonitor \"Infected people rate\" value: infected_rate;\n\t\t\n\t\tdisplay map type: opengl{\n\t\t\tspecies road aspect:geom;\n\t\t\tspecies building aspect:geom;\n\t\t\tspecies people aspect:circle;\t\t\t\n\t\t}\n\t\t\n\t\tdisplay map_3D type: opengl ambient_light: 120 {\n\t\t\timage \"../includes/soil.jpg\" refresh: false;\n\t\t\tspecies road aspect:geom3D refresh: false;\n\t\t\tspecies building aspect:geom3D refresh: false;\n\t\t\tspecies people aspect:geom3D;\t\t\t\n\t\t}\n\t\n\t\tdisplay chart refresh:every(10) {\n\t\t\tchart \"Disease spreading\" type: series {\n\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\n\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\n\t\t\t}\n\t\t}\n\t}\n}\n```","url":"wiki/LuneraysFlu_step5.md"},"PredatorPrey_step1.md":{"title":" 1. Basic Model","content":"# 1. Basic Model\nThis first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models.\n## Content\n\n\n\n\n\n\n\n## Formulation\n  * Definition of the **prey** species\n  * Definition of a **nb\\_prey\\_init** parameter\n  * Creation of **nb\\_prey\\_init** **prey** agents randomly located in the environment (size: 100x100)\n\n\n\n\n\n## Model Definition\n\n### model structure\nA GAMA model is composed of three type of sections:\n  * **global** : this section, that is unique, defines the \"world\" agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).\n  * **species** and **grid**: these sections define the species of agents composing the model. Grid are defined in the following model step \"vegetation dynamic\";\n  * **experiment** : these sections define a context of execution of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model.\n\nMore details about the different sections of a GAMA model can be found [here](ModelOrganization).\n\n### species\nA [species](RegularSpecies) represents a «prototype» of agents: it defines their common properties.\n\nA species definition requires the definition of three different elements :\n  * the internal state of its agents (attributes)\n  * their behavior\n  * how they are displayed (aspects)\n\n#### Internal state\nAn [attribute](RegularSpecies#declaration) is defined as follows: type of the attribute  and name. Numerous types of attributes are available: _int (integer), float (floating point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, espèce d’agents, rgb (color), graph, path..._\n  * Optional facets: <- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max\n\nIn addition to the attributes the modeler explicitly defines, species \"inherits\" other attributes called \"built-in\" variables:\n  * A name (_name_): the identifier of the species\n  * A shape (_shape_): the default shape of the agents to be construct after the species. It can be _a point, a polygon, etc._\n  * A location (_location_) : the centroid of its shape.\n\n#### Behavior\nIn this first model, we define one species of agents: the **prey** agents. For the moment, these agents will not have a particular behavior, they will just exist and be displayed.\n\n#### Display\nAn agent [aspects](RegularSpecies#the-aspect-statement) have to be defined. An aspect is a way to display the agents of a species : aspect aspect\\_name {...}\nIn the block of an aspect, it is possible to draw :\n  * A geometry :  for instance, the shape of the agent (but it may be a different one, for instance a disk instead of a complex polygon)\n  * An image : to draw icons\n  * A text : to draw a text\n\nIn order to display our prey agents we define two attributes:\n  * **size** of type float, with for initial value: 1.0\n  * **color** of type _rgb_, with for initial value: \"blue\". It is possible to get a color value by using the symbol _#_ + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink...\n\n#### Prey species code\nFor the moment, we only define an aspect for this species. We want to display for each prey agent a circle of radius _size_ and color _color_. We then use the keyword **draw** with a circle shape.\n\n```\nspecies prey {\n\tfloat size <- 1.0 ;\n\trgb color <- #blue;\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n} \n```\n\n\n### global section\nThe global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species.\nThe world agent represents everything that is global to the model : dynamics, variables...\nIt allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary (see the [Road traffic tutorial](RoadTrafficModel)).\n\n#### global variable\nIn the current model, we will only have a certain numbers of preys thus we need to hold this number in a global or world's variable of type integer (_int_) which can be done as follows:\n```\nglobal {\n   int nb_preys_init <- 200;\n}\n```\n\n#### Model initialization\n\nThe init section of the global block allows to initialize the model which is executing certain commands, here we will create _nb\\_preys\\_init_ number of prey agents. We use the statement _create_  to create agents of a specific species: **create** species\\_name + :\n  * number : number of agents to create (int, 1 by default)\n  * from : GIS file to use to create the agents (optional, string or file)\n  * returns: list of created agents (list)\n\nDefinition of the init block in order to create _nb\\_preys\\_init_ _prey_ agents:\n```\n   init {\n      create prey number: nb_preys_init ;\n   }\n```\n\n### experiment\nAn experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : **experiment** exp\\_name type: gui/batch {`[input]` `[output]`}\n  * gui : experiment with a graphical interface, which displays its input parameters and outputs.\n  * batch : Allows to setup a series of simulations (w/o graphical interface).\n\nIn our model, we define a gui experiment called _prey\\_predator_  :\n```\nexperiment prey_predator type: gui {\n}\n```\n\n#### input\nExperiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.\n\nA parameter is defined as follows:\n**parameter** title var: global\\_var category: cat;\n  * **title** : string to display\n  * **var** : reference to a global variable (defined in the global section)\n  * **category** : string used to «store» the operators on the UI - optional\n  * **<-** : init value - optional\n  * **min** : min value - optional\n  * **max** : min value - optional\n\nNote that the init, min and max values can be defined in the global variable definition.\n\nIn the experiment, definition of a parameter from the the global variable _nb\\_preys\\_init_ :\n```\nexperiment prey_predator type: gui {\n   parameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n}\n```\n\n#### output\nOutput blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet **refresh\\_every:** nb (int) (the display will be refreshed every nb steps of the simulation).\n\nEach display can include different layers (like in a GIS) :\n  * Agents lists : **agents** layer\\_name value: agents\\_list aspect: my\\_aspect;\n  * Agents species : **species**  my\\_species aspect: my\\_aspect\n  * Images: **image** layer\\_name file: image\\_file;\n  * Texts : **texte** layer\\_name value: my\\_text;\n  * Charts : see later.\n\nNote that it is possible to define a [opengl display](Defining3DDisplays) (for 3D display) by using the facet **type: opengl**.\n\nIn our model, we define a display to draw the _prey_ agents.\n```\n output {\n      display main_display {\n         species prey aspect: base ;\n      }\n   }\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tinit {\n\t\tcreate prey number: nb_preys_init ;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0 ;\n\trgb color <- #blue;\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n} \n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n\toutput {\n\t\tdisplay main_display {\n\t\t\tspecies prey aspect: base ;\n\t\t}\n\t}\n}\n```","url":"wiki/PredatorPrey_step1.md"},"PredatorPrey_step10.md":{"title":" 10. Charts","content":"# 10. Charts\nThis 10th step Illustrates how to define charts.\n\n\n\n\n\n\n\n## Formulation\n  * Adding a new display to visualize:\n    * One chart representing the evolution of the quantity of prey and predator agents over the time\n    * Two histograms representing the energy distribution of the prey and predator agents\n\n\n\n\n## Model Definition\n\n### output\n\nGAMA can display various chart types:\n  * Time series\n  * Pie charts\n  * Histograms\n\nA chart must be defined in a display : it behaves exactly like any other layer.\nDefinition of a chart :\n\n```\nchart chart_name type: chart_type  {\n     [data]\n}\n```\n\nThe data to draw are define inside the chart block as follow:\n\n```\n     data data_legend value: data_value\n```\n\nWe add a new display called **Population\\_information** that refreshes every 5 simulation steps.\nInside this display, we define 3 charts: one of type _series_ (i.e. time series chart), two of type _histogram_ :\n  * \"Species evolution\"; background : white; size : {1, 0.5}; position : {0, 0}\n    * data1: number\\_of\\_preys; color : blue\n    * data2: number\\_of\\_predator; color : red\n\n  * \"Prey Energy Distribution\"; background : lightGray; size : {0.5, 0.5}; position : {0, 0.5}\n    * data \"]0;0.25]\" : number of preys with (each.energy <= 0.25) ;\n    * data \"]0.25;0.5]\" number of preys with ((each.energy > 0.25) and (each.energy <= 0.5)) ;\n    * data \"]0.5;0.75]\" number of preys with ((each.energy > 0.5) and (each.energy <= 0.75)) ;\n    * data \"]0.75;1]\" number of preys with  (each.energy > 0.75) ;\n\n  * \"Predator Energy Distribution\"; background : lightGray; size : {0.5, 0.5}; position : {0.5, 0.5}\n    * data \"]0;0.25]\" : number of predators with (each.energy <= 0.25) ;\n    * data \"]0.25;0.5]\" number of predators with ((each.energy > 0.25) and (each.energy <= 0.5)) ;\n    * data \"]0.5;0.75]\" number of predators with ((each.energy > 0.5) and (each.energy <= 0.75)) ;\n    * data \"]0.75;1]\" number of predators with  (each.energy > 0.75) ;\n\nTo evaluate the value of the data of the two histogram, we use the operator **list count condition\" that returns the number of elements of**list**for which the condition is true.**\n\n```\ndisplay Population_information refresh:every(5) {\n\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\n\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\n\t}\n\tchart \"Prey Energy Distribution\" type: histogram background: rgb(\"white\") size: {0.5,0.5} position: {0, 0.5} {\n\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t}\n\tchart \"Predator Energy Distribution\" type: histogram background: rgb(\"white\") size: {0.5,0.5} position: {0.5, 0.5} {\n\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red ;\n\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;\n\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;\n\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t}\n}\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo halt ;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\tfile my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- choose_cell();\n\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- 1 + rnd(nb_max_offsprings -1);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmyCell <- myself.myCell ;\n\t\t\tlocation <- myCell.location ;\n\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t}\n\t\tenergy <- energy / nb_offsprings ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tdisplay Population_information refresh:every(5) {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red ;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```","url":"wiki/PredatorPrey_step10.md"},"PredatorPrey_step11.md":{"title":" 11. Writing Files","content":"# 11. Writing Files\nThis 11th step Illustrates how to save data in a text file.\n\n\n\n\n\n\n\n## Formulation\n  * At each simulation step, write in a text file:\n    * The time step\n    * The number of prey and predator agents\n    * The min and max energy of the prey and predator agents\n\n\n\n\n\n## Model Definition\n\n### global section\nGAMA provides several ways to write file.\n\nA first ways consist in using the statement **file** in the output section: at each simulation step, the expression given is written in the given file.\n```\n   file file_name type: file_type data: data_to_write;  \n```\n\nWith:\n  * file\\_name: string (by default the file in saved in the _/models/_ of your project directory)\n  * file\\_type: string\n\nThere are 2 possible types :\n  * ‘txt’ (text) : in that case, my\\_data is treated as a string, which is written directly in the file\n  * ‘csv’ : in that case, my\\_data is treated as a list of variables to write : [\"var1\", \"var2\", \"var3\"].\n\nA second way to write file consists in using the save statement:\n```\n   save my_data type: file_type to: file_name;  \n```\nWith:\n  * file\\_type : string\n  * file\\_name : string\n\nThere are 3 possible types :\n  * ‘shp’ (shapefile - GIS data) : in that case, my\\_data is treated as a list of agents : all their geometries are saved in the file (with some variables as attributes)\n  * ‘txt’ (text) : in that case, my\\_data is treated as a string, which is written directly in the file\n  * ‘csv’ : in that case, my\\_data is treated as a list of values : [val1, val2, val3].\n\nWe use this statement (in a global reflex called **save\\_result**) to write:\n  * The cycle step: use of the **cycle** keyword that returns the current simulation step.\n  * The number of prey and predator agents: use of nb\\_preys and nb\\_predators variables\n  * The min and max energy of the prey and predator agents: use of **list min\\_of expression** and **list max\\_of expression** keywords. In addition, we verify with the tertiary operator (condition ? val\\_if : val\\_else).\n```\nreflex save_result when: (nb_preys > 0) and (nb_predators > 0){\n\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\n\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\n\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \n\t   \t+ \"; nbPredators: \" + nb_predators           \n\t   \t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \n\t   \t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \n\t   \tto: \"results.txt\" type: \"text\" ;\n}\n```\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n\t\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){\n\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\n\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\n\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \n\t   \t\t+ \"; nbPredators: \" + nb_predators           \n\t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \n\t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \n\t   \t\tto: \"results.txt\" type: \"text\" ;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo halt ;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\tfile my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- choose_cell();\n\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- 1 + rnd(nb_max_offsprings -1);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmyCell <- myself.myCell ;\n\t\t\tlocation <- myCell.location ;\n\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t}\n\t\tenergy <- energy / nb_offsprings ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tdisplay Population_information refresh:every(5) {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red ;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```","url":"wiki/PredatorPrey_step11.md"},"PredatorPrey_step12.md":{"title":" 12. Image loading","content":"# 12. Image loading\nThis 12th step illustrates how to load an image file and to use it to initialize a grid.\n\n\n\n\n\n\n\n## Formulation\n  * Building of the initial environment (food and foodProd of the cells) from a image file\n\n\n\n\n\n## Model Definition\n### global variable\n\nWe add a new global variable: the image file:\n```\n\tfile map_init <- image_file(\"../images/predator_prey_raster_map.png\");\n```\n\nThe image file is here: ![images/predator_prey_raster_map.png](resources/images/tutorials/predator_prey_raster_map.png)\n\nYou have to copy it in your project folder: images/\n\n### model initialization\nIn order to have a more complex environment, we want to use this image as the initialization of the environment. The food level available in a vegetation\\_cell will be based on the green level of the corresponding pixel in the image. You will be able to use such process to represent existing real environment in your model.\nWe modify the global init of the model in order to cast the image file in a matrix. We use for that the **file as\\_matrix  {nb\\_cols, nb\\_lines}** operator that allows to convert a file (image, csv) to a matrix composed of **nb\\_cols** columns and **nb\\_lines** lines.\n\nConcerning the manipulation of matrix, it is possible to obtain the element [i,j] of a matrix by using **my\\_matrix [i,j]**.\n\nA  grid can be view as spatial matrix: each cell of a grid has two built-in variables **grid\\_x** and **grid\\_y** that represent the column and line indexes of the cell.\n\n```\n  init {\n      create prey number: nb_preys_init ;\n      create predator number: nb_predators_init ;\n      matrix init_data <- map_init as_matrix {50,50};\n      ask vegetation_cell {\n         color <- rgb (init_data[grid_x,grid_y]) ;\n         food <- 1 - ((color as list)[0] / 255) ;\n         foodProd <- food / 100 ;\n      }\n   }\n```\n\n\n## Conclusion\nCongratulations, you have complete your first GAMA models! Now, you know have enough knowledge to create many models that includes: dynamic grid-based environment, moving and interacting agents and the needed viusalization to make good use of your simulation. Feel free to use this knowledge to create your very own models! Or perhaps you want to continue your study with the more advanced [tutorials](Tutorials)?\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\tfile map_init <- image_file(\"../images/predator_prey_raster_map.png\");\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t\task vegetation_cell {\n\t\t\tcolor <- rgb (map_init at {grid_x,grid_y}) ;\n\t\t\tfood <- 1 - (((color as list)[0]) / 255) ;\n\t\t\tfoodProd <- food / 100 ; \n\t\t}\n\t}\n\t\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){\n\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\n\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\n\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \n\t   \t\t+ \"; nbPredators: \" + nb_predators           \n\t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \n\t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \n\t   \t\tto: \"results.txt\" type: \"text\" ;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo halt ;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\tfile my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- choose_cell();\n\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- 1 + rnd(nb_max_offsprings -1);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmyCell <- myself.myCell ;\n\t\t\tlocation <- myCell.location ;\n\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t}\n\t\tenergy <- energy / nb_offsprings ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tdisplay Population_information refresh:every(5) {\n\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\n\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\n\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\n\t\t\t}\n\t\t\tchart \"Prey Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\n\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\n\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\n\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;\n\t\t\t}\n\t\t\tchart \"Predator Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0.5, 0.5} {\n\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red ;\n\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;\n\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;\n\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;\n\t\t\t}\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```","url":"wiki/PredatorPrey_step12.md"},"PredatorPrey_step2.md":{"title":" 2. Vegetation Dynamic","content":"`[IN PROGRESS]`\n# 2. Vegetation Dynamic\nThis second steps present the idea of environment or topological space. Defining a \"vegetation\" environment allows to define the movement of the preys through dynamic variables (use of the _update_ facet). We will also discover more about displays.\n\n\n\n\n\n\n\n\n## Formulation\n  * Definition of a grid (for the vegetation)\n  * Definition of a dynamic for each cell (food production)\n  * Display of the cell color according to the quantity of food\n  * Localization of the prey agents on the cells (at its center)\n\n\n\n\n\n## Model Definition\n\n### grid\n\nIn GAMA, grids are specific agent species with a particular topology. First, a grid allow yet constrains the movement of other (moving) agents but they can have variables and behaviors.\n\nA grid is defined as follows:\n```\n   grid grid_name width: nb_cols height: nb_lines neighbors: 4/6/8 {\n      ...\n   }\n```\n\nWith:\n  * width : number of cells along x-axis\n  * height : number of cells along y-axis\n  * neighbours : neighborhood type (4 - Von Neumann, 6 - hexagon or 8 - Moore)\n\nIn our model, we define a grid species, called **vegetation\\_cell** composed of 50x50 cells and with a Von Neumann neighborhood.\nIn order for each grid agents (or cell of the grid) to represent the vegetation, we provide them with four variables:\n  * _maxFood_ : maximum food that a cell can contain -> type: _float_ ; init value: 1.0\n  * _foodProd_ : food produced at each simulation step -> type: _float_ ; init value: random number between 0 and 0.01\n  * _food_ : current quantity of food -> type: _float_ ; init value: random number between 0 and 1.0; at each simulation step : food <- food + foodProd\n  * _color_ : color of the cell -> type: _rgb_ ; init value: color computed according to the food value: more the food value is close to 1.0, greener the color is, more the food value is close to 0,  whiter the color is; update : computation of the new color depending on the current level of food (at each simulation step).\n\nThe **update** facet allows to give a behavior to the agents. Indeed, at each simulation step, each agent is activated (by default, in a random order) and first applies for each dynamic variable (in their definition order) its update expression. In the present case, it allows us to link the displayed color of the cell to its food level.\n```\n   grid vegetation_cell width: 50 height: 50 neighbours: 4 {\n      float maxFood <- 1.0 ;\n      float foodProd <- (rnd(1000) / 1000) * 0.01 ;\n      float food <- (rnd(1000) / 1000) update: food + foodProd max: maxFood;\n      rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) ;\n   }\n```\n\nThere are several ways to define colors in GAML:\n  * the simplest way consists in using the symbol _#_ + the color name (for a limited set of  [colors](Index#Constants_and_colors)):\n```\n   #blue\n   #red\n```\n  * Another way consists in defining the 3 rgb integer values: rgb(red, green, blue) with red, green and blue between 0 and 255 (as we used in the current model.\n```\n   rgb(0,0,0) : black ; rgb(255,255,255) : white\n   rgb(255,0,0) : red ;  rgb(0,255,0) : green ;  rgb(0,0,255) : blue\n```\n\n\n### prey agents\nIn order to relate our prey agents to the vegetation cell grid, we add them with one new variable : **my\\_cell** of type vegetation\\_cell and for init value one of the vegetation\\_cell (chosen randomly).\n\n```\n   species prey {\n      ...\n      vegetation_cell myCell <- one_of (vegetation_cell) ;\n   } \n```\n\nIt is possible to obtain the list of all agents of a given species by using the name of the species while **one\\_of** to pick one element randomly from this list.\n\nWe linked each prey agent to a vegetation\\_cell but we need to locate them onto the cell. To do so, we set the prey location as equals to the location of the vegetation cell (i.e. its centroid **location**), we use in the init block the **<-** statement that allows to modify the value of a variable :\n```\nspecies prey {\n     ...\n     init {\n         location <- myCell.location;\n     }\n}\n```\n\n### display\nIn order to visualize the vegetation , we need to add it to the display. We use for that the statement **grid** with the optional facet **lines** to draw the border of the cells. Note that grid agents have built-in aspect thus it is not necessary to define one.\n```\n   output {\n      display main_display {\n         grid vegetation_cell lines: #black;\n         species prey aspect: base ;\n      }\n   }\n```\n\nNote that the layers in a display work like layers in a GIS; the drawing order will be respected. In our model, the prey agents will be drawn above the vegetation\\_cell grid thus they need to be declared afterward.\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tinit {\n\t\tcreate prey number: nb_preys_init ;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0 ;\n\trgb color <- #blue;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\t\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t}\n\t}\n}\n```","url":"wiki/PredatorPrey_step2.md"},"PredatorPrey_step3.md":{"title":" 3. Prey Agent Behavior","content":"# 3. Prey Agent Behavior\nThis third step Illustrates how to define the behaviors of prey agents and the concept of spatial topology.\n\n\n\n\n\n\n## Formulation\n  * Random movement of the prey agents to a distance of 2 cells (Von Neumann neighborhood)\n  * At each step, the prey agents loss energy\n  * At each step, the prey agents eat food if there is food on the cell on which they are localized (with a max of max\\_transfer) and gain energy\n  * If a prey agent has no more energy, it dies\n\n\n\n\n\n## Model Definition\n\n### parameters\nTo define a behavior for the prey agents we add them three new parameters:\n  * The max energy of the prey agents\n  * The maximum energy that can a prey agent consume from vegetation per tick\n  * The energy used by a prey agent at each time step\n\nAs we consider these parameters to be global to all prey, we define them in the  global section as follows:\n\n```\n   float prey_max_energy <- 1.0;\n   float prey_max_transfer <- 0.1;\n   float prey_energy_consum <- 0.05;\n   \n```\n\nYet we may allow the user to change it from an experiment to another through the user interface. To do so we add the following definition of parameters within the experiment section :\n```\n   parameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n   parameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\" ;\n   parameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n```\n\n### vegetation\\_cell grid\nWe add a new variable for the vegetation\\_cell grid called **neighbours**, that contains for each vegetation cell the list of the neighbor vegetation cells (distance of 2 - Von Neumann neighborhood). We will use these neighbors list for the movement of the prey.\n\n```\n  grid vegetation_cell width: 50 height: 50 neighbours: 4 {\n      ...\n      list<vegetation_cell> neighbours <- self neighbours_at 2;\n   }\n```\n\nNote that the result of the operator **neighbours\\_at dist** depends on the type of topology of the agent applying this operator:\n  * For a grid topology (grid species), the operator returns the neighbor cells (with a Von Neumann or Moore neighborhood).\n  * For a continuous topology, the operator returns the list of agents of which the shape is located at a distance equals or inferior _dist_ meters to the agent shape.\n\nAlso note the use of the [self](PseudoVariables#self) pseudo variable which is a reference to the agent currently executing the statement\n\n## Prey agents\n\nWe copy the values of the three global parameters into the prey species in order for it to be available for each agent and possibly modified locally.\n```\nspecies prey {\n   ...\n   float max_energy <- prey_max_energy ;\n   float max_transfer <- prey_max_transfer ;\n   float energy_consum <- prey_energy_consum ;\n   ...\n}\t\t\n```\n\nThe energy used by each prey at each timestep is randomly computed initially (within ]0;max\\_energy]).\n```\nspecies prey {\n   ...\n   float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n   ...\n}    \n```\n\nIn order to define the movement behaviour of a prey we will add a **reflex**. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows:\n```\n   reflex reflex_name when: condition {...}\n```\n\nThe **when** facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.\n\nWe define a first reflex called **basic\\_move** that allows the prey agents to choose (randomly) a new vegetation\\_cell in the neighborhood of my\\_cell and to move to this cell.\n```\nspecies prey {\n   ...\n   reflex basic_move { \n       myCell <- one_of (myCell.neighbours) ;\n       location <- myCell.location ;\n   }\n}\n```\n\nWe define a second reflex called **eat** that will only be activated when there is food in my\\_cell and that will allows the prey agents to eat food and gain energy. In order to store the energy gain by the eating (that is equals to the minimum between the **max\\_transfer** value and the quantity of food available in **myCell**), we define a local variable called **energy\\_transfer**.  A local variable is a variable that will only exist within this block: once it has been executed, the variable is forgotten. To define it, we have to use the following statement:\n```\nvar_type var_name <- value; \n```\n\nThus, the reflex **eat** is defined by:\n```\nspecies prey {\n   ...\n   reflex eat when: myCell.food > 0 { \n      float energy_transfer <- min([max_transfer, myCell.food]) ;\n      myCell.food <- myCell.food - energy_transfer ;\n      energy <- energy + energy_transfer ;\n   }\n}\n```\n\nWe define a third reflex for the prey agent: when the agent has no more energy, it dies (application of the built-in **die** action):\n```\nspecies prey {\n   ...\n   reflex die when: energy <= 0 {\n      do die ;\n   }\n}\n```\n\nNote that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the **die** action defined for all the agents.\n  * An action can accept arguments. For instance, write takes an argument called message.\n  * An action can return a result.\n\nThere are two ways to call an action: using a statement or as part of an expression\n  * for actions that do not return a result:\n```\ndo action_name arg1: v1 arg2: v2;\n```\n\n  * for actions that return a result:\n```\nmy_var <- self action_name (arg1:v1, arg2:v2);\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ;\n\t}\n}\n\nspecies prey {\n\tfloat size <- 1.0 ;\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfer <- prey_max_transfer ;\n\tfloat energy_consum <- prey_energy_consum ;\n\t\t\n\tvegetation_cell myCell <- one_of (vegetation_cell) ; \n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\t\n\tinit { \n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move { \n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\treflex eat when: myCell.food > 0 { \n\t\tfloat energy_transfer <- min([max_transfer, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfer ;\n\t\tenergy <- energy + energy_transfer ;\n\t}\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t}\n\t}\n}\n```","url":"wiki/PredatorPrey_step3.md"},"PredatorPrey_step4.md":{"title":" 4. Inspectors and Monitors","content":"# 4. Inspectors and Monitors\nThis fourth step Illustrates how to monitor more precisely the simulation. Practically, we will define monitors to follow the evolution of specific variables (or expression) whereas inspector allows to follow the state of a given agent (or a species).\n\n\n\n\n\n\n## Formulation\n  * Adding of a monitor to follow the evolution of the number of prey agents\n\n\n\n\n\n## Model Definition\n\n### global variable\nWe add a new global variable:\n  * **nb\\_preys** : returns, each time it is called, the current number of (live) prey agents\n\nTo do so we use the **->{expression}** facet which returns the value of **expression**, each time it is called..\nWe use as well the operator **length** that returns the number of elements in a list.\n\nThus, In the global section, we add the **nb\\_preys** global variable:\n```\n   int nb_preys -> {length (prey)};\n```\n\n### monitor\nA monitor allows to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows:\n```\n      monitor monitor_name value: an_expression refresh:every(nb_steps);\n```\n\nWith:\n  * value: mandatory, its that value will be displayed in the monitor.\n  * refresh: bool, optional : if the expression is true, compute (default is true).\n\nIn this model, we define a monitor to follow the value of the variable **nb\\_preys**:\n```\n      monitor \"number of preys\" value: nb_preys;\n```\n\n### inspector\n\nInspectors allow to obtain informations about a species or an agent. There are two kinds of agent information features:\n  * Species browser: provides informations about all the agents of a species. Available in the Agents menu.\n\n![images/browser_table.png](resources/images/tutorials/browser_table.png)\n\n  * Agent inspector: provides information about one specific agent. Also allows to change the values of its variables during the simulation. Available from the Agents menu, by right\\_clicking on a display, in the species inspector or when inspecting another agent. It provides also the possibility to «highlight» the inspected agent.\n\n![images/inspector.png](resources/images/tutorials/inspector.png)\n\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200 ;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1;\n\tfloat prey_energy_consum <- 0.05;\n\tint nb_preys -> {length (prey)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ;\n\t}\n}\nspecies prey {\n\tfloat size <- 1.0 ;\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\t\t\n\tvegetation_cell myCell <- one_of (vegetation_cell) ; \n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\t\n\tinit { \n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move { \n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\treflex eat when: myCell.food > 0 { \n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2);\n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys ;\n\t}\n}\n```","url":"wiki/PredatorPrey_step4.md"},"PredatorPrey_step5.md":{"title":" 5. Predator Agent","content":"# 5. Predator Agent\nThis fifth step Illustrates how to use parent species. Indeed,prey and predators share a few common features thus we will define a generic species that will regroup all the common elements (variables, behaviors and aspects) between the prey and the predator species.\n\n\n\n\n\n\n\n## Formulation\n  * Definition of a new generic species: generic\\_species\n  * Definition of a new species: predator\n  * predator agents move randomly\n  * At each simulation step, a predator agent can eat a prey that is localized at its grid cell\n\n\n\n\n## Model Definition\n\n### parameters\n\nWe add four new parameters related to predator agents:\n  * The init number of predator agents\n  * The max energy of the predator agents\n  * The energy gained by a predator agent while eating a prey agent\n  * The energy consumed by a predator agent at each time step\n\nWe define four new global variables in the global section:\n```\nglobal {\n   ...\n   int nb_predators_init <- 20;\n   float predator_max_energy <- 1.0;\n   float predator_energy_transfer <- 0.5;\n   float predator_energy_consum <- 0.02;\n}\n```\n\nWe define then the four corresponding parameters in the experiment:\n```\n   parameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\" ;\n   parameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n   parameter \"Predator energy transfer: \" var: predator_energy_transfer  category: \"Predator\" ;\n   parameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n```\n\n### parent species\n\nA species can have a parent species: it automatically get all the variables, skill and actions/reflex of the parent species\n\nWe define a species called **generic\\_species** that is the parent of the species **prey** and **predator**:\n\n![images/parent_species.png](resources/images/tutorials/parent_species.png)\n\nThis species integrates all of the common feature between the **prey** and **predotor** species:\n  * the variables:\n    * size\n    * color\n    * max\\_energy\n    * max\\_transfer\n    * energy\\_consum\n    * myCell\n    * energy\n\n  * the behaviors:\n    * basic\\_move reflex\n    * die reflex\n\n  * the aspect:\n    * base aspect\n\n```\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n```\n\n### prey species\nWe specialize the **prey** species from the **generic\\_species** species:\n  * definition of the initial value of the agent variables\n  * definition of the eat reflex\n\n```\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfer <- prey_max_transfer ;\n\tfloat energy_consum <- prey_energy_consum ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfer <- min([max_transfer, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfer ;\n\t\tenergy <- energy + energy_transfer ;\n\t}\n}\n```\n\n### predator species\nAs done for the **prey** species, we specialize the **predator** species from the **generic\\_species** species:\n  * definition of the initial value of the agent variables\n  * definition of a new variable **reachable\\_preys** consisting in the list of prey agents contains in myCell; compute at each simulation step (when the agent is activated).\n  * definition of the eat reflex: activated when **reachable\\_preys** is not empty; choose one of the element of this list, ask it to die; and update the **predator** energy.\n\n```\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfer <- predator_energy_transfer ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\t\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfer ;\n\t}\n}\n```\n\nNote that we used the **ask** statement. This statement allows to make a remote agent executes a list of statements.\nUse of the ask statement as follows:\n```\nask one_agent or ask agents_list\n```\n\nWe used as well the **species/agent list inside geometry/agent** operator. This operator returns all the agents of the specified species (or from the specified agent list) that are inside the given geometry or agent geometry.\n\n### global init block\nLike in the previous model, in the init block of the model, we create nb\\_predators\\_init.\n\n```\nglobal {\n   ...\n   init {\n      create prey number: nb_preys_init ;\n      create predator number: nb_predators_init ;\n   }\n}\n```\n\n### monitor\nLike in the previous model, we define a monitor to display the number of predator agents.\n\nDefinition of a global variable **nb\\_predator** that returns the current number of **predator** agents:\n```\nglobal {\n   ...\n   int nb_predators -> {length (predator)};\n   ...\n}\n```\n\nDefinition of the corresponding monitor:\n```\nmonitor \"number of predators\" value: nb_predators ;\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfer <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfer <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfer;\n\tfloat energy_consum;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfer <- prey_max_transfer ;\n\tfloat energy_consum <- prey_energy_consum ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfer <- min([max_transfer, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfer ;\n\t\tenergy <- energy + energy_transfer ;\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfer <- predator_energy_transfer ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\t\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfer ;\n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food)));\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfer: \" var: predator_energy_transfer  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t\tspecies predator aspect: base ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```","url":"wiki/PredatorPrey_step5.md"},"PredatorPrey_step6.md":{"title":" 6. Breeding","content":"# 6. Breeding\nSo far we created agents only during the initialisation of the simulation. In this sixth step we Illustrate how to create new agents during a simulation of a dynamic species.\n\n\n\n\n\n\n\n## Formulation\n  * Adding of a reproduce action of the prey and predator agents:\n    * When a agent has energy enough, it has a certain probability to have a certain number of offspring\n    * The energy of the offspring is equal to the parent energy divided by the number of offspring\n    * The parent get the same energy as its offspring\n\n\n\n\n## Model Definition\n\n### parameters\n\nWe add six new parameters related to breeding:\n  * The reproduction probability for prey agents\n  * The max number of offspring for prey agents\n  * The minimum energy to reproduce for prey agents\n  * The reproduction probability for predator agents\n  * The max number of offspring for predator agents\n  * The minimum energy to reproduce for predator agents\n\nWe define six new global variables in the global section:\n```\nglobal {\n   ...\n   float prey_proba_reproduce <- 0.01;\n   int prey_nb_max_offsprings <- 5; \n   float prey_energy_reproduce <- 0.5; \n   float predator_proba_reproduce <- 0.01;\n   int predator_nb_max_offsprings <- 3;\n   float predator_energy_reproduce <- 0.5;\n}\n```\n\nWe define then the six corresponding parameters in the experiment:\n```\n   parameter \"Prey probability reproduce: \" var: prey_proba_reproduce category: \"Prey\" ;\n   parameter \"Prey nb max offsprings: \" var: prey_nb_max_offsprings category: \"Prey\" ;\n   parameter \"Prey energy reproduce: \" var: prey_energy_reproduce category: \"Prey\" ;\n   parameter \"Predator probability reproduce: \" var: predator_proba_reproduce category: \"Predator\" ;\n   parameter \"Predator nb max offsprings: \" var: predator_nb_max_offsprings category: \"Predator\" ;\n   parameter \"Predator energy reproduce: \" var: predator_energy_reproduce category: \"Predator\" ;\n```\n\n### parent species\nWe add three new variables for the **generic\\_species**:\n  * proba\\_reproduce\n  * nb\\_max\\_offsprings\n  * energy\\_reproduce\n\nWe add as well a new reflex called **reproduce**:\n  * this reflex is activated only when:\n    * the energy of the agent is greater or equals to energy\\_reproduce\n    * AND according to the probability proba\\_reproduce: for this second condition, we use the **flip(proba)** operator that returns _true_ according to the probability proba (_false_ otherwise).\n\n\n  * this reflex creates **nb\\_offsprings** (random number between 1 and nb\\_max\\_offsprings) new agent of species the species of the agent using the create statement: we use a species casting operator on the current agent.\n    * the created agents are initialized as follows:\n      * myCell: myCell of the agent creating the agents\n      * location: location of myCell\n      * energy: energy of the agent creating the agents (use of keyword **[myself](PseudoVariables#myself)**) divided by the number of offsprings.\n\n  * after the agent creation, the reflex updates the energy value of the current agent with the value: energy / nb\\_offsprings\n\n```\n   species generic_species {\n      ...\n      float proba_reproduce ;\n      int nb_max_offsprings;\n      float energy_reproduce;\n      ... \n      reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n         int nb_offsprings <- 1 + rnd(nb_max_offsprings -1);\n         create species(self) number: nb_offsprings {\n            myCell <- myself.myCell ;\n            location <- myCell.location ;\n            energy <- myself.energy / nb_offsprings ;\n         }\n         energy <- energy / nb_offsprings ;\n      }\n   }\n```\n\nNote that two keywords can be used to make explicit references to some agents :\n  * The agent that is currently executing the statements inside the block (for example a newly created agent): **self**\n  * The agent that is executing the statement that contains this block (for instance, the agent that has called the create statement): **myself**\n\n### prey species\nWe specialize the **prey** species from the **generic\\_species** species:\n  * definition of the initial value of the agent variables\n\n```\n   species prey parent: generic_species {\n      ...\n      float proba_reproduce <- prey_proba_reproduce ;\n      int nb_max_offsprings <- prey_nb_max_offsprings ;\n      float energy_reproduce <- prey_energy_reproduce ;\n      ...\n   }\n```\n\n### predator species\nAs done for the **prey** species, we specialize the **predator** species from the **generic\\_species** species:\n  * definition of the initial value of the agent variables\n\n```\n   species predator parent: generic_species {\n      ...\n      float proba_reproduce <- predator_proba_reproduce ;\n      int nb_max_offsprings <- predator_nb_max_offsprings ;\n      float energy_reproduce <- predator_energy_reproduce ;\n      ...\n   }\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tint nb_max_offsprings;\n\tfloat energy_reproduce;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- 1 + rnd(nb_max_offsprings -1);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmyCell <- myself.myCell ;\n\t\t\tlocation <- myCell.location ;\n\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t}\n\t\tenergy <- energy / nb_offsprings ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\t\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food)));\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: base ;\n\t\t\tspecies predator aspect: base ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```","url":"wiki/PredatorPrey_step6.md"},"PredatorPrey_step7.md":{"title":" 7. Agent Aspect","content":"# 7. Agent Aspect\nIn this seventh step we will focus on the display and more specifically the aspects of the agents: how they are represented. It can be a simple shape (circle, square, etc.), an icon, a polygon (see later GIS support).\n\n\n\n\n\n\n\n## Formulation\n  * Definition of two new aspects for the prey and predator agents:\n    * A icon\n    * A square with information about the agent energy\n\n  * Use of the **icon** aspect as default aspect for the prey and predator agents.\n\n\n\n\n\n## Model Definition\n\n### parent species\n\nWe add a new variable of type _file_ called **my\\_icon** to the **generic\\_species**.\nWe define as well two new aspects:\n  * **icon** : draw the image given by the variable **icon**\n  * **info** : draw a square of side size **size** and color **color**; draw as a text the energy of the agent (with a precision of 2)\n\n```\n   species generic_species {\n      ...\n      file my_icon;\n      ...\n      aspect base {\n         draw circle(size) color: color ;\n      }\n      aspect icon {\n         draw my_icon size: 2 * size ;\n      }\n      aspect info {\n         draw square(size) color: color ;\n         draw string(energy with_precision 2) size: 3 color: #black ;\n      }\n   }\n```\n\n### prey species\nWe specialize the **prey** species from the **generic\\_species** species:\n  * definition of the initial value of the agent variables\n```\n   species prey parent: generic_species {\n      ...  \n      file my_icon <- file(\"../images/predator_prey_sheep.png\") ;\n      ...\n   }\n```\n\nThe image file is here: ![images/predator_prey_sheep.png](resources/images/tutorials/predator_prey_sheep.png)\n\nYou have to copy it in your project folder: images/\n\n### predator species\nAs done for the **prey** species, we specialize the **predator** species from the **generic\\_species** species:\n  * definition of the initial value of the agent variables\n\n```\n   species predator parent: generic_species {\n      ...\n      file my_icon <- file(\"../images/predator_prey_wolf.png\") ;\n      ...\n   }\n```\n\nThe image file is here: ![images/predator_prey_wolf.png](resources/images/tutorials/predator_prey_wolf.png)\n\nYou have to copy it in your project folder: images\n\n### display\nWe change the default aspect of the prey and predator agents to **icon** aspect.\n```\n   output {\n      display main_display {\n         grid vegetation_cell lines: #black ;\n         species prey aspect: icon ;\n         species predator aspect: icon ;\n      }\n   }\n```\n\nWe define a new display called info\\_display that displays the prey and predator agents with the **info** aspect.\n```\n   output {\n      display info_display {\n         species prey aspect: info;\n         species predator aspect: info;\n      }\n   }\n```\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\tfile my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- one_of (myCell.neighbours) ;\n\t\tlocation <- myCell.location ;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- 1 + rnd(nb_max_offsprings -1);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmyCell <- myself.myCell ;\n\t\t\tlocation <- myCell.location ;\n\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t}\n\t\tenergy <- energy / nb_offsprings ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n        file my_icon <- file(\"../images/predator_prey_wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```","url":"wiki/PredatorPrey_step7.md"},"PredatorPrey_step8.md":{"title":" 8. Complex Behavior","content":"# 8. Complex Behavior\nThis eighth step Illustrates how to define and call actions and how to use conditional statements.\n\n\n\n\n\n\n\n## Formulation\n  * Definition of more complex behaviors for prey and predator agents:\n    * The preys agents are moving to the cell containing the highest quantity of food\n    * The predator agents are moving if possible to a cell that contains preys; otherwise random cell\n\n\n\n\n\n## Model Definition\n\n### parent species\nWe modify the **basic\\_move** reflex of the **generic\\_species** in order to give the **prey** and **predator** a more complex behaviors: instead of choose a random vegetation cell in the neighborhood, the agent will choose a vegetation cell (still in the neighborhood) thanks to a **choose\\_cell** action.\nThis action will be specialized for each species.\n\n```\n   species generic_species {\n        ...\n        reflex basic_move {\n\t\tmyCell <- choose_cell();\n\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n        ...\n   }\n```\n\nWe remind that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed.\n  * An action can accept arguments.\n  * An action can return a result (statement return)\n\nThere are two ways to call an action: using a statement or as part of an expression\n  * for actions that do not return a result:\n```\ndo action_name (arg1: v1 arg2: v2);\ndo action_name (v1, v2);\n```\n\n  * for actions that return a result (which is stored in _my\\_var_):\n```\nmy_var <- action_name (arg1:v1, arg2:v2);\nmy_var <- action_name (v1, v2);\n```\n\n### prey species\nWe specialize the **choose\\_cell** species for the **prey** species: the agent will choose the vegetation cell of the neighborhood (list myCell.neighbours) that maximizes the quantity of food.\n\nNote that GAMA offers numerous operators to manipulate lists and containers:\n  * Unary operators : min, max, sum...\n  * Binary operators :\n    * where : returns a sub-list where all the elements verify the condition defined in the right operand.\n    * first\\_with : returns the first element of the list that verifies the condition defined in the right operand.\n    * ...\nIn the case of binary operators, each element (of the first operand list) can be accessed with the keyword **each**\n\nThus the **choose\\_cell** action of the **prey** species is defined by:\n```\n   species prey parent: generic_species {\n      ...  \n      vegetation_cell choose_cell {\n\t  return (myCell.neighbours) with_max_of (each.food);\n      }\n      ...\n   }\n```\n\n### predator species\nWe specialize the **choose\\_cell** species for the **predator** species: the agent will choose, if possible, a vegetation cell of the neighborhood (list myCell.neighbours) that contains at least a **prey** agent; otherwise it will choose a random cell.\n\nWe use for this action the **first\\_with** operator on the list neighbor vegetation cells (myCell.neighbours) with the following condition: the list of **prey** agents contained in the cell is not empty. Note that we use the **shuffle** operator to randomize the order of the list of neighbor cell.\n\nIf all the neighbor cells are empty (myCell\\_tmp = nil, **nil** is the null value), then the agent choosse a random cell in the neighborhood (one\\_of (myCell.neighbours)).\n\nGAMA contains statements that allow to execute blocks depending on some conditions:\n```\n   if condition1 {...} \n   else if condition2{...} \n   ... \n   else {...} \n```\n\nThis statement means that if condition1 = true then the first block is executed; otherwise if condition2 = true, then it is the second block, etc. When no conditions are satisfied and an else block is defined (it is optional), this latter is executed.\n\nWe then write the **choose\\_cell** action as follows:\n```\n   species predator parent: generic_species {\n      ...\n      vegetation_cell choose_cell {\n\t  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t  if myCell_tmp != nil {\n\t\treturn myCell_tmp;\n\t  } else {\n\t\treturn one_of (myCell.neighbours);\n\t  } \n      }\n      ...\n   }\n```\n\nNote there is ternary operator allowing to directly use a condition structure to evaluate a variable:\n```\n   condition ? value1 : value2\n```\nif condition is true, then returns value1; otherwise, returns value2.\n\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\tfile my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- choose_cell();\n\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- 1 + rnd(nb_max_offsprings -1);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmyCell <- myself.myCell ;\n\t\t\tlocation <- myCell.location ;\n\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t}\n\t\tenergy <- energy / nb_offsprings ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```","url":"wiki/PredatorPrey_step8.md"},"PredatorPrey_step9.md":{"title":" 9. Stopping condition","content":"# 9. Stopping condition\nThis 9th step Illustrates how to use the **halt** action to stop a simulation\n\n\n\n\n\n\n\n## Formulation\n  * Adding of a stopping condition for the simulation: when there is no more prey or predator agents, the simulation stops\n\n\n\n\n\n## Model Definition\n\nWe add a new reflex that stops the simulation if the number of preys or the number of predator is null.\n\n```\nglobal {\n   ...\n   reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n      do halt ;\n   } \n}\n```\n\nNote that it would have been possible to use the **pause** action that pauses the simulation instead of the **halt** action that stops the simulation.\n\n\n\n\n\n## Complete Model\n\n```\nmodel prey_predator\n\nglobal {\n\tint nb_preys_init <- 200;\n\tint nb_predators_init <- 20;\n\tfloat prey_max_energy <- 1.0;\n\tfloat prey_max_transfert <- 0.1 ;\n\tfloat prey_energy_consum <- 0.05;\n\tfloat predator_max_energy <- 1.0;\n\tfloat predator_energy_transfert <- 0.5;\n\tfloat predator_energy_consum <- 0.02;\n\tfloat prey_proba_reproduce <- 0.01;\n\tint prey_nb_max_offsprings <- 5; \n\tfloat prey_energy_reproduce <- 0.5; \n\tfloat predator_proba_reproduce <- 0.01;\n\tint predator_nb_max_offsprings <- 3;\n\tfloat predator_energy_reproduce <- 0.5;\n\t\n\tint nb_preys -> {length (prey)};\n\tint nb_predators -> {length (predator)};\n\t\n\tinit {\n\t\tcreate prey number: nb_preys_init ; \n\t\tcreate predator number: nb_predators_init ;\n\t}\n\t\n\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\n\t\tdo halt ;\n\t} \n}\n\nspecies generic_species {\n\tfloat size <- 1.0;\n\trgb color  ;\n\tfloat max_energy;\n\tfloat max_transfert;\n\tfloat energy_consum;\n\tfloat proba_reproduce ;\n\tfloat nb_max_offsprings;\n\tfloat energy_reproduce;\n\tfile my_icon;\n\tvegetation_cell myCell <- one_of (vegetation_cell) ;\n\tfloat energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\n\t\n\tinit {\n\t\tlocation <- myCell.location;\n\t}\n\t\t\n\treflex basic_move {\n\t\tmyCell <- choose_cell();\n\t\tlocation <- myCell.location; \n\t} \n\t\n\tvegetation_cell choose_cell {\n\t\treturn nil;\n\t}\n\t\t\n\treflex die when: energy <= 0 {\n\t\tdo die ;\n\t}\n\t\n\treflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n\t\tint nb_offsprings <- 1 + rnd(nb_max_offsprings -1);\n\t\tcreate species(self) number: nb_offsprings {\n\t\t\tmyCell <- myself.myCell ;\n\t\t\tlocation <- myCell.location ;\n\t\t\tenergy <- myself.energy / nb_offsprings ;\n\t\t}\n\t\tenergy <- energy / nb_offsprings ;\n\t}\n\t\n\taspect base {\n\t\tdraw circle(size) color: color ;\n\t}\n\taspect icon {\n\t\tdraw my_icon size: 2 * size ;\n\t}\n\taspect info {\n\t\tdraw square(size) color: color ;\n\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\n\t}\n}\n\nspecies prey parent: generic_species {\n\trgb color <- #blue;\n\tfloat max_energy <- prey_max_energy ;\n\tfloat max_transfert <- prey_max_transfert ;\n\tfloat energy_consum <- prey_energy_consum ;\n\tfloat proba_reproduce <- prey_proba_reproduce ;\n\tint nb_max_offsprings <- prey_nb_max_offsprings ;\n\tfloat energy_reproduce <- prey_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_sheep.png\") ;\n\t\t\n\treflex eat when: myCell.food > 0 {\n\t\tfloat energy_transfert <- min([max_transfert, myCell.food]) ;\n\t\tmyCell.food <- myCell.food - energy_transfert ;\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\treturn (myCell.neighbours) with_max_of (each.food);\n\t}\n}\n\t\nspecies predator parent: generic_species {\n\trgb color <- #red ;\n\tfloat max_energy <- predator_max_energy ;\n\tfloat energy_transfert <- predator_energy_transfert ;\n\tfloat energy_consum <- predator_energy_consum ;\n\tlist<prey> reachable_preys update: prey inside (myCell);\n\tfloat proba_reproduce <- predator_proba_reproduce ;\n\tint nb_max_offsprings <- predator_nb_max_offsprings ;\n\tfloat energy_reproduce <- predator_energy_reproduce ;\n\tfile my_icon <- file(\"../images/predator_prey_wolf.png\") ;\n\t\n\treflex eat when: ! empty(reachable_preys) {\n\t\task one_of (reachable_preys) {\n\t\t\tdo die ;\n\t\t}\n\t\tenergy <- energy + energy_transfert ;\n\t}\n\t\n\tvegetation_cell choose_cell {\n\t\tvegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\n\t\tif myCell_tmp != nil {\n\t\t\treturn myCell_tmp;\n\t\t} else {\n\t\t\treturn one_of (myCell.neighbours);\n\t\t} \n\t}\n}\n\t\ngrid vegetation_cell width: 50 height: 50 neighbours: 4 {\n\tfloat maxFood <- 1.0 ;\n\tfloat foodProd <- (rnd(1000) / 1000) * 0.01 ;\n\tfloat food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n\tlist<vegetation_cell> neighbours  <- (self neighbours_at 2); \n}\n\nexperiment prey_predator type: gui {\n\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\n\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\n\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\n\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\n\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\n\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\n\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\n\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\n\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\n\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\n\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\n\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\n\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\n\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\n\t\n\toutput {\n\t\tdisplay main_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: icon ;\n\t\t\tspecies predator aspect: icon ;\n\t\t}\n\t\tdisplay info_display {\n\t\t\tgrid vegetation_cell lines: #black ;\n\t\t\tspecies prey aspect: info ;\n\t\t\tspecies predator aspect: info ;\n\t\t}\n\t\tmonitor \"Number of preys\" value: nb_preys;\n\t\tmonitor \"Number of predators\" value: nb_predators;\n\t}\n}\n```","url":"wiki/PredatorPrey_step9.md"},"RoadTrafficModel_step1.md":{"title":" 1. Loading of GIS Data","content":"# 1. Loading of GIS Data\nThis first step Illustrates how to load GIS data (shapefiles) and to read attributes from GIS data.\n\n\n\n\n\n\n\n## Formulation\n  * Set the time duration of a time step to 10 minutes\n  * Load, agentify and display two layers of GIS data (building and road). Agentifying a GIS element will allow us to give it a behavior later on (thus not being simply a static/passive object).\n  * Read the 'NATURE' attribute of the building data: the buildings of 'Residential' type will be colored in gray, the buildings of 'Industrial' type will be color in blue.\n\n\n\n\n\n## Model Definition\n\n### species\nIn this first model, we have to define two species of agents: the **building** agents and the **road** ones. These agents will not have a particular behavior, they will just be displayed.\nFor each of these species, we define a new attribute: **color** of type _rgb_, with for initial value: \"black\" for the **road** agent and \"gray\" (by default) for the **building** agent.\nConcerning the **building** agent, we define a second attribute named **type** representing the type of the building (\"Residential\" or \"Industrial\").\nAt last, we define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use the keyword **draw** that allow to draw a given geometry. In order to draw the geometry of the agent we use the attribute **shape** (which is a built-in attribute of all agents).\n\n\n```\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #black ;\n\t\n        aspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n```\n\n\n### parameters\nGAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define three parameters. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile, and, at last, one allowing him/her to choose the bounds shapefile. We will come back later on the notion of \"bounds\" in GAMA.\n\nDefinition of the three global variables of type _file_ concerning the GIS files:\n```\nglobal {\n   file shape_file_buildings <- file(\"../includes/building.shp\");\n   file shape_file_roads <- file(\"../includes/road.shp\");\n   file shape_file_bounds <- file(\"../includes/bounds.shp\");\n}\n```\n\nIn the experiment section, we add three parameters to allow the user to change the shapefile used directly through the UI:\n```\nexperiment road_traffic type: gui {\n   parameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n   parameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n   parameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n}\n```\n\n### agentification of GIS data\n\nIn GAMA, the agentification of GIS data is very straightforward: it only requires to use the **create** command with the **from** facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the **with** facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the **read** command followed by the name of the shapefile attribute (\"NATURE\" in our case).\n\nInit section of the global block: creation of the road and building agents from the shape files. Concerning the **building** agents, reading of the \"NATURE\" attribute of the shapefile to initiate the value of the **type** attribute. If the **type** attribute is equal to \"Industrial\" set the **color** attribute to \"blue\".\n```\nglobal {\n  ...\n  init {\n   create building from: shape_file_buildings with: [type::read (\"NATURE\")] {\n      if type=\"Industrial\" {\n         color <- #blue ;\n      }\n   }\n   create road from: shape_file_roads ;\n  } \n```\n\n### time step\nIn GAMA, by default, a time step represents 1 second. It is possible to redefine this value by overriding the **step** global variable. This value of the time step is used by the moving primitives of GAMA.\n\nIn our model, we define that a step represent 10 minutes. Note that it is possible to define the unit of a value by using _#_ + unit name. For instance, #mn or #km for kilometers.\n\n```\nglobal {\n  ...\n  float step <- 10 #mn;\n  ...\n}\n```\n### environment\nBuilding a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use a specific shapefile to define it. However, it would been possible to use the road shapefile to define it and let GAMA computes it enveloppe automatically.\n\n```\nglobal {\n  ...\n  geometry shape <- envelope(shape_file_bounds); \n  ...\n}\n```\n\n### display\nWe define a display to visualize the road and building agents. We use for that the classic **species** keyword. In order to optimize the display we use an opengl display (facet **type: opengl**).\n\nIn the **experiment** block:\n```\noutput {\n   display city_display type:opengl {\n      species building aspect: base ;\n      species road aspect: base ;\n   }\n}\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #black ;\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t}\n\t}\n}\n```","url":"wiki/RoadTrafficModel_step1.md"},"RoadTrafficModel_step2.md":{"title":" 2. People Agents","content":"# 2. People Agents\nThis second step Illustrates how to obtain a random point inside a geometry. We will also define some moving agent called _people_.\n\n\n\n\n\n\n\n## Formulation\n  * Define a new species of agents: the **people** agents. The **people** agents have a point for geometry and are represented by a yellow circle of radius 10m.\n  * At initialization, 100 **people** agents are created. Each **people** agent is placed inside a building of type 'Residential' (randomly selected).\n\n\n\n\n\n## Model Definition\n\n### species\nWe define a new species of agents: the **people** agents. In this model, these agents will not have a specific behavior yet. They will be just displayed. Thus, we just have to define an aspect for the agents. We want to represent the **people** agents by a yellow circle of radius 10m. We then use the **circle** value for the **shape** facet of the **draw** command, with the expected color and radius size (defined by the facet **size**).\n\n```\nspecies people {\n\trgb color <- #yellow ;\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n```\n\n\n### parameter\nWe have to add a new parameter: the number of **people** agents created\n\nIn the global section, definition of the **nb\\_people** variable:\n```\n   int nb_people <- 100;\n```\n\nIn the experiment section, definition of the parameter:\n```\n   parameter \"Number of people agents\" var: nb_people category: \"People\" ;\n```\n\n### creation and placement of the people agents\n\nWe have to create **nb\\_people** **people** agents. Each **people** is placed in a buildings of type 'Residential' randomly selected. In order to simplify the GAML code, we defined a local variable **residential\\_buildings** that represent the list of buildings of type 'Residential'. To filter the list of **building** agents (obtained by **building**), we use the **where** operator. We use the operator **one\\_of** to randomly select one agent of this list. There are several ways to place a **people** agent inside this building. In this tutorial, we choose to use the **any\\_location\\_in** operator. This operator returns a random point situated inside the operand geometry.\n\n```\nglobal {\n\t...\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tcreate people number: nb_people {\n\t\t\tlocation <- any_location_in (one_of (residential_buildings));\n\t\t}\n\t}\n}\n```\n\n### display\nWe add the **people** agent in the defined display.\n\n```\n   output {\n      display city_display {\n         species building aspect: base ;\n         species road aspect: base ;\n         species people aspect: base ;\n      }\n   }\n```\n\n\n\n\n## Complete Model\n\n```\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tcreate people number: nb_people {\n\t\t\tlocation <- any_location_in (one_of (residential_buildings));\n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #black ;\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people {\n\trgb color <- #yellow ;\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}\n```","url":"wiki/RoadTrafficModel_step2.md"},"RoadTrafficModel_step3.md":{"title":" 3. Movement of People","content":"# 3. Movement of People\n\nThis third step presents how to create a road system from GIS data. More precisely, it shows how to build a graph from a list of polylines and to constrain the movement of an agent according to this graph.\n\n\n\n\n\n\n\n## Formulation\n  * Definition of day\\_time global variable that will indicate, according to the simulation step, the time of the day: each simulation step will represent 10 minutes, then the day\\_time variable will be ranged between 0 and 144.\n  * For each **people** agent: define a living\\_place(building of type 'Residential') and working place (building of type 'Industrial').\n  * For each **people** agent: define start\\_work and end\\_work hours that respectively represent when the agent leaves its house to go to work and when it leaves its working\\_place to go back home. These hours will be randomly define between 36 (6 a.m;) and 60 (10 a.m.) for the start\\_work and 84 (2p.m.) and 132 (10p.m.) for the end\\_work.\n  * For each **people** agent: define a objective variable: this one can 'go home' or 'working'.\n  * For each **people** agent: define a speed. The speed will be randomly define between 50 and 100.\n  * The **people** agents move along the road, taking the shortest path.\n\n\n\n\n\n\n## Model Definition\n\n### people agents\nFirst, we have to change the skill of the **people** agents: as we want to use an action of the **moving** skill (**goto**), we will provide the **people** agents with this skill. A [skill](AttachingSkills) is a built-in module that provide the modeler a self-contain and relevant set of actions and variables.\n\n```\n   species people skills: [moving]{\n       ...\n   }\n```\n\nThen, we have to add new variables to the people agents: living\\_place, working\\_place, start\\_work, end\\_work, objective. In addition, we will add a \"the\\_target\" variable that will represents the point toward which the agent will be currently moving.\n\n```\n   species people skills: [moving]{\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n      \n       ...\n   }\n```\n\nWe define two reflex methods that allow to change the objective (and the\\_target) of the agent at the start\\_work and en\\_work hours. Concerning the _target value_, we choose a random point in the objective building (working\\_place or living\\_place) by using the **any\\_location\\_in** operator.\n\n```\n   species people skills: [moving]{  \n      ...\n      reflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n           objective <- \"working\" ;\n\t   the_target <- any_location_in (working_place);\n      }\n\t\t\n      reflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t   objective <- \"resting\" ;\n\t   the_target <- any_location_in (living_place); \n      } \n      ...\n  }\n```\n\nAt last, we define a reflex method that allows the agent to move. If a target point is defined (the\\_target != nil), the agent moves in direction to its target using the **goto** action (provided by the moving skill). Note that we specified a graph to constraint the movement of the agents on the road network with the facet **on**. We will see later how this graph is built. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at destination (the\\_target = location), the target is set to nil (the agent will stop moving).\n\n```\n  species people skills: [moving]{\n      ...\n      reflex move when: the_target != nil {\n\t  do goto target: the_target on: the_graph ; \n\t  if the_target = location {\n\t\tthe_target <- nil ;\n\t  }\n     }\n  }\n```\n\n### parameters\nWe add several parameters (**min\\_work\\_start**, **max\\_work\\_start**, **min\\_work\\_end**, **max\\_work\\_end**, **min\\_speed** and **max\\_speed**) and two global variables: **the\\_graph** (graph computed from the road network) and **current\\_hour** (current hour of the day). The value of the **current\\_hour** variable is automatically computed at each simulation step and is equals to \"(time(the simulation step **step) / 1 hour) modulo 24\".**\n\nIn the global section:\n```\nglobal {\n        ...\n        int current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tgraph the_graph;\n        ...\n}\n```\n\nIn the experiment section:\n```\nexperiment road_traffic type: gui {\n        ... \n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n        ...\n}\n```\n### initialization\nFirst, we need to compute from the **road** agents, a graph for the moving of the **people** agents. The operator **as\\_edge\\_graph** allows to do that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry.\n```\n   init {\n      ...\n      create road from: shape_file_roads ;\n      the_graph <- as_edge_graph(road);\n      ...\n   }\n```\n\nWe randomly assign one working place and one house to each **people** agent. To simplify the GAML code, we define two temporary variables: the list of buildings of type 'Residential' and the list of buildings of type 'Industrial' (by using the **where** command). At the creation of each **people** agent, we define a speed, a start\\_work and end\\_work to each **people** agent (according to the min and max define in the parameters). We define as well an initial objective (\"resting\"). Concerning the definition of the living\\_place and working\\_place, these ones are randomly chosen in the residential\\_buildings and industrial\\_buildings lists.\n```\n   init {\n      ...\n      list<building> residential_buildings <- building where (each.type=\"Residential\");\n      list<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n      create people number: nb_people {\n          speed <- min_speed + rnd (max_speed - min_speed) ;\n          start_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n          end_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n          living_place <- one_of(residential_buildings) ;\n          working_place <- one_of(industrial_buildings) ;\n          objective <- \"resting\";\n          location <- any_location_in (living_place); \n      }\n      ...\n  }\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tthe_graph <- as_edge_graph(road);\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\trgb color <- #black ;\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tdo goto target: the_target on: the_graph ; \n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}\n```","url":"wiki/RoadTrafficModel_step3.md"},"RoadTrafficModel_step4.md":{"title":" 4. Weight for Road Network","content":"# 4. Weight for Road Network\nThe present model will introduce how to design a road system, or graph, based on the road GIS data and provide each edge a `weight`representing the destruction level of the road.\n\n\n\n\n\n\n\n## Formulation\n  * Add a **destruction\\_coeff** variable to the **road** agent. The value of this variable is higher or equal to 1 or lower or equal to 2. At initialization, the value of this variable is randomly defined between 1 and 2.\n  * In the road network graph, more a road is worn out (destruction\\_coeff high), more a **people** agent takes time to go all over it. Then the value of the arc representing the road in the graph is equal to \"length of the road `*` destruction\\_coeff\".\n  * The color of the road depends of the **destruction\\_coeff**. If \"destruction\\_coeff = 1\", the road is green, if \"destruction\\_coeff = 2\", the road is red.\n\n\n\n\n\n## Model Definition\n\n### road agent\nWe add a **destruction\\_coeff** variable which initial value is randomly defined between 1 and 2 and that have a max of 2. The color of the agent will depend of this variable. In order to simplify the GAML code, we define a new variable  **colorValue** that represents the value of red color and that will be defined between 0 and 255.\n\n```\n   species road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\n        ...\n   }\n```\n\n\n### weigthed road network\nIn GAMA, adding a weight for a graph is very simple, we use the **as\\_edge\\_graph** operator with the graph for left-operand and a weight map for the right-operand. A weight contains the weight of each edge: [edge1::weight1, edge2:: weight2,...]. In this model, the weight will be equal to the length of the road (perimeter of the polyline) **its destruction coefficient.\n```\n    init {\n      ...\n      create road from: shape_file_roads ;\n      map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n      the_graph <- as_edge_graph(road) with_weights weights_map;\n      ...\n   }\n```**\n\n\n\n\n\n## Complete Model\n\n```\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tdo goto target: the_target on: the_graph ; \n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}\n```","url":"wiki/RoadTrafficModel_step4.md"},"RoadTrafficModel_step5.md":{"title":" 5. Dynamic weights","content":"# 5. Dynamic weights\nThis 5th step illustrates how to obtain a shortest path from a point to another and to update the weights of an existing graph.\n\n\n\n\n\n\n\n\n## Formulation\n  * At initialization, the value of the **destruction\\_coeff** of the **road** agents will be equal to 1.\n  * Add a new parameter: the **destroy** parameter that represents the value of destruction when a people agent takes a road. By default, it is equal to 0.02.\n  * When an people arrive at its destination (home or work), it updates the **destruction\\_coeff** of the **road** agents it took to reach its destination:  \"destruction\\_coeff = destruction\\_coeff - destroy\". Then, the graph is updated.\n\n\n\n\n\n## Model Definition\n### global section\nWe add the **destroy** parameter.\n\nIn the global section, definition of the **destroy** and **update\\_roads** variables:\n```\n   float destroy <- 0.02;\n```\n\nIn the experiment section, definition of the parameter:\n```\n   parameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n```\n\nWe define a new reflex that updates the graph at each simulation step. For that, we use the **with\\_weights** operator. This operator allows to update the weights of an existing graph.\n\n```\n   global {\n      ...\n      reflex update_graph{\n         map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n         the_graph <- the_graph with_weights weights_map;\n      }\n   }\n```\n\n### people agents\n\nAt each time-step, after a **people** agent have moved over one or multiple segments, it updates the value of the destruction coefficient of **road** agents crossed (i.e. roads belonging to the path followed). We have for that to set the argument **return\\_path** to _true_ in the **goto** action to obtain the path followed, then to compute the list of agents concerned by this path with the operator **agent\\_from\\_geometry**.\n```\n   species people skills: [moving]{\n      ...\n      reflex move when: the_target != nil {\n\t\tpath path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n   ...\n   }\t\n```\n\n\n\n\n\n\n## Complete Model\n\n```\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t}\n}\n```","url":"wiki/RoadTrafficModel_step5.md"},"RoadTrafficModel_step6.md":{"title":" 6. Charts","content":"# 6. Charts\nThis 6th step illustrates how to display charts.\n\n\n\n\n\n\n\n## Formulation\n  * Add a chart to display the evolution of the road destruction: the mean value of the **destruction\\_coeff** of the **road** agents, and its max value (refreshed every 10 simulation steps).\n  * Add a chart to display the activity of the **people** agent (working or staying home, refreshed every 10 simulation steps).\n\n\n\n\n\n## Model Definition\n### chart display\nFirst we add a chart of type **series** to display the road destruction evolution. To compute the mean of the **destruction\\_coeff**, we use the **mean** operator. For the max, we use the **max\\_of** operator.\n\n```\n     output {\n       display chart_display refresh:every(10) {\n             chart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\n                  data \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\n\t\t  data \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\n\t    }\n         ...\n      }\n   }\n```\n\nSecond, we add a chart of type **pie** to display the activity of the **people** agents. We use for that the **objective** variable of the **people** agents and the **count** operator that allows to compute the number of elements of a list that verify a condition.\n\n```\n    output {\n      ...\n      display chart_display refresh:every(10) {\n          ...\n          chart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\n\t       data \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\n\t       data \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\n\t  }\n     }\n   }\n```\n\n\n\n\n\n## Complete Model\n\n```\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t\tdisplay chart_display refresh:every(10) { \n\t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\n\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\n\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\n\t\t\t}\n\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\n\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\n\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}\n```","url":"wiki/RoadTrafficModel_step6.md"},"RoadTrafficModel_step7.md":{"title":" 7. Automatic Road Repair","content":"# 7. Automatic Road Repair\nThis 7th step illustrates how how to select in a list an element that optimize a given function.\n\n\n\n\n\n\n\n## Formulation\n  * Add a new parameter, **repair\\_time**, that is equal to 2.\n  * Every **repair\\_time**, the **road** with the highest **destruction\\_coeff** value is repaired (set its **destruction\\_coeff** to 1).\n\n\n\n\n\n## Model Definition\n\n### parameters\nWe add a new parameter: the **repair\\_time**.\n\nIn the global section, definition of the **repair\\_time** variable:\n```\n   int repair_time <- 2 ;\n```\n\nIn the experiment section, definition of the parameter:\n```\n   parameter \"Number of steps between two road repairs\" var: repair_time category: \"Road\" ;\n```\n\n### road repairing\nWe have to add a reflex method in the global section that is triggered every **repair\\_time** hours / step. This method selects, thanks to the **with\\_max\\_of** operation the **road** agent with the highest **destruction\\_coeff** value, then sets this value at 1.\n\n```\nglobal {\n   ...\n   reflex repair_road when: every(repair_time #hour / step) {\n\troad the_road_to_repair <- road with_max_of (each.destruction_coeff) ;\n\task the_road_to_repair {\n\t\tdestruction_coeff <- 1.0 ;\n\t}\n   }\n}\n```\n\n\n\n\n\n\n## Complete Model\n\n```\nmodel tutorial_gis_city_traffic\n\nglobal {\n\tfile shape_file_buildings <- file(\"../includes/building.shp\");\n\tfile shape_file_roads <- file(\"../includes/road.shp\");\n\tfile shape_file_bounds <- file(\"../includes/bounds.shp\");\n\tgeometry shape <- envelope(shape_file_bounds);\n\tfloat step <- 10 #mn;\n\tint nb_people <- 100;\n\tint current_hour update: (time / #hour) mod 24;\n\tint min_work_start <- 6;\n\tint max_work_start <- 8;\n\tint min_work_end <- 16; \n\tint max_work_end <- 20; \n\tfloat min_speed <- 1.0 #km / #h;\n\tfloat max_speed <- 5.0 #km / #h; \n\tfloat destroy <- 0.02;\n\tint repair_time <- 2 ;\n\tgraph the_graph;\n\t\n\tinit {\n\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n\t\t\tif type=\"Industrial\" {\n\t\t\t\tcolor <- #blue ;\n\t\t\t}\n\t\t}\n\t\tcreate road from: shape_file_roads ;\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- as_edge_graph(road) with_weights weights_map;\n\t\t\n\t\t\n\t\tlist<building> residential_buildings <- building where (each.type=\"Residential\");\n\t\tlist<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- min_speed + rnd (max_speed - min_speed) ;\n\t\t\tstart_work <- min_work_start + rnd (max_work_start - min_work_start) ;\n\t\t\tend_work <- min_work_end + rnd (max_work_end - min_work_end) ;\n\t\t\tliving_place <- one_of(residential_buildings) ;\n\t\t\tworking_place <- one_of(industrial_buildings) ;\n\t\t\tobjective <- \"resting\";\n\t\t\tlocation <- any_location_in (living_place); \n\t\t}\n\t}\n\t\n\treflex update_graph{\n\t\tmap<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\n\t\tthe_graph <- the_graph with_weights weights_map;\n\t}\n\treflex repair_road when: every(repair_time #hour / step) {\n\t\troad the_road_to_repair <- road with_max_of (each.destruction_coeff) ;\n\t\task the_road_to_repair {\n\t\t\tdestruction_coeff <- 1.0 ;\n\t\t}\n\t}\n}\n\nspecies building {\n\tstring type; \n\trgb color <- #gray  ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies road  {\n\tfloat destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;\n\tint colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\n\trgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\n\t\n\taspect base {\n\t\tdraw shape color: color ;\n\t}\n}\n\nspecies people skills:[moving] {\n\trgb color <- #yellow ;\n\tbuilding living_place <- nil ;\n\tbuilding working_place <- nil ;\n\tint start_work ;\n\tint end_work  ;\n\tstring objective ; \n\tpoint the_target <- nil ;\n\t\t\n\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\n\t\tobjective <- \"working\" ;\n\t\tthe_target <- any_location_in (working_place);\n\t}\n\t\t\n\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\n\t\tobjective <- \"resting\" ;\n\t\tthe_target <- any_location_in (living_place); \n\t} \n\t \n\treflex move when: the_target != nil {\n\t\tpath path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];\n\t\tlist<geometry> segments <- path_followed.segments;\n\t\tloop line over: segments {\n\t\t\tfloat dist <- line.perimeter;\n\t\t\task road(path_followed agent_from_geometry line) { \n\t\t\t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\n\t\t\t}\n\t\t}\n\t\tif the_target = location {\n\t\t\tthe_target <- nil ;\n\t\t}\n\t}\n\t\n\taspect base {\n\t\tdraw circle(10) color: color;\n\t}\n}\n\nexperiment road_traffic type: gui {\n\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\n\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\n\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\n\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\n\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\n\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\n\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\n\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\n\tparameter \"Number of hours between two road repairs\" var: repair_time category: \"Road\" ;\n\t\n\toutput {\n\t\tdisplay city_display type:opengl {\n\t\t\tspecies building aspect: base ;\n\t\t\tspecies road aspect: base ;\n\t\t\tspecies people aspect: base ;\n\t\t}\n\t\tdisplay chart_display refresh:every(10) { \n\t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\n\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\n\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\n\t\t\t}\n\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\n\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\n\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\n\t\t\t}\n\t\t}\n\t}\n}\n```","url":"wiki/RoadTrafficModel_step7.md"},"ThreeD_step1.md":{"title":" 1. Basic Model","content":"# 1. Basic Model\n\n\n\nIn this first step, we will see how to define a 3D environment and populate it.\n\n\n\n\n\n\n## Formulation\nInitialize a 3D world with a population of cells placed randomly in a 3D 100x100x100 cube.\n  * Definition of the **cells** species\n  * Definition of the **nb\\_cells** parameter\n  * Creation of **nb\\_cells** **cells** agents randomly located in the 3D environment size: 100x100x100.\n\n\n![images/3D_model_LQ.png](resources/images/tutorials/3D_model_LQ.png)\n\n\n\n\n\n## Model Definition\n\nIn this model we define one species of agent: the **cells** agents. The agents will be just displayed as a blue sphere of radius 1.\n\n```\nspecies cells{                      \n  aspect default {\n    draw sphere(1) color:#blue;   \n  }\n}\n```\n\n### Global Section\n\n#### Global variable\n\nDefinition of a global variable **nb\\_cells** of type _int_ representing the number of **cells** agents.\n\n```\nglobal {\n   int nb_cells <-100;\n}\n```\n\n#### Model initialization\n\nDefinition of the init block in order to create _nb\\_cells_ **cells** agents. By default an agent is created with a random location in x and y, and a z value equal to 0. In our case we want to place the **cells** randomly in the 3D environment so we set a random value for _x_, _y_ and _z_.\n\n```\ncreate cells number: nb_cells {\n  location <- {rnd(100), rnd(100), rnd(100)};\n}\n```\n\n\n\n### Experiment\n\nIn our model, we define a basic gui experiment called _Tuto3D_ :\n```\nexperiment Tuto3D type: gui {\n}\n```\n\n#### Input\nDefinition of a parameter from the the global variable _nb\\_cells_ :\n```\nexperiment Tuto3D type: gui {\n   parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\";\t\n}\n```\n\n#### Output\n\nIn our model, we define a display to draw the **cells** agents in a 3D environment.\n```\noutput {\n  display View1 type:opengl {\n    species cells;\n  }\n}\n```\n\n\n\n\n\n## Complete Model\n\nThis model is available in the model library (under Tutorials > 3D) and the GIT version of the model can be found here [Model 01.gaml](https://github.com/gama-platform/gama/tree/master/msi.gama.models/models/Tutorials/3D/models/Model 01.gaml)\n\n```\nmodel Tuto3D\n\nglobal {\n  int nb_cells <-100;\t\n  init { \n    create cells number: nb_cells { \n      location <- {rnd(100), rnd(100), rnd(100)};       \n    } \n  }  \n} \n  \nspecies cells{                      \n  aspect default {\n    draw sphere(1) color:#blue;   \n  }\n}\n\nexperiment Tuto3D  type: gui {\n  parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\" ;\t\n  output {\n    display View1 type:opengl {\n      species cells;\n    }\n  }\n}\n```","url":"wiki/ThreeD_step1.md"},"ThreeD_step2.md":{"title":" 2. Moving Cells","content":"# 2. Moving Cells\n\n\nThis second step model adds the **moving3D** skills to the **cell** agents and simply makes move the **cells** agent by defining a reflex that will call the action **move**. We will also add additional visual information to the display.\n\n\n\n\n\n## Formulation\n  * Redefining the shape of the world with a 3D Shape.\n  * Attaching new skills (**moving3D**) to **cells** agent.\n  * Modify **cells** aspect\n  * Add a graphics layer\n\n<a href='http://www.youtube.com/watch?feature=player_embedded&v=_QqUbC0MWRU' target='_blank'><img src='http://img.youtube.com/vi/_QqUbC0MWRU/0.jpg' width='425' height=344 /></a>\n\n\n\n\n\n## Model Definition\n\n\n\n### Global Section\n\n\n#### Global variable\nWe use a new global variable called _environmentSize\\_that to define the size of our 3D environment.\nIn the global section we define the new variable\n```\nint environmentSize <-100;\n```\n\nThen we redefine the shape of the world (by default the shape of the world is a 100x100 square) as cube that will have the size defined by the _environment\\_size_ variable. To do so we change the shape of the world in the **global** section:\n\n```\ngeometry shape <- cube(environmentSize);\t\n```\n\n#### Model initialization\n\n\nWhen we create the **cells** agent we want to place them randomly in the 3D environement. To do so we set the location with a random value for _x_, _y_ and _z_ between 0 and _environmentSize_.\n\n```\ncreate cells number: nb_cells { \n  location <- {rnd(environmentSize), rnd(environmentSize), rnd(environmentSize)};       \n}\n```\n\n### Moving3D skills\nIn the previous example, we only created **cells** agent that did not have any behavior. In this step we want to make move the **cells** agent. To do so we add a **moving3D** skills to the cells.\n\nMore information on built-in skills proposed by Gama can be found [here](BuiltInSkills)\n\n```\nspecies cells skills:[moving3D]{\n...  \t\n}\n```\n\nThen we define a new reflex for the species **cells** that consists in calling the action _move_ bundled in **moving3D** skills.\n```\nreflex move{\n  do move;\n}\t                    \n```\n\nFinally we modify a bit the aspect of the sphere to set its size according to the _environmentSize_ global variable previously defined.\n```\naspect default {\n  draw sphere(environmentSize*0.01) color:#blue;   \n}\n```\n\n\n\n\n### Experiment\nThe experiment is the same as the previous one except that we will display the bounds of the environment by using the **graphics** layer.\n\n\n```\ngraphics \"env\"{\n  draw cube(environmentSize) color: #black empty:true;\t\n}\n```\n\n#### Output\n```\noutput {\n  display View1 type:opengl{\n    graphics \"env\"{\n      draw cube(environmentSize) color: #black empty:true;\t\n    }\n    species cells;  \n  }\n}\n```\n\n\n\n\n\n## Complete Model\n\nThe GIT version of the model can be found here [Model 02.gaml](https://github.com/gama-platform/gama/tree/master/msi.gama.models/models/Tutorials/3D/models/Model 02.gaml)\n\n```\nmodel Tuto3D   \n\nglobal {\n  int nb_cells <-100;\n  int environmentSize <-100;\n  geometry shape <- cube(environmentSize);\t\n  init { \n    create cells number: nb_cells { \n      location <- {rnd(environmentSize), rnd(environmentSize), rnd(environmentSize)};       \n    } \n  }  \n} \n  \nspecies cells skills:[moving3D]{  \n\t\n  reflex move{\n  \tdo move;\n  }\t                    \n  aspect default {\n    draw sphere(environmentSize*0.01) color:#blue;   \n  }\n}\n\nexperiment Tuto3D  type: gui {\n  parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\" ;\n  output {\n    display View1 type:opengl{\n      graphics \"env\"{\n      \tdraw cube(environmentSize) color: #black empty:true;\t\n      }\n      species cells;\n    }\n  }\n}\n```\n\n> ","url":"wiki/ThreeD_step2.md"},"ThreeD_step3.md":{"title":" 3. Connections","content":"# 3. Connections\n\n\n\n\n\n\n\n\n\n## Formulation\n  * Mapping the network of connection\n\n<a href='http://www.youtube.com/watch?feature=player_embedded&v=6ZlBU6xTcfw' target='_blank'><img src='http://img.youtube.com/vi/6ZlBU6xTcfw/0.jpg' width='425' height=344 /></a>\n\n\n\n\n\n## Model Definition\nIn this final step we will display edges between cells that are within a given distance.\n\n### Cells update\n\nWe add a new reflex to collect the neighbours of the cell that are within a certain distance :\n\n```\nspecies cells skills:[moving3D]{\n...\nreflex computeNeighbours {\n                neighbours <- cells select ((each distance_to self) < 10);\n        }  \t\n}\n```\n\nThen we update the cell aspect as follows. For each elements (cells) of the **neighbours** list we draw a line between this neighbour's location and the current cell's location.\n```\naspect default {\n  draw sphere(environmentSize*0.01) color:#orange;\n  loop pp over: neighbors {\n    draw line([self.location,pp.location]);\n  }\t\n}\n```\n\n\n\n\n\n## Complete Model\n\nThe GIT version of the model can be found here [Model 03.gaml](https://github.com/gama-platform/gama/tree/master/msi.gama.models/models/Tutorials/3D/models/Model 03.gaml)\n\n```\nmodel Tuto3D\n\nglobal {\n  int nb_cells <-100;\n  int environmentSize <-100;\n  geometry shape <- cube(environmentSize);\t\n  init { \n    create cells number: nb_cells { \n      location <- {rnd(environmentSize), rnd(environmentSize), rnd(environmentSize)};       \n    } \n  }  \n} \n    \nspecies cells skills: [moving3D] {  \n\trgb color;\n\tlist<cells> neighbors;\n\tint offset;\n\t\n\treflex move {\n      do wander;\t\n\t}\t\n\t\n\treflex computeNeighbors {\n      neighbors <- cells select ((each distance_to self) < 10);\n    }\n\t\t\n\taspect default {\n\t\tdraw sphere(environmentSize*0.01) color:#orange;\n\t\tloop pp over: neighbors {\n\t\t\tdraw line([self.location,pp.location]);\n\t\t}\t\n    }\n}\n\n\nexperiment Tuto3D  type: gui {\n  parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\" ;\n  output {\n    display View1 type:opengl background:rgb(10,40,55){\n      graphics \"env\"{\n      \tdraw cube(environmentSize) color: #black empty:true;\t\n      }\n      species cells;\n    }\n  }  \n}\n```","url":"wiki/ThreeD_step3.md"},"IncrementalModel.md":{"title":" Incremental Model","content":"# Incremental Model\n\n\n\nThis tutorial has for goal to give an overview all most of the capabilities of GAMA. In particular, it presents how to build a simple model and the use of GIS data, graphs, 3D visualization, multi-level modeling and differential equations. All the files related to this tutorial (images and models) are available in the Models Library (project Tutorials/Incremental Model).\n\n\n\n\n\n\n## Model Overview\nThe model built in this tutorial concerns the study of the spreading of a disease in a small city.\nThree type of entities are taken into account: the people, the buildings and the roads.\n\nWe made the following modeling choice:\n  * Simulation step: 1 minute\n  * People are moving on the roads from building to building\n  * People use the shortest path to move between buildings\n  * All people have the same speed and move at constant speed\n  * Each time, people arrived at a building they are staying a certain time\n  * The staying time depends on the current hour (lower at 9h - go to work - at 12h go to lunch - at 18h - go back home)\n  * Infected people are never cured\n\n![images/incremental_model.jpg](resources/images/tutorials/incremental_model.jpg)\n\n\n\n\n\n## Step List\n\nThis tutorial is composed of 7 steps corresponding to 7 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.\n\n  1. [Simple SI Model](IncrementalModel_step1)\n  1. [Charts](IncrementalModel_step2)\n  1. [Integration of GIS Data](IncrementalModel_step3)\n  1. [Movement on Graph](IncrementalModel_step4)\n  1. [Visualizing in 3D](IncrementalModel_step5)\n  1. [Multi-Level](IncrementalModel_step6)\n  1. [Differential Equations](IncrementalModel_step7)","url":"wiki/IncrementalModel.md"},"LuneraysFlu.md":{"title":" Luneray's flu","content":"# Luneray's flu\n\n\nThis tutorial has for goal to introduce how to build a model with GAMA and to use GIS data and graphs. In particular, this tutorial shows how to write a simple GAMA model (the structure of a model, the notion of species...) load gis data, to agentify them and to use a network of polylines to constraint the movement of agents. The pdf of the presentation corresponding to this tutorial is available [here](https://github.com/gama-platform/gama/wiki/images/Tutorials/Luneray's flu/Luneray's flu.pdf). All the files related to this tutorial (shapefiles and models) are available [here](https://github.com/gama-platform/gama/wiki/images/Tutorials/Luneray's flu/Luneray's flu.zip). \n\nThe importation of models is described [here] (https://github.com/gama-platform/gama/wiki/G__ImportingModels)\n\n\n## Model Overview\nThe model built in this tutorial concerns the spreading of a flu in the city of Luneray (Normandie, France).\n\n![images/Luneray.jpg](resources/images/tutorials/Luneray.jpg)\n\nTwo layers of GIS data are used: a road layer (polylines) and a building layer (polygons). In this model, people agents are moving from building to building using the road network. Each infected people can infect the neighbor people.\n\nSome data collected concerning Luneray and the disease:\n* Number of inhabitants: 2147 (source : wikipedia)\n* Mean speed of the inhabitants (while moving on the road) : 2-5 km/h\n* The disease - non lethal - is spreading (by air) from people to people\n* Time to cure the disease: more than 100 days\n* Infection distance: 10 meters\n* Infection probability (when two people are at infection distance) : 0.05/minute\n\nFrom the data collected, we made some modeling choice:\n* Simulation step: 1 minute\n* People are moving on the roads from building to building \n* Most of time people are moving to meet their friend then go back home\n* People use the shortest path to move between buildings\n* All people move at constant speed\n* Each time, people arrived at a building they are staying a certain time : they are staying longer in their home than in their friend houses\n* Infected people are never cured\n\n![images/Luneray.png](resources/images/tutorials/Luneray.png)\n\n## Step List\n\nThis tutorial is composed of 5 steps corresponding to 5 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.\n\n  1. [Creation of a first basic disease spreading model](LuneraysFlu_step1)\n  1. [Definition of monitors and chart outputs](LuneraysFlu_step2)\n  1. [Importation of GIS data](LuneraysFlu_step3)\n  1. [Use of a graph to constraint the movements of people](LuneraysFlu_step4)\n  1. [Definition of 3D displays](LuneraysFlu_step5)","url":"wiki/LuneraysFlu.md"},"PredatorPrey.md":{"title":" Predator Prey","content":"# Predator Prey\n\n\n\nThis tutorial presents the structure of a GAMA model as well as the use of a grid topology. In particular, this tutorial shows how to define a basic model, to define \"grid agents\" which are able to move within the constraints. It also introduce the displays and agents' aspect.\n\n\nAll the files related to this tutorial (images and models) are available in the Models Library (project Tutorials/Predator Prey).\n## Content\n\n\n\n\n\n## Model Overview\nIn this model, three types of entities are considered: preys, predators and vegetation cells. Preys\neat grass on the vegetation cells and predators eat preys. At each simulation step, grass grows on the vegetation cells. Concerning the predators and preys, at each simulation step, they move (to a neighbor cell), eat, die if they do not have enough energy, and eventually reproduce.\n\n![images/predator_prey.png](resources/images/tutorials/predator_prey.png)\n\n\n\n\n## Step List\n\nThis tutorial is composed of 12 incremental steps corresponding to 12 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code of the model.\n\n  1. [Basic model (prey agents)](PredatorPrey_step1)\n  1. [Dynamic of the vegetation (grid)](PredatorPrey_step2)\n  1. [Behavior of the prey agent](PredatorPrey_step3)\n  1. [Use of Inspectors/monitors](PredatorPrey_step4)\n  1. [predator agents (parent species)](PredatorPrey_step5)\n  1. [Breeding of prey and predator agents](PredatorPrey_step6)\n  1. [Agent display (aspect)](PredatorPrey_step7)\n  1. [Complex behaviors for the preys and predators](PredatorPrey_step8)\n  1. [Adding of a stopping condition](PredatorPrey_step9)\n  1. [Definition of charts](PredatorPrey_step10)\n  1. [Writing files](PredatorPrey_step11)\n  1. [Image loading (raster data)](PredatorPrey_step12)","url":"wiki/PredatorPrey.md"},"RoadTrafficModel.md":{"title":" Road Traffic","content":"# Road Traffic\n\n\n\nThis tutorial has for goal to present the use of GIS data and complex geometries. In particular, this tutorial shows how to load gis data, to agentify them and to use a network of polylines to constraint the movement of agents. All the files related to this tutorial (shapefiles and models) are available in the Models Library (project road\\_traffic\\_tutorial).\n\nIf you are not familiar with agent-based models or GAMA we advice you to have a look at the [prey-predator](PredatorPrey) model first.\n\n\n\n\n\n\n## Model Overview\nThe model built in this tutorial concerns the study of the road traffic in a small city. Two layers of GIS data are used: a road layer (polylines) and a building layer (polygons). The building GIS data contain an attribute: the 'NATURE' of each building: a building can be either 'Residential' or 'Industrial'. In this model, people agents are moving along the road network. Each morning, they are going to an industrial building to work, and each night they are coming back home. Each time a people agent takes a road, it wears it out. More a road is worn out, more a people agent takes time to go all over it. The town council is able to repair some roads.\n\n![images/road_traffic.png](resources/images/tutorials/road_traffic.png)\n\n\n\n\n\n## Step List\n\nThis tutorial is composed of 7 steps corresponding to 7 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.\n\n  1. [Loading of GIS data (buildings and roads)](RoadTrafficModel_step1)\n  1. [Definition of people agents](RoadTrafficModel_step2)\n  1. [Movement of the people agents](RoadTrafficModel_step3)\n  1. [Definition of weight for the road network](RoadTrafficModel_step4)\n  1. [Dynamic update of the road network](RoadTrafficModel_step5)\n  1. [Definition of a chart display](RoadTrafficModel_step6)\n  1. [Automatic repair of roads](RoadTrafficModel_step7)","url":"wiki/RoadTrafficModel.md"},"ThreeD.md":{"title":" 3D Tutorial","content":"# 3D Tutorial\n\n\n\nThis tutorial introduces the 3D features offered by GAMA.\n\n\n\n\n\n\n\n## Model Overview\n\n<a href='http://www.youtube.com/watch?feature=player_embedded&v=6ZlBU6xTcfw' target='_blank'><img src='http://img.youtube.com/vi/6ZlBU6xTcfw/0.jpg' width='425' height=344 /></a>\n\n\n## Step List\n\nThis tutorial is composed of 3 steps corresponding to 3 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.\n\n  1. [Basic model](ThreeD_step1)\n  1. [Moving cells](ThreeD_step2)\n  1. [Moving cells with neighbours](ThreeD_step3)","url":"wiki/ThreeD.md"},"LearnGAMLStepByStep.md":{"title":" Learn GAML Step by Step","content":"# Learn GAML Step by Step\n\nThis large progressive tutorial has been designed to help you to learn **GAML** (**GA**ma **M**odeling **L**anguage).\nIt will cover the main part of the possibilities provided by GAML, and guide you to learn some more.\n\n## How to proceed to learn better ?\n\nAs you will progress in the tutorial, you will see several links (written in [blue](noURL)) to makes you jump to another part. You can click on them if you want to learn directly about a specific topic, but we do not encourage to do this, because you can get easily lost by reading this tutorial this way. As it is named, we encourage you to follow this tutorial \"step by step\". For each chapter, some links are available in the \"search\" tab, if you want to learn more about this subject.\n\nAlthough, if you really want to learn about a specific topic, our advise is to use the \"learning graph\" interface, in the website, so that you can choose your area of interest, and a learning path will be automatically design for you to assimilate the specific concept better.\n\nGood luck with your reading, and please do not hesitate to contact us through the [mailing list](https://groups.google.com/forum/#!forum/gama-platform) if you have a question/suggestion !","url":"wiki/LearnGAMLStepByStep.md"},"Recipes.md":{"title":" Recipes","content":"# Recipes\n\n\n\nUnderstanding the [structure of models](ModelOrganization) in GAML and gaining some insight of [the language](GamlReference) is required, but is usually not sufficient to build correct models or models that need to deal with specific approaches (like [equation-based modeling](Equations)). This section is intended to provide readers with practical \"how to\"s on various subjects, ranging from the use of [database access](UsingDatabase) to the design of [agent communication languages](UsingFIPAACL). It is by no means exhaustive, and will progressively be extended with more \"recipes\" in the future, depending on the concrete questions asked by users.","url":"wiki/Recipes.md"},"WhatsNext.md":{"title":" What's next ?","content":"# What's next ?\n\nNow you have a runnable GAMA on your computer, and you know a bit more about how to use the platform, you are ready to navigate through the website. Use the new powerful functionnalities of the website :\n\n* Try the **search engine** of the website to find quickly the notion you want to learn.\n* Navigate through the website by 3 different ways :\n  * [!images/general/icon_default_navigation.png](!images/general/icon_default_navigation.png) The **classic navigation** : to have a classic top-down navigation.\n  * [!images/general/icon_learning_graph_navigation.png](!images/general/icon_learning_graph_navigation.png) The **learning path navigation** : select the concept you want to learn, and a learning path will be build just for you, in order to assimilate this concept more quickly !\n  * [!images/general/icon_search_navigation.png](!images/general/icon_search_navigation.png) The **search related navigation** : for each page, some suggestions of related pages (dealing with the same concepts, or presenting the same GAML world) allows you to have a more transversal navigation.\n\n___________________________________________________________________________","url":"wiki/WhatsNext.md"},"CreatingAReleaseOfGama.md":{"title":" Product a release of GAMA","content":"# Product a release of GAMA\n## From the product\nLocate the file named `gama.product` (in plugin `ummisco.gama.product`) and open it.\nOn the first page, select the link `Eclipse Product export wizard` and follow the instructions in it. You can specify a root directory (under which the plugins will be copied) and an export directory on your hard drive where to export the whole application. Then click `Finish` and wait for a few minutes while Eclipse exports and packages your application. Once it is done, you can safely delete the `Repository` folder and the `logs.zip` file.\n## Specific to MacOS X\nUse `Gama.app` as the name of the root directory. Failing to do so will leave you with a non-working application. \n\n[[/resources/images/Export_Mac.png]]\n\nThis should result in a self-contained `Gama.app` application. However, the enclosed `Info.plist` lacks several key definitions. Open it (in a text editor) and paste the following items under the first <dict> (replace existing double entries if necessary):\n```\n\t<key>NSHighResolutionCapable</key>\n\t<string>True</string>\n\t<key>CFBundleExecutable</key>\n\t<string>Gama</string>\n\t<key>CFBundleGetInfoString</key>\n\t<string>Gama 1.7.0b, Copyright UMMISCO IRD/UPMC and partners 2006-2016 http://gama-platform.org</string>\n\t<key>CFBundleShortVersionString</key>\n\t<string>1.7.0b</string>\n\t<key>CFBundleSignature</key>\n\t<string>GAMA</string>\n\t<key>CFBundleVersion</key>\n\t<string>1.7.0b</string>\n\n```\n\nIf you also want the `.gaml` documents to be decorated with an icon and recognized when double-clicking on them, you can add:\n```\n\t<key>CFBundleDocumentTypes</key>\n\t<array>\n\t\t<dict>\n\t\t\t<key>CFBundleTypeExtensions</key>\n\t\t\t<array>\n\t\t\t\t<string>gaml</string>\n\t\t\t</array>\n\t\t\t<key>CFBundleTypeIconFile</key>\n\t\t\t<string>Model.icns</string>\n\t\t\t<key>CFBundleTypeName</key>\n\t\t\t<string>Gama Model</string>\n\t\t\t<key>CFBundleTypeRole</key>\n\t\t\t<string>Editor</string>\n\t\t\t<key>CFBundleTypeOSTypes</key>\n\t\t\t<array>\n\t\t\t\t<string>TEXT</string>\n\t\t\t</array>\n\t\t</dict>\n\t</array>\n```\n\nYou can additionally create an icon (`Model.icns`) for these files, which needs to reside in `Gama.app/Contents/Resources` next to `icon.icns`. An example of icon is available in the plugin `msi.gama.application/macosx`. \n\n## On Windows OS\nNo specific step to do. After select the link `Eclipse Product export wizard`, choose the directory for the export by click on Browse button, in Destination section. Then, click on Finish.\n\n## Configure your IDE in order to allow multi-platform builds\n\n* Open Eclipse Preferences\n* Navigate to Plugin Development Environment/Target Platform\n* Select your (active) target platform\n* Click Edit\n* Click Add\n* Select \"Software Site\"\n* Click Next\n* In \"Work With\" type: http://download.eclipse.org/eclipse/updates/4.5 (replace 4.5 with your current version)\n* Check \"Eclipse RCP Target Components\"\n* Check \"Equinox Target Components\"\n* **Uncheck** \"Include required software\" (**IMPORTANT**)\n* **Check** \"Include all environments\" (**IMPORTANT**)\n* Press Finish\n* Wait for the plugins to be downloaded and provisioned\n* Press Finish\n* Press OK\n\nOpen your product file and select the \"Export\" option. You will see that the \"Export for multiple platforms\" checkbox is available. The next page allows you to choose for which platform you'd like to export GAMA.","url":"wiki/CreatingAReleaseOfGama.md"},"DevelopingControlArchitectures.md":{"title":" Developing architecture","content":"# Developing architecture\n\n\n\nIn addition to existing [control architectures](BuiltInArchitectures), developers can add new ones.\n\nDefining a new control architecture needs to [create new statements of type behavior](DevelopingStatements) and included in species statements and to define how to manage their execution.\n\n\n\n\n\n\n## Implementation\n\nA control architecture is a Java class, that:\n  * is annotated by the [@skill](DevelopingIndexAnnotations#@skill) annotation,\n  * extends the `AbstractArchitecture` class (to get benefits of everything from the `reflex`-based control architecture, the `ReflexArchitecture` class can be extended instead).\n\nThe `AbstractArchitecture` extends the `ISkill` and `IStatement` interfaces and add the 2 following methods:\n  * `public abstract boolean init(IScope scope) throws GamaRuntimeException;`\n  * `public abstract void verifyBehaviors(ISpecies context);`\n\nThe three main methods to implement are thus:\n  * `public void setChildren(final List<? extends ISymbol> children)`: this method will be called at the compilation of the model. It allows to manage all the embeded statements (in `children`) and for example separate the statements that should be executed at the initialization only from the ones that should be executed at each simulation step. Following example allows to test the name of the all the embedded statements:\n```\nfor ( final ISymbol c : children ) {\n   if( IKeyword.INIT.equals(c.getFacet(IKeyword.KEYWORD).literalValue()) ) {\n```\n  * `public abstract boolean init(IScope scope) throws GamaRuntimeException`: this method is called only once, at the initialization of the agent.\n  * `public Object executeOn(final IScope scope) throws GamaRuntimeException`: this method is executed at each simulation step. It should manage the execution of the various embedded behaviors (e.g. their order or choose which one will be executed...)","url":"wiki/DevelopingControlArchitectures.md"},"DevelopingIndexAnnotations.md":{"title":" Index of annotations","content":"# Index of annotations\n\n\n\nAnnotations are used to link Java methods and classes to GAML language.\n\n\n\n\n## @action\nThis annotations is used to tag a method that will be considered as an action (or primitive) in GAML.\nThe method must have the following signature: ```\nObject methodName(IScope) throws GamaRuntimeException ``` and be contained in a class annotated with [@species](#species) or [@skill](#skill) (or a related class, like a subclass or an interface).\n\nThis annotation contains:\n  * **name** (String): _the name of the variable as it can be used in GAML_.\n  * **virtual** (boolean, false by default): _if true the action is virtual, i.e. equivalent to abstract method in java_.\n  * **args** (set of [@arg](#arg), empty by default): _the list of arguments passed to this action. Each argument is an instance of arg_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation associated to the action_.\n\n\n\n\n\n## @arg\nThis annotations describes an argument passed to an action.\n\nThis annotation contains:\n  * **name** (String, \"\" by default): _the name of the argument as it can be used in GAML_.\n  * **type** (set of ints, empty by default): _An array containing the textual representation of the types that can be taken by the argument (see IType)_.\n  * **optional** (boolean, true by default): _whether this argument is optional or not_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation associated to the argument._\n\n## @constant\nThis annotation is used to annotate fields that are used as constants in GAML.\n\nThis annotation contains:\n  * **category** (set of Strings, empty by default): _an array of strings, each representing a category in which this constant can be classified (for documentation indexes)_.\n  * **value** (String): _a string representing the basic keyword for the constant. Does not need to be unique throughout GAML_.\n  * **altNames** (set of Strings, empty by default): _an Array of strings, each representing a possible alternative name for the constant. Does not need to be unique throughout GAML_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation attached to this constant_.\n\n\n\n## @doc\nIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.\n\nThis annotation contains:\n  * **value** (String, \"\" by default): _a String representing the documentation of a GAML element_.\n  * **masterDoc** (boolean, false by default): _a boolean representing the fact that this instance of the operator is the master one, that is whether its value will subsume the value of all other instances of it_.\n  * **deprecated** (String, \"\" by default): _a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead_.\n  * **returns** (String, \"\" by default): _the documentation concerning the value(s) returned by this element (if any)._.\n  * **comment** (String, \"\" by default): _an optional comment that will appear differently from the documentation itself_.\n  * **special\\_cases** (set of Strings, empty by default): _an array of String representing the documentation of the \"special cases\" in which the documented element takes part_.\n  * **examples** (set of [@example](#example), empty by default): _an array of String representing some examples or use-cases about how to use this element_.\n  * **usages** (set of [@usage](#usage), empty by default): _An array of usages representing possible usage of the element in GAML_.\n  * **see** (set of Strings, empty by default): _an array of String representing cross-references to other elements in GAML_.\n\n\n## @example\nThis facet describes an example, that can be used either in the documentation, as unit test or as pattern.\n\nThis annotation contains:\n  * **value** (String, \"\" by default): _a String representing the expression as example_.\n  * **var** (String, \"\" by default): _The variable that will be tested in the equals, if it is omitted a default variable will be used_.\n  * **equals** (String, \"\" by default): _The value to which the value will be compared_.\n  * **returnType** (String, \"\" by default): _The type of the value that should be tested_.\n  * **isNot** (String, \"\" by default): _The value to which the value will be compared_.\n  * **raises** (String, \"\" by default): _The exception or warning that the expression could raise_.\n  * **isTestOnly** (boolean, false by default): _specifies that the example should not be included into the documentation_.\n  * **isExecutable** (boolean, true by default): _specifies that the example is correct GAML code that can be executed_.\n  * **test** (boolean, true by default): _specifies that the example is will be tested with the equals_.\n  * **isPattern** (boolean, false by default): _whether or not this example should be treated as part of a pattern (see @usage). If true, the developers might want to consider writing the example line (and its associated lines) using template variables (e.g. ${my_agent})_.\n\t\t\n\n## @facet\nThis facet describes a facet in a list of facets.\n\nThis annotation contains:\n  * **name** (String): _the name of the facet. Must be unique within a symbol_.\n  * **type** (set of int): _the string values of the different types that can be taken by this facet_.\n  * **values** (set of Strings, empty by default): _the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here_.\n  * **optional** (boolean, false by default): _whether or not this facet is optional or mandatory_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation associated to the facet_.\n\n\n\n\n\n## @facets\nThis annotation describes a list of facets used by a statement in GAML.\n\nThis annotation contains:\n  * **value** (set of [@facet](#facet)): array of @facet, each representing a facet name, type..\n  * **ommissible** (string): _the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement)_.\n\n\n## @file\nThis annotation is used to define a type of file.\n\nThis annotation contains:\n  * **name** (String): _a (human-understandable) string describing this type of files, suitable for use in composed operator names (e.g. \"shape\", \"image\"...). This name will be used to generate two operators: name+\"_file\" and \"is_\"+name. The first operator may have variants taking one or several arguments, depending on the @builder annotations present on the class_.\n  * **extensions** (set of Strings): _an array of extensions (without the '.' delimiter) or an empty array if no specific extensions are associated to this type of files (e.g. [\"png\",\"jpg\",\"jpeg\"...]). The list of file extensions allowed for this type of files. These extensions will be used to check the validity of the file path, but also to generate the correct type of file when a path is passed to the generic \"file\" operator_.\n  * **buffer\\_content** (int, ITypeProvider.NONE by default): _the type of the content of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider)_.\n  * **buffer\\_index** (int, ITypeProvider.NONE by default): _the type of the index of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider)_.\n  * **buffer\\_type** (int, ITypeProvider.NONE by default): _the type of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider)_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation attached to this operator_.\n\n\n## @getter\nThis annotations is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars).\n\nThis annotation contains:\n  * **value** (String): the name of the variable for which the annotated method is to be considered as a getter.\n  * **initializer** (boolean, false by default): returns whether or not this getter shoud also be used as an initializer\n\n\n\n\n\n## @inside\nThis annotation is used in conjunction with symbol. Provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used.\n\nThis annotation contains:\n  * **symbols** (set of Strings, empty by default): _symbol names of the parents_.\n  * **kinds** (set of int, empty by default): _generic symbol kinds of the parents (see [ISymbolKind.java](https://github.com/gama-platform/gama/tree/master/msi.gama.processor/src/msi/gama/precompiler/ISymbolKind.java) for more details)_.\n\n\n\n\n\n## @operator\nThis annotation represents an \"operator\" in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.\n\nThis annotation contains:\n  * **value** (set of Strings, empty by default): _names of the operator_.\n  * **category** (set of string, empty by default): _categories to which the operator belong (for documentation purpose)_.\n  * **iterator** (boolean, false by default): _true if this operator should be treated as an iterator (i.e.requires initializing the special variable \"each\" of WorldSkill within the method)_.\n  * **can\\_be\\_const** (boolean, false by default): _if true: if the operands are constant, returns a constant value_.\n  * **content\\_type** (int, ITypeProvider.NONE by default): _the type of the content if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider)_.\n  * **index\\_type** (int, ITypeProvider.NONE by default): _the type of the index if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider)_.\n  * **expected\\_content\\_type** (set of int, empty by default): _if the argument is a container, returns the types expected for its contents. Should be an array of IType.XXX_.\n  * **type** (int, ITypeProvider.NONE by default): _the type of the expression if it cannot be determined at compile time (i.e. when the return type is \"Object\"). Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider)._.\n  * **internal** (boolean, false by default): _returns whether this operator is for internal use only_. \n  * **doc** (set of [@doc](#doc), empty by default): _the documentation attached to this operator._\n\n\n\n\n\n\n## @serializer\nIt allows to declare a custom serializer for Symbols (statements, var declarations, species ,experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be subclasses of the SymbolSerializer class.\n  * **value** (Class): _the serializer class_.\n\n\n\n\n\n\n## @setter\nThis annotations is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars).\n\nThis annotation contains:\n  * **value** (String): the name of the variable for which the annotated method is to be considered as a setter.\n\n\n\n\n\n\n## @skill\nThis annotations Allows to define a new skill (class grouping variables and actions that can be used by agents).\n\nThis annotation contains:\n  * **name** (String): _a String representing the skill name in GAML (must be unique throughout GAML)_.\n  * **attach\\_to** (set of strings): _an array of species names to which the skill will be automatically added (complements the \"skills\" parameter of species)_.\n  * **internal** (boolean, false by default): _return whether this skill is for internal use only_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation associated to the skill_.\n\n\n\n\n\n## @species\nThis annotation represents a \"species\" in GAML. The class annotated with this annotation will be the support of a species of agents.\n\nThis annotation contains:\n  * **name** (string): _the name of the species that will be created with this class as base. Must be unique throughout GAML_.\n  * **skills** (set of strings, empty by default): _An array of skill names that will be automatically attached to this species._ Example: ```\n @species(value=\"animal\" skills={\"moving\"}) ```\n  * **internal** (boolean, false by default): _whether this species is for internal use only_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation attached to this operator._\n\n\n\n\n\n\n## @symbol\nThis annotation represents a \"statement\" in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.\n\nThis annotation contains:\n  * **name** (set of string, empty by default): _names of the statement_.\n  * **kind** (int): _the kind of the annotated symbol (see [ISymbolKind.java](https://github.com/gama-platform/gama/tree/master/msi.gama.processor/src/msi/gama/precompiler/ISymbolKind.java) for more details)_.\n  * **with\\_scope** (boolean, true by default): _indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope_.\n  * **with\\_sequence** (boolean): _indicates wether or not a sequence can or should follow the symbol denoted by this class_.\n  * **with\\_args** (boolean, false by default): _indicates wether or not the symbol denoted by this class will accept arguments_.\n  * **remote\\_context** (boolean, false by default): _indicates that the context of this statement is actually an hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation attached to this symbol_.\n  * **internal** (boolean, false by default): _returns whether this symbol is for internal use only_.\n  * **unique\\_in\\_context** (boolean, false by default): _Indicates that this statement must be unique in its super context (for example, only one return is allowed in the body of an action)._.\n  * **unique\\_name** (boolean, false by default): _Indicates that only one statement with the same name should be allowed in the same super context_.\n\n\n## @type\nIt provides information necessary to the processor to identify a type.\n\nThis annotation contains:\n  * **name** (String, \"\" by default): _a String representing the type name in GAML_.\n  * **id** (int, 0 by default): _the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE\\_TYPE and IType.SPECIES\\_TYPE (exclusive) (cf. [IType.java](https://github.com/gama-platform/gama/tree/master/msi.gama.core/src/msi/gaml/types/IType.java))_.\n  * **wraps** (tab of Class, null by default): _the list of Java Classes this type is \"wrapping\" (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList)_.\n  * **kind** (int, ISymbolKind.Variable.REGULAR by default): _the kind of Variable used to store this type. See [ISymbolKind.Variable](https://github.com/gama-platform/gama/tree/master/msi.gama.processor/src/msi/gama/precompiler/ISymbolKind.java)_.\n  * **internal** (boolean, false by default): _whether this type is for internal use only_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation associated to the facet_.\n\n\n## @usage\nThis replaces @special_cases and @examples, and unifies the doc for operators, statements and others.\nAn @usage can also be used for defining a template for a GAML structure, and in that case requires the following to be defined:\n  * A name (attribute \"name\"), optional, but better\n  * A description (attribute \"value\"), optional\n  * A menu name (attribute \"menu\"), optional\n  * A hierarchical path within this menu (attribute \"path\"), optional\n  * A pattern (attribute \"pattern\" or concatenation of the @example present in \"examples\" that define \"isPattern\" as true)\n\nThis annotation contains:\n  * **value** (String): _a String representing one usage of the keyword. Note that for usages aiming at defining templates, the description is displayed on a tooltip in the editor. The use of the path allows to remove unecessary explanations. For instance, instead of writing : description=\"This template illustrates the use of a complex form of the \"create\" statement, which reads agents from a shape file and uses the tabular data of the file to initialize their attributes\", choose: name=\"Create agents from shapefile\" menu=STATEMENT; path={\"Create\", \"Complex forms\"} description=\"Read agents from a shape file and initialze their attributes\". If no description is provided, GAMA will try to grab it from the context where the template is defined (in the documentation, for example)_.\n  * **menu** (String, \"\" by default): _Define the top-level menu where this template should appear. Users are free to use other names than the provided constants if necessary (i.e. \"My templates\"). When no menu is defined, GAMA tries to guess it from the context where the template is defined_.\n  * **path** (set of Strings, empty be default): The path indicates where to put this template in the menu. For instance, the following annotation: \" menu = STATEMENT; path = {\"Control\", \"If\"} will put the template in a menu called \"If\", within \"Control\", within the top menu \"Statement\". When no path is defined, GAMA will try to guess it from the context where the template is defined (i.e. keyword of the statement, etc.)\n  * **name** (String, \"\" by default): _The name of the template should be both concise (as it will appear in a menu) and precise (to remove ambiguities between templates)_.\n  * **examples** (set of [@example](#example), empty by default): _An array of String representing some examples or use-cases about how to use this element, related to the particular usage above_.\n  * **pattern** (String, \"\" by default): _Alternatively, the contents of the usage can be descried using a @pattern (rather than an array of [@example](#example)). The formatting of this string depends entirely on the user (e.g. including \\n and \\t for indentation, for instance)_.\n\n\n## @validator\nIt allows to declare a custom validator for Symbols (statements, var declarations, species ,experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be subclass of IDescriptionValidator.\n  * **value** (Class): _the validator class_.\n\n\n\n\n\n## @var\nThis annotation is used to describe a single variable or field.\n\nThis annotation contains:\n  * **name** (String): _the name of the variable as it can be used in GAML_.\n  * **type** (int): _The textual representation of the type of the variable (see IType)_.\n  * **of** (int, 0 by default): _The textual representation of the content type of the variable (see IType#defaultContentType())_.\n  * **index** (int, 0 by default): _The textual representation of the index type of the variable (see IType#defaultKeyType())_.\n  * **constant** (boolean, false by default): _returns whether or not this variable should be considered as non modifiable_.\n  * **init** (String, \"\" by default): _the initial value of this variable as a String that will be interpreted by GAML_.\n  * **depend\\_on** (set of Strings, empty by default): _an array of String representing the names of the variables on which this variable depends (so that they are computed before)_.\n  * **internal** (boolean, false by default): _return whether this var is for internal use only_.\n  * **doc** (set of [@doc](#doc), empty by default): _the documentation associated to the variable_.\n\n\n\n\n\n\n## @vars\nThis annotation is used to describe a set of variables or fields.\n\nThis annotation contains:\n  * **value** (set of @var): _an Array of var instances, each representing a variable_.","url":"wiki/DevelopingIndexAnnotations.md"},"DevelopingIScope.md":{"title":" IScope interface","content":"# IScope interface\n\n\n\nAn object of type IScope represents the context of execution of an agent (including experiments, simulations, and \"regular\" agents). Everywhere it is accessible (either passed as a parameter or available as an instance variable in some objects), it provides an easy access to a number of features: the current active agent, the shared random number generator, the global clock, the current simulation and experiment agents, the local variables declared in the current block, etc.\n\nIt also allows modifying this context, like changing values of local variables, adding new variables, although these functions should be reserved to very specific usages. Ordinarily, the scope is simply passed to core methods that allow to evaluate expressions, cast values, and so on.\n\n\n\n\n\n\n## Use of an IScope\n\nA variable `scope` of type `IScope` can be used to:\n  * get the current agent with: `scope.getAgentScope()`\n```\nIAgent agent = scope.getAgentScope();\n```\n  * evaluate an expression in the current scope:\n```\nString mes = Cast.asString(scope, message.value(scope));\n```\n  * know whether the scope has been interrupted:\n```\nboolean b = scope.interrupted();\n```","url":"wiki/DevelopingIScope.md"},"DevelopingOperators.md":{"title":" Developing Operators","content":"# Developing Operators\n\n\n\n[Operators](Operators) in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Developing a new operator allows, then, to add a new function to GAML.\n\n\n\n\n\n\n## Implementation\n\nA new operator can be **any Java method** that:\n  * begins by the [@operator](DevelopingIndexAnnotations#@operator) (other fields can be added to the annotation): `@operator(value = \"name_of_the_operator_gaml\")`,\n```\n@operator(value = \"rgb\")\npublic static GamaColor rgb(final int r, final int g, final int b, final double alpha) {\t\n```\n\nThe method:\n  * must return a value (that has to be one of the GAMA Type: Integer, Double, Boolean, String, IShape, IList, IGraph, IAgent...),\n  * can define any number of parameters, defined using Java type,\n  * can be either static or non-static:\n    * in the case it is static, the number of parameters (except an IScope attribute) of the method is equal to the number of operands of the GAML operator.\n    * in the case it is not static, a first operand is added to the operator with the type of the current class.\n  * can have a IScope parameter, that will be taken into account as operand of the operator.\n\n\n\n\n\n\n## Annotations\n### @operator\nThis annotation represents an \"operator\" in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.\n\nThis annotation contains:\n  * **value** (set of string, empty by default): _names of the operator_.\n  * **content\\_type** (integer) : _if the operator returns a container, type of elements contained in the container_\n  * **can\\_be\\_const** (boolean, false by default): _if true: if the operands are constant, returns a constant value_.\n  * **category** (set of string, empty by default): _categories to which the operator belong (for documentation purpose)_.\n  * **doc** (set of @doc, empty by default): _the documentation attached to this operator._\n\n### @doc\nIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.\n  * **value** (String, \"\" by default): _a String representing the documentation of a GAML element_.\n  * **deprecated** (String, \"\" by default): _a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead_.\n  * **returns** (String, \"\" by default): _the documentation concerning the value(s) returned by this element (if any)._.\n  * **comment** (String, \"\" by default): _an optional comment that will appear differently from the documentation itself_.\n  * **special\\_cases** (set of Strings, empty by default): _an array of String representing the documentation of the \"special cases\" in which the documented element takes part_.\n  * **examples** (set of Strings, empty by default): _an array of String representing some examples or use-cases about how to use this element_.\n  * **see** (set of Strings, empty by default): _an array of String representing cross-references to other elements in GAML_.\n\nAll these annotations are defined in the `GamlAnnotations.java` file of the `msi.gama.processor` plug-in.","url":"wiki/DevelopingOperators.md"},"DevelopingPlugins.md":{"title":" Developing Plugins","content":"# Developing Plugins\n\n\n\nThis page details how to create a new plug-in in order to extend the GAML language with new skills, species, displays or operators.\nIt also details how to create a plug-in that can be  uploaded on an update site and can be installed into the GAMA release.\nWe consider here that the developer version of GAMA has been installed (as detailled in [this page](InstallingGitVersion)).\n\n\n\n\n\n\n## Creation of a plug-in\n\nHere are detailled steps to create and configure a new GAMA plug-in.\n\n  * File > New > Project > plug-in project\n  * In the \"New plug-in Project\" / \"Plug-in project\" window:\n    * Choose as **name** « name\\_of\\_the\\_plugin » (or anything else)\n    * Check \"Use défaut location\"\n    * Check \"Create a Java Project\"\n    * The project should be targeted to run with Eclipse\n    * working set is unchecked\n    * Click on \"Next\"\n  * In the \"New plug-in Project\" / \"Content\" window:\n    * Id : could contain the name of your institution and/or your project, e.g. « irit.maelia.gaml.additions »\n    * version 1.0.0.qualifier (this latter mention is important if you plan on distributing the plugin on GAMA update site)\n    * Name « Additions to GAML from Maelia project »\n    * Uncheck \"Generate an activator, a Java class that controls the plug-in's life cycle\" ,\n    * Uncheck \"This plug-in will make contributions to the UI\"\n    * Check \"No\" when its asks \"Would you like to create a rich client application ?\"\n    * Click on \"Next\"\n  * In the \"New plug-in Project\" / \"Templates\" window:\n    * Uncheck \"Create a plug-in using one of the templates\"\n    * Click on \"Finish\"\n\nYour plug-in has been created.\n\n  * Edit the file \"Manifest.MF\":\n    * Overview pane:\n      * check « This plug-in is a singleton »\n    * Dependencies pane:\n      * add (at least minimum) the three plug-ins \"msi.gama.core\", \"msi.gama.ext\" and \"msi.gama.processor\" in the \"Required Plug-ins\". When you click on \"Add\", a new window will appear without any plug-in. Just write the beginning of the plug-in name in the text field under \"Select a plug-in\".\n    * Runtime pane:\n      * In exported Packages: nothing (but when you will have implemented new packages in the plug-in you should add them there)\n      * Add in the classpath all the additional libraries (.jar files) used in the project.\n    * Extensions pane:\n      * \"Add\" \"gaml.extension\"\n    * Save the file. This should create a \"plugin.xml\" file.\n\n  * Select the project and in menu Project > Properties:\n    * Java Compiler  > Annotation Processing: check \"Enable project specific settings\", then in \"Generated Source Directory\", change \".apt\\_generated\" in \"gaml\",\n    * Java Compiler  > Annotation Processing > Factory path: check \"Enable project specific settings\", then \"Add Jars\" and choose \"msi.gama.processor/processor/plugins/msi.gama.processor.1.4.0.jar\"\n    * Close the menu. It should compile the project and create the `gaml` directory.\n    * Return in the Project > Properties Menu.\n    * In Java Buildpath  > Source, check that the gaml directory has been added. Otherwise click on Add Folder and select the gaml directory\n\n\nThe plug-in is ready to accept any addition to the GAML language, e.g. skills, actions, operators.\n\nDo not forget to export the created packages that could be used by \"clients\", especially the packages containing the code of the additions (in the plugin.xml of the new project, tab \"Runtime\").\n\nTo test the plug-in and use it into GAMA, developers have to define a new feature project containing your plugin and its dependencies, and adds this feature to the existing product (or a new .product file of your own).\nThe use of feature is also mandatory to define a plug-in that can be uploaded on the update site and can be installed in the release of GAMA.\n\n\n\n\n\n## Creation of a feature\n\nA feature is an Eclipse project dedicated to gather one or several plug-ins to integrate them into a product or to deploy them on the update site and install them from the GAMA release (a feature is mandatory in this case).\n\nHere are detailled steps to create and configure a new feature.\n\n  * File > New > Feature project (or File > New > Project... then  Plug-in Development > Feature Project)\n  * In Feature properties\n    * Choose a project name (e.g. \"institution.gama.feature.pluginsName\")\n    * Click on \"Next\"\n  * In Referenced Plug-ins and fragments\n    * Check \"Initialize from the plug-ins list:\"\n    * Choose the plug-ins that have to be gathered in the feature\n    * Click on \"Finish\"\n  * A new project has been created. The \"feature.xml\" file will configure the feature.\n    * In \"Information pane\":\n      * You can add description of the various plug-ins of the feature, define the copyright notice and the licence.\n    * In \"Plug-ins and Fragments\"\n      * In the Plug-ins and Fragments, additional plug-ins can be added.\n\n\n\n\n\n## Addition of a feature to the product\n\nIn the product, e.g. `gama.product` in the `ummisco.gama.product` project:\n  * Contents pane\n    * Click on Add button\n    * In the window select the feature\n    * Click on OK.\n\n**Remark:** To check whether the new plug-in has been taken into account by GAMA, after GAMA launch, it should appear in the Eclipse console in a line beginning by \">> GAMA bundle loaded in \".\n\n\n\n\n\n## How to make a plug-in available at GAMA update site for the GAMA release \n\nConsidering a working GAMA plugin named institution.gama.pluginsName\n\n### Configure plugin to be available for Maven\n\na/ Add pom.xml for plugin institution.gama.pluginsName :\n* Right click -> Configure -> Convert to maven project to add pom.xml:\n* Set:\n  * Group id: institution.gama.pluginsName\n  * Artifact id: institution.gama.pluginsName\n  * Version: 1.0.0-SNAPSHOT // must have -SNAPSHOT if the plugin version is x.x.x.qualifier\n  * Packaging: eclipse-plugin\n* Finish\n\nb/ Configure pom.xml to recognize the parent pom.xml for Maven builds\n* Open pom.xml in institution.gama.pluginsName\n* Tab overview, Parent section, type in:\n  * Group id: msi.gama\n  * Artifact id: msi.gama.experimental.parent\n  * Version: 1.7.0-SNAPSHOT\n  * Relative path: ../msi.gama.experimental.parent\n* Save\n\nc/ Update maven cache in eclipse (optional)\nIt will fix this compilation error \"Project configuration is not up-to-date with pom.xml. Select: Maven->Update Project... from the project context menu or use Quick Fix.\"\n* Right click -> Maven -> Update project\n\n\n### Create a feature for the plugin\n\na/ Create new feature\n* New -> Project -> type in : feature -> Select \"Feature Project\"\n* Set:\n  * Project name: institution.gama.feature.pluginsName\n  * Uncheck use default location, type in: {current git repository}\\aaa.bbb.feature.ccc \n  * Feature Version: 1.0.0.qualifier\n  * Update Site URL: http://updates.gama-platform.org/experimental\n  * Update Site Name: GAMA 1.7.x Experimental Plugins Update Site\n* Click Next\n  * Initialize from the plugin list -> check all plugins needed:\n    institution.gama.pluginsName (1.0.0.qualifier)\n* Finish\n\nb/  Add pom.xml for feature institution.gama.feature.pluginsName :\n\n* Right click -> Configure -> Convert to maven project (to add pom.xml)\n* Set:\n  * Group id: institution.gama.feature.pluginsName\n  * Artifact id: institution.gama.feature.pluginsName\n  * Version: 1.0.0-SNAPSHOT \n  * Packaging: eclipse-feature\n* Finish\n\nc/ Configure pom.xml to recognize the parent pom.xml for Maven builds\n* Open pom.xml in institution.gama.pluginsName\n* Tab overview, Parent section, type in:\n  * Group id: msi.gama\n  * Artifact id: msi.gama.experimental.parent\n  * Version: 1.7.0-SNAPSHOT\n  * Relative path: ../msi.gama.experimental.parent\n* Save\n\nd/ Update maven cache in eclipse (optional)\nIt will fix this compilation error \"Project configuration is not up-to-date with pom.xml. Select: Maven->Update Project... from the project context menu or use Quick Fix.\"\n* Right click -> Maven -> Update project\n\n\n### Update p2updatesite category.xml (this step will be done automatically by travis, soon)\nOpen msi.gama.experimental.p2updatesite\n* Tab Managing the Categories -> Add feature -> institution.gama.feature.pluginsName\n\n\n\n\n\n\n\n\n\n\n\n\n\n## How to make a plug-in available as an extension for the GAMA release (obsolete)\n\nOnce the plug-in has been tested in the GAMA SVN version, it can be made available for GAMA release users.\n\nFirst, the `update_site` should be checked out from the SVN repository:\n  * File > New > Other... > SVN > Project from SVN\n  * In Checkout Project from SVN repository\n    * Use existing repository location (it is the same location as for the GAMA code)\n    * Next\n  * In Select resource:\n    * Browse\n      * choose svn > update\\_site\n    * Finish\n  * Finish\n\nNow the update\\_site project is available in the project list (in Package Explorer).\nThe sequel describes how to add a new feature to the update site.\n  * Open the `site.xml` file\n  * In update site Map:\n    * Click on Extensions\n    * click on the Add Feature... button\n      * Choose the feature to be added\n      * It should appear in Extensions\n    * Select the added feature and click on the Synchronize... button\n      * Check Synchronize selected features only\n      * Finish\n    * Select the added feature and click on the Build button\n  * All the files and folder of the update\\_site project have been modified.\n  * Commit all the modifications on the SVN repository\n    * Richt-click on the project, Team > Update\n    * Richt-click on the project, Team > Commit...\n\nThe plug-in is now available as an extension from the GAMA release.\nMore details about the update of the GAMA realease are available [on the dedicated page](Updating).","url":"wiki/DevelopingPlugins.md"},"DevelopingSkills.md":{"title":" Developing a New Skill","content":"# Developing a New Skill\n\n\n\nA skill adds new features (attributes) and new capabilities (actions) to the instances of the species that use it.\n\n\n\n\n\n## Defining the class\n\nA Skill is basically a **singleton** and **stateless** Java class that:\n  * extends the abstract class `Skill`,\n  * begins by the annotation [@skill](DevelopingIndexAnnotations#@skill): `@skill(name = \"name_of_the_skill_in_gaml\")`.\n\nNote: GAMA annotations are classes defined into the `msi.gama.precompiler.GamlAnnotations` class.\n\n\n\n\n\n## Defining new attributes\n\nTo add new attributes to the species that declares this skill, developers have to define them before the class using the [@vars](DevelopingIndexAnnotations#@vars) and `@var` annotations.\nThe `@vars` annotation contains a set of `@var` elements.\n\nIn a [@var](DevelopingIndexAnnotations#@var) element, one has to define the name, the type and the default value of the attribute. For example in MovingSkill:\n```\n@vars({\n  @var(name = IKeyword.SPEED, type = IType.FLOAT, init = \"1.0\"),\n  @var(name = IKeyword.HEADING, type = IType.INT, init = \"rnd(359)\")\n})\n```\n\nIn order to detail how to access these new attributes (if needed), developers have to define a getter (using `@getter`) and a setter (using `@setter`) methods.\nIf no getter (and setter) is defined, the attribute can nevertheless be set and get, using implicit by default getter and setter. But as soon as a getter and/or a setter is defined, they replace the implicit default ones.\nFor example:\n```\n@getter(var = IKeyword.SPEED)\npublic double getSpeed(final IAgent agent) {\n    return (Double) agent.getAttribute(IKeyword.SPEED);\n}\n\n@setter(IKeyword.SPEED)\npublic void setSpeed(final IAgent agent, final double s) {\n    agent.setAttribute(IKeyword.SPEED, s);\n}\n```\n\n\n\n\n\n## Defining new actions\nAn action (also called `primitive`) is basically a Java method that can be called from the GAML language using the same syntax as the one used for calling actions defined in a model. The method should be annotated with `@action`, supplying the name of the action as it will be available in GAML.\n\nThe developer can also define parameters for this action using the annotation `@arg` will a set of parameters names. For example, the action `goto` of the MovingSkill is defined as follows:\n```\n@action(name=\"goto\", args={ \n    @arg(name = \"target\", type = { IType.AGENT, IType.POINT,IType.GEOMETRY }, optional = false),\n    @arg(name = IKeyword.SPEED, type = IType.FLOAT, optional = true),\n    @arg(name = \"on\", type = { IType.GRAPH }, optional = true)\n    }\n)\n\npublic IPath primGoto(final IScope scope) throws GamaRuntimeException {\n...\n}\n```\nIt is called in GAMA models with:\n```\ndo goto (target: the_target, on: the_graph);\n```\nor\n```\npath path_followed <- self goto (target: the_target, on: the_graph, return_path: true);\n```\n\n\n\n\n\n### Access to parameters in actions\nTo get the value of the arguments passed in GAML to the Java code, two methods can be useful:\n  * `scope.hasArg(\"name_of_argument\")` returns a boolean value testing whether the argument \"name\\_of\\_argument\" has been defined by the modeler, since all the arguments to actions should be considered as optional.\n  * `getArg(name_arg,IType)`, `getFloatArg(name_param_of_float)`, `getIntArg(name_param_of_int)` and their variants return the value of the given parameter using a given (or predefined) type to cast it.\n\n\n\n\n\n### Warnings\nDevelopers should notice that:\n  * the method associated with an action has to return a non-void object.\n  * the method should have only one parameter: the scope (type IScope).\n  * the method can only throw `GamaRuntimeException`s. Other exceptions should be caught in the method and wrapped in a `GamaRuntimeException` before being thrown.\n\n\n\n\n\n## Annotations\n### @skill\nThis annotations Allows to define a new skill (class grouping variables and actions that can be used by agents).\n\nThis annotation contains:\n  * **name** (String): _a String representing the skill name in GAML (must be unique throughout GAML)_.\n  * **attach\\_to** (set of strings): _an array of species names to which the skill will be automatically added (complements the \"skills\" parameter of species)_.\n  * **internal** (boolean, false by default): _return whether this skill is for internal use only_.\n  * **doc** (set of @doc, empty by default): _the documentation associated to the skill_.\n\n\n### @var\nThis annotations is used to describe a single variable or field.\n\nThis annotation contains:\n  * **name** (String): _the name of the variable as it can be used in GAML_.\n  * **type** (int): _The textual representation of the type of the variable (see IType)_.\n  * **of** (int, 0 by default): _The textual representation of the content type of the variable (see IType#defaultContentType())_.\n  * **index** (int, 0 by default): _The textual representation of the index type of the variable (see IType#defaultKeyType())_.\n  * **constant** (int, false by default): _returns whether or not this variable should be considered as non modifiable_.\n  * **init** (String, \"\" by default): _the initial value of this variable as a String that will be interpreted by GAML_.\n  * **depend\\_on** (set of Strings, empty by default): _an array of String representing the names of the variables on which this variable depends (so that they are computed before)_.\n  * **internal** (boolean, false by default): _return whether this var is for internal use only_.\n  * **doc** (set of @doc, empty by default): _the documentation associated to the variable_.\n\n### @doc\nIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.\n  * **value** (String, \"\" by default): _a String representing the documentation of a GAML element_.\n  * **deprecated** (String, \"\" by default): _a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead_.\n  * **returns** (String, \"\" by default): _the documentation concerning the value(s) returned by this element (if any)._.\n  * **comment** (String, \"\" by default): _an optional comment that will appear differently from the documentation itself_.\n  * **special\\_cases** (set of Strings, empty by default): _an array of String representing the documentation of the \"special cases\" in which the documented element takes part_.\n  * **examples** (set of Strings, empty by default): _an array of String representing some examples or use-cases about how to use this element_.\n  * **see** (set of Strings, empty by default): _an array of String representing cross-references to other elements in GAML_.\n\n### @getter\nThis annotations is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars).\n\nThis annotation contains:\n  * **value** (String): the name of the variable for which the annotated method is to be considered as a getter.\n  * **initializer** (boolean, false by default): returns whether or not this getter should also be used as an initializer\n\n### @setter\nThis annotations is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars).\n\nThis annotation contains:\n  * **value** (String): the name of the variable for which the annotated method is to be considered as a setter.\n\n### @action\nThis annotations is used to tag a method that will be considered as an action (or primitive) in GAML.\nThe method must have the following signature: ```\nObject methodName(IScope) throws GamaRuntimeException ``` and be contained in a class annotated with @species or @skill (or a related class, like a subclass or an interface).\n\nThis annotation contains:\n  * **name** (String): _the name of the variable as it can be used in GAML_.\n  * **virtual** (boolean, false by default): _if true the action is virtual, i.e. equivalent to abstract method in java_.\n  * **args** (set of arg, empty by default): _the list of arguments passed to this action. Each argument is an instance of arg_.\n  * **doc** (set of @doc, empty by default): _the documentation associated to the action_.\n\n### @arg\nThis annotations describes an argument passed to an action.\n\nThis annotation contains:\n  * **name** (String, \"\" by default): _the name of the argument as it can be used in GAML_.\n  * **type** (set of ints, empty by default): _An array containing the textual representation of the types that can be taken by the argument (see IType)_.\n  * **optional** (boolean, true by default): _whether this argument is optional or not_.\n  * **doc** (set of @doc, empty by default): _the documentation associated to the argument._\n\n\n\nAll these annotations are defined in the `GamlAnnotations.java` file of the `msi.gama.processor` plug-in.","url":"wiki/DevelopingSkills.md"},"DevelopingSpecies.md":{"title":" Developing Species","content":"# Developing Species\n\n\n\nAdditional [built-in species](BuiltInSpecies) can be defined in Java in order to be used in GAML models. Additional attributes and actions can be defined. It could be very useful in order to define its behavior thanks to external libraries (e.g. [mulit-criteria decision-making](OtherBuiltInSpecies), [database connection](OtherBuiltInSpecies)...).\n\nA new built-in species extends the `GamlAgent` class, which defines the basic GAML agents. As a consequence, new built-in species have all the attributes (`name`, `shape`, ...) and actions (`die`...) of [regular species](AgentBuiltIn).\n\n\n\n\n\n\n## Implementation\n\nA new species can be **any Java class** that:\n  * extends the `GamlAgent` class,\n  * begins by the [@species](DevelopingIndexAnnotations#@species): `@species(name = \"name_of_the_species_gaml\")`,\n```\n@species(name = \"multicriteria_analyzer\")\npublic class MulticriteriaAnalyzer extends GamlAgent {\n```\n\n[Similarly to skills](DevelopingSkills), a species can define additional attributes and actions.\n\n### Additional attributes\n\nDefining new attributes needs:\n  * to add [@vars](DevelopingIndexAnnotations#@vars) (and one embedded [@var](DevelopingIndexAnnotations#@var) per additional attribute) annotation on top of the class,\n  * to define [@setter](DevelopingIndexAnnotations#@setter) and [@getter](DevelopingIndexAnnotations#@getter) annotations to the accessors methods.\n\nFor example, regular species are defined with the following annotation:\n```\n@vars({ @var(name = IKeyword.NAME, type = IType.STRING), @var(name = IKeyword.PEERS, type = IType.LIST),\n\t@var(name = IKeyword.HOST, type = IType.AGENT),\n\t@var(name = IKeyword.LOCATION, type = IType.POINT, depends_on = IKeyword.SHAPE),\n\t@var(name = IKeyword.SHAPE, type = IType.GEOMETRY) })\n```\n\nAnd accessors are defined using:\n```\n@getter(IKeyword.NAME)\npublic abstract String getName();\n\n@setter(IKeyword.NAME)\npublic abstract void setName(String name);\n```\n\n### Additional actions\n\nAn additional action is a method annotated by the [@action](DevelopingIndexAnnotations#@action) annotation.\n```\n@action(name = ISpecies.stepActionName)\npublic Object _step_(final IScope scope) {\n```\n\n\n\n\n\n\n## Annotations\n### @species\nThis annotation represents a \"species\" in GAML. The class annotated with this annotation will be the support of a species of agents.\n\nThis annotation contains:\n  * **name** (string): _the name of the species that will be created with this class as base. Must be unique throughout GAML_.\n  * **skills** (set of strings, empty by default): _An array of skill names that will be automatically attached to this species._ Example: ```\n @species(value=\"animal\" skills={\"moving\"}) ```\n  * **internal** (boolean, false by default): _whether this species is for internal use only_.\n  * **doc** (set of @doc, empty by default): _the documentation attached to this operator._\n\nAll these annotations are defined in the `GamlAnnotations.java` file of the `msi.gama.processor` plug-in.","url":"wiki/DevelopingSpecies.md"},"DevelopingStatements.md":{"title":" Developing Statements","content":"# Developing Statements\n\n\n\nStatements are a fundamental part of GAML, as they represent both commands (imperative programming style) or declarations (declarative programming style). Developing a new statement allows, then, to add a new instruction to GAML.\n\n\n\n\n\n\n## Defining the class\n\nA new statement must be a Java class that:\n  * either implements the interface `IStatement` or extends an existing implementation of this interface (like `AbstractStatement` or `AbstractSequenceStatement`).\n  * begins by the 2 following mandatory annotations:\n    * [@symbol](DevelopingIndexAnnotations#@symbol): `@symbol(name = \"name_of_the_statement_gaml\", kind = \"kind_of_statement\", with_sequence = true/false)`,\n    * [@inside](DevelopingIndexAnnotations#@inside): `@symbol(kinds = {\"kind_of_statement_1\",\"kind_of_statement_2\",\"...\"}`\n\nIn addition the 4 following optional annotations can be added:\n  * [@facets](DevelopingIndexAnnotations#@facets): to describe the set of [@facet](DevelopingIndexAnnotations#@facet) annotations,\n  * [@doc](DevelopingIndexAnnotations#@doc): to document the statement.\n  * [@serializer](DevelopingIndexAnnotations#@serializer): in addition, statements can benefit from a custom serializer, by declaring `@serializer(CustomSerializer.class)`, with a class extending `SymbolSerializer`.\n  * [@validator](DevelopingIndexAnnotations#@validator): in addition, statements can benefit from a custom validation during the validation process, by declaring `@validator(CustomValidator.class)` with a class implementing `IDescriptionValidator` as value. This class will receive the `IDescription` of the statement and be able to execute further validations on the type of expressions, etc. or even to change the `IDescription`  (by adding new information, changing the value of facets, etc.).\n\nNote: GAMA annotations are classes defined into the `msi.gama.precompiler.GamlAnnotations` class.\n\n\n\n\n\n## Examples\n\n### The `write` statement\n\nThe `write` statement is an example of a SINGLE\\_STATEMENT (i.e. statement that does not embed a sequence of statements).\nIt can used inside a BEHAVIOR statement (i.e. `reflex`, `init`...), a SEQUENCE\\_STATEMENT (e.g. `loop`, `ask`, `if`...) or a LAYER statement.\nIt defines a single facet (\"message\") mandatory and omissible.\n```\n@symbol(name = IKeyword.WRITE, kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false)\n@inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT, ISymbolKind.LAYER })\n@facets(value = { \n        @facet(name = IKeyword.MESSAGE, type = IType.NONE, optional = false) \n   }, omissible = IKeyword.MESSAGE)\npublic class WriteStatement extends AbstractStatement {\n```\n\n### The `aspect` statement\n\nThe `aspect` statement defines an example of BEHAVIOR statement (i.e. a statement that can written at the same level as `init`, `reflex`...), containing a sequence of embedded statements. It can only be used inside a `species` statement (i.e. the definition of a new species) and the `global` block. It defines a single facet `name` mandatory and omissible.\n```\n@symbol(name = { IKeyword.ASPECT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true)\n@inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.MODEL })\n@facets(value = { @facet(name = IKeyword.NAME, type = IType.ID, optional = true) \n   }, omissible = IKeyword.NAME)\npublic class AspectStatement extends AbstractStatementSequence {\n```\n\n### The `action` statement\n\nThe `action` statement defines an example of ACTION statement containing a sequence of embedded statements and that can have arguments.\nIt can be used (to define an action) in any species, experiment or global statement. It defines several facets and uses a custom validator and a custom serializer.\n```\n@symbol(name = IKeyword.ACTION, kind = ISymbolKind.ACTION, with_sequence = true, with_args = true, unique_name = true)\n@inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL })\n@facets(value = {\n\t@facet(name = IKeyword.NAME, type = IType.ID, optional = false),\n\t@facet(name = IKeyword.TYPE, type = IType.TYPE_ID, optional = true, internal = true),\n\t@facet(name = IKeyword.OF, type = IType.TYPE_ID, optional = true, internal = true),\n\t@facet(name = IKeyword.INDEX, type = IType.TYPE_ID, optional = true, internal = true),\n\t@facet(name = IKeyword.VIRTUAL, type = IType.BOOL, optional = true) \n    }, omissible = IKeyword.NAME)\n@validator(ActionValidator.class)\n@serializer(ActionSerializer.class)\npublic class ActionStatement extends AbstractStatementSequenceWithArgs {\n```\n\n\n\n\n\n\n## Implementation\n\nAll the statements inherits from the abstract class `AbstractStatement`. Statements with a sequence of embedded statements inherit from the class `AbstractStatementSequence` (which extends `AbstractStatement`).\n\nThe main methods of a statement class are:\n  * its constructor, that is executed at the compilation of the model.\n  * `executeOn(final IScope scope)`, it executes the statement on a given scope. **This method is executed at each call of the statement in the model**,\n  * `privateExecuteIn(IScope scope)`: the `executeOn(final IScope scope)` method implemented in `AbstractStatement` does some verification and call the `privateExecuteIn(IScope scope)` method to perform the statement. **The execution of any statement should be redefined in this method.**\n\n\n### Define a SINGLE\\_STATEMENT statement\n\nTo define a SINGLE\\_STATEMENT statement that can be executed in any behavior and sequence of statements and with 2 facets, we first define a new Java class that extends `AbstractStatement` such as:\n```\n@symbol(name = \"testStatement\", kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false)\n@inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT})\n@facets(value = { \n        @facet(name = IKeyword.NAME, type = IType.NONE, optional = false),\n        @facet(name = \"test_facet\", type = IType.NONE, optional = true)     \n   }, omissible = IKeyword.NAME)\npublic class SingleStatementExample extends AbstractStatement {\n```\n\nThe class should at least implement:\n  * a **constructor**: the constructor is called at the compilation. It is usually used to get the expressions given to the facets (using the `getFacet(String)` method) and to store it into an attribute of the class.\n```\nfinal IExpression name;\n\npublic SingleStatementExample(final IDescription desc) {\n\tsuper(desc);\n\tname = getFacet(IKeyword.NAME);\n}\n```\n  * the **method privateExecuteIn**: this method is executed each time the statement is called in the model.\n```\nprotected Object privateExecuteIn(IScope scope) throws GamaRuntimeException { \n\tIAgent agent = stack.getAgentScope();\n\tString nameStr = null;\n\tif ( agent != null && !agent.dead() ) {\n\t\tnameStr = Cast.asString(stack, name.value(stack));\n\t\tif ( nameStr == null ) {\n\t\t\tnameStr = \"nil\";\n\t\t}\n\t\tGuiUtils.informConsole(nameStr);\n\t}\n\treturn nameStr;\n}  \n```\nThe variable `scope` of type `IScope` can be used to:\n  * get the current agent with: `scope.getAgentScope()`\n  * evaluate an expression in the current scope: `Cast.asString(scope, message.value(scope))`\n\n\n### Define a statement with sequence\n\nThis kind of statements includes SEQUENCE\\_STATEMENT (e.g. `if`, `loop`,...), BEHAVIOR (e.g. `reflex`,...)...\n\nSuch a statement is defined in a class extending the `AbstractStatementSequence` class, e.g.:\n```\n@symbol(name = { IKeyword.REFLEX, IKeyword.INIT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true)\n@inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL })\n@facets(value = { @facet(name = IKeyword.WHEN, type = IType.BOOL, optional = true),\n\t@facet(name = IKeyword.NAME, type = IType.ID, optional = true) }, omissible = IKeyword.NAME)\n@validator(ValidNameValidator.class)\n\npublic class ReflexStatement extends AbstractStatementSequence {\n```\n\nThis class should only implement a constructor. The class `AbstractStatementSequence` provides a generic implementation for:\n  * `privateExecuteIn(IScope scope)`: it executes each embedded statement with the scope.\n  * `executeOn(final IScope scope)`: it executes the statement with a given scope.\n\n\n### Additional methods that can implemented\n\nThe following methods have a default implementation, but can be overridden if necessary:\n  * the **`String getTrace(final IScope scope)` method** is called to trace the execution of statements using [trace statement](Statements#trace).\n```\npublic String getTrace(final IScope scope) {\n\t// We dont trace write statements\n\treturn \"\";\n} \n```\n  * the `setChildren(final List<? extends ISymbol> commands)` is used to define which are the statement children to the sequence statement. By default, all the embedded statements are taken as children\n\n\n\n\n\n## Annotations\n### @symbol\nThis annotation represents a \"statement\" in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.\n\nThis annotation contains:\n  * **name** (set of string, empty by default): _names of the statement_.\n  * **kind** (int): _the kind of the annotated symbol (see [ISymbolKind.java](https://github.com/gama-platform/gama/tree/master/msi.gama.processor/src/msi/gama/precompiler/ISymbolKind.java) for more details)_.\n  * **with\\_scope** (boolean, true by default): _indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope_.\n  * **with\\_sequence** (boolean): _indicates wether or not a sequence can or should follow the symbol denoted by this class_.\n  * **with\\_args** (boolean, false by default): _indicates wether or not the symbol denoted by this class will accept arguments_.\n  * **remote\\_context** (boolean, false by default): _indicates that the context of this statement is actually an hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context_.\n  * **doc** (set of @doc, empty by default): _the documentation attached to this symbol_.\n\n### @inside\nThis annotation is used in conjunction with symbol. Provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used.\n\nThis annotation contains:\n  * **symbols** (set of Strings, empty by default): _symbol names of the parents_.\n  * **kinds** (set of int, empty by default): _generic symbol kinds of the parents (see [ISymbolKind.java](https://github.com/gama-platform/gama/tree/master/msi.gama.processor/src/msi/gama/precompiler/ISymbolKind.java) for more details)_.\n\n### @facets\nThis annotation describes a list of facets used by a statement in GAML.\n\nThis annotation contains:\n  * **value** (set of @facet): array of @facet, each representing a facet name, type..\n  * **ommissible** (string): _the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement)_.\n\n### @facet\nThis facet describes a facet in a list of facets.\n\nThis annotation contains:\n  * **name** (String): _the name of the facet. Must be unique within a symbol_.\n  * **type** (set of Strings): _the string values of the different types that can be taken by this facet_.\n  * **values** (set of Strings): _the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here_.\n  * **optional** (boolean, false by default): _whether or not this facet is optional or mandatory_.\n  * **doc** (set of @doc, empty by default): _the documentation associated to the facet_.\n\n### @doc\nIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.\n  * **value** (String, \"\" by default): _a String representing the documentation of a GAML element_.\n  * **deprecated** (String, \"\" by default): _a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead_.\n  * **returns** (String, \"\" by default): _the documentation concerning the value(s) returned by this element (if any)._.\n  * **comment** (String, \"\" by default): _an optional comment that will appear differently from the documentation itself_.\n  * **special\\_cases** (set of Strings, empty by default): _an array of String representing the documentation of the \"special cases\" in which the documented element takes part_.\n  * **examples** (set of Strings, empty by default): _an array of String representing some examples or use-cases about how to use this element_.\n  * **see** (set of Strings, empty by default): _an array of String representing cross-references to other elements in GAML_.\n\n### @serializer\nIt allows to declare a custom serializer for Symbols (statements, var declarations, species ,experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be sublasses of the SymbolSerializer class.\n  * **value** (Class): _the serializer class_.\n\n### @validator\nIt allows to declare a custom validator for Symbols (statements, var declarations, species ,experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be subclass of IDescriptionValidator.\n  * **value** (Class): _the validator class_.\n\nAll these annotations are defined in the `GamlAnnotations.java` file of the `msi.gama.processor` plug-in.","url":"wiki/DevelopingStatements.md"},"DevelopingTypes.md":{"title":" Developing Types","content":"# Developing Types\n\n\n\nGAML provides a given number of built-in simple types (int, bool...) and more complex ones (path, graph...).\nDeveloping a new type allows, then, to add a new data structure to GAML.\n\n\n\n\n\n\n## Implementation\nDeveloping a new type requiers the implementation of 2 Java files:\n  * the first one that describes the data structure (e.g.: `GamaColor.java` to define a type color)\n  * the second one that implements the type itself, wrapping the data structure file (e.g.: `GamaColorType.java`), and providing accessors to data structure attributes.\n\n## The data structure file\n\nThe class representing the data structure is a Java class annotated by:\n  * a [@vars](DevelopingIndexAnnotations#@vars) annotation to describe the attributes of a complex type. The `@vars` annotation contains a set of `@var` elements.\n```\n@vars({ @var(name = IKeyword.COLOR_RED, type = IType.INT), @var(name = IKeyword.COLOR_GREEN, type = IType.INT),\n\t@var(name = IKeyword.COLOR_BLUE, type = IType.INT), @var(name = IKeyword.ALPHA, type = IType.INT),\n\t@var(name = IKeyword.BRIGHTER, type = IType.COLOR), @var(name = IKeyword.DARKER, type = IType.COLOR) })\npublic class GamaColor extends Color implements IValue {\n```\n\nIt can contain setter and/or getter for each of its attributes. Setters and getters are methods annotated by the [@getter](DevelopingIndexAnnotations#@getter) or [@setter](DevelopingIndexAnnotations#@setter) annotations.\n```\n@getter(IKeyword.COLOR_RED)\npublic Integer red() {\n\treturn super.getRed();\n}\n```\n\nIn addition it is recommended that this class implements the `IValue` interface. It provides a clean way to give a string representation of the type and thus eases good serialization of the object.\nTo this purpose the following method needs to be implemented:\n```\npublic abstract String stringValue(IScope scope) throws GamaRuntimeException;\n```\n\n## The type file\n\nThe class representing the type is a Java class such that:\n  * the class should be annotated by the [@type](DevelopingIndexAnnotations#@type) annotation,\n  * the class should extend the class `GamaType<DataStructureFile>` (and thus implement its 3 methods),\n\n\nExample (from [GamaFloatType.java](https://github.com/gama-platform/gama/tree/master/msi.gama.core/src/msi/gaml/types/GamaFloatType.java)):\n```\n@type(name = IKeyword.FLOAT, id = IType.FLOAT, wraps = { Double.class, double.class }, kind = ISymbolKind.Variable.NUMBER)\n```\n\n### Inheritance from the `GamaType<T>` class\nEach java class aiming at implement a type should inherit from the GamaType abstract class.\nExample (from [GamaColorType.java](https://github.com/gama-platform/gama/tree/master/msi.gama.core/src/msi/gaml/types/GamaColorType.java)):\n```\npublic class GamaColorType extends GamaType<GamaColor>\n```\n\nThis class imposes to implement the three following methods (with the example of the GamaColorType):\n  * `public boolean canCastToConst()`\n  * `public GamaColor cast(IScope scope, Object obj, Object param)`: the way to cast any object in the type,\n  * `public GamaColor getDefault()`: to define the default value of a variable of the current type.\n\nRemark: for each type, an unary operator is created with the exact name of the type. It can be used to cast any expression in the given type.\nThis operator calls the previous `cast` method.\n\n\n\n\n\n## Annotations\n\n### @type\nIt provides information necessary to the processor to identify a type.\n\nThis annotation contains:\n  * **name** (String, \"\" by default): _a String representing the type name in GAML_.\n  * **id** (int, 0 by default): _the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE\\_TYPE and IType.SPECIES\\_TYPE (exclusive) (cf. [IType.java](https://github.com/gama-platform/gama/tree/master/msi.gama.core/src/msi/gaml/types/IType.java))_.\n  * **wraps** (tab of Class, null by default): _the list of Java Classes this type is \"wrapping\" (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList)_.\n  * **kind** (int, ISymbolKind.Variable.REGULAR by default): _the kind of Variable used to store this type. See [ISymbolKind.Variable](https://github.com/gama-platform/gama/tree/master/msi.gama.processor/src/msi/gama/precompiler/ISymbolKind.java)_.\n  * **internal** (boolean, false by default): _whether this type is for internal use only_.\n  * **doc** (set of @doc, empty by default): _the documentation associated to the facet_.\n\nAll these annotations are defined in the file [GamlAnnotations.java](https://github.com/gama-platform/gama/tree/master/msi.gama.processor/src/msi/gama/precompiler/GamlAnnotations.java).","url":"wiki/DevelopingTypes.md"},"Documentation.md":{"title":" Table of contents ","content":"## Table of contents \n\n* [Requirements](#requirements)\n\t* [Configuration](#configuration)\n\t* [Generated files location](#generated-files-location)\n* [Workflow to generate wiki files](#workflow-to-generate-wiki-files)\n* [Workflow to generate PDF files](#workflow-to-generate-pdf-files)\n* [Workflow to generate unit tests](#workflow-to-generate-unit-tests)\n* [Main internal steps](#main-internal-steps)\n\t* [Generate wiki files](#generate-wiki-files)\n\t* [Generate pdf files](#generate-pdf-files)\n\t* [Generate unit test files](#generate-unit-test-files)\n* [How to document](#how-to-document)\n\t* [The @doc annotation](#the-doc-annotation)\n\t* [the @example annotation](#the-example-annotation)\n\t* [How to document operators](#how-to-document-operators)\n\t* [How to document statements](#how-to-document-statements)\n\t* [How to document skills](#how-to-document-skills)\n* [How to change the processor](#how-to-change-the-processor)\n* [General workflow of file generation](#general-workflow-of-file-generation)\n\n\n# Documentation\n\nThe GAMA documentation comes in 2 formats: a set of wiki files availaible from the wiki section of the GitHub website and a PDF file. The PDF file is produced from the wiki files.\n\nIn the wiki files, some are hand-written by the GAMA community and some others are generated automatically from the Java code and the associated java annotations.\n\nThe section summarizes:\n* how to generate this wiki files,\n* how to generate the PDF documentation,\n* how to generate the unit tests from the java annotations, \n* how to add documentation in the java code.\n\n\n\n## Requirements\n\nTo generate automatically the documentation, the GAMA Git version is required. See [Install Git version](InstallingGitVersion) for more details. \n\nAmong all the GAMA plugins, the following ones are related to documentation generation:\n* `msi.gama.processor`: the java preprocessor is called during java compilation of the various plugins and extract information from the java code and the java annotations. For each plugin it produces the `docGAMA.xml` file in the `gaml` directory.\n* `msi.gama.documentation`: it contains all the java classes needed to gather all the `docGAMA.xml` files and generate wiki, pdf or unit test files.\n\nIn addition, the folder containing the wiki files is required. In the GitHub architecture, the wiki documentation is stored in a separate Git repository `https://github.com/gama-platform/gama.wiki.git`. A local clone of this repository should thus be created:\n1. Open the Git perspective:\n  * Windows > Open Perspective > Other...\n  * Choose `Git`\n2. Click on \"Clone a Git repository\"\n  * In **Source Git repository** window: \n    * Fill in the URI label with: `https://github.com/gama-platform/gama.wiki.git`\n    * Other fields will be automatically filled in.\n  * In **Branch Selection** windows, \n    * check the master branch \n    * Next\n  * In **Local Destination** windows,\n    * Choose the directory in which the gama Git repository has been cloned\n    * Everything else should be unchecked \n    * Finish\n3. In the **Git perspective** and the **Git Repositories** view, Right-Click on \"Working Directory\" inside the `gama.wiki` repository, and choose \"Import projects\"\n  * In the **Select a wizard to use for importing projects** window:\n    * \"Import existing projects\" should be checked\n    * \"Working Directory\" should be selected\n  * In **Import Projects** window:\n    * **Uncheck « Search for nested project »**\n    * Check the project `gama.wiki`\n    * Finish\n2. Go back to the Java perspective: a `gama.wiki` plugin should have been added.\n\nIn order to generate the PDF file from the wiki files, we use an external application named [Pandoc](http://pandoc.org/).\nFollow the [Pandoc installation instructions to install it](http://pandoc.org/installing.html). Specify the path to the pandoc folder in the file \"Constants.java\", in the static constant `CMD_PANDOC` : \"_yourAbsolutePathToPandoc/pandoc_\".\n\nNote that Latex should be installed in order to be able to generate PDF files. Make sure you have already installed [Miktex](http://miktex.org/download) (for OS Windows and Mac). Specify the path to the miktex folder in the file \"Constants.java\", in the static constant `CMD_PDFLATEX` : \"_yourAbsolutePathToMiktex/pdflatex_\".\n\n\n### Configuration\n\nThe location where the files are generated (and other constants used by the generator) are defined in the file `msi.gama.documentation/src/msi/gama/doc/util/Constants.java`.\n\nThe use of Pandoc (path to the application and so on) is defined in the file `msi.gama.documentation/src/msi/gama/doc/util/ConvertToPDF.java`. *This should be changed in the future...*\n\n\n### Generated files location\nThe generated files are (by default) generated in various locations depending on their type:\n* wiki files: they are generated in the plugin `gama.wiki`.\n* pdf file: they are generated in the plugin `msi.gama.documentation`, in the folder `files/gen/pdf`.\n* unit test files: they are generated in the plugin `msi.gama.models`, in the folder `models/Tests`.\n\n\n\n## Workflow to generate wiki files\n\nThe typical workflow to generate the wiki files is as follow:\n* Clean and Build all the GAMA projects,\n* Run the `MainGenerateWiki.java` file in the `msi.gama.documentation`,\n* The wiki files are generated in the `gama.wiki` plugin.\n\n## Workflow to generate PDF files\n\nThe typical workflow to generate the wiki files is as follow:\n* Clean and Build all the GAMA projects,\n* In the file mytemplate.tex, specify the absolute path to your \"gama_style.tex\" (it should be just next to this file)\n* Run the `MainGeneratePDF.java` file in the `msi.gama.documentation`, accepting all the packages install of latex,\n* The wiki files are generated in the `msi.gama.documentation` plugin.\n\nNote that generating the PDF takes a lot of time. Please be patient !\n\nIf you want to update the file \"gama_style.sty\" (for syntax coloration), you have to turn the flag \"generateGamaStyle\" to \"true\" (and make sure the file \"keywords.xml\" is already generated).\n\n## Workflow to generate unit tests\n\nThe typical workflow to generate the wiki files is as follow:\n* Clean and Build all the GAMA projects,\n* Run the `MainGenerateUnitTest.java` file in the `msi.gama.documentation`,\n* The wiki files are generated in the `msi.gama.models` plugin.\n\n\n## Main internal steps\n\n* Clean and Build all the GAMA projects will create a `docGAMA.xml` file in the `gaml` directory of each plugin,\n* The `MainGenerateXXX.java` files then perform the following preparatory tasks:\n  * they *prepare the gen folder* by deleting the existing folders and create all the folders that may contain intermediary generated folders\n  * they merge all the `docGAMA.xml` files in a `docGAMAglobal.xml` file, created in the `files/gen/java2xml` folder. **Only the plugins that are referred in the product files are merged.**\n  \nAfter these common main first steps, each generator (wiki, pdf or unit test) performs specific tasks.\n  \n### Generate wiki files\n\n* The `docGamaglobal.xml` is parsed in order to generate 1 wiki file per kind of keyword: \n  * operators,\n  * statements,\n  * skills,\n  * architectures,\n  * built-in species,\n  * constants and units.\n  * in addition an index wiki file containing all the GAML keywords is generated.\n* One wiki file is generated for each *extension* plugin, i.e. plugin existing in the Eclipse workspace but not refered in the product.\n\n### Generate pdf files\n\nThe pdf generator uses the table of content (toc) file located in the `files/input/toc` folder (`msi.gama.documetation` plugin) to organize the wiki files in a pdf file.\n\n* `MainGeneratePDF.java` file parsers the toc file and create the associated PDF file using the wiki files associated to each element of the toc. The generation is tuned using files located in the `files/input/pandocPDF` folder.\n\n### Generate unit test files\n\n* `MainGenerateUnitTest.java` creates GAMA model files for each kind of keyword from the `docGAMAglobal.xml` file.\n\n## How to document\n\nThe documentation is generate from the Java code thanks to the Java additional processor, using mainly information from Java classes or methods and from the Java annotations. (see [the list of all annotations](DevelopingIndexAnnotations) for more details about annotations).\n\n### The `@doc` annotation\n\nMost of the annotations can contain a [`@doc`](DevelopingIndexAnnotations#doc) annotation, that can contain the main part of the documentation.\n\nFor example, the `inter` ([inter](Operators#inter)) operator is commented using: \n```\n@doc(\n  value = \"the intersection of the two operands\",\n  comment = \"both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.\",\n  usages = {\n    @usage(value = \"if an operand is a graph, it will be transformed into the set of its nodes\"),\n    @usage(value = \"if an operand is a map, it will be transformed into the set of its values\", examples = {\n      @example(value = \"[1::2, 3::4, 5::6] inter [2,4]\", equals = \"[2,4]\"),\n      @example(value = \"[1::2, 3::4, 5::6] inter [1,3]\", equals = \"[]\") }),\n    @usage(value = \"if an operand is a matrix, it will be transformed into the set of the lines\", examples =\n      @example(value = \"matrix([[1,2,3],[4,5,4]]) inter [3,4]\", equals = \"[3,4]\")) },\n  examples = { \n    @example(value = \"[1,2,3,4,5,6] inter [2,4]\", equals = \"[2,4]\"),\n    @example(value = \"[1,2,3,4,5,6] inter [0,8]\", equals = \"[]\") },\n  see = { \"remove_duplicates\" })\n```\nThis `@doc`annotation contains 5 parts: \n* value: describes the documented element,  \n* comment: a general comment about the documented element,\n* usages: a set of ways to use the documented element, each of them being in a `@usage` annotation. The usage contains mainly a description and and set of examples,\n* examples: a set of examples that are not related to a particular usage, \n* see: other related keywords.\n\n### the `@example` annotation\n\nThis annotation contains a particular use example of the documented element. It is also used to generate unit test and patterns.\n\nThe simplest way to use it:\n```\n@example(value = \"[1::2, 3::4, 5::6] inter [2,4]\", equals = \"[2,4]\")\n```\n\nIn this example:\n* `value` contains an example of use of the operator,\n* `equals` contains the expected results of expression in value.\n\nThis will become in the documentation:\n```\nlist var3 <- [1::2, 3::4, 5::6] inter [2,4];    // var3 equals [2,4]\n```\nWhen no variable is given in the annotation, an automatic name is generated. The type of the variable is determined thanks to the return type of the operator with these parameters.\n\nThis example can also generate a unit test model. In this case, the value in the variable will be compared to the `equals` part.\n\nBy default, the `@example` annotation has the following default values:\n* `isTestOnly` = `false`, meaning that the example will be added to the documentation too,\n* `isExecutable` = `true`, meaning that content of `value` can be added in a model and can be compiled (it can be useful to switch it to false, in a documentation example containing name of species that have not been defined),\n* `test` = `true`, meaning that the content of value will be tested to the content of equals,\n* `isPattern` = `false`.\n\n\n### How to document operators\n\nA GAML operator is defined by a Java method annoted by the `@operator` annotation (see [the list of all annotations](DevelopingIndexAnnotations) for more details about annotations). In the core of GAMA, most of the operators are defined in the plugin `msi.gama.core` and in the package `msi.gaml.operators`.\n\nThe documentation generator will use information from:\n* the `@operator` annotation:\n  * `value`: it provides the name(s) of the operator (if an operator has several names, the other names will be considered as alternative names)\n  * `category`: it is used to classified the operators in categories\n* the `@doc` annotation,\n* the method definition:\n  * the return value type\n  * parameters and their type (if the method is static, the IScope attribute is not taken into account)\n\n### How to document statements\n\nA GAML statement is defined by a Java class annoted by the `@symbol` annotation (see [the list of all annotations](DevelopingIndexAnnotations) for more details about annotations). In the core of GAMA, most of the statements are defined in the plugin `msi.gama.core` and in the package `msi.gaml.statements`.\n\nThe documentation generator will use information from:\n* `@symbol` annotation,\n* `@facets` annotation (each facet can contain a documentation in a `@doc` annotation),\n* `@inside` annotation (where the statement can be used),\n* `@doc` annotation\n\n### How to document skills\n\nA GAML skill is defined by a Java class annoted by the `@skill` annotation (see [the list of all annotations](DevelopingIndexAnnotations) for more details about annotations). In the core of GAMA, most of the skills are defined in the plugin `msi.gama.core` and in the package `msi.gaml.skills`.\n\nThe documentation generator will use information from:\n* `@skill` annotation,\n* `@vars` annotation (each var can contain a documentation in a `@doc` annotation),\n* `@doc` annotation\n\n## How to change the processor\n\nIf you make some modifications in the plugin processor, you have to rebuild the .jar file associated to the processor to take in account the changes.\nHere are the several steps you have to do :\n- In the \"processor\" plugin, open the _plugin.xml_.\n- In exporting (from the _Overview_ tab), click on _Export Wizard_.\n- In the tab \"Destination\", choose processor/plugins for the directory. In the tab \"Options\", delete the field _Qualifier replacement_. Click \"finish\".\n- Right click on the folder \"processor\" to refresh.\n--> It's ok !\n\n# General workflow of file generation\n\nThis following diagram explains roughly the workflow for the generation of the different files : \n![resources/images/developpingExtension/generationFilesWorkflow.png](resources/images/developpingExtension/generationFilesWorkflow.png)","url":"wiki/Documentation.md"},"GamaArchitecture.md":{"title":" Architecture of GAMA","content":"# Architecture of GAMA\n\n\n\nGAMA is made of a number of Eclipse Java projects, some representing the core projects without which the platform cannot be run, others additional plugins adding functionalities or concepts to the platform.\n\n__Vocabulary:__\nEach project is either designed as a __plugin__ (containing an xml file \"plugin.xml\") or as a __feature__ (containing an xml file \"feature.xml\").\n  * A __plugin__ can be seen as a module (or bundle in the OSGI architecture), which can be necessary (the GAMA platform can't run without it) or optional (providing new functionalities to the platform). This decomposition between several plugins ensure the cohesion between functional blocks, each plugin has to be as independent as he can.\n  * A __feature__ is a group of one or several modules (or plugin), which can be loaded. NB : Unlike a plugin, a feature does not include source code, but only two files : a build.properties and a feature.xml.\n\nTo see how to create a plugin and a feature, please read [this page](InstallingGitVersion).\n\n## Table of contents \n\n* [Architecture of GAMA](#architecture-of-gama)\n\t* [The minimal configuration](#the-minimal-configuration)\n\t* [Optional Plugins](#optional-plugins)\n\t\t* [Plugins present in the release version](#plugins-present-in-the-release-version)\n\t\t* [Plugins not present by default in the release version](#plugins-not-present-by-default-in-the-release-version)\n\t\t* [Plugins not designated to be in the release version](#plugins-not-designated-to-be-in-the-release-version)\n\t* [Unmaintained projects](#unmaintained-projects)\n\t* [Features](#features)\n\t* [Models](#models)\n\t* [Plugins overview](#plugins-overview)\n\n## The minimal configuration\n\nHere is the list of projects which have to be imported in order to run the GAMA platform, and to execute a simple model in gaml language:\n\n  * `msi.gama.core` : Encapsulates the core of the modeling and simulation facilities offered by the platform : runtime, simulation, meta-model, data structures, simulation kernel, scheduling, etc. It contains 2 main packages :\n    * `msi.gama`\n    * `msi.gaml`, wich defines the GAML modeling language: keywords, operators, statements, species, skills�\n  * `msi.gama.application` : Describes the graphical user interface (`msi.gama.gui` package). This project also contains the file gama1.7.Eclipse3_8_2.product, when you can configure the application (and also launch the application). It contains the following sub-packages :\n    * `msi.gama.gui.displays`\n    * `msi.gama.gui.navigator`\n    * `msi.gama.gui.parameters`\n    * `msi.gama.gui.swt`\n    * `msi.gama.gui.views`\n    * `msi.gama.gui.wizards`\n    * `msi.gama.gui.viewers`\n  * `msi.gama.ext` : Gathers all the external libraries upon which GAMA relies upon\n    * `msi.gama.lang.gaml` : Contains the gaml.xtext file which defines the GAML grammar\n    * `msi.gama.lang.gaml.ui` : Contains the GAML Editor (syntax highlighting, code completion�)\n  * `msi.gama.processor` : Is responsible for processing the annotations made in the Java source code and producing additions to GAML (Java, properties and documentation files), which are added into a source package called \"gaml.additions\" (containing two main generated files: GamlAdditions.java and GamlDocumentation.java). These additions are loaded automatically when GAMA launches, allowing extensions made by developers in other plugins to be recognized when their plugin is added to the platform.\n  * `ummisco.gaml.editbox` : Project used to define the edit boxes in the gaml ui.\n\nMinimal configuration projects dependencies:\n\n![Minimal configuration projects dependencies](resources/images/developpingExtension/minimal_configuration.png)\n\n## Optional Plugins\n\n### Plugins present in the release version\nFrom this minimal configuration, it is possible to add some features. Here is the list of the features installed by default in the release version:\n  * `idees.gama.mapcomparison` : Contains some useful tools to do map comparaison\n  * `msi.gaml.extensions.fipa` : Provides some operators for communication between agents, using the FIPA standards\n  * `msi.gama.headless` : Enables to run simulations in console mode\n  * `simtools.gaml.extensions.traffic` : Provides operators and skills for traffic simulation\n  * `simtools.gaml.extensions.physics` : Physics engine, collision modelling, using the library JBullet\n  * `ummisco.gaml.extensions.maths` : Solving differential equation, using Euler methods and Runge Kutta.\n  * `irit.gaml.extensions.database` : Provides database manipulation tools, using SQL requests\n  * `irit.gaml.extensions.test` : Add unitary test statements\n  * `ummisco.gama.opengl` : Provide a 3D visualization using OpenGL.\n  * `simtools.gamanalyzer.fr` : Adding tools for the analysis of several execution result of a simulation (in order to find some correlations).\n  * `dream.gama.opengis` : Used to load some geographic information datas from online GIS server.\n  * `simtools.graphanalysis.fr` : Advanced graph operators\n \n### Plugins not present by default in the release version\nSome other plugins are not present by default in the release version (because their use is very specific), but it's possible to install them through features.\nHere is the list of those plugins:\n  * `idees.gama.weka` : Data-mining operators, using the library Weka.\n  * `msi.gaml.architecture.simplebdi` : Architecture for using the Belief-Desire-Intention software model.\n  * `ummisco.gaml.extensions.sound` : Use of sound in simulations\n  * `ummisco.gaml.extensions.stats` : Advanced statistics operators\n  * `ummisco.gama.communicator` : Communication between several instances of GAMA\n  * `ummisco.gaml.extensions.rjava` : Adding the R language into GAMA for data mining\n \n### Plugins not designated to be in the release version\nOther plugins will never be on the released version, and will never be loaded during the gama execution. They are just used in the \"developer\" version:\n  * `msi.gama.documentation` : Generate automatically the documentation in the wiki form (and also a pdf file)\n \n## Unmaintained projects\n\nSome other projects are still in the git repository in case we need to work on it one day, but they are either unfinished, obsolete, or used in very rare situations (They are not delivered in release versions, of course). Here is the list :\n  * `cenres.gaml.extensions.hydro` : Provide some tools in order to create hydrology models\n  * `msi.gaml.extensions.traffic2d` : Provide some tools for traffic in 2 dimensions (depreciated, now replace by msi.gaml.extensions.traffic)\n  * `msi.gaml.extensions.humainmoving` : Provide a skill to represent human movement\n  * `ummisco.gama.gpu` : Computation directly on the GPU for more efficiency. Results or not concluant, slower than using CPU.\n  * `msi.gama.hpc` : \"High Power Computing\" to execute gama simulation in several computer.\n  * `msi.gaml.extensions.cplex` : Originaly designed to be able to run CPLEX function in GAMA. The CPLEX is a proprietary library, we can't deliver it in the project. Instead, we use a stub, \"cplex.jar\", that you can replace by the real cplex.jar file.\n  * `irit.maelia.gaml.additions` : Used for the project \"Maelia\". Provide the possibility to represent the computing time in a simulation.\n  * `msi.gama.display.web` : Originaly designed to run some GAMA simulation in a browser, inside gama application, using WebGL. Does not work for the moment\n  * `ummisco.miro.extension` : Once used for the \"miro\" project, no longer used.\n  * `ummisco.miro.extension.traffic` : Once used for the \"miro\" project, no longer used.\n \n## Features\n \n  * `ummisco.gama.feature.audio` : sound plugin\n  * `ummisco.feature.stats` : stats plugin\n  * `ummisco.gama.feature.opengl.jogl2` : gathers physics and opengl plugins\n  * `simtools.graphlayout.feature` : gathers core, ext, processor and graphanalysis plugins\n  * `ummisco.gama.feature.core` : gathers mapcomparison, database, test, application, core, ext, headless, gaml, gaml.ui, processor, fipa, traffic and maths plugins\n  * `ummisco.gama.feature.dependencies` : a bunch of libraries and plugins\n  * `other.gama.feature.plugins` gathers hydro, opengis, addition, web, hpc, cplex, traffic2d, communicator, gpu, stats, extensions and traffic plugins\n  * `ummisco.gama.feature.models` : model plugin\n  * `idees.gama.features.weka` : weka plugin\n  * `ummisco.gama.feature.jogl2.product` : gathering of the following features : core, dependencies, models, jogl2\n  * `ummisco.gama.feature.product` : gathering of the following features : core, dependencies, models, jogl1\n \n## Models\n \nBeside those plugins and features, a project dedicated to gather a bunch of examples is also in the git repository. It contains gaml code:\n  * `msi.gama.models`\n\n## Plugins overview\n\nGlobal architecture of GAMA (nb : the features graphlayout, core, dependencies, plugins, jogl2.product and product are not represented here)\n\n![Global architecture of GAMA](resources/images/developpingExtension/plugin_architecture.png)","url":"wiki/GamaArchitecture.md"},"InstallingGitVersion.md":{"title":" Installing the GIT version","content":"# Installing the GIT version\n\nTested on MacOS X (10.9 to 10.11), Windows (8 to 10) and Ubuntu 15.04 (Vivid)\n\n_Important note: the current Git version is **not** compatible with the GAMA 1.6.1 release: if you plan to create plugins for this release, please download the source at revision r11988 (on Google Code) and [Eclipse following this procedure](InstallingSvnOldVersions)_\n\n## Install Eclipse Mars SR2\n\nDownload the [\"Eclipse IDE for Java and DSL Developers\"](http://www.eclipse.org/downloads/packages/eclipse-ide-java-and-dsl-developers/mars2) version (If Java is not installed on your computer you can download it [here](http://www.oracle.com/technetwork/java/javase/downloads/index.html)). \n\nUnpack it and launch it. Please refer to this [link](http://help.eclipse.org/mars/index.jsp?nav=%2F0) for more information on running Eclipse.\n\n**One important step** required for GAMA to correctly produce its supporting files once it will have been installed is to set the default encoding of the workspace to UTF-8. It can be done by selecting, in the Preferences, \"General\", then \"Workspace\", then \"Text file encoding\" and choosing \"UTF-8\" in the drop-down menu available in \"Other:\".\n\n## Install GAMA source code\n\nThe source is to be downloaded from GitHub in two steps: by creating a local clone of the GitHub repository and then importing the different projects that constitute GAMA into the Eclipse workspace.\n\n1. Open the Git perspective:\n  * Windows > Perspective > Open Perspective > Other...\n  * Choose `Git`\n![Open GIT perspective](resources/images/developpingExtension/GIT_open_perspective.png)\n2. Click on \"Clone a Git repository\"\n![Clone Repository](resources/images/developpingExtension/GIT_Clone_Repository.png)\n  * In **Source Git repository** window: \n    * Fill in the URI label with: `https://github.com/gama-platform/gama.git`\n    * Other fields will be automatically filled in.\n![Source GIT repository](resources/images/developpingExtension/GIT_source_git_repository.png)    \n  * In **Branch Selection** windows, \n    * check the master branch \n    * Next\n    * Note: If you are using Ubuntu 16 and you did not find any branch in this windows, may be your eclipse has a bug related with the OS. The workaround should be: \n        * Close eclipse\n        * Open eclipse.ini\n        * Add these 2 lines before **--launcher.appendVmargs**:\n\n        --launcher.GTK_version   \n        2\n        * Change required version of java from : -Dosgi.requiredJavaVersion=1.7 into -Dosgi.requiredJavaVersion=1.8\n        * Remove this line: -XX:MaxPermSize=256m\n        * Save and close eclipse.ini\n        * Start eclipse and redo from step 1\n\n![Git branch selection](resources/images/developpingExtension/GIT_branch_selection.png)\n  * In **Local Destination** windows,\n    * Choose a Directory (where the source files will be downloaded).\n    * Everything else should be unchecked \n    * Finish\n![Local destination](resources/images/developpingExtension/GIT_local_destination.png)\nThis can take a while...\n\n### Import projects into workspace\nYou have now to import projects into the workspace (notice that the folders downloaded during the clone will neither be copied nor moved).\n\n1. In the **Git perspective** and the **Git Repositories** view, Right-Click on \"Working Tree\" inside the `gama` repository, and choose \"Import projects\"\n![Context Working tree](resources/images/developpingExtension/GIT_Context_WorkingDirectory.png)\n  * In the **Select a wizard to use for importing projects** window:\n    * \"Import existing projects\" should be checked\n    * \"Working Tree\" should be selected\n![GIT Import projects](resources/images/developpingExtension/GIT_Import_projects.png)    \n  * In **Import Projects** window:\n    * **Uncheck « Search for nested project »**\n    * Check the projects you want to import\n    * Finish\n![Choose Projects to import](resources/images/developpingExtension/GIT_ChooseProjectToImport.png)\n2. Go back to the Java perspective\n3. Clean project (Project menu > Clean ...)\n\n### If you have errors...\nIf errors continue to show on in the different projects, be sure to correctly set the JDK used in the Eclipse preferences. GAMA is targeting JDK 1.8, and Eclipse will produce errors if it not found in your environment. So, either you set the compatibility to 1.8 by default (in Preferences > Java > Compiler > Compiler Compliance Level) or you change the error produced by Eclipse to a warning only (in Preferences > Java > Compiler > Building > \"No strictly compatible JRE for execution environment available).\n\n### Run GAMA\n1. In the `ummisco.gama.product` plugin, open the `gama.runtime.product` file (`gama.product` is used to produce the release).\n2. Go to \"Contents\" tab and click on \"Add required\"\n3. Go to \"Overview\" tab and click on Synchronize\n4. Click on Launch an Eclipse Application\n\n###GIT Tutorials\nFor those who want learn more about Git and Egit, please consult the following tutorials/papers\n\n1. EGIT/User Guide http://wiki.eclipse.org/EGit/User_Guide\n2. Git version control with Eclipse (EGIT) - Tutorial http://www.vogella.com/tutorials/EclipseGit/article.html\n3. 10 things I hate about Git http://stevebennett.me/2012/02/24/10-things-i-hate-about-git/\n4. Learn Git and GitHub Tutorial https://www.youtube.com/playlist?list=PL1F56EA413018EEE1","url":"wiki/InstallingGitVersion.md"},"InstallingSvnOldVersions.md":{"title":" Installing the SVN version","content":"# Installing the SVN version\n\n\n\nThese installation procedures have been tested on MacOS X 10.6 to 10.9, and Windows 8. On Mac OS X 10.10 (Yosemite), please have a look here: [install Java on Yosemite](Installation) for details about the Java version to use. **Eclipse 3.8.2 is the recommended Eclipse version to install GAMA**. Kepler install is still experimental.\n\n**Important note: the current SVN version is no more compatible with the GAMA 1.6.1 release.**\n  * If you plan to create plugin that should be compatible with the release, please download the GAMA code source at revision r11988 (on Google Code).\n  * If you want to have the last GAMA version (new GUI and APIs), you can download the head revision. The eclipse install should also be updated:\n    * EMF should be updated to the latest release available (2.10.2 in Apr. 2015)\n    * Xtext should be updated to the latest release (2.8.2 in April 2015)\n    * SWT 4.4\n    * ummisco.gaml.editbox plugin is now mandatory.\n\n\n\n\n\n\n## Detailed Instructions for Eclipse 4.4.2 (Luna SR2)\n### Get and configure Eclipse Luna\n  1. Download the Eclipse Modeling Tools version of Luna SR2\n    * https://eclipse.org/downloads/packages/eclipse-modeling-tools/lunasr2\n  1. Unpack it anywhere and run it\n  1. Choose a new workspace\n    * A workspace is a folder in which Eclipse stores all your projects.\n  1. Install the required plugins. � Help � -> � Install new software �\n    * In \"work with\", write \"http://download.eclipse.org/modeling/tmf/xtext/updates/composite/releases/\", click on \"Add\" and choose a name (e.g. Xtext)\n      * In \"Xtext\", install the following one:\n        * Xtext Complete SDK\t2.8.2.v201504100559\n\n### Get code source from GitHub\nIn Eclipse:\n  1. Windows > Open Perspective > Other�\n    * Git\n  1. Click on \"Clone a Git repository\"\n    * First window:\n      * URI: https://github.com/gama-platform/gama.git\n    * Branch Selection:\n      * Check master\n      * Next\n    * Local Destination\n      * Choose a Directory\n      * Finish\n\nYou have then to import projects:\n  1. Right-Click on Working Directory > Import projects\n    * Select a wizard to use for importing projects:\n      * \"Import existing projects\" should be  checked\n      * \"Working Directory\" should be selected\n      * Next\n    * In Import Projects:\n      * Uncheck ��Search for nested project��\n      * Check the projects you want to import\n      * Finish\n\nGo back to the Java perspective\n\n\n\n\n\n## Detailed Instructions for Eclipse 3.7.2 (Indigo)\n**PLEASE NOTE THAT SUPPORT FOR THIS INSTALLATION HAS BEEN STOPPED. IF YOU CANNOT RUN A NEWER VERSION OF ECLIPSE, THEN YOU HAVE TO CHECKOUT THE LATEST VERSION OF GAMA WORKING IN INDIGO (r11438 (on Google Code)).**\n  1. Download the Eclipse Modeling Tools version of Indigo\n    * http://www.eclipse.org/downloads/packages/eclipse-modeling-tools/indigosr2\n  1. Unpack it anywhere and run it\n  1. Choose a new workspace\n    * A workspace is a folder in which Eclipse stores all your projects.\n  1. Install the required plugins. � Help � -> � Install new software �\n    * In \"Work with\", type \"http://download.eclipse.org/technology/subversive/0.7/update-site/\" and install:\n      * In \"Subversive SVN Team Provider Plugin (Incubation)\"\n        * Subversive SVN Team Provider (Incubation)\t0.7.9.I20120520-1700\n    * In \"work with\", write \"http://download.eclipse.org/modeling/tmf/xtext/updates/composite/releases/\", click on \"Add\" and choose a name (e.g. Xtext)\n      * In \"Xtext-2.4.1\"   (to see it, you have to uncheck the \"Show only the latest versions of available software\")\n        * Xtext SDK\t2.4.1.v201304180855\n    * If you plan to build a release version, in \"work with\", write \"http://download.eclipse.org/tools/orbit/downloads/drops/R20110523182458/repository/\", click on \"Add\" and choose a name (e.g. ICU)\n      * Type 'icu' in the text filter.\n      * The site should propose you a list of plugins. Choose (if this version is not available, untick (\"Show only the latest versions\").\n        * International Components for Unicode for Java (ICU4J) Replacement plug-in\t4.4.2.v20110208\n  1. Eclipse proposes to restart -> Restart now\n  1. Add SVN repository exploring perspective\n    * To activate this perspective, choose Window / Open Perspective / Other... and select \"SVN Repository Exploring\"\n    * A popup appears (Discovery of SVN connector)\n    * Choose: SVN Kit 1.7.x\n      * Popup Unsigned content -> ok\n    * Popup -> restart now\n  1. Configure a new repository location:\n    * File > New > Other... > SVN > Repository Location\n    * URL: https://gama-platform.googlecode.com/svn\n    * Finish (& wait)\n  1. Checkout of the GAMA code source\n    * In the SVN repository view, navigate to the directory \"branches/GAMA\\_CURRENT\" and select \"Find/Checkout As...\" from the contectual menu.\n    * Choose \"Find projects in the children of the selected resource\" and follow the indications.\n    * Pop-up \"Check Out projects\", all projects should be selected. Finish.\n    * Once the checkout is finished, switch to Java Perspective.\n\nTo compile and run GAMA properly, you will need to configure your Eclipse IDE and the GAMA `.product` file.\n  1. By default, Eclipse uses Java 7 when it is installed whereas GAMA only needs Java 6. On MacOS X in particular, we may have to change the version of the JDK to ensure that GAMA will run smoothly.\n    * Window->Preferences\n    * In: Java / Compiler: set \"Compiler compliance level\" to 1.6\n    * In: Java / Installed JREs -> Add -> Standard VM -> JRE home -> Directory and choose the directory of a Java 6 JDK (preferable) or a Java 7 JDK (except for MacOS X, see [Installation](Installation)).\n      * Download the JDK 6 (for Windows & Linux) [here](http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html#jdk-6u45-oth-JPR)\n      * Download the JDK 7 (for Windows & Linux) [here](http://www.oracle.com/technetwork/java/javase/downloads/index.html).\n      * Download the JDK 6 (for Mac OS X) [here](http://support.apple.com/kb/DL1572). To switch between 1.7 and 1.6 (if both are installed), look at the use of `java-home` on this [page](http://docs.oracle.com/javase/7/docs/webnotes/install/mac/mac-jdk.html).\n    * In: Java / Installed JREs -> select Java 1.6 (for Mac) or 1.7 (on Windows & Linux).\n  1. You should configure the GAMA `.product` file depending on your OS.\n    * In the `msi.gama.application` project, open the `gama1.6.1.feature_based_release.product` file.\n    * In: the \"Launching\" tab: check whether the launching options are correct\n      * In particular, for a 32bits OS, you have to change in \"VM Arguments\" \"-Xmx1536m\" into \"-Xmx1024m\"\n      * For 64bits OS, check that the option \"-d32\" is not in the \"VM Arguments\" (otherwise delete it) in the \"macosx\" specific tab.\n  1. Compile and Run GAMA\n    * Do a \"Project -> Clean... (clean all projects)\"\n    * In the .product file, in \"Overview\" tab:\n      * click on the � Synchronize � link. This will ensure your product has updated the inclusion of the plugins (from both Eclipse and the new XText). Do not forget to save it.\n      * The product, or some of the included features, may complain about missing plugins (identified by an error icon on the plugin icon in the dependencies view). It is normal for \"fragments\" that apply to another OS than yours and it is harmless in this case. If you are, however, concerned about this, you can install the \"delta-pack\" for Eclipse 3.7.2 or Eclipse 3.8.2 (follow these steps: http://ugosan.org/eclipse-rcp-delta-pack/. The delta pack itself can be downloaded from [here](http://archive.eclipse.org/eclipse/downloads/drops/R-3.7.2-201202080800/download.php?dropFile=eclipse-3.7.2-delta-pack.zip)).\n      * If one of the missing plugins happens to be \"com.ibm.icu.base\" (and you did not want to install it as told above), you can replace it by \"com.ibm.icu\" without worries.\n      * As of GAMA 1.6.1, we use a version of the SWT binary fragments that is not the one shipped with Eclipse Indigo nor Juno. Although it is not mandatory to use it, it is required if you plan to produce release versions of GAMA from your product. To install it, simply download this [file](https://drive.google.com/file/d/0B8DTAk4nDgyNNmN0NkMtX1RDRDA/edit?usp=sharing) and install it like the delta pack above.\n      * click on the � Launch an Eclipse application � link. Note that a run configuration will be automatically created allowing to only click on the run button for future runs.\n\n**If the GAMA launch crashes:**\n  * Open Run configurations....\n  * In Eclipse Application / gama1.6.1.feature\\_based\\_release.product configuration, open the plug-ins pane\n  * After Launch with: , choose \"all workspace and enable plug-ins\".\n\n\n\n\n## Detailed Instructions for Eclipse 3.8.2\n\nFirst note that GAMA will not work with the packaged Juno version (in fact version 4.2 of Eclipse). Instead, you will need to download the core Eclipse package (Eclipse SDK) from http://archive.eclipse.org/eclipse/downloads/drops/R-3.8.2-201301310800/ , and to install additional plugins using this repository: http://download.eclipse.org/releases/juno/ . Among these additional plugins, only the EMF (Eclipse Modeling Framework) components should be necessary. In \"Modeling\":\n  * EMF - Eclipse Modeling Framework SDK\n  * EMF Validation Frameworkd SDK\n\nThe same instructions (than for Eclipse 3.7.2) can then be applied to this installation, with three differences :\n  * The delta-pack for Juno is available [here](http://archive.eclipse.org/eclipse/downloads/drops/R-3.8.2-201301310800/download.php?dropFile=eclipse-3.8.2-delta-pack.zip).\n  * The name of the product to use is  `gama1.6.1.feature_based_Eclipse3_8_2_updatable_release.product`\n  * The version of XText to use is 2.8.2 and it should be obtained from [here](http://download.eclipse.org/modeling/tmf/xtext/updates/composite/releases/), as this site will also provide updates for EMF and other components necessary for XText to work (you may need to install these components first, notably EMF ones, if the installation of XText does not work).\n\n\n\n\n\n## Detailed Instructions for Eclipse 4.3.2 (Kepler)\n  1. Download the Eclipse Modeling Tools version\n  * http://www.eclipse.org/downloads/packages/eclipse-modeling-tools/keplersr2\n    1. Unpack it anywhere and run it\n    1. Choose a new workspace\n      * A workspace is a folder in which Eclipse stores all your projects.\n    1. Install the required plugins. � Help � -> � Install new software �\n      * In \"Work with\", type \"http://download.eclipse.org/technology/subversive/0.7/update-site/\" and install:\n        * In \"Subversive SVN Team Provider Plugin (Incubation)\"\n          * Subversive SVN Team Provider (Incubation)\t0.7.9.I20120520-1700\n      * In \"work with\", write \"http://download.itemis.de/updates/\", click on \"Add\" and choose a name (e.g. Xtext)\n        * In \"Xtext-2.5.3\"\n          * Xtext SDK\t2.5.3.v20140220820\n        * In \"Xtext Antlr-2.1.0\"\n          * Xtext Antlr SDK 2.1.0.v201308291703\n      * If you plan to build a release version, in \"work with\", write \"http://download.eclipse.org/tools/orbit/downloads/drops/R20110523182458/repository/\", click on \"Add\" and choose a name (e.g. ICU)\n        * Type 'icu' in the text filter.\n        * The site should propose you a list of plugins. Choose (if this version is not available, untick (\"Show only the latest versions\").\n          * International Components for Unicode for Java (ICU4J) Replacement plug-in\t4.4.2.v20110208\n    1. Eclipse proposes to restart -> Restart now\n    1. Add SVN repository exploring perspective\n      * To activate this perspective, choose Window / Open Perspective / Other... and select \"SVN Repository Exploring\"\n      * A popup appears (Discovery of SVN connector)\n      * Choose: SVN Kit 1.7.x\n        * Popup Unsigned content -> ok\n      * Popup -> restart now\n    1. New > repository location\n      * https://gama-platform.googlecode.com/svn\n      * Finish (& wait)\n    1. Checkout of the GAMA code source\n      * In the SVN repository view, navigate to the directory \"branches/GAMA\\_CURRENT\" and select \"Find/Checkout As...\" from the contectual menu.\n      * Choose \"Find projects in the children of the selected resource\" and follow the indications.\n      * Pop-up \"Check Out projects\", all projects should be selected. Select \"Check out as a folders into workspace\". Click \"Next\" and then \"Finish\".\n      * Once the checkout is finished, switch to Java Perspective.\n    1. Configure Build path of all projects :\n      * In the Properties of project, Java build path category, Libraries tab, click on JRE System Libray to change Excution environment from Java 1.6 to Java 1.7\n    1. Configure the GAMA `.product` file (gama1.6.1.feature\\_based\\_release.jogl2.product) :\n      * In the `msi.gama.application` project, open the `gama1.6.1.feature_based_release.jogl2.product` file\n      * In the \"Dependencies\" tab:\n        * Choose all `org.eclipse.equinox.*` plugins and remove them.\n      * Click `Add` button, type in `org.eclipse.equinox` and add all displayed packages.\n      * Click `Add` button, type in `org.eclipse.e4`, then select all and click OK.\n      * Click `Add Required` button, this will add two more: `org.eclipse.emf.ecore` and `org.eclipse.emf.common`\n    1. Configure `ummisco.gama.feature.dependencies` project:\n      * In the `ummisco.gama.feature.dependencies` project, open the `feature.xml` file\n      * In: the \"Plugin\" tab:\n        * Click `Add` and type in `org.w3c.dom`, choose `org.w3c.dom.events` and `org.w3c.dom.smil`, click OK.\n    1. Compile and Run GAMA\n      * Do a \"Project -> Clean... (clean all projects)\"\n      * In `gama1.6.1.feature_based_release.jogl2.product` file, in \"Overview\" tab.\n        * click on the � Synchronize � link. This will ensure your product has updated the inclusion of the plugins (from both Eclipse 3.7 and the new XText). Do not forget to save it.\n        * click on the � Launch an Eclipse application � link. Note that a run configuration will be automatically created allowing to only click on the run button for future runs.\nHave fun!\n\n\n\n\n\n## Install additional plug-ins\n\n### Install the Graphical Modeling Framework\n\nThis installation procedure has been tested on a macbook pro with macosx 10.6 64 bits.\n\n**Important note**: for the moment, the plug-in works only with Eclipse Indigo and graphiti 0.8. Some modifications will be made later to make it works with the latest version of Eclipse and graphiti.\n\n#### Details\n\nThe graphical modeling framework is based on the [Graphiti](http://www.eclipse.org/graphiti/) plug-in.\n\n  1. The first step consists in installing the graphiti plug-ins : � Help � -> � Install new software �\nIn \"Work with\", choose \"Indigo - http://download.eclipse.org/releases/indigo\" and install: Graphiti, Graphiti Export, Graphiti SDK and Graphiti SDK Plus.\n  1. Eclipse proposes to restart -> Restart now\n  1. � Help � -> � Check of Updates �\n  1. Install the proposed updates\n  1. Eclipse proposes to restart -> Restart now\n  1. From the GAMA SVN, checkout the idees.gama.graphicalmodeling, idees.gama.emf.metamodel and idees.gama.feature.graphical\\_modeling projects.\n    * In the SVN repository view, navigate to the directory \"branches/GAMA\\_CURRENT\" and select the three mentioned projects and select \"Find/Checkout As...\" from the contectual menu.\n    * Choose \"Find projects in the children of the selected resource\" and follow the indications.\n    * Pop-up \"Check Out projects\", all projects should be selected. Finish.\n    * Once the checkout is finished, switch to Java Perspective.\n  1. You have to add the plugin to the GAMA `.product` file .\n    * In the `msi.gama.application` project, open the `gama1.6.1.feature_based_release.product` file\n    * In: the \"Dependencies\" tab: click on \"Add ...\" and select the idees.gama.feature.graphical\\_modeling plugin\n    * In: the \"Dependencies\" tab: click on \"Add Required plug-ins\" then save the file\n  1. Compile and Run GAMA\n    * Do a \"Project -> Clean... (clean all projects)\"\n    * In `gama1.6.1.feature_based_release.product` file, in \"Overview\" tab.\n      * click on the � Synchronize � link. This will ensure your product has updated the inclusion of the plugins. Do not forget to save it.\n      * click on the � Launch an Eclipse application � link. Note that, a run configuration will be automatically created allowing to only click on the run button for future runs.\n\n#### Note\nIf you have some errors on the META-INF/MANIFEST.MF file (in particular on the line  `org.eclipse.draw2d;bundle-version=\"3.8.3\"`), you can follow next steps.\n\n  1. Fix the MANIFEST.MF error (if any)\n    * In the plug-in idees.gama.graphicalmodeling, open the file : META-INF/MANIFEST.MF\n    * In the 'Dependencies' pane,\n      * Select org.eclipse.draw2d (3.8.1) and click on the 'Properties' button\n      * In 'Available version to match', select the one you have (mine is the v 3.7.2), and click on 'Match' and 'OK'\n    * Save the file\n    * Repeat Step 8 (clean, synchronize...)\n\n\n\n\n\n### Install additional plug-ins to generate the documentation\n  1. A plug-in to use Python should be installed as additional plug-ins: � Help � -> � Install new software �\nIn \"Work with\", choose \"http://pydev.org/updates\" and install: PyDev for Eclipse.\n  1. Configure the Python Interpreters:\nEclipse -> Preferences -> PyDev -> Interpreters -> Python Interpreter: Quick auto-config.","url":"wiki/InstallingSvnOldVersions.md"},"SerializeAgents.md":{"title":" Syntax in GAML","content":"Using SavedAgent kind of GamlAgent, it is now possible to serialize and unserialize agents and simulations as a string. It can be done using the operators: `serializeSimulation`, `unserializeSimulation`, `saveSimulation` of `ummisco.gama.serialize`.\n\nNeed to be improved:\n* serialization of random generator\n* serialization of shapes\n* to allow any agent to be serialized\n\n\nExample of use of the two operators:\n```\nexperiment toto {\n\tlist<string> history <- [];\n\n\treflex store when: (cycle < 6){\n\t\tadd serializeSimulation(cycle) to: history;\n\t}\n\t\n\treflex restore when: (cycle = 6){\n\t\tint i <- unSerializeSimulation(string(history[0]));\n\t} \n\t\n\treflex store22 when: cycle=2{\n\t\twrite \"Sauvegarde de la simulation \" + saveSimulation(\"file.xml\");\n\t}\n}\n```\n\n\n## Syntax in GAML\n\nHow to make it as simple as possible for the modeler to save and restore simulation states, or come back in time ?\n(like the creation of new simulations, for instance, which reuses exactly the same syntax than the creation of agents) ? \n\n### Statements\n\n`store` (to differentiate it from `save`) ?\n* `to: ` a file \n\n`restore` with facets that could allow to precise:\n* `at:` a cycle number (to come back at a certain point in time)\n* `at: ` a negative number (to come back relatively in time)\n* `at: ` a date ? \n* `from:` a file\n* `\n","url":"wiki/SerializeAgents.md"},"WebsiteGeneration.md":{"title":" How to write the Website Content","content":"# How to write the Website Content\n\nIn this page, we will explain all about the convention we use to write and generate the website content and the wiki content.\nSince the release of GAMA 1.7, with the new GAMA website, we have two contents:\n* The _wiki_ content is hosted in github, witch directly interpret the markdown format of the files to display them in a proper way. This wiki, since it is a wiki, can be edited by any user. It is then, in constant changes.\n* The _website_ content is the content of the real GAMA website. It is a verified and fixed version of the documentation (usually a re-generation of the website content is done when there is a new release of the software)\n\n## Index\n\n* [Requirements](#requirements)\n* [gama.wiki tree structure](#gamawiki-tree-structure)\n* [Good practices when writing markdown files](#good-practices-when-writing-markdown-files)\n  * [Title](#title)\n  * [Hypertext Links](#hypertext-links)\n  * [Images Links](#images-links)\n  * [Insert Metadatas](#insert-metadatas)\n* [Website Generation Workflow](#website-generation-workflow)\n  * [Website Database](#website-database)\n  * [Loading the Database](#loading-the-database)\n* [Manage concepts keywords](#manage-concepts-keywords)\n\n## Requirements\n\nTo generate automatically the documentation, the GAMA Git version is required. See [Install Git version](InstallingGitVersion) for more details.\n\nAmong all the GAMA plugins, only one is related to documentation generation:\n* `msi.gama.documentation`: it contains some useful java scripts to help you to write a correct documentation.\n\nIn addition, the folder containing the wiki files is required. In the GitHub architecture, the wiki documentation is stored in a separate Git repository `https://github.com/gama-platform/gama.wiki.git`. A local clone of this repository should thus be created:\n1. Open the Git perspective:\n  * Windows > Open Perspective > Other...\n  * Choose `Git`\n2. Click on \"Clone a Git repository\"\n  * In **Source Git repository** window: \n    * Fill in the URI label with: `https://github.com/gama-platform/gama.wiki.git`\n    * Other fields will be automatically filled in.\n  * In **Branch Selection** windows, \n    * check the master branch \n    * Next\n  * In **Local Destination** windows,\n    * Choose the directory in which the gama Git repository has been cloned\n    * Everything else should be unchecked \n    * Finish\n3. In the **Git perspective** and the **Git Repositories** view, Right-Click on \"Working Directory\" inside the `gama.wiki` repository, and choose \"Import projects\"\n  * In the **Select a wizard to use for importing projects** window:\n    * \"Import existing projects\" should be checked\n    * \"Working Directory\" should be selected\n  * In **Import Projects** window:\n    * **Uncheck « Search for nested project »**\n    * Check the project `gama.wiki`\n    * Finish\n2. Go back to the Java perspective: a `gama.wiki` plugin should have been added.\n\n## gama.wiki tree structure\n\nThe \"gama.wiki\" plugin contains all the wiki content, and almost all the website content. It contains a folder content which contains the following folders:\n* Tutorials\n  * LearnGAMLStepByStep: contains the linear documentation to learn about the concepts of GAML\n  * Recipes: contains short pieces of documentation answering a specific problematic\n  * Tutorials: contains applicative tutorials \n* References\n  * ModelLibrary: contains the model library (only present in the website) \n  * PlatformDocumentation: contains the documentation dealing with how to use the platform\n  * GAMLReferences: contains GAML references\n  * PluginDocumentation: contains the documentation of the additional plugins\n* Community\n  * Projects: contains a presentation of the projects where GAMA is involved (only present in the website)\n  * Training: contains a presentation of the training sessions organized by the GAMA team (only present in the website)\n* WikiOnly: contains the content only present in the wiki, and not in the website\n  * DevelopingExtensions: contains explanations about how to extend the platform\n* resources: contains all the additional resources needed (images, pdf...)\n\nFor the rest of this document, the highest level of tree structure (\"Tutorials\"/\"References\"/\"Community\"/\"WikiOnly\") will be named as **tabs**. The level just under will be named as **sections**, and the level under will be named as **sub-section**.\nAll this content is written using the markdown format.\nAll the images resources are included in the _resources/images_ folder. They are actually under different sub-folders. From the markdown page, you can call the resource with the relative path `resource/images/sub_folder/image_name.png`.\nIf a _section_/_sub-section_ contains one of several sub-division, then those sub-divisions will be stored in a folder with the name of the corresponding _section_/_sub-section_, and this _section_/_sub-section_ folder will be associated with a markdown file with the same name (indeed, a _section_/_sub-section_ has its own page).\nIf a _section_/_sub-section_ has no sub-division, then this _section_/_sub-section_ is simply defined with a markdown file containing the content wanted.\n\n![resources/images/developpingExtension/tree_structure.png](resources/images/developpingExtension/tree_structure.png) \n\nNotice that there is some content which is present only in the wiki (the \"WikiOnly\" content), some content present only in the website (the model library, most of the community content...). In fact, the wiki tree structure is determined by the file _Sidebar, while the website tree structure is determined by the file _WebsiteTreeStructure_.\n\n## Good practices when writing markdown files\n\n### Title\n\nEach markdown files **has to** start with a title in the markdown format (like `# title`). This is this title which will be displayed in the tree structure of the website.\n\n### Hypertext Links\n\nEven if the repository how have a more complexe tree structure, you don't have to (and you must not !) speficy the relative or absolute path to the target page, just naming the page will work : `[text_displayed](the_name_of_the_md_file)`\n\n### Images Links\n\nAs already said in the [previous paragraph](#gamawiki-tree-structure), images have to be in an \"resources/images/folder_name\" folder next to your md file, so that you can write the relative path more easily.\n\n### Insert Metadatas\n\nMetadatas in content files are written as comments, with the following syntax:\n\n```\n[//]: # (name_of_the_medatada|value_of_the_metadata)\n```\n\nMedatadas are not displayed in the wiki and the website content. For the website generation, metadatas are used in order to build the database, most of all to manage the search engine, and the learning graph.\n\nHere is the list of metadata we use in the content files:\n\n* **keyword** : will write an invisible anchor in this exact place in the website. When the user will do a research about this word, he can access directly to this anchor.\n\n* **startConcept**/**endConcept** : used to delimit a concept. The value of those two metadatas is the name of the concept. All the concepts are listed in the file \"DependencyGraph\", in the content folder in your wiki repository.\n\n#### keyword\n\nThe value of the keyword has to have this structure : keyword_category_keyword_name (indeed, several keywords can have the same name ! The type of the keyword has to be specified).\nHere is the list of the several keyword categories : concept, operator, statement, species, architecture, type, constant and skill.\nExample of metadata : `[//]: # (keyword|concept_3D)`, or `[//]: # (keyword|operator_int)`.\n\n#### startConcept/endConcept\n\nThe value of the keyword have to be one of the values defined in the file learningConcept.xml.\n\nNotice that a _concept_ in the meaning of keyword is not the same as a _concept_ (or _learning concept_) in the learning graph ! \nPlease read the part concerning the database to learn more about it.\n\n## Website generation workflow\n\n_This part is not implemented yet, it is under construction._\n\n![resources/images/developpingExtension/website_generation_workflow.png](resources/images/developpingExtension/website_generation_workflow.png)\n\n### The gama.documentation plugin\n\nThis plugin is used to [generate GAML documentation automatically in the markdown format](Documentation), and copy paste the content to the wiki folder.\nThe plugin is also used to generate the model library in the markdown format, with the source code, a quick description, and an image (screenshot). In the same time, the plugin generates a html page (an \"abstract\") and put it directly in the model folder (in order to be loaded directly from GAMA).\n\nThe documentation plugin contains also 2 other scripts which helps to create content:\n\n#### learningGraphDatabaseGenerator\n\nThe **learningGraphDatabaseGenerator** script is used to generate the \"_nodesDatabase.js_\" file, which is read to visualize the learning graph. This script needs the \"learningGraph.xml\" file as input. Each learning concepts has an id, a name, a very short description, a position (position in x and y in %, between 0 and 1. This value is then multiplied by the **coeff** in the learningGraphDatabaseGenerator), and a list of prerequisite learning concepts. A category of learning concept (also defined in the learningGraph.xml file) has an id, a position (position in x and y), a position for the hallow (position in x and y of the big circle displayed when a category is selected), a size for the hallow, a color, a name, and the list of learningConcept associated.\n\n#### modelLibraryGenerator\n\nThe **modelLibraryGenerator** script is used to generate all the markdown files of the model library. This script\n\n* Parse all the models of the model library, and build an \"input\" xml file for a headless execution (this file is deleted at the end of the execution).\n  * By default, this will ask to execute all the experiments for each model, and take a screenshot of the 10th cycle for each display.\n  * You can change this default behavior by changing the file \"**modelScreenshot.xml**\", in the wiki repo (see description below)\n* Execute the headless\n* Copy-paste all the generated images in the write folder, with the write names.\n* Browse a second time all the models, build the md file, including the screenshot computed from the headless execution, and analyzing the header of each model to extract the title, author and tags. Each md files respects the following format : path_from_model_with_underscore_instead_of_slash_without_strange_char + \".md\". (ex : \"Features/3D/3D Visualization/models/3D camera and trajectories.gaml\" becomes \"Features_3D_Visualization_models_3D_camera_and_trajectories.md\".)\n\nFormat of the xml file to \"tune up\" the screenshot generation :\n```\n<xmlFile>\n  <experiment id=\"name_of_the_file_without_extention\"+\" \"+\"model_name\"+\" \"+\"experiment_name\">\n    <display name=\"display_name_1\" cycle_number=\"number_of_the_cycle_for_the_screenshot\"/>\n    <display name=\"display_name_2\" cycle_number=\"number_of_the_cycle_for_the_screenshot\"/>\n  </experiment>\n</xmlFile>\n```\n\n_TODO_\n\n### The gama.wiki repository\n\nThis repository contains in on hand the content auto generated by the documentation plugin, and in the other hand a handmade content. All the content is in the markdown format, organized through a [specific tree structure](#gamawiki-tree-structure), sometime containing [metadatas](#metadatas).\n\n### The website repository\n\nThis repository contains:\n* A copy of the content of the wiki repo (copy/pasted manually to freeze a specific commit of the wiki)\n* A Database management system\n* A script used to interpret the metadatas from the content, in order to load the database\n* Some pages which are not in the wiki repo, and some heavy resources (such as videos)\n\n\n### Website database\n\n![resources/images/developpingExtension/global_database.png](resources/images/developpingExtension/global_database.png)\n\n#### Keyword\n\nA **keyword** is a keyword that can be used for search, either manually (the user enters the wanted keyword in the searchbar of the website) or automatically (through the search tab in the navigation panel)\nA keyword in attached with a category (among the following names : concept, type, operator, statement, species, architecture, constant, action, attribute, skill, facet).\n\n* A keyword that is a **_concept_** can be linked with other keywords (ex : the keyword \"BDI\" will be linked with the keywords \"eval_when\", \"get_priority\"...)\n* A keyword that is a **_facet_** is linked to a **_statement_** or a **_species_** keyword (ex : the keyword \"torus\" will be linked with the keyword \"global\").\n* A keyword that is an **_action_** or an **_attribute_** is linked either to a **_skill_** keyword (if it is actually an action or an attribute of a skill), an **_architecture_** keyword (if it is an action or a behavior of an architecture), or a **_species_** keyword (if it is a built-in action or attribute).\n* A keyword that is a **_statement_** can be linked to an **_architecture_**.\n\nA keyword is composed of:\n* **id** (unique id)\n* **name** (the word which is searched by the user)\n* **idCategory** (id of the category)\n\nA cagegory is composed of:\n* **id** (unique id)\n* **name** (the name of the category)\n\n![resources/images/developpingExtension/keyword_table.png](resources/images/developpingExtension/keyword_table.png)\n\n#### Alias\n\nAn other database is used to join an **alias** to an existing keyword. Ex : the word \"alias\" will be changed as \"die\".\n\nAn alias is composed of:\n* **id** (unique id)\n* **name** (name of the alias. ex : \"kill\")\n* **attachedKeywordName** (name of the keyword attached. ex : \"die\")\n\nNote that an alias does not know the id of the keyword, but only the name of the attached keyword(s). Indeed, the alias \"integer\" will give the keyword name \"int\", but several keywords correspond to the keyword name \"int\" (it can be the type \"int\", or the cast operator \"int\")\n\n![resources/images/developpingExtension/alias_table.png](resources/images/developpingExtension/alias_table.png)\n\n#### Webpage\n\nA **webpage** can be either a page of the model library, a page of the gaml reference, or an other page of the documentation.\n\nA webpage is composed of:\n* **id** (unique id)\n* **name** (name of the webpage)\n* **webpageCategory** (the name of the category of the webpage, a value among _modelPage_, _docPage_, gamlRefPage_).\n\nThe tables **webpage** and **keyword** are linked through an association table. This association table contains also an anchor (an anchor has an unique value) to the wanted paged.\n\n![resources/images/developpingExtension/webpage_table.png](resources/images/developpingExtension/webpage_table.png)\n\nNote that only the keywords which have the category _concept_, _species_, _type_, _operator_, _skill_ and _constant_ can be attached to a webpage. \n\nThe keywords which have the category _action_, _attribute_ and _facet_ forward to the attached keyword.\n\nThe keywords which have the category _statement_ are attached to a webpage only if they are not attached to another keyword. If they are attached to another keyword (an _architecture_ keyword), then the _statement_ keyword forward to the attached keyword.\n\n#### LearningConcept\n\n**LearningConcept** is used to build the learning graph (notice that a \"learning concept\" and a \"keyword concept\" is not the same thing !)\n\nA LearningConcept is composed with:\n\n* **id** (unique id)\n* **name** (name of the learning concept)\n\nA LearningConcept is linked to a webpage through an association table. This table is composed also with two anchors that are used to delimit the position of the learning concept in a page (the beginning position and the ending position).\n\nA LearningConcept can be associated to other LearningConcepts through an association table, used to spefify the \"prerequisite concepts\".\n\n![resources/images/developpingExtension/learningConcept_table.png](resources/images/developpingExtension/learningConcept_table.png)\n\n### Loading the Database\n\nThe database is loaded from a gathering of independent files. Some of those files are handmade written, other are generated automatically.\n\n#### Role of the documentation generation script in the construction of the database\n\nAs explained in the explication of the [documentation generation pages](Documentation), the documentation generation script is used to generate the gaml references and the model library pages (in the markdown format with metadatas), but also to build two files **category.txt** and **keyword.xml**.\n\nThe file **category.txt** is a very simple file, listing the different keyword categories. This file will be used to build the **Category** table.\n\nFormat of the file:\n```\nconcept, type, statement, species, architecture, operator, skill, constant, action, attribute, facet\n```\n\nThe file **keyword.xml** is an xml file that contains all the possible keywords (all except some keywords written manually directly in the documentation pages). The GAML words can be found directly using the code of GAMA. The concept words can be found using the code of GAMA (thanks to the tag \"category\") and also by using the tags in the header of the model files. This xml file will be used to build the **Keyword** and the **AssociationKeywordCategory** tables.\n\nFormat of the file:\n```\n<keyword id:keywordname_keywordcategory>\n  <name>keywordname</name>\n  <category>keywordcategory</category>\n  <associatedKeywordList>\n    <associatedKeyword>keywordId1</associatedKeyword>\n    <associatedKeyword>keywordId2</associatedKeyword>\n  </associatedKeywordList>\n</keyword>\n```\n\nNote that:\n* The list associatedKeywordList contains only one element for the _facet_ keywords, one of no element for the _action_ or _attribute_ keywords (none when the action/attribute is a built-in), several or no elements for the _concept_ keywords, and none for the other type of keywords.\n\n* The id is build with the value of the attribute \"name\" and with the value of the attribute \"category\" for every keywords except the _statement_, _facet_, _action_ and _attribute_ keywords, which need also the value of the associatedKeyword linked. Ex : the id of the facet \"torus\" will be \"facet_torus_statement_global\".\n\n#### Preparation of the repository before the generation of the database\n\nAfter the generation of the markdown content in the wiki repository, two other files have to be built manually : the files **alias.txt** and **learningConcept.xml**.\n\nThe **alias.txt** file contains all the connexions between alias and keyword name. It will be used to build the **Alias** table.\n\nFormat of the file :\n```\naliasName1:remplacedWord1\naliasName2:remplacedWord2\nkill:die\n```\n\nThe **learningConcept.xml** file is used to list the learning concepts, and to connect them to their prerequisite concepts. It will be used to build the **LearningConcept** and the **AssociationLearningConcept** tables.\n\nFormat of the file :\n```\n<learningConcept id:learningConceptName>\n  <name>learningConceptName</name>\n  <prerequisiteList>\n    <prerequisite>learningConcept1</prerequisite>\n    <prerequisite>learningConcept2...</prerequisite>\n  </prerequisiteList>\n</learningConcept>\n```\nNote that the value of the attribute \"name\" can be used as an unique id.\n\n#### Role of the website content generation script in the construction of the database\n\nAfter copy-paste the content to the website folder, a script is used to build the database and to generate website content.\n\nThe **Category**, **Alias**, **LearningConcept** and **AssociationLearningConcept** tables are loaded easily from the files **category.txt**, **alias.txt**, and **learningConcept.xml**.\n\nThe **Keyword** and **AssociationKeywordCategory** tables are loaded from the **keyword.xml** file. Note that those two tables are not entirely loaded yet, because other keywords can be presents in the header of other files.\n\nThe markdown files are converted one by one into html format.\n\n* When a metadata **startConcept**/**endConcept** is found (syntax : [//]: # (beginAnchor|name_of_learning_concept)), the metadata is replaced with an anchor in the page (with an unique id), and the **AssociationWebpageConcept** table is updated.\n* When a metadata **keyword** is found (syntax :  [//]: # (keyword|name_of_keyword_category_name_of_keyword)), the metadata is replaced with an anchor in the page (with an unique id), and the **AssociationWebpageKeyword** table is updated (the **Keyword** and **AssociationKeywordCategory** are updated if the keyword does not exist yet in the table).\n\n## Manage concepts keywords\n\n**ALL** the concepts must be declared in the \"IConcept\" java class. If you want to add a new concept, please check before if your the concept you want to add cannot be remplaced by one of the existing concept. If it is the case, you can add your word as if it was an **alias**, pointing to the existing concept. Note that all the alias are listed in the alias.txt file. If you realy think that the concept has to be added, please add it to the IConcept file, and also to (one or several) of the lists _CONCEPTS_NOT_FOR_GAML_REF_, _CONCEPTS_NOT_FOR_MODEL_LIBRARY_, _CONCEPTS_DEDICATED_TO_SYNTAX_ in the ConceptManager class if needed.\n\nMost of the keywords of the website (used for the search) are managed automatically. But the \"concepts\" keywords have to be (partially) hand-made managed. You can add the concepts with 3 differents methods :\n\n### In the Documentation\n\"Documentation\" here designs all the content manually written in the wiki. All those pages can contain \"concepts\" through the metadata format :\n\n`[//]: # (keyword|concept_name_of_concept)`\n\nYou can either :\n- place those metadatas anywhere in the page if you want to point directly in this part of the page if the user makes a search\n- place those metadatas **above the title** : doing this, the \"automatic search\" (left navigation panel) will be made with this concept. You have to be really sure this concept is the **main** concept of the page to place it there.\n\n### In the Model library\nDirectly from the gaml files of the model library, you can add the concept you want through the \"Tags\" in the header of the model.\n\nExemple :\n\n```\n/**\n* Name: 3D Display model of differents shapes and a special Object\n* Author: \n* Description: Model presenting a 3D display of differents shapes (pyramid, cone, cylinder, sphere and a teapot object) to represent the same agents but with\n*       different aspects. Five experiments are possible, one for each of the shapes presented previously. In each experiment, the agents move to create a big circle but flee\n*       from their closest neighbour. \n* Tags: 3d, shape, neighbors\n*/\n```\n\nNote that if you don't want this model to have a page in the website, you can name it starting with the character `_`.\n\n### In the GAML References\nYou can add a concept to a gaml word by using the syntax `concept = { IConcept.MY_CONCEPT }`.\n\nExemple :\n\n```\n@operator(value = \"flip\",\n\tconcept = { IConcept.RANDOM }\n```\n\n___________________________________________________________\n\n\n\n\n_The following text has been automatically generated from \"mainCheckConcepts\"_\n\n______________ _last update : 2017/02/28 14:21:42_\n\n**List of concepts to use for model library (except Syntax):**\n\n3d, agent_location, agent_movement, algorithm, architecture, asc, batch, bdi, camera, chart, clustering, color, communication, comodel, comparison, csv, database, date, dem, dgs, diffusion, dxf, edge, elevation, equation, fipa, fsm, geometry, gis, graph, graph_weight, graphic, grid, gui, headless, hydrology, image, inheritance, inspector, light, load_file, math, mirror, monitor, multi_criteria, multi_level, multi_simulation, neighbors, network, nil, node, obj, obstacle, osm, overlay, physics_engine, r, raster, regression, save_file, scheduler, serialize, shape, shapefile, shortest_path, skill, sound, spatial_computation, spatial_relation, spatial_transformation, sport, statistic, svg, system, task_based, test, text, texture, tif, topology, transport, txt, xml\n\n**List of concepts to use exclusively in Syntax models:**\n\narithmetic, attribute, cast, condition, container, filter, list, logical, loop, map, matrix, string, ternary\n\n**List of concepts to use for GAML worlds:**\n\n3d, action, agent_location, agent_movement, algorithm, architecture, arithmetic, asc, attribute, batch, bdi, behavior, camera, cast, chart, clustering, color, communication, comodel, comparison, condition, constant, container, csv, cycle, database, date, dem, dgs, diffusion, dimension, display, dxf, edge, elevation, equation, experiment, file, filter, fipa, fsm, geometry, gis, graph, graph_weight, graphic, graphic_unit, grid, gui, headless, hydrology, image, inspector, length_unit, light, list, load_file, logical, loop, map, math, matrix, mirror, monitor, multi_criteria, multi_level, multi_simulation, neighbors, network, nil, node, obj, obstacle, optimization, osm, overlay, parameter, physics_engine, point, r, random, random_operator, raster, regression, save_file, scheduler, serialize, shape, shapefile, shortest_path, skill, sound, spatial_computation, spatial_relation, spatial_transformation, species, statistic, string, surface_unit, svg, system, task_based, ternary, test, text, texture, tif, time, time_unit, topology, transport, txt, type, volume_unit, weight_unit, xml\n\n| **Concept name** | **in Doc** | **in GAML Ref** | **in Model Lib** | **TOTAL** |\n|:----------------------------|:-------------|:-------------|:-------------|:-------------|\n| 3d | 2 | 17 | 39 | 58 |\n| action | 3 | 5 | _ | 9 |\n| agent_location | 1 | 21 | 0 | 22 |\n| agent_movement | 0 | 2 | 23 | 25 |\n| algorithm | 1 | 8 | 2 | 11 |\n| architecture | 2 | 11 | 1 | 14 |\n| arithmetic | 0 | 33 | 0 | 33 |\n| asc | 0 | 2 | 2 | 4 |\n| attribute | 2 | 6 | _ | 9 |\n| autosave | 2 | _ | _ | 2 |\n| background | 1 | _ | _ | 1 |\n| batch | 3 | 8 | 4 | 15 |\n| bdi | 1 | 51 | 0 | 52 |\n| behavior | 3 | 7 | _ | 10 |\n| camera | 1 | 1 | 2 | 4 |\n| cast | 1 | 17 | 1 | 19 |\n| chart | 0 | 5 | 5 | 10 |\n| clustering | 0 | 5 | 3 | 8 |\n| color | 1 | 17 | 4 | 22 |\n| communication | 0 | 3 | 0 | 3 |\n| comodel | 0 | 0 | 8 | 8 |\n| comparison | 0 | 6 | 2 | 8 |\n| condition | 1 | 7 | 0 | 8 |\n| constant | 0 | 13 | _ | 13 |\n| container | 1 | 60 | 1 | 62 |\n| csv | 2 | 4 | 3 | 9 |\n| cycle | 2 | 2 | _ | 4 |\n| database | 1 | 3 | 17 | 21 |\n| date | 1 | 48 | 2 | 51 |\n| dem | 0 | 0 | 1 | 1 |\n| dgs | 0 | 0 | 1 | 1 |\n| diffusion | 1 | 1 | 14 | 16 |\n| dimension | 2 | 35 | _ | 37 |\n| display | 2 | 25 | _ | 29 |\n| distribution | 1 | _ | _ | 1 |\n| dxf | 0 | 2 | 1 | 3 |\n| edge | 1 | 15 | 1 | 17 |\n| elevation | 0 | 0 | 7 | 7 |\n| enumeration | 1 | _ | _ | 1 |\n| equation | 2 | 7 | 15 | 24 |\n| experiment | 2 | 3 | _ | 5 |\n| facet | 1 | _ | _ | 1 |\n| file | 1 | 44 | _ | 47 |\n| filter | 1 | 12 | 0 | 13 |\n| fipa | 1 | 4 | 11 | 16 |\n| fsm | 1 | 0 | 0 | 1 |\n| geometry | 2 | 96 | 0 | 98 |\n| gis | 0 | 5 | 24 | 29 |\n| global | 1 | _ | _ | 1 |\n| graph | 1 | 55 | 32 | 88 |\n| graph_weight | 1 | 3 | 0 | 4 |\n| graphic | 1 | 10 | 1 | 12 |\n| graphic_unit | 1 | 6 | _ | 7 |\n| grid | 4 | 10 | 33 | 47 |\n| gui | 3 | 9 | 24 | 36 |\n| halt | 1 | _ | _ | 1 |\n| headless | 0 | 1 | 0 | 1 |\n| hydrology | 0 | 0 | 1 | 1 |\n| image | 0 | 4 | 0 | 4 |\n| import | 1 | _ | _ | 1 |\n| inheritance | 1 | _ | 1 | 2 |\n| init | 3 | _ | _ | 3 |\n| inspector | 1 | 2 | 1 | 4 |\n| layer | 1 | _ | _ | 1 |\n| length_unit | 0 | 9 | _ | 9 |\n| light | 2 | 1 | 4 | 7 |\n| list | 0 | 9 | 2 | 11 |\n| load_file | 4 | 1 | 18 | 23 |\n| logical | 1 | 7 | 0 | 8 |\n| loop | 1 | 2 | 2 | 5 |\n| map | 0 | 15 | 1 | 16 |\n| math | 1 | 41 | 20 | 62 |\n| matrix | 2 | 22 | 8 | 32 |\n| mirror | 1 | 0 | 2 | 3 |\n| model | 1 | _ | _ | 1 |\n| monitor | 1 | 1 | 1 | 3 |\n| multi_criteria | 0 | 4 | 1 | 5 |\n| multi_level | 1 | 3 | 9 | 13 |\n| multi_simulation | 1 | 0 | 2 | 3 |\n| neighbors | 1 | 5 | 1 | 7 |\n| network | 0 | 1 | 0 | 1 |\n| nil | 1 | 0 | 0 | 1 |\n| node | 1 | 20 | 1 | 22 |\n| obj | 0 | 0 | 2 | 2 |\n| obstacle | 0 | 1 | 3 | 4 |\n| opengl | 3 | _ | _ | 3 |\n| operator | 1 | _ | _ | 1 |\n| optimization | 3 | 1 | _ | 4 |\n| osm | 1 | 2 | 2 | 5 |\n| output | 2 | _ | _ | 7 |\n| overlay | 0 | 0 | 1 | 1 |\n| parameter | 2 | 1 | _ | 3 |\n| pause | 1 | _ | _ | 1 |\n| permanent | 1 | _ | _ | 1 |\n| physics_engine | 0 | 0 | 4 | 4 |\n| point | 0 | 29 | _ | 29 |\n| probability | 1 | _ | _ | 1 |\n| pseudo_variable | 1 | _ | _ | 1 |\n| r | 1 | 2 | 0 | 3 |\n| random | 3 | 10 | _ | 13 |\n| random_operator | 0 | 0 | _ | 0 |\n| raster | 0 | 0 | 4 | 4 |\n| reflex | 1 | _ | _ | 1 |\n| refresh | 2 | _ | _ | 2 |\n| regression | 0 | 2 | 1 | 3 |\n| save_file | 0 | 2 | 8 | 10 |\n| scheduler | 2 | 2 | 0 | 4 |\n| serialize | 0 | 0 | 0 | 0 |\n| shape | 3 | 21 | 1 | 25 |\n| shapefile | 2 | 2 | 34 | 38 |\n| shortest_path | 1 | 6 | 4 | 11 |\n| skill | 2 | 17 | 42 | 61 |\n| sound | 0 | 4 | 0 | 4 |\n| spatial_computation | 0 | 73 | 7 | 80 |\n| spatial_relation | 0 | 32 | 0 | 32 |\n| spatial_transformation | 0 | 24 | 2 | 26 |\n| species | 1 | 20 | _ | 21 |\n| sport | 0 | _ | 2 | 2 |\n| statistic | 0 | 66 | 5 | 71 |\n| string | 0 | 27 | 0 | 27 |\n| surface_unit | 0 | 4 | _ | 4 |\n| svg | 0 | 2 | 0 | 2 |\n| system | 1 | 11 | 0 | 12 |\n| task_based | 1 | 4 | 0 | 5 |\n| ternary | 1 | 2 | 1 | 4 |\n| test | 0 | 4 | 2 | 6 |\n| text | 2 | 10 | 0 | 12 |\n| texture | 0 | 1 | 3 | 4 |\n| tif | 0 | 2 | 1 | 3 |\n| time | 2 | 20 | _ | 22 |\n| time_unit | 0 | 13 | _ | 13 |\n| topology | 3 | 9 | 4 | 16 |\n| torus | 1 | _ | _ | 1 |\n| transport | 1 | 5 | 6 | 12 |\n| txt | 0 | 0 | 1 | 1 |\n| type | 0 | 53 | _ | 53 |\n| update | 1 | _ | _ | 1 |\n| volume_unit | 0 | 5 | _ | 5 |\n| weight_unit | 0 | 8 | _ | 8 |\n| world | 1 | _ | _ | 1 |\n| write | 1 | _ | _ | 1 |\n| xml | 0 | 4 | 0 | 4 |\n","url":"wiki/WebsiteGeneration.md"},"Event__CC15_Reorganization.md":{"title":" Introduction","content":"# Introduction\n\nLe but est de proposer une réorganisation des plug-ins de Gama\n\nCf. page Google Doc: https://docs.google.com/document/d/1gd4nlJH8ns4_iKqiIdw3LSa__Sk9yUccX9TEbzr2PW0/edit?usp=sharing","url":"wiki/Event__CC15_Reorganization.md"},"Event__CodingCamp2012.md":{"title":" Coding Activities Summary","content":"March 19-24th 2012\n\n# Coding Activities Summary\n\n|[Physics constraints operators](Event__CP12traffic) | [Water-management tutorial](Event__CP12Water) | [Test Models & Language](Event__CP12Test)|\n|:------------------------------------------------------|:-------------------------------------------------|:--------------------------------------------|\n|[Library of models](Event__CP12Library)             | [FIPA-ACL Skill](Event__CP12FIPA)             | [Git repository](Event__CP12Git)         |\n|[SLD-based aspects](Event__CP12SLD)                 | [Headless operation](Event__CP12Headless)     | [Batch Experiments](Event__CP12Batch)    |\n|[OpenGL Display](Event__CP12OpenGL)                 | [Enhancement of the IDE](Event__CP12IDE)      | [GAMA Architecture](Event__CP12Archi)    |\n|[Improvement of the Multi-scale framework](Event__CP12MultiScale) | [GAMA Development](Event__CP12Development)    | [Online & Local Documentation](Event__CP12Doc)|\n|[Statistical Tools in GAMA](Event__CP12Stats)       | [Graph operators and indicators](Event__CP12Graph)|                                             |\n\n[and some \"working\" images...](https://picasaweb.google.com/114770356492687537213/Hanoiwiki?authuser=0&authkey=Gv1sRgCIKj0ITH_KOyiwE&feat=directlink)\n\n<a href='http://gama-platform.googlecode.com/files/IMG_1622.png' title='CodingCampNight'><img src='http://gama-platform.googlecode.com/files/IMG_1622.png' alt='CodingCampNight' /></a>","url":"wiki/Event__CodingCamp2012.md"},"Event__CodingCampFall2012.md":{"title":" Introduction","content":"# Introduction\n\nThe Fall GAMA Coding Camp 2012 will take place from the 17th to the 19th of November in the hotel called \"Hon Trem Resort & Spa \". You can find more information about it here : http://www.hontremresort-spa.com.\n\nDeparture will take place from Ninh Kieu 3 hotel in Can Tho at 3:30 PM, Friday the 16th of November, and we expect to arrive in Hon Trem resort at around 9:00 PM (dinner will be taken on the road).\n\nA summary of the Spring GAMA Coding Camp 2012 can be found [here](Event__CodingCamp2012).\n\n# Work\n\n**The use of the last version of GAMA will be necessary, the development version should thus be installed. [See the documentation for the Installation procedure](G__InstallingSvnVersion).**\n\nSome ideas of tasks that could be investigated during the camp (feel free to add anything you think about)\n\n## [COUPLING GAMA WITH OTHER TOOLS](Event__CodingCampFall2012_coupling)\n  * **Coupling GAMA with hydrodynamics simulators (for water flows, etc.)**\n    * Participants: Thanh, Tuu, Benoit, Nghi, Quang, M.Thai\n  * **Integration of EDP solver into GAMA**\n    * Participants: Benoit\n    * Plug-in needed: maps.gama.extensions\n  * **Calling statistical libraries of R in GAMA: Basic statistics, geostatistics (maptools, gstat), Gaussian process (tgp, gptk)**\n    * Participants: M.Thai, Viet\n  * **Integration of `SimAnalyzer`**\n    * Participants: Philippe, Javier\n  * **Improving SQL features in GAMA**\n    * Participants: M.Thai\n  * **Improving the physics engine**\n    * Participants: Javier, Philippe, Arnaud, Patrick\n    * Plug-in needed: simtools.gaml.extensions.physics\n## [IMPROVEMENTS / ENHANCEMENTS](Event__CodingCampFall2012_improvements)\n  * **Improving and simplifying the syntax of GAML**\n    * Participants: Nicolas, Alexis, Nghi\n  * **Documenting and enhancing the command line version**\n    * Participants: Nicolas, Nghi\n    * Plug-in needed: msi.gama.headless\n  * **Improving the user interaction possibilities**\n    * Participants: Nghi, Nicolas, Arnaud\n  * **Torus environment (at least, grid)**\n    * Participants: Patrick, Viet\n  * **Enhancement of the IDE**\n    * Participants: Nghi (implement first-step of GUI-GAML)\n  * **Communication Skill**\n    * Participants: Benoit, An, Philippe\n    * Plugin-needed: msi.gaml.extensions.fipa\n  * **Update of the Trust Skill to Gama 1.5**\n    * Participants: Quang Anh\n  * **Multicore runner in Headless Mode to Gama 1.5**\n    * Participants: Nicolas, Nhan, Nghi\n  * **Driving skill in 2D (skill: driving2d)**\n    * Participants: Minh\n## [BUG FIXES](Event__CodingCampFall2012_bug)\n  * **Eliminating bugs found in the 1.5 version**\n    * Participants: Benoit, Patrick (for spatial/geometry related bugs). Arnaud for Opengl bug\n## [MODELS](Event__CodingCampFall2012_models)\n  * **Adding 3D to the models**\n    * Participants: Arnaud, Patrick, Nghi\n## OTHER\n  * **Documentation**\n    * Participants: (Benoit)\n    * Plug-in needed: msi.gama.documentation\n    * Requirements: Python (CPython) and PyDev Eclipse plugin: [see this page](Documentation15) for details about the installation","url":"wiki/Event__CodingCampFall2012.md"},"Event__CodingCampFall2012_bug.md":{"title":" Eliminating bugs found in the 1.5 version","content":"\n\n\n# Eliminating bugs found in the 1.5 version\n  * Arnaud: Opengl is now working with Java2D (possibility to define n opengl display and n java2D display in the same output)\nhttp://code.google.com/p/gama-platform/issues/detail?id=190\n\nno more seg fault when running a simulation with opengl while the update is done on the all model\nhttp://code.google.com/p/gama-platform/issues/detail?id=233\n\n  * Communication Skills http://code.google.com/p/gama-platform/issues/detail?id=271","url":"wiki/Event__CodingCampFall2012_bug.md"},"Event__CodingCampFall2012_coupling.md":{"title":" Coupling GAMA with hydrodynamics simulators","content":"\n\n\n# Coupling GAMA with hydrodynamics simulators\n\n# Integration of EDP solver into GAMA\n\nThe maps.gaml.extensions has been extended in order to allow modeler to write its own equation systems (as simple strings), specify parameters with their values and variables and \"solve\"/integrate them either step by step or N steps by N steps.\n\nAn example has been implemented on the Lokta-Voltera equation system.\n\nPossible extension:\n  * parse the equations to detect errors\n  * rename the skill has EDO, because we consider only variables depending on time\n  * extends to solve EDP\n  * add some methods/algorithms in order to \"resolve\" the system, in a sense of finding some equilibria (asymptots or oscillation equilibrium...)\n\n\n# R in GAMA\n**Results**: Verifying the old operators (A simple example \"CallingR\" is uploaded in the model list); Applying these statistical operators on the data loaded from RDBMS.\n\n# SQL features in GAMA\nResults:\n  * 1.Added PostgresSQL driver into SQSKILL and AgentDB.\n  * 2.Wrote example models for testing.\n  * Now,GAMA supported query features for MySQL, MSSQL, PostgresSQL and SQLite.\n\n# Physics engine\n\nIntegration of a 3D Physics Engine Library (http://jbullet.advel.cz/) in `simtools.gaml.extensions.physics`\nThis has been implemented as a new skill.\n\n```\nspecies myPhysicsAgent skills: [physical3D]\n```\n\nMore details: [3D Physics Engine](Event__CodingCampFall2012_models)","url":"wiki/Event__CodingCampFall2012_coupling.md"},"Event__CodingCampFall2012_improvements.md":{"title":" Possibility to directly create agents from a CSV file","content":"Improvements and Enhancements\n\n\n\n\n# Possibility to directly create agents from a CSV file\nThe create statement has been extended in order to let the possibility to create agents of specified species directly from a CSV file.\nAn agent is created by line of the CSV file. It is also possible to read the different column of the file using the read operator: **read (column\\_index) (start at 0)**\n\n```\nread(1)\n```\n\nFor example:\n```\ncreate people from: \"data_file.csv\" with: [speed::read(0), age:: read(1)];\n```\n\nIt is also possible to specify that the CSV file has a header that can give the name of the different column using the **header** facet (**boolean**). It this case, it is possible to directly use this name to read the column value: **read(\"attribute1\")**.\n\nFor example:\n```\ncreate people from: \"data_file.csv\" with: [speed::read(\"SPEED\"), age:: read(\"AGE\")] header: true;\n```\n\n# Improving and simplifying the syntax of GAML\nNew features:\n  * Possibility to define 3D points with the **{x,y,z}** syntax:\n```\nlet pt type: point <- {2, 5, 3};\n```\n# Documenting and enhancing the command line version\n\n#summary One-sentence summary of this page.\n\n\nThe aim of this feature is to run models and experiments on a grid or a cluster without GUI and to take advantages of High Performance Computing. It promises efficient running by accelerating each simulation and experiment plan computing. The GUI is not loaded and managed. Several simulations could be run in parallel, at same time.\n\n\nThere is two ways to run a GAMA experiment in headless mode: using command-line launcher or Java command line. These commands take 2 arguments: an experiment file and an output directory.\n\nFor the command-line :\n```\n sh gamaHeadless.sh $1 $2\n```\n  * with:\n    * $1 input parameter file : an xml file determining experiment parameters and attended outputs\n    * $2 output directory path : a directory which contains simulation results (numerical data and simulation snapshot)\n\n[go to headless documentation](Headless)\n\n# Torus environment\nIt is now possible to use toroidal environment for grid and continuous environments (even with complex GIS geometries).  The only thing to do is to use the **torus** facet.\n\nFor a grid:\n```\ngrid cell width: 5 height: 5 neighbours: 8 torus: true \n```\n\nFor the continuous environment:\n```\nenvironment bounds: {50,50} torus: true;\n```\n\nBe careful concerning toroidal continuous environment: the computation required by these environment is high, thus they should be used only when they are really necessary.\n\nA demonstration of a continuous toroidal environment is given in the experimental model: testTorus-> continuous\\_torus.\n\n\n![http://gama-platform.googlecode.com/files/toroidalEnv.png](http://gama-platform.googlecode.com/files/toroidalEnv.png)\n\n# Communication Skill\nPlugin-needed: msi.gaml.extensions.fipa\n\nThe communicating skill now re-works on GAMA 1.5. Sample toy models are found in \"models/fipa\".\n\n# Update of the Trust Skill to Gama 1.5\n\n# Hexgonal geometry and grid\nIt is now possible to create a hexagon of with the given width and height (point) thanks to the operator **hexagon({width, height})**\n\n```\nhexagon({3,4})\n```\n\nIn the same way, an operator has been defined in order to decomposed a geometry into a set of hexagons of a given a number of columns and rows. This operator returns a set of hexagons: geometry as\\_hexagonal\\_grid({nb\\_cols, nb\\_rows})\n\n```\nshape as_hexagonal_grid({50, 40})\n```\n\nAt last, it is now possible to define a hexagonal grid. To do so, the neighbors should is set to **6**. It is possible to use torus environment with hexagonal grid.\n\n```\ngrid cell width: 20 height: 20 neighbours: 6 torus: true;\n```\n\n\n![http://gama-platform.googlecode.com/files/imageHexGrid.png](http://gama-platform.googlecode.com/files/imageHexGrid.png)\n\n# Using HSB color\n\nAdd [HSB](http://en.wikipedia.org/wiki/HSL_and_HSV) color to be able to iterate through colors and use it to represent qualitative data.\n\nExample:\n\nThe association of the orientation of agents is enhanced by mapping the orientation of the agent to a hue.\n\n```\ncolor hsb_to_rgb ([heading/360,1.0,1.0]);\n```\n\nIn the following example boids are represented by a triangle with the colors depending on their heading. [![](http://gama-platform.googlecode.com/files/HSB_Color.png)](http://gama-platform.googlecode.com/files/Dynamic_Color_HSB.mov)\n\n\n# Multicore runner in Headless Mode\nResults: distribution of command-line version on multicore machine, integration with GAMA interface, visualisation of outputs.\n\n\n\n\n# Defining interaction in a model\n\nOne statement have been added to facilitate the proposal of serious game on which user could interact through a map. It is now possible to catch event done on 2D display in order to do an action and to modify clicked agent attributes.\n\n## Attributes\n  * **name** (omissible) ` [mouse_down , mouse_up] `\n  * **action** name of the action to be run\n\n## Definition\nAllows to interact with the simulation by capturing mouse event and do an action. This action could apply a change on environment or on agents, according to the goal.\n\nEvents are determine for a display. Thus, they can be play a different behavior\n\n```\nevent [event_type] action: myAction\n```\n  * event\\_type (mouse\\_down or mouse\\_up\n  * myAction is an action written in the global block. This action have to follow the specification below.\n\n```\n\n global\n {\n   ...\n   action myAction \n   {\n     arg location type: point; // contains le location of the click in the environment\n     arg selected_agents type: list; // contains agents clicked by the event\n    \n    ... //code written by the authors ...\n   } \n }\n\n experiment Simple type:gui {\n\tparameter 'Evaporation Rate:' var: evaporation_rate;\n\tparameter 'Diffusion Rate:' var: diffusion_rate;\n\toutput { \n\t\tdisplay Ants refresh_every: 2 { \n\t\t\tgrid ant_grid;\n\t\t\tspecies ant aspect: default;\n\t\t\ttext tt value: string ( food_remaining ) size: 24.0 position: { 20 , 20 } color: rgb ( 'white' );\n\t\t\tevent mouse_up action: myAction;\n\t\t}  \n\n...\n\n```\n\n# Driving skill in 2D (skill: driving2d)\n\nA skill (inherited from moving skill) permits agent to move to the target and avoid the others.\n\n## Attributes\n  * **heading** initial heading of agent\n  * **obstacle\\_species** list of species to avoid\n  * **background\\_species** list of species on which agent move\n\n## Action\nThe action inherits the \"goto\" action of moving skill.\n\n```\ndo vehicle_goto target: target on: the_graph speed: speed target_type: true returns: moving_status;\n```\n\n  * **target** the goal (in type of location) for agent to go\n  * **speed** maximum of moving distance for each step\n  * **on** the topology on which agent moves. By default, the topology is the graph and agent uses the shortest path algorithm to move\n  * **target\\_type** if \"true\", agent goes to the exact location of the target. Otherwise (in the case of false target), agent go to an point on the topology that is nearest to the target.\n  * **returns** the action returns an integer with the meaning: -1: failed to move; 0: success to move closer and closer to the target; 1: arrive the false target; 2: arrive the target\n\n```\n\n reflex move_with_vehicle_goto when: target != nil{\n\t\t\tlet moving_status type: int <- -1;\n\t\t\tdo vehicle_goto target: target on: the_graph speed: speed target_type: true returns: moving_status;\n\t\t\tif (int(moving_status) > 0){\n\t\t\t\tlet temp_targets <- list(targetpoint) - target;\n\t\t\t\tset target <- one_of(temp_targets);\n\t\t\t}\n\t\t\t\n\t\t}\n```","url":"wiki/Event__CodingCampFall2012_improvements.md"},"Event__CodingCampFall2012_models.md":{"title":" 3D River morphology display","content":"\n\n# 3D River morphology display\n\nDisplay the channel bed of a river in 3D from synthetic data and can be applied directly to real data.\n\n\n# Models using the 3D Physics Engine\n\nIntegration of a 3D Physics Engine Library (http://jbullet.advel.cz/) in `simtools.gaml.extensions.physics`\n\nThis has been implemented as a new skill.\n\n```\nspecies myPhysicsAgent skills: [physical3D]\n```\n\nSome toy model has been added in\n\n```\nmsi.gama.models/models/3D/3D_Engine\n```\n\n**hello\\_World\\_falling\n> Ball falling (due to the gravity) on a floor.**\n\n**pool3D.gaml**\n\n[![](http://gama-platform.googlecode.com/files/Pool_3D.png)](http://gama-platform.googlecode.com/files/Pool_3D.mov)","url":"wiki/Event__CodingCampFall2012_models.md"},"Event__CP12Archi.md":{"title":" GAMA Architecture","content":"# GAMA Architecture","url":"wiki/Event__CP12Archi.md"},"Event__CP12Batch.md":{"title":" Batch Experiments","content":"# Batch Experiments\n\nBy the Batch People\n\nPhilippe Caillou,\nThomas Louail,\nNicolas Marilleau,\nHuynh Quang Nghi,\nSerge Stinckwich,\nPatrick Taillandier,\nJean-Daniel Zucker\n\n\n## What do we have?\n\nDefine an experiment, batch mode (but same capabilities as GUI mode)\n\n·         Parameter exploration:  Param element\n\no   Explicit\n\no   List with step\n\n·         Method Element\n\no   Exhaustive\n\no   Hill climbing\n\no   Simulated annealing\n\no   Tabu Search\n\no   Reactive Tabu Search\n\no   Genetic Algorithm\n\n·         File export\n\no   File\n\n## How does it work?\n\n·         The experiment (the plan) creates the simulation (future: Headless mode)\n\n\n## What would be great in Gama 12.4?\n\n·         Export agent/simulation data in the file\n\no   =>Define code in the experiment (loop over agents)\n\n·         Put rules for variable exploration\n\no   Ex: explore b={1,2,3}. if a=2 explore b={2,3} only\n\no   How? Put code in the exploring loop => put real GAML code in the agent\n\no   => reflex \"method\" or \"explore\"\n\no   Some existing exploration actions can be used with a ParameterSet (Map?) parameter\n\n·         Show plots in batch\n\no   Define output with the code/variable of the experiment agent\n\no   Require a getVariable() operator that gets the last simulation variables values\n\n·         Compare agent trajectories\n\no   Stats a posteriori\n\no   (not possible inside a simulation because there is no end)\n\no   => action « aftersimulation » défined by the user\n\no   Require a getVariable() operator that gets the last simulation variables values (to be able to loop on agents)\n\n·         Define more parameters/variables in the file (CSV)\n\no   => use of the Save already working\n\n·         Launch parallel simulation on multicore/clusters\n\no   => special action \"runSimulation\" parameter to launch 4 in parallel?\n\n·         \"Generate\" agents\n\no   Define agent parameters by using global/previous variables/files\n\no   Use of an \"initSimulation\" action before the \"runSimulation\" to  be able to change manually the simulation parameters\n\n·         Définition graphique de l’espace de valeur, éventuellement en 2D et disjoint\n\no   Specific OutPut\n\n## The Solution\n\nDefine a new **Experimenter** agent and put real code/reflexes/actions... GAML code inside the Experimenter.\n\n## One simple example of what would be great:\n```\nexperiment InteliExplore type: batch repeat: 2 keep_seed: true until: ( time > 200 ) {\n      int nbprey init:0;\n      int nbpredator init:0;\n\n      init\n      {\n            //for example read experiment plan from file\n           \n      }\n     \n\n      reflex method\n      {\n            loop prm over:prey_max\n            {\n                   do: createsimulation\n                   setParameter(\"nb_preys_init\",pr)\n\n                   do: initsimulation\n\n                   if (prey_max<100)\n                   setParameter(\"nb_predators_init\",200)\n                   if (prey_max>100)\n                   setParameter(\"nb_predators_init\",200)\n\n                   do: runsimulation;\n\n                   do: aftersimulation;\n                  \n            }\n      }\n\n      action aftersimulation\n      {\n            loop over getVariable(agents)\n            {\n                   log(\"everything dans file\");      //with the save function?\n            }     \n      }\n\n      chart name: 'Species evolution' type: series background: rgb('white') size: {1,0.4} position: {0, 0.05}\n      {\n      data initial_number_of_preys value: getValue(\"nb_preys_init\") color: rgb('blue') ;\n        data final_number_of_predator value: getValue(\"nb_predators\") color: rgb('red') ;\n      }\n    file name: 'logsimple' type: text data: 'simulation: '+ step\n                                  +'; allparams' + getAllParamters // PROBLEME comment sauver tous les parametres?\n                                   + '; nbPreys: ' + getValue(\"nb_preys_init\")\n                                    + '; finalPredators: ' + getValue(\"nb_preys\") ;\n}\n\n```\n\n## TODO\n\nAnd Alexis did almost all this in less than a day....... But how does he do that??\n\n- A new type of Custom Experiment\n\n- In this experiment block, an ExperimenterAgent manages the simulations\n\n- Init() may have to create a Simulation to get a Scheduler (?) and/or a World(?)\n\n- He must have a Scheduler to be able to stop/wait in a loop for the end of a Simulation (contradiction with previous point...)\n\n- Its most important function is to be able to call Simulation.step()\n\n=>Create a Simulation Type which has a Step() operator\n\n- Create a ExperimentatorSkill with a lot of usefull actions (Step(int), ...)\n\n- Check that it is possible to define plots, logs, ...","url":"wiki/Event__CP12Batch.md"},"Event__CP12Development.md":{"title":" GAMA Development","content":"# GAMA Development","url":"wiki/Event__CP12Development.md"},"Event__CP12Doc.md":{"title":" Online & Local Documentation","content":"# Online & Local Documentation","url":"wiki/Event__CP12Doc.md"},"Event__CP12FIPA.md":{"title":" FIPA-ACL Skill","content":"# FIPA-ACL Skill","url":"wiki/Event__CP12FIPA.md"},"Event__CP12Git.md":{"title":" Gama on Git","content":"# Gama on Git\n\nhttp://eclipselabs.org/p/gama\n\n# Details","url":"wiki/Event__CP12Git.md"},"Event__CP12Graph.md":{"title":" Graph operators and indicators","content":"# Graph operators and indicators\n\n## goals\n\n**load graphs from files** generate graphs using generators\n**operators for graph manipulation (including stats)** graphs display\n\n## done\n\n### load graphs from file\n\nFor parsing network files, we use the graphstream library which supports the top- 10 file formats. All these formats are supported by GAMA now.\n\nTill now, the GAML langage does not enables an easy way to create primitives that both take more than 3 args as an input and return an object. Thus loading a graph is defined as an action of a skill; one has to create an instance of agent with this skill for loading the network.\n\n```\nglobal {  \n\tvar mongraphe type:graph;\n\tgraph_manager graph_util;\n\n\tinit { \n\t\tcreate graph_manager returns: graph_util;\n\t\task graph_util {\n\t\t\t\n\t\t\tset mongraphe value:load_graph_from_dgs_old(self, [edge_species::edgeSpecy, vertex_species::nodeSpecy,file::\"../includes/BarabasiGenerated.dgs\"]);\n\t\t\n\t\t}\n\t}  \n}\n\n```\n\n### graph manipulators\n\nThe structure for the manipulation of graphs is based on the existing GAMA graph type. As a consequence, novel algorithms, operators and visualizations will be usable for both spatial graphs (loading from GIS for instance, like roads) and more abstract graphs (not spatialized).\n\nPatrick did some interesting work for searching shortest pathes and so on.\n\nNovel operators should still be defined.\n\n### graph visualization\n\nFirst of all, we had to disturb many GAMA-gurus for undertanding how to create a novel View (that is, another tab in the simulation perspective) from GAML. A novel display is defined for displaying a network.\n\n```\noutput {\n\tgraphdisplay nameOfMyDisplay graph: mongraphe {\t \n\t}\n}\n```\n\nThis line indicates that we would like to display a graph defined in the variable \"mongraphe\". This simple line will open the display.\n\n\n\n## Roadmap\n\n**provide another (simpler !) syntax for loading networks** visu:\n  * implement prefuse instead of graphstream for the visualisation\n  * map GAML aspects to the view of the network\n**implement operators for graph manipulation** add generators for simple graphs generation (with a simple syntax as well)","url":"wiki/Event__CP12Graph.md"},"Event__CP12Headless.md":{"title":" Headless operation","content":"# Headless operation\n\nBe able to launch a simulation without any interface.\n\nBasic example:\n```\n$gama.jar test.gaml input.xml\n```","url":"wiki/Event__CP12Headless.md"},"Event__CP12IDE.md":{"title":" Enhancement of the IDE","content":"# Enhancement of the IDE","url":"wiki/Event__CP12IDE.md"},"Event__CP12Library.md":{"title":" Library of models","content":"# Library of models","url":"wiki/Event__CP12Library.md"},"Event__CP12MultiScale.md":{"title":" Improvement of the Multi-scale framework","content":"# Improvement of the Multi-scale framework","url":"wiki/Event__CP12MultiScale.md"},"Event__CP12OpenGL.md":{"title":" OpenGL Display","content":"# OpenGL Display\n\nIntegrate OpenGL (jogl) view in Gama.\n\nHave a display using OpenGL (Jogl: http://jogamp.org/jogl/www/) libraries implement as a gama plug-ins.\n\nplugin name: ` msi.gama.jogl`\n\n`msi.gama.jogl` will depend on `msi.gama.application` and `msi.gama.core`\n\nCurrent work:\n  * A new output symbol has been defined in order to call a new display in gaml\n\n# Definition of the symbol in `msi.gama.core/src/msi/gama/opengl/GLOutput.java`\n```\n@symbol(name = IKeyword.DISPLAY_GL, kind = ISymbolKind.OUTPUT)\n@facets(value = {\n\t//@facet(name = IKeyword.DISPLAY_GRAPH, type = IType.STRING_STR, optional = false),\n\t@facet(name = IKeyword.NAME, type = IType.STRING_STR, optional = true)\n\t}, omissible = IKeyword.NAME)\n@with_sequence\n@inside(symbols = IKeyword.OUTPUT)\n```\n\n\n# Use of the symbol in `msi.gama.models/models/graph/model/testSIG.gaml` :\n```\noutput {\n\tgraphdisplaygl {\t\t\n\t}\n```\n  * A new view in msi.gama.jogl plugin.xml\n\n```\n    <extension\n          point=\"org.eclipse.ui.views\">\n           <view allowMultiple=\"true\"\n            category=\"msi.gama.gui.category.gama\"\n            class=\"msi.gama.jogl.GLView\"\n            icon=\"icons/view_console.png\"\n            id=\"msi.gama.jogl.GLView\"\n            name=\"GL\"\n            restorable=\"true\">\n          </view>\n    </extension>\n```\n\nThis view is implemented in `/Users/macbookpro/Projects/GamaDev/msi.gama.jogl/src/msi/gama/jogl/GLView.java`\n\nThe view ID must also be defined `src/msi/gama/common/util/GuiUtils.java`\n```\npublic static final String GL_VIEW_ID = \"msi.gama.jogl.GLView\";\n```\n\n\n<a href='http://gama-platform.googlecode.com/files/gama-opengl.png' title='CodingCampNight'><img src='http://gama-platform.googlecode.com/files/gama-opengl.png' alt='CodingCampNight' /></a>","url":"wiki/Event__CP12OpenGL.md"},"Event__CP12SLD.md":{"title":" SLD-based aspects","content":"# SLD-based aspects\n\nNot chosen as a work theme for the coding camp...","url":"wiki/Event__CP12SLD.md"},"Event__CP12Stats.md":{"title":" Statistical Tools in GAMA","content":"# Statistical Tools in GAMA","url":"wiki/Event__CP12Stats.md"},"Event__CP12Test.md":{"title":" Test Models & Language","content":"# Test Models & Language\n\n  * A Coding Dojo (5 people) was organized in order to sensibilize developpers about unit tests.\nThe produced code is available here: https://github.com/SergeStinckwich/TennisKataTamCoc\nThe usual retrospective done after a Dojo is here: https://github.com/SergeStinckwich/TennisKataTamCoc/tree/master/README\n\n  * Some very simple models has been done in the \"multi-scale\" group with An. At that occasion, we didn't define real tests, but the idea was the same: define models as simple as possible that illustrate some basic concepts. The same work should be done for all aspects (skills, operators, actions, GAML architecture, ...).\n\n  * Difficult and boring to introduce tests in the GAMA platform at the moment. It is easier to introduce tests in ongoing developments. For example, Serge and Samuel do some unit tests for the new GraphSkill based on GraphStream.","url":"wiki/Event__CP12Test.md"},"Event__CP12traffic.md":{"title":" Traffic simulation and Physics constraints operators","content":"# Traffic simulation and Physics constraints operators\n\n**Traffic simulation**\n\nA first task that we done was to define a new plug-in in order to take into account the fact that a road has a limited number of lanes.\n\nWe propose a plug-in that contains the driving plug-in. This plug-in extends the moving skill. In particular, it proposes a new primitive \"gotoTraffic\" that integrates a collision avoiding algorithm.\n2 models (in \"models/experimental models\") were proposed to illustrate the use of our plug-in.\n\nDrivingSkill.java implements a new skill in `package msi.gaml.extensions.traffic`\n```\n@skill(\"driving\")\npublic class DrivingSkill extends MovingSkill{\n...\n}\n```\n\nNew model in `msi.gama.models/experimental_models/traffic`\n\n**Physics constraints operators**\n\nA second plugin is under development concerning physic computation. In particular, it allows to handle collisions between two convex polygons. A first toy model concerning pool game was developed.\nLibrary used: http://www.jbox2d.org/\n\n`src/msi/gaml/extensions/physics/PhysicsSkill.java` implements a new skill in `package msi.gaml.extensions.physics`\n```\n@skill(\"physical\")\npublic class PhysicsSkill extends Skill{\n        @setter(\"physical_world\")\n        public void setWorldAgent(final IAgent _agent, final IAgent _world){\n                if(_world == null)\n                        return;\n                        \n                PhysicalWorldAgent pwa = (PhysicalWorldAgent)_world;\n                pwa.registerAgent(_agent);\n        }\n\n\n```","url":"wiki/Event__CP12traffic.md"},"Event__CP12Water.md":{"title":" Water-management tutorial","content":"# Water-management tutorial\n\nWe did not work on this theme, but we made some decisions :\n- Plenary talk 1h10 : 1h : introduction to agent-based modeling; 20 minutes : MAELIA\n- a meeting will be organized just after the WAT-GAME training (the 26th of April at Toulouse).\n\nDeadlines :\n- 30 march: Biographies\n- 13 april: short synopsis of the plenary talk (5 to 10 lines)\n- 13 april: short synopsis of the workshop (5 to 10 lines)\n- 25 may: final synopsis of the plenary talk\n- 25 may: presentation (ppt) of the plenary talk\n- 25 may (if translated) (optional) : paper concerning the plenary talk (max 10 pages, text longer in English - not translated into vietnamese)\n- 25 may (if translated) (optional) : paper concerning the workshop (max 10 pages, text longer in English - not translated into vietnamese)\n- 8 june: final synopsis of the workshop\n- 8 june: presentation (ppt) of the workshop","url":"wiki/Event__CP12Water.md"},"Event__Events.md":{"title":" Coding Camps","content":"# Coding Camps\nList of GAMA Coding Camps :\n  * [Coding Camp March 2012](Event__CodingCamp2012)\n  * [Fall Coding Camp 2012](Event__CodingCampFall2012)\n  * [Programme doctoral internationale 2012](Event__PDI2012)","url":"wiki/Event__Events.md"},"Event__MIMSCOP2012.md":{"title":" Introduction","content":"# Introduction\n\nThe MIMSCOP Summer school 2012 (Modélisation Informatique et Mathématique des Systèmes Complexes de Pêcherie took place from the 16th to the 21th of July in the AIMS-IRD Campus at Mbour (Senegal).\n\n![http://gama-platform.googlecode.com/files/affiche_reduite.png](http://gama-platform.googlecode.com/files/affiche_reduite.png)\n\n# Developed models\n\n  * _Baye Cheikh MBAYE and Fatou Nene DIOP_ **Modélisation de l'impat de l'environnement sur la migration de sardinella aurita le long de la côte sénégalo-mauritanienne : outil de suivi et de prévision du stock pour la pêche** ([Slidehow](http://gama-platform.googlecode.com/files/Presentation_model_migration_poisson.pdf))\n  * _Macire Thieba TOURE and ￼Harouna DIOUF_ **Impact de la gestion sur la biomasse de la thonine pêchée au Sénégal** [(Slideshow)](http://gama-platform.googlecode.com/files/biomass.pdf)\n  * _Mansour NDOUR and Thierno DIOP_ **Modélisation Impacts des AMP sur la biomasse et les captures en fonction du site et du mode de gestion** [(Slideshow)](http://gama-platform.googlecode.com/files/simulationtp_final_AMP_mansourthierno.pdf)\n  * _Sidy DIOP and Papa Baba FALL_ **L'impact de la pollution sur les espèces halieutiques** [(slideshow)](http://gama-platform.googlecode.com/files/ImpactPollutionEspecesHalieutiques.pdf)\n  * _Sana KEITA and  Serigne Mbacke GUEYE_ **Comparaison de la pêche sélective et non sélective sur la petite côte** [(Slideshow](http://gama-platform.googlecode.com/files/serine-sana.pdf)\n  * _Siny NDOYE and Erick FARGEAS_  **Une alternative à la baisse de la biomasse : « l’aquaculture, solution de développement durable »** [(Slideshow)](http://gama-platform.googlecode.com/files/siny_fargeas.pdf)\n  * _Abdoulaye THIAM and Mouhamadou Baidy DIA_ **Evolution de poissons dans les AMP et dans l’aquaculture** [(Slideshow)](http://gama-platform.googlecode.com/files/thiam_Dia.pdf)\n\n# Trainers\n\n  * **Auger** Pierre - UMMISCO, IRD-UCAD\n  * **Bah** Alassane - UMMISCO, ESP, UCAD\n  * **Diouf** Niokhor - IUPA, UCAD\n  * **Guy** Gohier - CRAMS\n  * **Marilleau** Nicolas - UMMISCO, IRD-UPMC\n  * **Ndiaye**\t Samba - UMMISCO, FST, UCAD\n  * **Seck** Diaraf - UMMISCO, FAESG, UCAD\n\n\n# Learners\n\n  * **Badji** Insa - AIMS\n  * **Dia** Mouhamadou Baidy - AIMS\n  * **Diop** Sidy -  AIMS\n  * **Diop** Thierno - \tAIMS\n  * **Diouf** Harouna - IUPA, UCAD\n  * **Fall** Papa Baba - LTI, FST, UCAD\n  * **Fargeas** Eric - LTI, FST, UCAD\n  * **Gueye** Serigne Mbacké - LID, FST, UCAD\n  * **Keita** Sana - AIMS\n  * **Ly** Sidy - LGA, FST, UCAD\n  * **Mansal** Fulgurence - LGA, FST, UCAD\n  * **Mbaye** Baye Cheikh - LPAO-SF, ESP, UCAD\n  * **Ndour** Mansour - IUPA, UCAD\n  * **Ndoye** Siny - LPAO-SF, ESP, UCAD\n  * **Thiam** Abdoulaye - AIMS\n  * **Touré** Macire Thieba - AIMS\n\n# The participants\n\n![http://gama-platform.googlecode.com/files/photo.png](http://gama-platform.googlecode.com/files/photo.png)","url":"wiki/Event__MIMSCOP2012.md"},"Event__PDI2012.md":{"title":" Introduction","content":"# Introduction\n\nDuring the [PDI2012](http://www.ummisco.ird.fr/pdi/) nearly 50 PhD students were working together on different topic related to complex system modeling.\nAt the end of the formation, each student (by groups of 2 or 3) had to present a model in a mini-projet. The purpose of this mii-project was to use a platform and to create a model related to their respective research topics. Here is an overview of the model that has been implemented with Gama. Some of those projects has been presenting in [COMMISCO 2012](http://www.ummisco.ird.fr/pdi/spip.php?rubrique6)\n\n\n# Projects\n\n## First year (promo2012)\n**Siny  Ndoye - Quang Truong Chi** _Modelisation of the land use applied to the commune of My An-Ben Tre in the Delta Mekong._\n\nSince 1999, Vietnam has transformed 380 000 ha of rice agriculture into aquaculture. It has different impact like the fall of the rice agriculture, forest destruction and demographic increase near aqua farm. The shrimp culture is responsible of the destruction of the mangrove swamp since the 90's. The aim of this model was to study the impact of a government aid for rice producer on this problem.\n\n**Cedrigue Djiongo - Abdelkarim Ed-Darraz** _Modelisation of the different  land use in the forest._\n\nThe model study the dynamic of forest parcel over the time according to the activity of nomad paysans. The parcel can have different state such as primary forest, chromolaena forest, bush fallow, forest crop field or secondary forest).\n\n**Souleymane Sy - Nghi Huynh Quang** _Impact of the dynamic of the vegetation of the rain in west africa_\n\nWest africa is one of the part of the world that faced the most climate variability during the second half of the 20th century. To understand the origin on the variability on the amount of rain Gama is used to study the impact of the vegetation dynamic on the rain using a retroactivity between vegetation and atmosphere\n\n**Hédia Zardi - Tran Thi Cam Giang** _Modelisation of the SEIR model by GAMA_\n\nUntil today, many infectious diseases in the world such as measles, tuberculosis, dengue ... still exist. These diseases are one of the main causes of infant mortality in most countries of Asis, Africa, etc.\nTherefore, we want to present these infectious diseases in the computer models, after we want to find the periods of diseases to provide positive solutions that allow us to turn them off.\n\n## Second year (promo2011)\n\n**Ahmed Tidjane Cisse - Arnaud Grignard** _Vector disease modélisation- Multi point of view approach and visualization._\n\nPropose a meta-model applied to vector disease. Gama has been used to study the rift valley fever disease according to a meta-model previously defined. The idea is to define basic or macro behavior for host, environment and  infectious agent on which a vector is moving and then to implement those meta-agent for a specific vector disease (in this case the rift valey fever).\n\n## Third year (promo2010)\n\n**Moussa Gueye - Inès Hassoumi - Zineb Belarbi** _Impact of the dispersion of air pollutants: applied to the city of Tunis_\n\nThis project study the impact of pollutants on the environment on the health. The goal is to identify where new urban zone can be created by taking in account the concentration of each pollutants in the city. The main interest of the model is the coupling of the data coming from numerical equation of the advection-diffusion process using finite element method and then include those results on a grid created in Gama on which the value of each pollutants is extrapolated.","url":"wiki/Event__PDI2012.md"},"Event__TrainingSessionHanoi2009.md":{"title":" <font color='blue'>Context</font>","content":"\n\n# <font color='blue'>Context</font>\nTraining session on agent-based modeling and a tutorial on GAMA 1.1 organized at the IFI from the 26th to the 28th of October, 2009\n\n# <font color='blue'>List of presentations</font>\nHere the list of the different presentations given during the training session:\n\n  1. [Introduction to Agent Based Modeling](http://gama-platform.googlecode.com/files/1. Introduction to Agent Based Modeling.pdf)\n  1. [An introduction to GAMA](http://gama-platform.googlecode.com/files/2. Introduction to GAMA.pdf)\n  1. [Tutorial: Forest fires](http://gama-platform.googlecode.com/files/3. Tutorial Forest Fire.pdf)\n  1. [Tutorial: Segregation](http://gama-platform.googlecode.com/files/4. Tutorial Segregation.pdf)\n  1. [GIS in GAMA: part1](http://code.google.com/p/gama-platform/downloads/detail?name=5. GIS in GAMA Part 1.pdf&can=1&q=)\n  1. [GIS in GAMA: part2](http://code.google.com/p/gama-platform/downloads/detail?name=6. GIS in GAMA Part 2.pdf&can=1&q=)\n  1. [Exploring Models](http://code.google.com/p/gama-platform/downloads/detail?name=7. Exploring Models in GAMA.pdf&can=1&q=)","url":"wiki/Event__TrainingSessionHanoi2009.md"},"Event__TraininSessionPDI2011.md":{"title":" <font color='blue'>Context</font>","content":"\n\n# <font color='blue'>Context</font>\nTraining session on GAMA 1.4 at IRD Bondy (France) the 5th of December, 2011.\n\n# <font color='blue'>List of presentations</font>\nHere, the list of the different presentations (in French) given during the training session:\n\n  1. [Introduction to GAMA](http://gama-platform.googlecode.com/files/Intro_GAMA14_PDI2011.pdf)\n  1. [GAMA and GIS](http://gama-platform.googlecode.com/files/GAMA14_and_GIS_PDI2011.pdf)\n  1. Multi-scale Modeling\n\n\n# <font color='blue'>Models</font>\nthe models used during the training session are all provided with the last version of GAMA (1.4)","url":"wiki/Event__TraininSessionPDI2011.md"},"DevelopingExtensions.md":{"title":" Developing Extensions","content":"# Developing Extensions\n\n\n\nGAMA accepts _extensions_ to the GAML language, defined by external programmers and dynamically loaded by the platform each time it is run. Extensions can represent new built-in species, types, file-types, skills, operators, statements, new control architectures or even types of displays. Other internal structures of GAML will be progressively \"opened\" to this mechanism in the future: display layers (hardwired for the moment), new types of outputs (hardwired for the moment), scheduling policies (hardwired for the moment), random number generators (hardwired for the moment).\nThe extension mechanism relies on two complementary techniques:\n  * the first one consists in defining the GAML extensions [in a plug-in](DevelopingPlugins) (in the OSGI sense, see [here](http://www.eclipse.org/equinox/)) that will be loaded by GAMA at runtime and must \"declare\" that it is contributing to the platform.\n  * the second one is to indicate to GAMA where to look for extensions, using Java annotations that are gathered at compile time (some being also used at runtime) and directly compiled into GAML structures.\n\nThe following sections describe this extension process.\n\n  * 1. [Installing the GIT version](InstallingGitVersion)\n  * 2. [Architecture of GAMA](GamaArchitecture)\n  * 3. [Developing a Plugin](DevelopingPlugins)\n  * 4. [Developing a Skill](DevelopingSkills)\n  * 5. [Developing a Statement](DevelopingStatements)\n  * 6. [Developing an Operator](DevelopingOperators)\n  * 7. [Developing a Type](DevelopingTypes)\n  * 8. [Developing a Species](DevelopingSpecies)\n  * 9. [Developing a Control Architecture](DevelopingControlArchitectures)\n  * 10. [Index of annotations](DevelopingIndexAnnotations)\n  * 11. [IScope](DevelopingIScope)","url":"wiki/DevelopingExtensions.md"},"Download.md":{"title":" Download GAMA","content":"# Download GAMA\n\n## GAMA 1.7 [Continuous Release](https://github.com/gama-platform/gama/releases)\n\n\n## GAMA 1.6.1 (Archived)\n* GAMA for Windows 64 bits [Download](http://51.255.46.42/releases/gama1_6_1_win64.zip ) \n* GAMA for Windows 32 bits [Download](http://51.255.46.42/releases/gama1_6_1_win32.zip )  \n* GAMA for OSX 64 bits  [Download](http://51.255.46.42/releases/gama1_6_1_osx64.zip ) \n* GAMA for OSX 32 bits [Download](http://51.255.46.42/releases/gama1_6_1_osx32.zip) \n* GAMA for Linux 64 bits [Download](http://51.255.46.42/releases/gama1_6_1_linux64.zip) \n* GAMA for Linux 32 bits [Download](http://51.255.46.42/releases/gama1_6_1_linux32.zip) \n","url":"wiki/Download.md"},"Events.md":{"title":" References","content":"# References\n\n\n\nThis page references the events that are linked to GAMA.\n\nIf you happen to participate to an event linked to GAMA, please let us know, so that we can include it in this list.\n\n\n\n\n\n\n## Events linked to GAMA\n\nList of GAMA Coding Camps :\n  * [Coding Camp March 2014 (photos)](https://plus.google.com/u/0/photos/103876396184641904282/albums/5997643312439563137)\n  * [Coding Camp March 2012](Event__CodingCamp2012)\n  * [Fall Coding Camp 2012](Event__CodingCampFall2012)\n  * [Programme doctoral internationale 2012](Event__PDI2012)","url":"wiki/Events.md"},"GamlLanguage.md":{"title":" GAML","content":"\n# GAML\n\n\n\nModels that users want to simulate in GAMA have to be written in a special language, called **GAML** (short for **GA**ma **M**odeling **L**anguage)\n\nGAML is born from the necessity to have a high-level declarative way of defining and reusing structures found in almost all agent-based models. See [here](Introduction) for more information about its background.\n\nAlthough this choice requires users to learn a new programming (or better, _modeling_) language, everything has been made in GAMA to support a short learning curve, so that they can become almost autonomous in a limited time (informal measures taken at the different [events centered on GAMA](Events) have shown that one day is enough to acquire sufficient skills in writing complete models in GAML).\n\nThe documentation on GAML is organized in 5 main points:\n\n  * Description of the general structure of a model: see [this page](ModelOrganization)\n  * Description of the declaration of species (and all their components): see [this page](ManipulateBasicSpecies) and all its subpages\n  * Description of the declaration of experiments: see [this page](DefiningGUIExperiment) for regular experiments and [this one](BatchExperiments) for batch experiments.\n  * Reference of the [language](GamlReference) regarding all the structures provided to modelers\n  * Recipes of how to use special or advanced features offered in GAML: see this [page](Recipes).\n\nIn addition, some of the fundamental concepts behind GAML are also described in detail, both on the [modeling infrastructure](Introduction) and the [runtime infrastructure](RuntimeConcepts) on which GAML is relying to run experiments on models.","url":"wiki/GamlLanguage.md"},"Index.md":{"title":" Exhaustive list of GAMA Keywords","content":"\n# Exhaustive list of GAMA Keywords\n\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Operators\n[-](OperatorsAC#-), [:](OperatorsAC#:), [::](OperatorsAC#::), [!](OperatorsAC#!), [!=](OperatorsAC#!=), [?](OperatorsAC#?), [/](OperatorsAC#/), [.](OperatorsAC#.), [^](OperatorsAC#^), [@](OperatorsAC#@), [*](OperatorsAC#*), [+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [<>](OperatorsAC#<>), [=](OperatorsAC#=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [abs](OperatorsAC#abs), [accumulate](OperatorsAC#accumulate), [acos](OperatorsAC#acos), [action](OperatorsAC#action), [add_days](OperatorsAC#add_days), [add_edge](OperatorsAC#add_edge), [add_hours](OperatorsAC#add_hours), [add_minutes](OperatorsAC#add_minutes), [add_months](OperatorsAC#add_months), [add_ms](OperatorsAC#add_ms), [add_node](OperatorsAC#add_node), [add_point](OperatorsAC#add_point), [add_seconds](OperatorsAC#add_seconds), [add_weeks](OperatorsAC#add_weeks), [add_years](OperatorsAC#add_years), [adjacency](OperatorsAC#adjacency), [after](OperatorsAC#after), [agent](OperatorsAC#agent), [agent_closest_to](OperatorsAC#agent_closest_to), [agent_farthest_to](OperatorsAC#agent_farthest_to), [agent_from_geometry](OperatorsAC#agent_from_geometry), [agents_at_distance](OperatorsAC#agents_at_distance), [agents_inside](OperatorsAC#agents_inside), [agents_overlapping](OperatorsAC#agents_overlapping), [all_pairs_shortest_path](OperatorsAC#all_pairs_shortest_path), [alpha_index](OperatorsAC#alpha_index), [among](OperatorsAC#among), [and](OperatorsAC#and), [and](OperatorsAC#and), [angle_between](OperatorsAC#angle_between), [any](OperatorsAC#any), [any_location_in](OperatorsAC#any_location_in), [any_point_in](OperatorsAC#any_point_in), [append_horizontally](OperatorsAC#append_horizontally), [append_vertically](OperatorsAC#append_vertically), [arc](OperatorsAC#arc), [around](OperatorsAC#around), [as](OperatorsAC#as), [as_4_grid](OperatorsAC#as_4_grid), [as_distance_graph](OperatorsAC#as_distance_graph), [as_driving_graph](OperatorsAC#as_driving_graph), [as_edge_graph](OperatorsAC#as_edge_graph), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [as_int](OperatorsAC#as_int), [as_intersection_graph](OperatorsAC#as_intersection_graph), [as_map](OperatorsAC#as_map), [as_matrix](OperatorsAC#as_matrix), [as_path](OperatorsAC#as_path), [asin](OperatorsAC#asin), [at](OperatorsAC#at), [at_distance](OperatorsAC#at_distance), [at_location](OperatorsAC#at_location), [atan](OperatorsAC#atan), [atan2](OperatorsAC#atan2), [attributes](OperatorsAC#attributes), [BDIPlan](OperatorsAC#BDIPlan), [before](OperatorsAC#before), [beta_index](OperatorsAC#beta_index), [between](OperatorsAC#between), [betweenness_centrality](OperatorsAC#betweenness_centrality), [biggest_cliques_of](OperatorsAC#biggest_cliques_of), [binomial](OperatorsAC#binomial), [blend](OperatorsAC#blend), [bool](OperatorsAC#bool), [box](OperatorsAC#box), [brewer_colors](OperatorsAC#brewer_colors), [brewer_palettes](OperatorsAC#brewer_palettes), [buffer](OperatorsAC#buffer), [build](OperatorsAC#build), [ceil](OperatorsAC#ceil), [centroid](OperatorsAC#centroid), [char](OperatorsAC#char), [circle](OperatorsAC#circle), [clean](OperatorsAC#clean), [closest_points_with](OperatorsAC#closest_points_with), [closest_to](OperatorsAC#closest_to), [collect](OperatorsAC#collect), [column_at](OperatorsAC#column_at), [columns_list](OperatorsAC#columns_list), [command](OperatorsAC#command), [cone](OperatorsAC#cone), [cone3D](OperatorsAC#cone3D), [connected_components_of](OperatorsAC#connected_components_of), [connectivity_index](OperatorsAC#connectivity_index), [container](OperatorsAC#container), [contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), [contains_edge](OperatorsAC#contains_edge), [contains_vertex](OperatorsAC#contains_vertex), [conversation](OperatorsAC#conversation), [convex_hull](OperatorsAC#convex_hull), [copy](OperatorsAC#copy), [copy_between](OperatorsAC#copy_between), [corR](OperatorsAC#corR), [cos](OperatorsAC#cos), [cos_rad](OperatorsAC#cos_rad), [count](OperatorsAC#count), [covers](OperatorsAC#covers), [cross](OperatorsAC#cross), [crosses](OperatorsAC#crosses), [crs](OperatorsAC#crs), [CRS_transform](OperatorsAC#CRS_transform), [csv_file](OperatorsAC#csv_file), [cube](OperatorsAC#cube), [curve](OperatorsAC#curve), [cylinder](OperatorsAC#cylinder), [date](OperatorsDM#date), [dbscan](OperatorsDM#dbscan), [dead](OperatorsDM#dead), [degree_of](OperatorsDM#degree_of), [dem](OperatorsDM#dem), [det](OperatorsDM#det), [determinant](OperatorsDM#determinant), [diff](OperatorsDM#diff), [diff2](OperatorsDM#diff2), [directed](OperatorsDM#directed), [direction_between](OperatorsDM#direction_between), [direction_to](OperatorsDM#direction_to), [disjoint_from](OperatorsDM#disjoint_from), [distance_between](OperatorsDM#distance_between), [distance_to](OperatorsDM#distance_to), [distinct](OperatorsDM#distinct), [distribution_of](OperatorsDM#distribution_of), [distribution2d_of](OperatorsDM#distribution2d_of), [div](OperatorsDM#div), [dxf_file](OperatorsDM#dxf_file), [edge](OperatorsDM#edge), [edge_between](OperatorsDM#edge_between), [edge_betweenness](OperatorsDM#edge_betweenness), [edges](OperatorsDM#edges), [eigenvalues](OperatorsDM#eigenvalues), [electre_DM](OperatorsDM#electre_DM), [ellipse](OperatorsDM#ellipse), [emotion](OperatorsDM#emotion), [empty](OperatorsDM#empty), [enlarged_by](OperatorsDM#enlarged_by), [envelope](OperatorsDM#envelope), [eval_gaml](OperatorsDM#eval_gaml), [eval_when](OperatorsDM#eval_when), [even](OperatorsDM#even), [every](OperatorsDM#every), [every_cycle](OperatorsDM#every_cycle), [evidence_theory_DM](OperatorsDM#evidence_theory_DM), [exp](OperatorsDM#exp), [fact](OperatorsDM#fact), [farthest_point_to](OperatorsDM#farthest_point_to), [farthest_to](OperatorsDM#farthest_to), [file](OperatorsDM#file), [file_exists](OperatorsDM#file_exists), [first](OperatorsDM#first), [first_of](OperatorsDM#first_of), [first_with](OperatorsDM#first_with), [flip](OperatorsDM#flip), [float](OperatorsDM#float), [floor](OperatorsDM#floor), [folder](OperatorsDM#folder), [font](OperatorsDM#font), [frequency_of](OperatorsDM#frequency_of), [from](OperatorsDM#from), [fuzzy_kappa](OperatorsDM#fuzzy_kappa), [fuzzy_kappa_sim](OperatorsDM#fuzzy_kappa_sim), [gaml_file](OperatorsDM#gaml_file), [gamma_index](OperatorsDM#gamma_index), [gamma_rnd](OperatorsDM#gamma_rnd), [gauss](OperatorsDM#gauss), [generate_barabasi_albert](OperatorsDM#generate_barabasi_albert), [generate_complete_graph](OperatorsDM#generate_complete_graph), [generate_watts_strogatz](OperatorsDM#generate_watts_strogatz), [geojson_file](OperatorsDM#geojson_file), [geometric_mean](OperatorsDM#geometric_mean), [geometry](OperatorsDM#geometry), [geometry_collection](OperatorsDM#geometry_collection), [get](OperatorsDM#get), [get_about](OperatorsDM#get_about), [get_agent](OperatorsDM#get_agent), [get_agent_cause](OperatorsDM#get_agent_cause), [get_decay](OperatorsDM#get_decay), [get_dominance](OperatorsDM#get_dominance), [get_familiarity](OperatorsDM#get_familiarity), [get_intensity](OperatorsDM#get_intensity), [get_lifetime](OperatorsDM#get_lifetime), [get_liking](OperatorsDM#get_liking), [get_praiseworthiness](OperatorsDM#get_praiseworthiness), [get_priority](OperatorsDM#get_priority), [get_solidarity](OperatorsDM#get_solidarity), [get_super_intention](OperatorsDM#get_super_intention), [gif_file](OperatorsDM#gif_file), [gini](OperatorsDM#gini), [graph](OperatorsDM#graph), [grayscale](OperatorsDM#grayscale), [grid_at](OperatorsDM#grid_at), [grid_cells_to_graph](OperatorsDM#grid_cells_to_graph), [grid_file](OperatorsDM#grid_file), [group_by](OperatorsDM#group_by), [harmonic_mean](OperatorsDM#harmonic_mean), [hexagon](OperatorsDM#hexagon), [hierarchical_clustering](OperatorsDM#hierarchical_clustering), [hsb](OperatorsDM#hsb), [hypot](OperatorsDM#hypot), [IDW](OperatorsAC#IDW), [image_file](OperatorsDM#image_file), [in](OperatorsDM#in), [in_degree_of](OperatorsDM#in_degree_of), [in_edges_of](OperatorsDM#in_edges_of), [indented_by](OperatorsDM#indented_by), [index_by](OperatorsDM#index_by), [index_of](OperatorsDM#index_of), [inside](OperatorsDM#inside), [int](OperatorsDM#int), [inter](OperatorsDM#inter), [interleave](OperatorsDM#interleave), [internal_at](OperatorsDM#internal_at), [internal_integrated_value](OperatorsDM#internal_integrated_value), [internal_zero_order_equation](OperatorsDM#internal_zero_order_equation), [intersection](OperatorsDM#intersection), [intersects](OperatorsDM#intersects), [inverse](OperatorsDM#inverse), [inverse_distance_weighting](OperatorsDM#inverse_distance_weighting), [is](OperatorsDM#is), [is_csv](OperatorsDM#is_csv), [is_dxf](OperatorsDM#is_dxf), [is_finite](OperatorsDM#is_finite), [is_gaml](OperatorsDM#is_gaml), [is_geojson](OperatorsDM#is_geojson), [is_gif](OperatorsDM#is_gif), [is_grid](OperatorsDM#is_grid), [is_image](OperatorsDM#is_image), [is_json](OperatorsDM#is_json), [is_number](OperatorsDM#is_number), [is_obj](OperatorsDM#is_obj), [is_osm](OperatorsDM#is_osm), [is_pgm](OperatorsDM#is_pgm), [is_property](OperatorsDM#is_property), [is_R](OperatorsDM#is_R), [is_shape](OperatorsDM#is_shape), [is_skill](OperatorsDM#is_skill), [is_svg](OperatorsDM#is_svg), [is_text](OperatorsDM#is_text), [is_threeds](OperatorsDM#is_threeds), [is_URL](OperatorsDM#is_URL), [is_xml](OperatorsDM#is_xml), [json_file](OperatorsDM#json_file), [kappa](OperatorsDM#kappa), [kappa_sim](OperatorsDM#kappa_sim), [kmeans](OperatorsDM#kmeans), [kurtosis](OperatorsDM#kurtosis), [last](OperatorsDM#last), [last_index_of](OperatorsDM#last_index_of), [last_of](OperatorsDM#last_of), [last_with](OperatorsDM#last_with), [layout](OperatorsDM#layout), [length](OperatorsDM#length), [line](OperatorsDM#line), [link](OperatorsDM#link), [list](OperatorsDM#list), [list_with](OperatorsDM#list_with), [ln](OperatorsDM#ln), [load_graph_from_file](OperatorsDM#load_graph_from_file), [load_shortest_paths](OperatorsDM#load_shortest_paths), [log](OperatorsDM#log), [lower_case](OperatorsDM#lower_case), [map](OperatorsDM#map), [masked_by](OperatorsDM#masked_by), [material](OperatorsDM#material), [matrix](OperatorsDM#matrix), [matrix_with](OperatorsDM#matrix_with), [max](OperatorsDM#max), [max_of](OperatorsDM#max_of), [maximal_cliques_of](OperatorsDM#maximal_cliques_of), [mean](OperatorsDM#mean), [mean_deviation](OperatorsDM#mean_deviation), [mean_of](OperatorsDM#mean_of), [meanR](OperatorsDM#meanR), [median](OperatorsDM#median), [message](OperatorsDM#message), [milliseconds_between](OperatorsDM#milliseconds_between), [min](OperatorsDM#min), [min_of](OperatorsDM#min_of), [minus_days](OperatorsDM#minus_days), [minus_hours](OperatorsDM#minus_hours), [minus_minutes](OperatorsDM#minus_minutes), [minus_months](OperatorsDM#minus_months), [minus_ms](OperatorsDM#minus_ms), [minus_seconds](OperatorsDM#minus_seconds), [minus_weeks](OperatorsDM#minus_weeks), [minus_years](OperatorsDM#minus_years), [mod](OperatorsDM#mod), [months_between](OperatorsDM#months_between), [moran](OperatorsDM#moran), [mul](OperatorsDM#mul), [nb_cycles](OperatorsNZ#nb_cycles), [neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [new_emotion](OperatorsNZ#new_emotion), [new_folder](OperatorsNZ#new_folder), [new_predicate](OperatorsNZ#new_predicate), [new_social_link](OperatorsNZ#new_social_link), [node](OperatorsNZ#node), [nodes](OperatorsNZ#nodes), [norm](OperatorsNZ#norm), [not](OperatorsNZ#not), [obj_file](OperatorsNZ#obj_file), [of](OperatorsNZ#of), [of_generic_species](OperatorsNZ#of_generic_species), [of_species](OperatorsNZ#of_species), [one_of](OperatorsNZ#one_of), [or](OperatorsNZ#or), [or](OperatorsNZ#or), [osm_file](OperatorsNZ#osm_file), [out_degree_of](OperatorsNZ#out_degree_of), [out_edges_of](OperatorsNZ#out_edges_of), [overlapping](OperatorsNZ#overlapping), [overlaps](OperatorsNZ#overlaps), [pair](OperatorsNZ#pair), [partially_overlaps](OperatorsNZ#partially_overlaps), [path](OperatorsNZ#path), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [paths_between](OperatorsNZ#paths_between), [percent_absolute_deviation](OperatorsNZ#percent_absolute_deviation), [pgm_file](OperatorsNZ#pgm_file), [plan](OperatorsNZ#plan), [plus_days](OperatorsNZ#plus_days), [plus_hours](OperatorsNZ#plus_hours), [plus_minutes](OperatorsNZ#plus_minutes), [plus_months](OperatorsNZ#plus_months), [plus_ms](OperatorsNZ#plus_ms), [plus_seconds](OperatorsNZ#plus_seconds), [plus_weeks](OperatorsNZ#plus_weeks), [plus_years](OperatorsNZ#plus_years), [point](OperatorsNZ#point), [points_along](OperatorsNZ#points_along), [points_at](OperatorsNZ#points_at), [points_on](OperatorsNZ#points_on), [poisson](OperatorsNZ#poisson), [polygon](OperatorsNZ#polygon), [polyhedron](OperatorsNZ#polyhedron), [polyline](OperatorsNZ#polyline), [polyplan](OperatorsNZ#polyplan), [predecessors_of](OperatorsNZ#predecessors_of), [predicate](OperatorsNZ#predicate), [predict](OperatorsNZ#predict), [product](OperatorsNZ#product), [product_of](OperatorsNZ#product_of), [promethee_DM](OperatorsNZ#promethee_DM), [property_file](OperatorsNZ#property_file), [pyramid](OperatorsNZ#pyramid), [R_correlation](OperatorsAC#R_correlation), [R_file](OperatorsAC#R_file), [R_mean](OperatorsAC#R_mean), [range](OperatorsNZ#range), [read](OperatorsNZ#read), [rectangle](OperatorsNZ#rectangle), [reduced_by](OperatorsNZ#reduced_by), [regression](OperatorsNZ#regression), [remove_duplicates](OperatorsNZ#remove_duplicates), [remove_node_from](OperatorsNZ#remove_node_from), [replace](OperatorsNZ#replace), [replace_regex](OperatorsNZ#replace_regex), [reverse](OperatorsNZ#reverse), [rewire_n](OperatorsNZ#rewire_n), [rgb](OperatorsNZ#rgb), [rgb_to_xyz](OperatorsNZ#rgb_to_xyz), [rnd](OperatorsNZ#rnd), [rnd_choice](OperatorsNZ#rnd_choice), [rnd_color](OperatorsNZ#rnd_color), [rotated_by](OperatorsNZ#rotated_by), [round](OperatorsNZ#round), [row_at](OperatorsNZ#row_at), [rows_list](OperatorsNZ#rows_list), [sample](OperatorsNZ#sample), [scaled_by](OperatorsNZ#scaled_by), [scaled_to](OperatorsNZ#scaled_to), [select](OperatorsNZ#select), [set_about](OperatorsNZ#set_about), [set_agent](OperatorsNZ#set_agent), [set_agent_cause](OperatorsNZ#set_agent_cause), [set_decay](OperatorsNZ#set_decay), [set_dominance](OperatorsNZ#set_dominance), [set_familiarity](OperatorsNZ#set_familiarity), [set_intensity](OperatorsNZ#set_intensity), [set_liking](OperatorsNZ#set_liking), [set_solidarity](OperatorsNZ#set_solidarity), [set_truth](OperatorsNZ#set_truth), [set_z](OperatorsNZ#set_z), [shape_file](OperatorsNZ#shape_file), [shuffle](OperatorsNZ#shuffle), [signum](OperatorsNZ#signum), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), [simple_clustering_by_envelope_distance](OperatorsNZ#simple_clustering_by_envelope_distance), [simplification](OperatorsNZ#simplification), [sin](OperatorsNZ#sin), [sin_rad](OperatorsNZ#sin_rad), [since](OperatorsNZ#since), [skeletonize](OperatorsNZ#skeletonize), [skew_gauss](OperatorsNZ#skew_gauss), [skewness](OperatorsNZ#skewness), [skill](OperatorsNZ#skill), [smooth](OperatorsNZ#smooth), [social_link](OperatorsNZ#social_link), [solid](OperatorsNZ#solid), [sort](OperatorsNZ#sort), [sort_by](OperatorsNZ#sort_by), [source_of](OperatorsNZ#source_of), [spatial_graph](OperatorsNZ#spatial_graph), [species](OperatorsNZ#species), [species_of](OperatorsNZ#species_of), [sphere](OperatorsNZ#sphere), [split_at](OperatorsNZ#split_at), [split_geometry](OperatorsNZ#split_geometry), [split_lines](OperatorsNZ#split_lines), [split_with](OperatorsNZ#split_with), [sqrt](OperatorsNZ#sqrt), [square](OperatorsNZ#square), [squircle](OperatorsNZ#squircle), [standard_deviation](OperatorsNZ#standard_deviation), [string](OperatorsNZ#string), [subtract_days](OperatorsNZ#subtract_days), [subtract_hours](OperatorsNZ#subtract_hours), [subtract_minutes](OperatorsNZ#subtract_minutes), [subtract_months](OperatorsNZ#subtract_months), [subtract_ms](OperatorsNZ#subtract_ms), [subtract_seconds](OperatorsNZ#subtract_seconds), [subtract_weeks](OperatorsNZ#subtract_weeks), [subtract_years](OperatorsNZ#subtract_years), [successors_of](OperatorsNZ#successors_of), [sum](OperatorsNZ#sum), [sum_of](OperatorsNZ#sum_of), [svg_file](OperatorsNZ#svg_file), [tan](OperatorsNZ#tan), [tan_rad](OperatorsNZ#tan_rad), [tanh](OperatorsNZ#tanh), [target_of](OperatorsNZ#target_of), [teapot](OperatorsNZ#teapot), [text_file](OperatorsNZ#text_file), [TGauss](OperatorsAC#TGauss), [threeds_file](OperatorsNZ#threeds_file), [to](OperatorsNZ#to), [to_GAMA_CRS](OperatorsNZ#to_GAMA_CRS), [to_gaml](OperatorsNZ#to_gaml), [to_rectangles](OperatorsNZ#to_rectangles), [to_squares](OperatorsNZ#to_squares), [to_triangles](OperatorsNZ#to_triangles), [tokenize](OperatorsNZ#tokenize), [topology](OperatorsNZ#topology), [touches](OperatorsNZ#touches), [towards](OperatorsNZ#towards), [trace](OperatorsNZ#trace), [transformed_by](OperatorsNZ#transformed_by), [translated_by](OperatorsNZ#translated_by), [translated_to](OperatorsNZ#translated_to), [transpose](OperatorsNZ#transpose), [triangle](OperatorsNZ#triangle), [triangulate](OperatorsNZ#triangulate), [truncated_gauss](OperatorsNZ#truncated_gauss), [undirected](OperatorsNZ#undirected), [union](OperatorsNZ#union), [unknown](OperatorsNZ#unknown), [until](OperatorsNZ#until), [upper_case](OperatorsNZ#upper_case), [URL_file](OperatorsAC#URL_file), [use_cache](OperatorsNZ#use_cache), [user_input](OperatorsNZ#user_input), [using](OperatorsNZ#using), [variance](OperatorsNZ#variance), [variance_of](OperatorsNZ#variance_of), [voronoi](OperatorsNZ#voronoi), [weight_of](OperatorsNZ#weight_of), [weighted_means_DM](OperatorsNZ#weighted_means_DM), [where](OperatorsNZ#where), [with_lifetime](OperatorsNZ#with_lifetime), [with_max_of](OperatorsNZ#with_max_of), [with_min_of](OperatorsNZ#with_min_of), [with_optimizer_type](OperatorsNZ#with_optimizer_type), [with_praiseworthiness](OperatorsNZ#with_praiseworthiness), [with_precision](OperatorsNZ#with_precision), [with_priority](OperatorsNZ#with_priority), [with_values](OperatorsNZ#with_values), [with_weights](OperatorsNZ#with_weights), [without_holes](OperatorsNZ#without_holes), [writable](OperatorsNZ#writable), [xml_file](OperatorsNZ#xml_file), [years_between](OperatorsNZ#years_between), \n\t\t\t  \t\n----\n\n## Statements \n[=](Statements#=), [action](Statements#action), [add](Statements#add), [agents](Statements#agents), [annealing](Statements#annealing), [ask](Statements#ask), [aspect](Statements#aspect), [assert](Statements#assert), [benchmark](Statements#benchmark), [break](Statements#break), [camera](Statements#camera), [capture](Statements#capture), [chart](Statements#chart), [conscious_contagion](Statements#conscious_contagion), [create](Statements#create), [data](Statements#data), [datalist](Statements#datalist), [default](Statements#default), [diffuse](Statements#diffuse), [display](Statements#display), [display_grid](Statements#display_grid), [display_population](Statements#display_population), [do](Statements#do), [draw](Statements#draw), [else](Statements#else), [emotional_contagion](Statements#emotional_contagion), [enter](Statements#enter), [equation](Statements#equation), [error](Statements#error), [event](Statements#event), [exhaustive](Statements#exhaustive), [exit](Statements#exit), [experiment](Statements#experiment), [export](Statements#export), [focus](Statements#focus), [focus_on](Statements#focus_on), [genetic](Statements#genetic), [graphics](Statements#graphics), [highlight](Statements#highlight), [hill_climbing](Statements#hill_climbing), [if](Statements#if), [image](Statements#image), [inspect](Statements#inspect), [let](Statements#let), [light](Statements#light), [loop](Statements#loop), [match](Statements#match), [migrate](Statements#migrate), [monitor](Statements#monitor), [output](Statements#output), [output_file](Statements#output_file), [overlay](Statements#overlay), [parameter](Statements#parameter), [perceive](Statements#perceive), [permanent](Statements#permanent), [plan](Statements#plan), [put](Statements#put), [reactive_tabu](Statements#reactive_tabu), [reflex](Statements#reflex), [release](Statements#release), [remove](Statements#remove), [return](Statements#return), [rule](Statements#rule), [run](Statements#run), [save](Statements#save), [save_batch](Statements#save_batch), [set](Statements#set), [setup](Statements#setup), [simulate](Statements#simulate), [socialize](Statements#socialize), [solve](Statements#solve), [species](Statements#species), [state](Statements#state), [status](Statements#status), [switch](Statements#switch), [tabu](Statements#tabu), [task](Statements#task), [test](Statements#test), [trace](Statements#trace), [transition](Statements#transition), [unconscious_contagion](Statements#unconscious_contagion), [user_command](Statements#user_command), [user_init](Statements#user_init), [user_input](Statements#user_input), [user_panel](Statements#user_panel), [using](Statements#using), [Variable_container](Statements#Variable_container), [Variable_number](Statements#Variable_number), [Variable_regular](Statements#Variable_regular), [warn](Statements#warn), [write](Statements#write), \n\n----\n\n## Architectures\n[fsm](BuiltInControlArchitectures#fsm), [parallel_bdi](BuiltInControlArchitectures#parallel_bdi), [probabilistic_tasks](BuiltInControlArchitectures#probabilistic_tasks), [reflex](BuiltInControlArchitectures#reflex), [simple_bdi](BuiltInControlArchitectures#simple_bdi), [sorted_tasks](BuiltInControlArchitectures#sorted_tasks), [user_first](BuiltInControlArchitectures#user_first), [user_last](BuiltInControlArchitectures#user_last), [user_only](BuiltInControlArchitectures#user_only), [weighted_tasks](BuiltInControlArchitectures#weighted_tasks), \n\n----\n\n## Constants and colors\n[#aliceblue](UnitsAndConstants), [#antiquewhite](UnitsAndConstants), [#aqua](UnitsAndConstants), [#aquamarine](UnitsAndConstants), [#azure](UnitsAndConstants), [#beige](UnitsAndConstants), [#bisque](UnitsAndConstants), [#black](UnitsAndConstants), [#blanchedalmond](UnitsAndConstants), [#blue](UnitsAndConstants), [#blueviolet](UnitsAndConstants), [#bold](UnitsAndConstants), [#brown](UnitsAndConstants), [#burlywood](UnitsAndConstants), [#cadetblue](UnitsAndConstants), [#camera_location](UnitsAndConstants), [#camera_orientation](UnitsAndConstants), [#camera_target](UnitsAndConstants), [#chartreuse](UnitsAndConstants), [#chocolate](UnitsAndConstants), [#cl](UnitsAndConstants) (#centiliter,#centiliters), [#cm](UnitsAndConstants) (#centimeter,#centimeters), [#coral](UnitsAndConstants), [#cornflowerblue](UnitsAndConstants), [#cornsilk](UnitsAndConstants), [#crimson](UnitsAndConstants), [#custom](UnitsAndConstants), [#cyan](UnitsAndConstants), [#cycle](UnitsAndConstants) (#cycles), [#darkblue](UnitsAndConstants), [#darkcyan](UnitsAndConstants), [#darkgoldenrod](UnitsAndConstants), [#darkgray](UnitsAndConstants), [#darkgreen](UnitsAndConstants), [#darkgrey](UnitsAndConstants), [#darkkhaki](UnitsAndConstants), [#darkmagenta](UnitsAndConstants), [#darkolivegreen](UnitsAndConstants), [#darkorange](UnitsAndConstants), [#darkorchid](UnitsAndConstants), [#darkred](UnitsAndConstants), [#darksalmon](UnitsAndConstants), [#darkseagreen](UnitsAndConstants), [#darkslateblue](UnitsAndConstants), [#darkslategray](UnitsAndConstants), [#darkslategrey](UnitsAndConstants), [#darkturquoise](UnitsAndConstants), [#darkviolet](UnitsAndConstants), [#day](UnitsAndConstants) (#days), [#deeppink](UnitsAndConstants), [#deepskyblue](UnitsAndConstants), [#dimgray](UnitsAndConstants), [#dimgrey](UnitsAndConstants), [#display_height](UnitsAndConstants), [#display_width](UnitsAndConstants), [#dl](UnitsAndConstants) (#deciliter,#deciliters), [#dm](UnitsAndConstants) (#decimeter,#decimeters), [#dodgerblue](UnitsAndConstants), [#e](UnitsAndConstants), [#epoch](UnitsAndConstants), [#firebrick](UnitsAndConstants), [#flat](UnitsAndConstants), [#floralwhite](UnitsAndConstants), [#foot](UnitsAndConstants) (#feet,#ft), [#forestgreen](UnitsAndConstants), [#fuchsia](UnitsAndConstants), [#gainsboro](UnitsAndConstants), [#ghostwhite](UnitsAndConstants), [#gold](UnitsAndConstants), [#goldenrod](UnitsAndConstants), [#gram](UnitsAndConstants) (#grams), [#gray](UnitsAndConstants), [#green](UnitsAndConstants), [#greenyellow](UnitsAndConstants), [#grey](UnitsAndConstants), [#h](UnitsAndConstants) (#hour,#hours), [#hl](UnitsAndConstants) (#hectoliter,#hectoliters), [#honeydew](UnitsAndConstants), [#horizontal](UnitsAndConstants), [#hotpink](UnitsAndConstants), [#inch](UnitsAndConstants) (#inches), [#indianred](UnitsAndConstants), [#indigo](UnitsAndConstants), [#infinity](UnitsAndConstants), [#iso_local](UnitsAndConstants), [#iso_offset](UnitsAndConstants), [#iso_zoned](UnitsAndConstants), [#italic](UnitsAndConstants), [#ivory](UnitsAndConstants), [#kg](UnitsAndConstants) (#kilo,#kilogram,#kilos), [#khaki](UnitsAndConstants), [#km](UnitsAndConstants) (#kilometer,#kilometers), [#l](UnitsAndConstants) (#liter,#liters,#dm3), [#lavender](UnitsAndConstants), [#lavenderblush](UnitsAndConstants), [#lawngreen](UnitsAndConstants), [#lemonchiffon](UnitsAndConstants), [#lightblue](UnitsAndConstants), [#lightcoral](UnitsAndConstants), [#lightcyan](UnitsAndConstants), [#lightgoldenrodyellow](UnitsAndConstants), [#lightgray](UnitsAndConstants), [#lightgreen](UnitsAndConstants), [#lightgrey](UnitsAndConstants), [#lightpink](UnitsAndConstants), [#lightsalmon](UnitsAndConstants), [#lightseagreen](UnitsAndConstants), [#lightskyblue](UnitsAndConstants), [#lightslategray](UnitsAndConstants), [#lightslategrey](UnitsAndConstants), [#lightsteelblue](UnitsAndConstants), [#lightyellow](UnitsAndConstants), [#lime](UnitsAndConstants), [#limegreen](UnitsAndConstants), [#linen](UnitsAndConstants), [#longton](UnitsAndConstants) (#lton), [#m](UnitsAndConstants) (#meter,#meters), [#m2](UnitsAndConstants), [#m3](UnitsAndConstants), [#magenta](UnitsAndConstants), [#maroon](UnitsAndConstants), [#max_float](UnitsAndConstants), [#max_int](UnitsAndConstants), [#mediumaquamarine](UnitsAndConstants), [#mediumblue](UnitsAndConstants), [#mediumorchid](UnitsAndConstants), [#mediumpurple](UnitsAndConstants), [#mediumseagreen](UnitsAndConstants), [#mediumslateblue](UnitsAndConstants), [#mediumspringgreen](UnitsAndConstants), [#mediumturquoise](UnitsAndConstants), [#mediumvioletred](UnitsAndConstants), [#midnightblue](UnitsAndConstants), [#mile](UnitsAndConstants) (#miles), [#min_float](UnitsAndConstants), [#min_int](UnitsAndConstants), [#mintcream](UnitsAndConstants), [#minute](UnitsAndConstants) (#minutes,#mn), [#mistyrose](UnitsAndConstants), [#mm](UnitsAndConstants) (#milimeter,#milimeters), [#moccasin](UnitsAndConstants), [#month](UnitsAndConstants) (#months), [#msec](UnitsAndConstants) (#millisecond,#milliseconds,#ms), [#nan](UnitsAndConstants), [#navajowhite](UnitsAndConstants), [#navy](UnitsAndConstants), [#none](UnitsAndConstants), [#now](UnitsAndConstants), [#oldlace](UnitsAndConstants), [#olive](UnitsAndConstants), [#olivedrab](UnitsAndConstants), [#orange](UnitsAndConstants), [#orangered](UnitsAndConstants), [#orchid](UnitsAndConstants), [#ounce](UnitsAndConstants) (#oz,#ounces), [#palegoldenrod](UnitsAndConstants), [#palegreen](UnitsAndConstants), [#paleturquoise](UnitsAndConstants), [#palevioletred](UnitsAndConstants), [#papayawhip](UnitsAndConstants), [#peachpuff](UnitsAndConstants), [#peru](UnitsAndConstants), [#pi](UnitsAndConstants), [#pink](UnitsAndConstants), [#pixels](UnitsAndConstants) (#px), [#plain](UnitsAndConstants), [#plum](UnitsAndConstants), [#pound](UnitsAndConstants) (#lb,#pounds,#lbm), [#powderblue](UnitsAndConstants), [#purple](UnitsAndConstants), [#red](UnitsAndConstants), [#rosybrown](UnitsAndConstants), [#round](UnitsAndConstants), [#royalblue](UnitsAndConstants), [#saddlebrown](UnitsAndConstants), [#salmon](UnitsAndConstants), [#sandybrown](UnitsAndConstants), [#seagreen](UnitsAndConstants), [#seashell](UnitsAndConstants), [#sec](UnitsAndConstants) (#second,#seconds,#s), [#shortton](UnitsAndConstants) (#ston), [#sienna](UnitsAndConstants), [#silver](UnitsAndConstants), [#skyblue](UnitsAndConstants), [#slateblue](UnitsAndConstants), [#slategray](UnitsAndConstants), [#slategrey](UnitsAndConstants), [#snow](UnitsAndConstants), [#split](UnitsAndConstants), [#springgreen](UnitsAndConstants), [#sqft](UnitsAndConstants) (#square_foot,#square_feet), [#sqin](UnitsAndConstants) (#square_inch,#square_inches), [#sqmi](UnitsAndConstants) (#square_mile,#square_miles), [#square](UnitsAndConstants), [#stack](UnitsAndConstants), [#steelblue](UnitsAndConstants), [#stone](UnitsAndConstants) (#st), [#tan](UnitsAndConstants), [#teal](UnitsAndConstants), [#thistle](UnitsAndConstants), [#to_deg](UnitsAndConstants), [#to_rad](UnitsAndConstants), [#tomato](UnitsAndConstants), [#ton](UnitsAndConstants) (#tons), [#transparent](UnitsAndConstants), [#turquoise](UnitsAndConstants), [#user_location](UnitsAndConstants), [#vertical](UnitsAndConstants), [#violet](UnitsAndConstants), [#week](UnitsAndConstants) (#weeks), [#wheat](UnitsAndConstants), [#white](UnitsAndConstants), [#whitesmoke](UnitsAndConstants), [#yard](UnitsAndConstants) (#yards), [#year](UnitsAndConstants) (#years,#y), [#yellow](UnitsAndConstants), [#yellowgreen](UnitsAndConstants), [#zoom](UnitsAndConstants), \n\n----\n\n## Skills\n[advanced_driving](BuiltInSkills#advanced_driving), [driving](BuiltInSkills#driving), [fipa](BuiltInSkills#fipa), [GAMASQL](BuiltInSkills#GAMASQL), [grid](BuiltInSkills#grid), [MDXSKILL](BuiltInSkills#MDXSKILL), [messaging](BuiltInSkills#messaging), [moving](BuiltInSkills#moving), [moving3D](BuiltInSkills#moving3D), [network](BuiltInSkills#network), [physics](BuiltInSkills#physics), [skill_road](BuiltInSkills#skill_road), [skill_road_node](BuiltInSkills#skill_road_node), [SQLSKILL](BuiltInSkills#SQLSKILL), \t\n\n----\n\n## Species\n[agent](BuiltInSpecies#agent), [AgentDB](BuiltInSpecies#AgentDB), [base_edge](BuiltInSpecies#base_edge), [experiment](BuiltInSpecies#experiment), [graph_edge](BuiltInSpecies#graph_edge), [graph_node](BuiltInSpecies#graph_node), [model](BuiltInSpecies#model), [physical_world](BuiltInSpecies#physical_world), \n   \t[world](BuiltInSpecies#model )\n\n----\n\n## Actions\n[_init_](BuiltInSpecies#_init_), [_step_](BuiltInSpecies#_step_), [isConnected](BuiltInSpecies#isConnected), [close](BuiltInSpecies#close), [timeStamp](BuiltInSpecies#timeStamp), [connect](BuiltInSpecies#connect), [testConnection](BuiltInSpecies#testConnection), [select](BuiltInSpecies#select), [executeUpdate](BuiltInSpecies#executeUpdate), [getParameter](BuiltInSpecies#getParameter), [setParameter](BuiltInSpecies#setParameter), [insert](BuiltInSpecies#insert), [update_outputs](BuiltInSpecies#update_outputs), [related_to](BuiltInSpecies#related_to), [pause](BuiltInSpecies#pause), [halt](BuiltInSpecies#halt), [compute_forces](BuiltInSpecies#compute_forces), [advanced_follow_driving](BuiltInSkills#advanced_follow_driving), [is_ready_next_road](BuiltInSkills#is_ready_next_road), [test_next_road](BuiltInSkills#test_next_road), [compute_path](BuiltInSkills#compute_path), [path_from_nodes](BuiltInSkills#path_from_nodes), [drive_random](BuiltInSkills#drive_random), [drive](BuiltInSkills#drive), [external_factor_impact](BuiltInSkills#external_factor_impact), [speed_choice](BuiltInSkills#speed_choice), [lane_choice](BuiltInSkills#lane_choice), [follow_driving](BuiltInSkills#follow_driving), [goto_driving](BuiltInSkills#goto_driving), [start_conversation](BuiltInSkills#start_conversation), [send](BuiltInSkills#send), [reply](BuiltInSkills#reply), [accept_proposal](BuiltInSkills#accept_proposal), [agree](BuiltInSkills#agree), [cancel](BuiltInSkills#cancel), [cfp](BuiltInSkills#cfp), [end_conversation](BuiltInSkills#end_conversation), [failure](BuiltInSkills#failure), [inform](BuiltInSkills#inform), [propose](BuiltInSkills#propose), [query](BuiltInSkills#query), [refuse](BuiltInSkills#refuse), [reject_proposal](BuiltInSkills#reject_proposal), [request](BuiltInSkills#request), [subscribe](BuiltInSkills#subscribe), [testConnection](BuiltInSkills#testConnection), [read](BuiltInSkills#read), [SqlObject](BuiltInSkills#SqlObject), [timeStamp](BuiltInSkills#timeStamp), [testConnection](BuiltInSkills#testConnection), [select](BuiltInSkills#select), [send](BuiltInSkills#send), [wander](BuiltInSkills#wander), [move](BuiltInSkills#move), [follow](BuiltInSkills#follow), [goto](BuiltInSkills#goto), [move](BuiltInSkills#move), [execute](BuiltInSkills#execute), [connect](BuiltInSkills#connect), [fetch_message](BuiltInSkills#fetch_message), [has_more_message](BuiltInSkills#has_more_message), [leave_the_group](BuiltInSkills#leave_the_group), [register](BuiltInSkills#register), [unregister](BuiltInSkills#unregister), [timeStamp](BuiltInSkills#timeStamp), [getCurrentDateTime](BuiltInSkills#getCurrentDateTime), [getDateOffset](BuiltInSkills#getDateOffset), [testConnection](BuiltInSkills#testConnection), [executeUpdate](BuiltInSkills#executeUpdate), [insert](BuiltInSkills#insert), [select](BuiltInSkills#select), [list2Matrix](BuiltInSkills#list2Matrix),    \t\n\n----\n\n## Variables\n[speed](BuiltInSkills), [real_speed](BuiltInSkills), [current_path](BuiltInSkills), [final_target](BuiltInSkills), [current_target](BuiltInSkills), [current_index](BuiltInSkills), [targets](BuiltInSkills), [security_distance_coeff](BuiltInSkills), [current_lane](BuiltInSkills), [vehicle_length](BuiltInSkills), [speed_coeff](BuiltInSkills), [max_acceleration](BuiltInSkills), [current_road](BuiltInSkills), [on_linked_road](BuiltInSkills), [proba_lane_change_up](BuiltInSkills), [proba_lane_change_down](BuiltInSkills), [proba_respect_priorities](BuiltInSkills), [proba_respect_stops](BuiltInSkills), [proba_block_node](BuiltInSkills), [proba_use_linked_road](BuiltInSkills), [right_side_driving](BuiltInSkills), [max_speed](BuiltInSkills), [distance_to_goal](BuiltInSkills), [segment_index_on_road](BuiltInSkills), [living_space](BuiltInSkills), [lanes_attribute](BuiltInSkills), [tolerance](BuiltInSkills), [obstacle_species](BuiltInSkills), [speed](BuiltInSkills), [conversations](BuiltInSkills), [accept_proposals](BuiltInSkills), [agrees](BuiltInSkills), [cancels](BuiltInSkills), [cfps](BuiltInSkills), [failures](BuiltInSkills), [informs](BuiltInSkills), [proposes](BuiltInSkills), [queries](BuiltInSkills), [refuses](BuiltInSkills), [reject_proposals](BuiltInSkills), [requests](BuiltInSkills), [requestWhens](BuiltInSkills), [subscribes](BuiltInSkills), [color](BuiltInSkills), [neighbors](BuiltInSkills), [grid_value](BuiltInSkills), [bands](BuiltInSkills), [grid_x](BuiltInSkills), [grid_y](BuiltInSkills), [mailbox](BuiltInSkills), [location](BuiltInSkills), [speed](BuiltInSkills), [heading](BuiltInSkills), [current_path](BuiltInSkills), [current_edge](BuiltInSkills), [real_speed](BuiltInSkills), [destination](BuiltInSkills), [speed](BuiltInSkills), [heading](BuiltInSkills), [pitch](BuiltInSkills), [roll](BuiltInSkills), [destination](BuiltInSkills), [network_name](BuiltInSkills), [network_groups](BuiltInSkills), [network_server](BuiltInSkills), [space](BuiltInSkills), [density](BuiltInSkills), [mass](BuiltInSkills), [velocity](BuiltInSkills), [collisionBound](BuiltInSkills), [motor](BuiltInSkills), [agents_on](BuiltInSkills), [all_agents](BuiltInSkills), [source_node](BuiltInSkills), [target_node](BuiltInSkills), [lanes](BuiltInSkills), [linked_road](BuiltInSkills), [maxspeed](BuiltInSkills), [roads_in](BuiltInSkills), [priority_roads](BuiltInSkills), [roads_out](BuiltInSkills), [stop](BuiltInSkills), [block](BuiltInSkills),    \t\n\n----\n\n## Pseudo-Variables\n\n[self](PseudoVariables#self ), [myself](PseudoVariables#myself ), [each](PseudoVariables#each)\n\n----\n\n## Types\n[bool](DataTypes#bool), [float](DataTypes#float), [int](DataTypes#int), [string](DataTypes#string), [agent](DataTypes#agent), [container](DataTypes#container)\n, [file](DataTypes#file), [geometry](DataTypes#geometry), [graph](DataTypes#graph), [list](DataTypes#list), [map](DataTypes#map), [matrix](DataTypes#matrix)\n, [pair](DataTypes#pair), [path](DataTypes#path), [point](DataTypes#point), [rgb](DataTypes#rgb), [color](DataTypes#rgb), [species](DataTypes#species), [topology](DataTypes#topology)\n\n----\n\n## [the world](GlobalSpecies)\n[torus](GlobalSpecies), [Environment Size](GlobalSpecies#Environment_Size), [world](GlobalSpecies#world), [time](GlobalSpecies#time)\n[cycle](GlobalSpecies#cycle ), [step](GlobalSpecies#step), [time](GlobalSpecies#time), [duration](GlobalSpecies#duration), [total_duration](GlobalSpecies#total_duration)\n[average_duration](GlobalSpecies#average_duration), [machine_time](GlobalSpecies#machine_time), [agents](GlobalSpecies#agents), [stop](GlobalSpecies#halt), [halt](GlobalSpecies#halt), [pause](GlobalSpecies#pause), [scheduling](GlobalSpecies#scheduling)\n\n----\n\n## Grid\n[grid_x](GridSpecies#grid_x), [grid_y](GridSpecies#grid_y), [agents](GridSpecies#agents), [color](GridSpecies#color), [grid_value](GridSpecies#grid_value) \n\n----\n\n## Other concepts\n[scheduling](RuntimeConcepts#Scheduling_of_Agents ), [step](RuntimeConcepts#Agents_Step), [Key concepts](KeyConcepts), [KeyConcepts#Vocabulary_correspondance_with_the_agent-based_paradigm_as_in_Ne correspondance GAMA Netlogo], [operators statements type species](KeyConcepts#Translation_into_a_concrete_syntax)\n\n","url":"wiki/Index.md"},"NewVersionChanges.md":{"title":" Java version","content":"# Java version\n\nDue to changes in the libraries used by GAMA 1.7, this version now **requires JDK/JVM 1.8** to run.\n\n# Changes between 1.6.1 and 1.7 that can influence the dynamics of models\n\n* Initialization order between the initialization of variables and the execution of the `init` block in grids\ninit -> vars in 1.6.1 / vars -> init in 1.7\n* Initialization order of agents -> now, the init block of the agents are not executed at the end of the global init, but during it.\nput a sample model to explain the order of creation and its differences\n* Initialization of vars to their default value\nmap ? list ? \n* Systematic casting and verification of types\ngive examples\n* header of CSV files: be careful, in GAMA 1.7, if the first line is detected as a header, it is not read when the file is casted as a matrix (so the first row of the matrix is not the header, but the first line of data)\ngives examples\n* the step of batch experiments is now executed after all repetitions of simulations are done (not after each one). They can however be still accessed using the attributes `simulations` (see Batch.gaml in Models Library)\n* signal and diffuse have been merged into a single statement\n* facets do not accept a space between their identifier and the `:` anymore.\n* simplification of equation/solve statements and deprecation of old facets\n* in FIPA skill, `content`is replaced everywhere with `contents`\n* in FIPA skill, `receivers` is replaced everywhere with `to`\n* in FIPA skill, `messages` is replaced by `mailbox`\n* The pseudo-attribute `user_location` has been removed (not deprecated, unfortunately) and replaced by the \"unit\" `#user_location`.\n* The actions called by an `event` layer do not need anymore to define `point` and `list<agent>` arguments to receive the mouse location and the list of agents selected. Instead, they can now use `#user_location` and they have to compute the selected agents by themselves (using an arbitrary function).\n* The random number generators now better handle seeding (larger range), but it can change the series of values previously obtained from a given seed in 1.6.1\n* all models now have a starting_date and a current_date. They then dont begin at an hypothetical \"zero\" date, but at the epoch date defined by ISO 8601 (1970/1/1). It should not change models that dont rely on dates, except that:\n* #year (and its nicknames #y, #years) and #month (and its nickname #month) do not longer have a default value (of resp. 30 days and 360 days). Instead, they are always evaluated against the current_date of the model. If no starting_date is defined, the values of #month and #year will then depend on the sequence of months and year since epoch day.\n* `as_time`, `as_system_time`, `as_date` and `as_system_date` have been removed\n\n# Enhancements in 1.7\n\n* Simulations\n * simulations can now be run in parallel withing an experiment (with their outputs, displays, etc.)\n * batch experiments inherit from this possibility and can now run their repetitions in parallel too.\n * concurrency between agents is now possible and can be controlled on a species/grid/ask basis (from multi-threaded concurrency to complete parallelism within a species/grid or between the targets of an `ask` statement)\n\n* Language\n * `gama` : a new immutable agent that can be invoked to change preferences or access to platform-only properties (like `machine-time`)\n * `date` : new data type that offers the possibility to use a real calendar, to define a `starting_date` and to query a `current_date` from a simulation, to parse dates from date files or to output them in custom formats. Dates can be added, subtracted, compared. Various new operators (`minus_months`, etc.) allow for a fine manipulation of their data. Time units (`#sec`, `#s`, `#mn`, `#minute`, `#h`, `#hour`, `#day`, etc.) can be used in conjunction with them. Interval of dates (date1 to date2) can be created and used as a basis for loops, etc. Various simple operators allow for defining conditions based on the current_date (after(date1), before(date2), since(date1), etc.).\n * font in draw\n * BDI control architecture for agents\n * file management, new operators, new statements, new skills(?), new built-in variables, files can now download their contents from the web by using standard http: https: addresses instead of file paths.\n * The `save` can now directly manipulate files and ... save them. So something like `save shape_file(\"bb.shp\", my_agents collect each.shape);` is possible. \n * `status` statement (to manipulate the status line from GAML)\n * new operators (`sum_of`, `product_of`, etc.)\n * casting of files works\n * co-modeling (importation of micro-models that can be managed within a macro-model)\n * populations of agents can now be easily exported to CSV files using the `save` statement \n * Simple `messaging` skill between agents  \n * Terminal commands can now be issued from within GAMA using the `console` operator\n * New `status` statement allows to change the text of the status.\n * light statement in 3D display provides the possibility to custom your lights (point lights, direction lights, spot lights)\n * `on_change:` facet for attributes/parameters allows to define a sequence of statements to run whenever the value changes. \n\n* Data importation\n * draw of complex shapes through obj file\n * new types fo files are taken into account: geotiff and dxf\n * viewers for common files\n * navigator: better overview of model files and their support files, addition of plugin models \n\n* Editor\n * doc on built-in elements, templates, shortcuts to common tasks, hyperlinks to files used\n * improvement in time, gathering of infos/todos\n * warnings can be removed from model files\n\n\n* Models library: \n * New models (make a list)\n\n* Preferences\n * For performances and bug fixes in displays\n * OpenGL displays should be up to 3 times faster in rendering\n\n* Simulation displays\n * fullscreen mode for displays (ESC key)\n * CTRL+O for overlay and CTRL+L for layers side controls\n * cleaner OpenGL displays (less garbage, better drawing of lines, rotation helper, sticky ROI, etc.)\n * possibility to use a new OpenGl pipeline and to define keystoning parameters (for projections)\n * faster java2D displays (esp. on zoom)\n * better user interaction (mouse move, hover, key listener)\n * a whole new set of charts\n * getting values when moving the mouse on charts\n * possibility to declare `permanent layout: ` + `#splitted`, `#horizontal`, `#vertical`, `#stacked` in the `output` section to automatically layout the display view.\n * Changing simulation names is reflected in their display titles (and it can be dynamic)\n * OpenGL displays now handle rotations of 2D and 3D shapes, combinations of textures and colours, and keystoning\n\n* Error view\n * Much faster (up to 100x !) display of errors\n * Contextual menu to copy the text of errors to clipboard or open the editor on it\n\n* Validation\n * Faster validation of multi-file models (x2 approx.)\n * Much less memory used compared to 1.6.1 (/10 approx.)\n * No more \"false positive\" errors\n\n* Console\n * Interactive console allows to directly interact with agents (experiments, simulations and any agent) and get a direct feedback on the impact of code execution using a new interpreter integrated with the console. Available in the modeling perspective (to interact with the new `gama` agent) as well as the simulation perspective (to interact with the current `experiment` agent).\n * Console now accepts colored text output \n\n* Monitor view\n * monitors can have colors\n\n* GAMA-wide online help on the language\n * A global search engine is now available in the top-right corner of the GAMA window to look for GAML idioms\n\n* Serialization\n * Serialize simulations and replay them (to come)\n * Serialization and deserialization of agents between simulations (to come)\n\n* Allow TCP, UDP and MQQT communications between agents in different simulations (to come)","url":"wiki/NewVersionChanges.md"},"OlderVersions.md":{"title":" Versions of GAMA","content":"# Versions of GAMA\n\n\n\nGAMA exists since 2007 and has undergone a number of changes since its first release, materialized by different versions of the platform. Although we do not maintain these versions anymore, some are still used in lectures or specific projects. This page provides a list of these versions and, for each of them, a summary of its features and a link to its documentation in PDF format.\n\n\n\n\n\n\n\n\n## GAMA 1.6.1 (June 2014)\n\nVersion 1.6.1 is the current version of GAMA. It improves many features over version 1.6 :\n\n  * OpenGL displays improvements\n  * Various enhancements for displays (overlay, focus, light, trace, DEM, colors with alpha, addition of CSS colors..)\n  * Compilation of models (errors tracked, memory, report of errors, etc.)\n  * Validation of stochastic models (random now extended to every areas of a model, incl. the operations on HashSets)\n  * GIS file handling (esp. with the possibility to pass a custom CRS)\n  * Handling of OSM data\n  * Comparison of raster and vectorial maps\n  * Traffic moving skill improvement\n  * Handling of various other file types (uniform constructors, ...)\n  * Documentation itself (both online and on the website)\n  * Testing framework and debugging tools (trace, sample)\n  * Speed of computation of several spatial operators\n  * Experiments (permanent output, access to the duration of cycles)\n  * Type system (complete parametric definitions of types)\n  * Addition of several 3D operations\n  * Auto-update mechanism of plugins\n  * Automatic importation of files/projects when double-clicked in the OS (or transmitted by command line arguments)\n  * Definition of charts (dynamic data lists, marker type, range, etc.)\n\nDocumentation:\n  * Available [online](Overview)\n\n\n![images/splash_1_61.png](resources/images/splash_1_61.png)\n\n\n\n## GAMA 1.6 (July 2013)\nThis version introduced many features over 1.5.1 :\n\n  * correction of bugs (in particular, freeze, memory consumption)\n  * performance improvement (in particular for \"big\" models)\n  * further simplification of the GAML language (assignments, manipulation of containers)\n  * integration of an agent browser\n  * improvement of the 3D integration (new operators, new display facet bug corrections...)\n  * removing of the environment block\n  * more user/simulation interaction (event statement)\n\nDocumentation:\n  * [Documentation in PDF](https://github.com/gama-platform/gama/wiki/Content/ressources/pdf/GAMAv16.pdf)\n\n\n![images/splash_1_6.png](resources/images/splash_1_6.png)\n\n\n\n## GAMA 1.5 / 1.5.1 (July & November 2012)\nKey points :\n  * Improvement of the performance and stability\n  * Simplification of the modeling language (omissible facets, types as declarations, etc.)\n  * Integration of non-spatial graphs\n  * Introduction of OpenGL displays\n  * Improvement of the user interaction in the simulation perspective\n  * Generalization of the notion of experiment\n\nVersion 1.5.1 improved some features of 1.5 :\n\n  * correction of bugs (in particular, no more freezes when reloading an experiment)\n  * performance improvement (in particular for \"big\" models)\n  * improvement of the 3D integration (new operators to add a \"z\" to geometries, bug corrections...)\n  * new models (driving\\_traffic, Vote, 3D models)\n\nDocumentation:\n  * [Documentation in PDF](https://github.com/gama-platform/gama/wiki/Content/ressources/pdf/GAMAv151.pdf)\n\n\n![images/splash_1_5.png](resources/images/splash_1_5.png)\n\n\n\n\n\n## GAMA 1.4 (December 2011)\nThis versions introduced the new integrated development environment based on XText, as well as a completely revamped modeling language, not based on XML anymore, and much easier to read and write. It also introduced new important types such as geometry, graph, path and topology in order to ease the spatial manipulation of agents.\n\nKey points :\n  * Deep refactoring of the source code\n  * New programming language (based on XText)\n  * Integration of a true IDE based on Eclipse/Xtext\n  * Deep refactoring of the meta-model\n  * Better integration of multi-level species\n  * New important notion: topology\n  * New variable types: geometry, graph, path, topology\n  * Many more novelties/improvements/enrichments...\n\nDocumentation:\n  * [Documentation in PDF](https://github.com/gama-platform/gama/wiki/Content/ressources/pdf/GAMAv14.pdf)\n\n\n![images/splash_1_4.png](resources/images/splash_1_4.png)\n\n\n\n\n## GAMA 1.3 (August 2010)\nVersion 1.3 added numerous operators to manipulate GIS data. Moreover, it integrated new features like the possibility to define custom displays and to define multi-level models. It allowed to use clustering and decision-making methods. And it greatly improved the performances of the platform.\n\nKey points :\n  * Important improvement of the performance of the platform\n  * Improvement of the simulation display\n  * Enrichment of the spatial operators/actions\n  * Integration of multi-level models\n  * Integration of clustering algorithms\n  * Integration of decision-making algorithms\n\nDocumentation:\n  * [Documentation in PDF](https://github.com/gama-platform/gama/wiki/Content/ressources/pdf/GAMAv13.pdf)\n\n\n![images/splash_1_3.png](resources/images/splash_1_3.png)\n\n\n\n\n## GAMA 1.1 (October 2009)\nThe first \"real\" release of GAMA, which incorporated several changes, including an XML editor coupled with the simulator, the possibility to take snapshots of every graphical window, save parameters and monitors for future reuse, save charts as CSV files, and definitely fixed the memory leaks observed in previous internal versions.\n\nKey points :\n  * Transformation into a more complete and versatile platform\n  * Addition of batch controllers\n  * Integration of a true modeling language (based on XML)\n  * First release as an open-source project\n\nDocumentation:\n  * [Guidebook of GAMA 1.1](https://github.com/gama-platform/gama/wiki/Content/ressources/pdf/GAMAv11.pdf)\n  * [Training session on GAMA 1.1 (Hanoi)](TrainingSessionHanoi2009)\n\n\n![images/splash_1_1.png](resources/images/splash_1_1.png)","url":"wiki/OlderVersions.md"},"OperatorsAC.md":{"title":" Operators (A to C)","content":"#Operators (A to C)\n \t\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Definition \n\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. \n\nMost of them use a classical prefixed functional syntax (i.e. `operator_name(operand1, operand2, operand3)`, see below), with the exception of arithmetic (e.g. `+`, `/`), logical (`and`, `or`), comparison (e.g. `>`, `<`), access (`.`, `[..]`) and pair (`::`) operators, which require an infixed notation (i.e. `operand1 operator_symbol operand1`). \n\nThe ternary functional if-else operator, `? :`, uses a special infixed syntax composed with two symbols (e.g. `operand1 ? operand2 : operand3`). Two unary operators (`-` and `!`) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10`, `! (operand1 or operand2)`). \n\nFinally, special constructor operators (`{...}` for constructing points, `[...]` for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. `{1,2,3}`, `[operand1, operand2, ..., operandn]` or `[key1::value1, key2::value2... keyn::valuen]`).\n\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n* if they only have one operand, the functional prefixed syntax is mandatory (e.g. `operator_name(operand1)`)\n* if they have two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2)`) or the infixed syntax (e.g. `operand1 operator_name operand2`) can be used.\n* if they have more than two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2, ..., operand)`) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. `operand1 operator_name(operand2, ..., operand)`) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\n\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the `shuffle` operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\n<br/>\n----\n\n## Priority between operators\n\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\n\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n* the constructor operators, like `::`, used to compose pairs of operands, have the lowest priority of all operators (e.g. `a > b :: b > c` will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, `[a > 10, b > 5]` will return a list of boolean values.\n* it is followed by the `?:` operator, the functional if-else (e.g. ` a > b ? a + 10 : a - 10` will return the result of the if-else).\n* next are the logical operators, `and` and `or` (e.g. `a > b or b > c` will return the value of the test)\n* next are the comparison operators (i.e. `>`, `<`, `<=`, `>=`, `=`, `!=`)\n* next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\n* next the unary operators `-` and `!`\n* next the access operators `.` and `[]` (e.g. `{1,2,3}.x > 20 + {4,5,6}.y` will return the result of the comparison between the x and y ordinates of the two points)\n* and finally the functional operators, which have the highest priority of all.\n\n----\n\n## Using actions as operators\n\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\n\nFor instance, if the following species is defined:\n\n```\nspecies spec1 {\n        int min(int x, int y) {\n                return x > y ? x : y;\n        }\n}\n```\n\nAny agent instance of spec1 can use `min` as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\n\n```\nglobal {\n        init {\n                create spec1;\n                spec1 my_agent <- spec1[0];\n                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);\n        }\n}\n```\n\nIf the action doesn't have any operands, the syntax to use is `my_agent the_action()`. Finally, if it does not return a value, it might still be used but is considering as returning a value of type `unknown` (e.g. `unknown result <- my_agent the_action(op1, op2);`).\n\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\n\t\n\n----\n\n## Table of Contents\n\n----\n\n## Operators by categories\n\t\n\n----\n\n### 3D\n[box](OperatorsAC#box), [cone3D](OperatorsAC#cone3d), [cube](OperatorsAC#cube), [cylinder](OperatorsAC#cylinder), [dem](OperatorsDM#dem), [hexagon](OperatorsDM#hexagon), [pyramid](OperatorsNZ#pyramid), [rgb_to_xyz](OperatorsNZ#rgb_to_xyz), [set_z](OperatorsNZ#set_z), [sphere](OperatorsNZ#sphere), [teapot](OperatorsNZ#teapot), \n\n----\n\n### Arithmetic operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [^](OperatorsAC#^), [*](OperatorsAC#*), [+](OperatorsAC#+), [abs](OperatorsAC#abs), [acos](OperatorsAC#acos), [asin](OperatorsAC#asin), [atan](OperatorsAC#atan), [atan2](OperatorsAC#atan2), [ceil](OperatorsAC#ceil), [cos](OperatorsAC#cos), [cos_rad](OperatorsAC#cos_rad), [div](OperatorsDM#div), [even](OperatorsDM#even), [exp](OperatorsDM#exp), [fact](OperatorsDM#fact), [floor](OperatorsDM#floor), [hypot](OperatorsDM#hypot), [is_finite](OperatorsDM#is_finite), [is_number](OperatorsDM#is_number), [ln](OperatorsDM#ln), [log](OperatorsDM#log), [mod](OperatorsDM#mod), [round](OperatorsNZ#round), [signum](OperatorsNZ#signum), [sin](OperatorsNZ#sin), [sin_rad](OperatorsNZ#sin_rad), [sqrt](OperatorsNZ#sqrt), [tan](OperatorsNZ#tan), [tan_rad](OperatorsNZ#tan_rad), [tanh](OperatorsNZ#tanh), [with_precision](OperatorsNZ#with_precision), \n\n----\n\n### BDI\n[and](OperatorsAC#and), [eval_when](OperatorsDM#eval_when), [get_about](OperatorsDM#get_about), [get_agent](OperatorsDM#get_agent), [get_agent_cause](OperatorsDM#get_agent_cause), [get_decay](OperatorsDM#get_decay), [get_dominance](OperatorsDM#get_dominance), [get_familiarity](OperatorsDM#get_familiarity), [get_intensity](OperatorsDM#get_intensity), [get_lifetime](OperatorsDM#get_lifetime), [get_liking](OperatorsDM#get_liking), [get_praiseworthiness](OperatorsDM#get_praiseworthiness), [get_priority](OperatorsDM#get_priority), [get_solidarity](OperatorsDM#get_solidarity), [get_super_intention](OperatorsDM#get_super_intention), [new_emotion](OperatorsNZ#new_emotion), [new_predicate](OperatorsNZ#new_predicate), [new_social_link](OperatorsNZ#new_social_link), [or](OperatorsNZ#or), [set_about](OperatorsNZ#set_about), [set_agent](OperatorsNZ#set_agent), [set_agent_cause](OperatorsNZ#set_agent_cause), [set_decay](OperatorsNZ#set_decay), [set_dominance](OperatorsNZ#set_dominance), [set_familiarity](OperatorsNZ#set_familiarity), [set_intensity](OperatorsNZ#set_intensity), [set_liking](OperatorsNZ#set_liking), [set_solidarity](OperatorsNZ#set_solidarity), [set_truth](OperatorsNZ#set_truth), [with_lifetime](OperatorsNZ#with_lifetime), [with_praiseworthiness](OperatorsNZ#with_praiseworthiness), [with_priority](OperatorsNZ#with_priority), [with_values](OperatorsNZ#with_values), \n\n----\n\n### Casting operators\n[as](OperatorsAC#as), [as_int](OperatorsAC#as_int), [as_matrix](OperatorsAC#as_matrix), [font](OperatorsDM#font), [is](OperatorsDM#is), [is_skill](OperatorsDM#is_skill), [list_with](OperatorsDM#list_with), [matrix_with](OperatorsDM#matrix_with), [species](OperatorsNZ#species), [to_gaml](OperatorsNZ#to_gaml), [topology](OperatorsNZ#topology), \n\n----\n\n### Color-related operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [*](OperatorsAC#*), [+](OperatorsAC#+), [blend](OperatorsAC#blend), [brewer_colors](OperatorsAC#brewer_colors), [brewer_palettes](OperatorsAC#brewer_palettes), [grayscale](OperatorsDM#grayscale), [hsb](OperatorsDM#hsb), [mean](OperatorsDM#mean), [median](OperatorsDM#median), [rgb](OperatorsNZ#rgb), [rnd_color](OperatorsNZ#rnd_color), [sum](OperatorsNZ#sum), \n\n----\n\n### Comparison operators\n[!=](OperatorsAC#!=), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [between](OperatorsAC#between), \n\n----\n\n### Containers-related operators\n[-](OperatorsAC#-), [::](OperatorsAC#::), [+](OperatorsAC#+), [accumulate](OperatorsAC#accumulate), [among](OperatorsAC#among), [at](OperatorsAC#at), [collect](OperatorsAC#collect), [contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), [count](OperatorsAC#count), [distinct](OperatorsDM#distinct), [empty](OperatorsDM#empty), [every](OperatorsDM#every), [first](OperatorsDM#first), [first_with](OperatorsDM#first_with), [get](OperatorsDM#get), [group_by](OperatorsDM#group_by), [in](OperatorsDM#in), [index_by](OperatorsDM#index_by), [inter](OperatorsDM#inter), [interleave](OperatorsDM#interleave), [internal_at](OperatorsDM#internal_at), [internal_integrated_value](OperatorsDM#internal_integrated_value), [last](OperatorsDM#last), [last_with](OperatorsDM#last_with), [length](OperatorsDM#length), [max](OperatorsDM#max), [max_of](OperatorsDM#max_of), [mean](OperatorsDM#mean), [mean_of](OperatorsDM#mean_of), [median](OperatorsDM#median), [min](OperatorsDM#min), [min_of](OperatorsDM#min_of), [mul](OperatorsDM#mul), [one_of](OperatorsNZ#one_of), [product_of](OperatorsNZ#product_of), [range](OperatorsNZ#range), [reverse](OperatorsNZ#reverse), [shuffle](OperatorsNZ#shuffle), [sort_by](OperatorsNZ#sort_by), [sum](OperatorsNZ#sum), [sum_of](OperatorsNZ#sum_of), [union](OperatorsNZ#union), [variance_of](OperatorsNZ#variance_of), [where](OperatorsNZ#where), [with_max_of](OperatorsNZ#with_max_of), [with_min_of](OperatorsNZ#with_min_of), \n\n----\n\n### Date-related operators\n[-](OperatorsAC#-), [!=](OperatorsAC#!=), [+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [after](OperatorsAC#after), [before](OperatorsAC#before), [between](OperatorsAC#between), [every](OperatorsDM#every), [milliseconds_between](OperatorsDM#milliseconds_between), [minus_days](OperatorsDM#minus_days), [minus_hours](OperatorsDM#minus_hours), [minus_minutes](OperatorsDM#minus_minutes), [minus_months](OperatorsDM#minus_months), [minus_ms](OperatorsDM#minus_ms), [minus_weeks](OperatorsDM#minus_weeks), [minus_years](OperatorsDM#minus_years), [months_between](OperatorsDM#months_between), [plus_days](OperatorsNZ#plus_days), [plus_hours](OperatorsNZ#plus_hours), [plus_minutes](OperatorsNZ#plus_minutes), [plus_months](OperatorsNZ#plus_months), [plus_ms](OperatorsNZ#plus_ms), [plus_weeks](OperatorsNZ#plus_weeks), [plus_years](OperatorsNZ#plus_years), [since](OperatorsNZ#since), [to](OperatorsNZ#to), [until](OperatorsNZ#until), [years_between](OperatorsNZ#years_between), \n\n----\n\n### Dates\n\n\n----\n\n### Driving operators\n[as_driving_graph](OperatorsAC#as_driving_graph), \n\n----\n\n### edge\n[edge_between](OperatorsDM#edge_between), \n\n----\n\n### EDP-related operators\n[diff](OperatorsDM#diff), [diff2](OperatorsDM#diff2), [internal_zero_order_equation](OperatorsDM#internal_zero_order_equation), \n\n----\n\n### Files-related operators\n[crs](OperatorsAC#crs), [file](OperatorsDM#file), [file_exists](OperatorsDM#file_exists), [folder](OperatorsDM#folder), [get](OperatorsDM#get), [new_folder](OperatorsNZ#new_folder), [osm_file](OperatorsNZ#osm_file), [read](OperatorsNZ#read), [writable](OperatorsNZ#writable), \n\n----\n\n### FIPA-related operators\n[conversation](OperatorsAC#conversation), [message](OperatorsDM#message), \n\n----\n\n### Graphs-related operators\n[add_edge](OperatorsAC#add_edge), [add_node](OperatorsAC#add_node), [adjacency](OperatorsAC#adjacency), [agent_from_geometry](OperatorsAC#agent_from_geometry), [all_pairs_shortest_path](OperatorsAC#all_pairs_shortest_path), [alpha_index](OperatorsAC#alpha_index), [as_distance_graph](OperatorsAC#as_distance_graph), [as_edge_graph](OperatorsAC#as_edge_graph), [as_intersection_graph](OperatorsAC#as_intersection_graph), [as_path](OperatorsAC#as_path), [beta_index](OperatorsAC#beta_index), [betweenness_centrality](OperatorsAC#betweenness_centrality), [biggest_cliques_of](OperatorsAC#biggest_cliques_of), [connected_components_of](OperatorsAC#connected_components_of), [connectivity_index](OperatorsAC#connectivity_index), [contains_edge](OperatorsAC#contains_edge), [contains_vertex](OperatorsAC#contains_vertex), [degree_of](OperatorsDM#degree_of), [directed](OperatorsDM#directed), [edge](OperatorsDM#edge), [edge_between](OperatorsDM#edge_between), [edge_betweenness](OperatorsDM#edge_betweenness), [edges](OperatorsDM#edges), [gamma_index](OperatorsDM#gamma_index), [generate_barabasi_albert](OperatorsDM#generate_barabasi_albert), [generate_complete_graph](OperatorsDM#generate_complete_graph), [generate_watts_strogatz](OperatorsDM#generate_watts_strogatz), [grid_cells_to_graph](OperatorsDM#grid_cells_to_graph), [in_degree_of](OperatorsDM#in_degree_of), [in_edges_of](OperatorsDM#in_edges_of), [layout](OperatorsDM#layout), [load_graph_from_file](OperatorsDM#load_graph_from_file), [load_shortest_paths](OperatorsDM#load_shortest_paths), [maximal_cliques_of](OperatorsDM#maximal_cliques_of), [nb_cycles](OperatorsNZ#nb_cycles), [neighbors_of](OperatorsNZ#neighbors_of), [node](OperatorsNZ#node), [nodes](OperatorsNZ#nodes), [out_degree_of](OperatorsNZ#out_degree_of), [out_edges_of](OperatorsNZ#out_edges_of), [path_between](OperatorsNZ#path_between), [paths_between](OperatorsNZ#paths_between), [predecessors_of](OperatorsNZ#predecessors_of), [remove_node_from](OperatorsNZ#remove_node_from), [rewire_n](OperatorsNZ#rewire_n), [source_of](OperatorsNZ#source_of), [spatial_graph](OperatorsNZ#spatial_graph), [successors_of](OperatorsNZ#successors_of), [sum](OperatorsNZ#sum), [target_of](OperatorsNZ#target_of), [undirected](OperatorsNZ#undirected), [use_cache](OperatorsNZ#use_cache), [weight_of](OperatorsNZ#weight_of), [with_optimizer_type](OperatorsNZ#with_optimizer_type), [with_weights](OperatorsNZ#with_weights), \n\n----\n\n### Grid-related operators\n[as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [grid_at](OperatorsDM#grid_at), [path_between](OperatorsNZ#path_between), \n\n----\n\n### Iterator operators\n[accumulate](OperatorsAC#accumulate), [as_map](OperatorsAC#as_map), [collect](OperatorsAC#collect), [count](OperatorsAC#count), [distribution_of](OperatorsDM#distribution_of), [distribution_of](OperatorsDM#distribution_of), [distribution_of](OperatorsDM#distribution_of), [distribution2d_of](OperatorsDM#distribution2d_of), [distribution2d_of](OperatorsDM#distribution2d_of), [distribution2d_of](OperatorsDM#distribution2d_of), [first_with](OperatorsDM#first_with), [frequency_of](OperatorsDM#frequency_of), [group_by](OperatorsDM#group_by), [index_by](OperatorsDM#index_by), [last_with](OperatorsDM#last_with), [max_of](OperatorsDM#max_of), [mean_of](OperatorsDM#mean_of), [min_of](OperatorsDM#min_of), [product_of](OperatorsNZ#product_of), [sort_by](OperatorsNZ#sort_by), [sum_of](OperatorsNZ#sum_of), [variance_of](OperatorsNZ#variance_of), [where](OperatorsNZ#where), [with_max_of](OperatorsNZ#with_max_of), [with_min_of](OperatorsNZ#with_min_of), \n\n----\n\n### List-related operators\n[copy_between](OperatorsAC#copy_between), [index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), \n\n----\n\n### Logical operators\n[:](OperatorsAC#:), [!](OperatorsAC#!), [?](OperatorsAC#?), [and](OperatorsAC#and), [or](OperatorsNZ#or), \n\n----\n\n### Map comparaison operators\n[fuzzy_kappa](OperatorsDM#fuzzy_kappa), [fuzzy_kappa_sim](OperatorsDM#fuzzy_kappa_sim), [kappa](OperatorsDM#kappa), [kappa_sim](OperatorsDM#kappa_sim), [percent_absolute_deviation](OperatorsNZ#percent_absolute_deviation), \n\n----\n\n### Map-related operators\n[as_map](OperatorsAC#as_map), [index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), \n\n----\n\n### Material\n[material](OperatorsDM#material), \n\n----\n\n### Matrix-related operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [.](OperatorsAC#.), [*](OperatorsAC#*), [+](OperatorsAC#+), [append_horizontally](OperatorsAC#append_horizontally), [append_vertically](OperatorsAC#append_vertically), [column_at](OperatorsAC#column_at), [columns_list](OperatorsAC#columns_list), [determinant](OperatorsDM#determinant), [eigenvalues](OperatorsDM#eigenvalues), [index_of](OperatorsDM#index_of), [inverse](OperatorsDM#inverse), [last_index_of](OperatorsDM#last_index_of), [row_at](OperatorsNZ#row_at), [rows_list](OperatorsNZ#rows_list), [shuffle](OperatorsNZ#shuffle), [trace](OperatorsNZ#trace), [transpose](OperatorsNZ#transpose), \n\n----\n\n### multicriteria operators\n[electre_DM](OperatorsDM#electre_dm), [evidence_theory_DM](OperatorsDM#evidence_theory_dm), [promethee_DM](OperatorsNZ#promethee_dm), [weighted_means_DM](OperatorsNZ#weighted_means_dm), \n\n----\n\n### Path-related operators\n[agent_from_geometry](OperatorsAC#agent_from_geometry), [all_pairs_shortest_path](OperatorsAC#all_pairs_shortest_path), [as_path](OperatorsAC#as_path), [load_shortest_paths](OperatorsDM#load_shortest_paths), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [paths_between](OperatorsNZ#paths_between), [use_cache](OperatorsNZ#use_cache), \n\n----\n\n### Points-related operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [*](OperatorsAC#*), [+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [add_point](OperatorsAC#add_point), [angle_between](OperatorsAC#angle_between), [any_location_in](OperatorsAC#any_location_in), [centroid](OperatorsAC#centroid), [closest_points_with](OperatorsAC#closest_points_with), [farthest_point_to](OperatorsDM#farthest_point_to), [grid_at](OperatorsDM#grid_at), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [points_along](OperatorsNZ#points_along), [points_at](OperatorsNZ#points_at), [points_on](OperatorsNZ#points_on), \n\n----\n\n### Random operators\n[binomial](OperatorsAC#binomial), [flip](OperatorsDM#flip), [gauss](OperatorsDM#gauss), [poisson](OperatorsNZ#poisson), [rnd](OperatorsNZ#rnd), [rnd_choice](OperatorsNZ#rnd_choice), [sample](OperatorsNZ#sample), [shuffle](OperatorsNZ#shuffle), [skew_gauss](OperatorsNZ#skew_gauss), [truncated_gauss](OperatorsNZ#truncated_gauss), \n\n----\n\n### ReverseOperators\n\n\n----\n\n### Shape\n[arc](OperatorsAC#arc), [box](OperatorsAC#box), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [cone3D](OperatorsAC#cone3d), [cross](OperatorsAC#cross), [cube](OperatorsAC#cube), [curve](OperatorsAC#curve), [cylinder](OperatorsAC#cylinder), [ellipse](OperatorsDM#ellipse), [envelope](OperatorsDM#envelope), [geometry_collection](OperatorsDM#geometry_collection), [hexagon](OperatorsDM#hexagon), [line](OperatorsDM#line), [link](OperatorsDM#link), [plan](OperatorsNZ#plan), [polygon](OperatorsNZ#polygon), [polyhedron](OperatorsNZ#polyhedron), [pyramid](OperatorsNZ#pyramid), [rectangle](OperatorsNZ#rectangle), [sphere](OperatorsNZ#sphere), [square](OperatorsNZ#square), [squircle](OperatorsNZ#squircle), [teapot](OperatorsNZ#teapot), [triangle](OperatorsNZ#triangle), \n\n----\n\n### Spatial operators\n[-](OperatorsAC#-), [*](OperatorsAC#*), [+](OperatorsAC#+), [add_point](OperatorsAC#add_point), [agent_closest_to](OperatorsAC#agent_closest_to), [agent_farthest_to](OperatorsAC#agent_farthest_to), [agents_at_distance](OperatorsAC#agents_at_distance), [agents_inside](OperatorsAC#agents_inside), [agents_overlapping](OperatorsAC#agents_overlapping), [angle_between](OperatorsAC#angle_between), [any_location_in](OperatorsAC#any_location_in), [arc](OperatorsAC#arc), [around](OperatorsAC#around), [as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [at_distance](OperatorsAC#at_distance), [at_location](OperatorsAC#at_location), [box](OperatorsAC#box), [centroid](OperatorsAC#centroid), [circle](OperatorsAC#circle), [clean](OperatorsAC#clean), [closest_points_with](OperatorsAC#closest_points_with), [closest_to](OperatorsAC#closest_to), [cone](OperatorsAC#cone), [cone3D](OperatorsAC#cone3d), [convex_hull](OperatorsAC#convex_hull), [covers](OperatorsAC#covers), [cross](OperatorsAC#cross), [crosses](OperatorsAC#crosses), [crs](OperatorsAC#crs), [CRS_transform](OperatorsAC#crs_transform), [cube](OperatorsAC#cube), [curve](OperatorsAC#curve), [cylinder](OperatorsAC#cylinder), [dem](OperatorsDM#dem), [direction_between](OperatorsDM#direction_between), [disjoint_from](OperatorsDM#disjoint_from), [distance_between](OperatorsDM#distance_between), [distance_to](OperatorsDM#distance_to), [ellipse](OperatorsDM#ellipse), [envelope](OperatorsDM#envelope), [farthest_point_to](OperatorsDM#farthest_point_to), [farthest_to](OperatorsDM#farthest_to), [geometry_collection](OperatorsDM#geometry_collection), [gini](OperatorsDM#gini), [hexagon](OperatorsDM#hexagon), [hierarchical_clustering](OperatorsDM#hierarchical_clustering), [IDW](OperatorsAC#idw), [inside](OperatorsDM#inside), [inter](OperatorsDM#inter), [intersects](OperatorsDM#intersects), [line](OperatorsDM#line), [link](OperatorsDM#link), [masked_by](OperatorsDM#masked_by), [moran](OperatorsDM#moran), [neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [overlapping](OperatorsNZ#overlapping), [overlaps](OperatorsNZ#overlaps), [partially_overlaps](OperatorsNZ#partially_overlaps), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [plan](OperatorsNZ#plan), [points_along](OperatorsNZ#points_along), [points_at](OperatorsNZ#points_at), [points_on](OperatorsNZ#points_on), [polygon](OperatorsNZ#polygon), [polyhedron](OperatorsNZ#polyhedron), [pyramid](OperatorsNZ#pyramid), [rectangle](OperatorsNZ#rectangle), [rgb_to_xyz](OperatorsNZ#rgb_to_xyz), [rotated_by](OperatorsNZ#rotated_by), [round](OperatorsNZ#round), [scaled_to](OperatorsNZ#scaled_to), [set_z](OperatorsNZ#set_z), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), [simplification](OperatorsNZ#simplification), [skeletonize](OperatorsNZ#skeletonize), [smooth](OperatorsNZ#smooth), [sphere](OperatorsNZ#sphere), [split_at](OperatorsNZ#split_at), [split_geometry](OperatorsNZ#split_geometry), [split_lines](OperatorsNZ#split_lines), [square](OperatorsNZ#square), [squircle](OperatorsNZ#squircle), [teapot](OperatorsNZ#teapot), [to_GAMA_CRS](OperatorsNZ#to_gama_crs), [to_rectangles](OperatorsNZ#to_rectangles), [to_squares](OperatorsNZ#to_squares), [touches](OperatorsNZ#touches), [towards](OperatorsNZ#towards), [transformed_by](OperatorsNZ#transformed_by), [translated_by](OperatorsNZ#translated_by), [triangle](OperatorsNZ#triangle), [triangulate](OperatorsNZ#triangulate), [union](OperatorsNZ#union), [using](OperatorsNZ#using), [voronoi](OperatorsNZ#voronoi), [with_precision](OperatorsNZ#with_precision), [without_holes](OperatorsNZ#without_holes), \n\n----\n\n### Spatial properties operators\n[covers](OperatorsAC#covers), [crosses](OperatorsAC#crosses), [intersects](OperatorsDM#intersects), [partially_overlaps](OperatorsNZ#partially_overlaps), [touches](OperatorsNZ#touches), \n\n----\n\n### Spatial queries operators\n[agent_closest_to](OperatorsAC#agent_closest_to), [agent_farthest_to](OperatorsAC#agent_farthest_to), [agents_at_distance](OperatorsAC#agents_at_distance), [agents_inside](OperatorsAC#agents_inside), [agents_overlapping](OperatorsAC#agents_overlapping), [at_distance](OperatorsAC#at_distance), [closest_to](OperatorsAC#closest_to), [farthest_to](OperatorsDM#farthest_to), [inside](OperatorsDM#inside), [neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [overlapping](OperatorsNZ#overlapping), \n\n----\n\n### Spatial relations operators\n[direction_between](OperatorsDM#direction_between), [distance_between](OperatorsDM#distance_between), [distance_to](OperatorsDM#distance_to), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [towards](OperatorsNZ#towards), \n\n----\n\n### Spatial statistical operators\n[hierarchical_clustering](OperatorsDM#hierarchical_clustering), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), \n\n----\n\n### Spatial transformations operators\n[-](OperatorsAC#-), [*](OperatorsAC#*), [+](OperatorsAC#+), [as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [at_location](OperatorsAC#at_location), [clean](OperatorsAC#clean), [convex_hull](OperatorsAC#convex_hull), [CRS_transform](OperatorsAC#crs_transform), [rotated_by](OperatorsNZ#rotated_by), [scaled_to](OperatorsNZ#scaled_to), [simplification](OperatorsNZ#simplification), [skeletonize](OperatorsNZ#skeletonize), [smooth](OperatorsNZ#smooth), [split_geometry](OperatorsNZ#split_geometry), [split_lines](OperatorsNZ#split_lines), [to_GAMA_CRS](OperatorsNZ#to_gama_crs), [to_rectangles](OperatorsNZ#to_rectangles), [to_squares](OperatorsNZ#to_squares), [transformed_by](OperatorsNZ#transformed_by), [translated_by](OperatorsNZ#translated_by), [triangulate](OperatorsNZ#triangulate), [voronoi](OperatorsNZ#voronoi), [without_holes](OperatorsNZ#without_holes), \n\n----\n\n### Species-related operators\n[index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), [of_generic_species](OperatorsNZ#of_generic_species), [of_species](OperatorsNZ#of_species), \n\n----\n\n### Statistical operators\n[build](OperatorsAC#build), [corR](OperatorsAC#corr), [dbscan](OperatorsDM#dbscan), [distribution_of](OperatorsDM#distribution_of), [distribution2d_of](OperatorsDM#distribution2d_of), [frequency_of](OperatorsDM#frequency_of), [gamma_rnd](OperatorsDM#gamma_rnd), [geometric_mean](OperatorsDM#geometric_mean), [gini](OperatorsDM#gini), [harmonic_mean](OperatorsDM#harmonic_mean), [hierarchical_clustering](OperatorsDM#hierarchical_clustering), [kmeans](OperatorsDM#kmeans), [kurtosis](OperatorsDM#kurtosis), [max](OperatorsDM#max), [mean](OperatorsDM#mean), [mean_deviation](OperatorsDM#mean_deviation), [meanR](OperatorsDM#meanr), [median](OperatorsDM#median), [min](OperatorsDM#min), [moran](OperatorsDM#moran), [mul](OperatorsDM#mul), [predict](OperatorsNZ#predict), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), [skewness](OperatorsNZ#skewness), [standard_deviation](OperatorsNZ#standard_deviation), [sum](OperatorsNZ#sum), [variance](OperatorsNZ#variance), \n\n----\n\n### Strings-related operators\n[+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [at](OperatorsAC#at), [char](OperatorsAC#char), [contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), [copy_between](OperatorsAC#copy_between), [date](OperatorsDM#date), [empty](OperatorsDM#empty), [first](OperatorsDM#first), [in](OperatorsDM#in), [indented_by](OperatorsDM#indented_by), [index_of](OperatorsDM#index_of), [is_number](OperatorsDM#is_number), [last](OperatorsDM#last), [last_index_of](OperatorsDM#last_index_of), [length](OperatorsDM#length), [lower_case](OperatorsDM#lower_case), [replace](OperatorsNZ#replace), [replace_regex](OperatorsNZ#replace_regex), [reverse](OperatorsNZ#reverse), [sample](OperatorsNZ#sample), [shuffle](OperatorsNZ#shuffle), [split_with](OperatorsNZ#split_with), [string](OperatorsNZ#string), [upper_case](OperatorsNZ#upper_case), \n\n----\n\n### System\n[.](OperatorsAC#.), [command](OperatorsAC#command), [copy](OperatorsAC#copy), [dead](OperatorsDM#dead), [eval_gaml](OperatorsDM#eval_gaml), [every](OperatorsDM#every), [user_input](OperatorsNZ#user_input), \n\n----\n\n### Time-related operators\n[date](OperatorsDM#date), [string](OperatorsNZ#string), \n\n----\n\n### Types-related operators\n\n\n----\n\n### User control operators\n[user_input](OperatorsNZ#user_input), \n\t\n----\n\n## Operators\n\t\n    \t\n----\n\n[//]: # (keyword|operator_-)\n### `-`\n\n#### Possible use: \n  *  **`-`** (`int`) --->  `int`\n  *  **`-`** (`point`) --->  `point`\n  *  **`-`** (`float`) --->  `float`\n  * `int` **`-`** `float` --->  `float`\n  *  **`-`** (`int` , `float`) --->  `float`\n  * `int` **`-`** `int` --->  `int`\n  *  **`-`** (`int` , `int`) --->  `int`\n  * `matrix` **`-`** `float` --->  `matrix`\n  *  **`-`** (`matrix` , `float`) --->  `matrix`\n  * `float` **`-`** `matrix` --->  `matrix`\n  *  **`-`** (`float` , `matrix`) --->  `matrix`\n  * `date` **`-`** `float` --->  `date`\n  *  **`-`** (`date` , `float`) --->  `date`\n  * `species` **`-`** `agent` --->  `container`\n  *  **`-`** (`species` , `agent`) --->  `container`\n  * `date` **`-`** `date` --->  `float`\n  *  **`-`** (`date` , `date`) --->  `float`\n  * `matrix` **`-`** `matrix` --->  `matrix`\n  *  **`-`** (`matrix` , `matrix`) --->  `matrix`\n  * `point` **`-`** `int` --->  `point`\n  *  **`-`** (`point` , `int`) --->  `point`\n  * `date` **`-`** `int` --->  `date`\n  *  **`-`** (`date` , `int`) --->  `date`\n  * `point` **`-`** `float` --->  `point`\n  *  **`-`** (`point` , `float`) --->  `point`\n  * `float` **`-`** `float` --->  `float`\n  *  **`-`** (`float` , `float`) --->  `float`\n  * `rgb` **`-`** `rgb` --->  `rgb`\n  *  **`-`** (`rgb` , `rgb`) --->  `rgb`\n  * `int` **`-`** `matrix` --->  `matrix`\n  *  **`-`** (`int` , `matrix`) --->  `matrix`\n  * `container` **`-`** `container` --->  `container`\n  *  **`-`** (`container` , `container`) --->  `container`\n  * `rgb` **`-`** `int` --->  `rgb`\n  *  **`-`** (`rgb` , `int`) --->  `rgb`\n  * `container` **`-`** `unknown` --->  `container`\n  *  **`-`** (`container` , `unknown`) --->  `container`\n  * `point` **`-`** `point` --->  `point`\n  *  **`-`** (`point` , `point`) --->  `point`\n  * `float` **`-`** `int` --->  `float`\n  *  **`-`** (`float` , `int`) --->  `float`\n  * `geometry` **`-`** `geometry` --->  `geometry`\n  *  **`-`** (`geometry` , `geometry`) --->  `geometry`\n  * `matrix` **`-`** `int` --->  `matrix`\n  *  **`-`** (`matrix` , `int`) --->  `matrix`\n  * `geometry` **`-`** `float` --->  `geometry`\n  *  **`-`** (`geometry` , `float`) --->  `geometry`\n  * `map` **`-`** `map` --->  `map`\n  *  **`-`** (`map` , `map`) --->  `map`\n  * `map` **`-`** `pair` --->  `map`\n  *  **`-`** (`map` , `pair`) --->  `map`\n  * `geometry` **`-`** `container<geometry>` --->  `geometry`\n  *  **`-`** (`geometry` , `container<geometry>`) --->  `geometry` \n\n#### Result: \nReturns the difference of the two operands.\nIf it is used as an unary operator, it returns the opposite of the operand.  \n\n#### Comment: \nThe behavior of the operator depends on the type of the operands.\n\n#### Special cases:     \n  * if the left operand is a species and the right operand is an agent of the species, - returns a list containing all the agents of the species minus this agent    \n  * if both operands are containers and the right operand is empty, - returns the left operand    \n  * if both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float. \n  \n```\nint var7 <- 1 - 1; \t// var7 equals 0\nint var8 <- 1.0 - 1; \t// var8 equals 0.0\nint var9 <- 3.7 - 1.2; \t// var9 equals 2.5\nint var10 <- 3 - 1.2; \t// var10 equals 1.8\n\n``` \n\n    \n  * if both operands are dates, returns the duration in seconds between  date2 and date1. To obtain a more precise duration, in milliseconds, use milliseconds_between(date1, date2) \n  \n```\nfloat var11 <- date1 - date2; \t// var11 equals 598\n\n``` \n\n    \n  * if one of the operands is a date and the other a number, returns a date corresponding to the date minus the given number as duration (in seconds) \n  \n```\ndate1 - 200\n\n``` \n\n    \n  * if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number. \n  \n```\npoint var13 <- {1, 2} - 4.5; \t// var13 equals {-3.5, -2.5, -4.5}\npoint var14 <- {1, 2} - 4; \t// var14 equals {-3.0,-2.0,-4.0}\n\n``` \n\n    \n  * if both operands are colors, returns a new color resulting from the subtraction of the two operands, component by component \n  \n```\nrgb var15 <- rgb([255, 128, 32]) - rgb('red'); \t// var15 equals rgb([0,128,32])\n\n``` \n\n    \n  * if one operand is a matrix and the other a number (float or int), performs a normal arithmetic difference of the number with each element of the matrix (results are float if the number is a float. \n  \n```\nmatrix var16 <- 3.5 - matrix([[2,5],[3,4]]); \t// var16 equals matrix([[1.5,-1.5],[0.5,-0.5]])\n\n``` \n\n    \n  * if both operands are containers, returns a new list in which all the elements of the right operand have been removed from the left one \n  \n```\nlist<int> var17 <- [1,2,3,4,5,6] - [2,4,9]; \t// var17 equals [1,3,5,6]\nlist<int> var18 <- [1,2,3,4,5,6] - [0,8]; \t// var18 equals [1,2,3,4,5,6]\n\n``` \n\n    \n  * if one operand is a color and the other an integer, returns a new color resulting from the subtraction of each component of the color with the right operand \n  \n```\nrgb var19 <- rgb([255, 128, 32]) - 3; \t// var19 equals rgb([252,125,29])\n\n``` \n\n    \n  * if the left operand is a list and the right operand is an object of any type (except list), - returns a list containing the elements of the left operand minus all the occurrences of this object \n  \n```\nlist<int> var20 <- [1,2,3,4,5,6] - 2; \t// var20 equals [1,3,4,5,6]\nlist<int> var21 <- [1,2,3,4,5,6] - 0; \t// var21 equals [1,2,3,4,5,6]\n\n``` \n\n    \n  * if both operands are points, returns their difference (coordinates per coordinates). \n  \n```\npoint var22 <- {1, 2} - {4, 5}; \t// var22 equals {-3.0, -3.0}\n\n``` \n\n    \n  * if both operands are a point, a geometry or an agent, returns the geometry resulting from the difference between both geometries \n  \n```\ngeometry var23 <- geom1 - geom2; \t// var23 equals a geometry corresponding to difference between geom1 and geom2\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distance \n  \n```\ngeometry var24 <- shape - 5; \t// var24 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5\n\n``` \n\n    \n  * if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometries \n  \n```\ngeometry var25 <- rectangle(10,10) - [circle(2), square(2)]; \t// var25 equals rectangle(10,10) - (circle(2) + square(2))\n\n``` \n\n\n\n#### Examples: \n```\nint var0 <- - (-56); \t// var0 equals 56\npoint var1 <- -{3.0,5.0}; \t// var1 equals {-3.0,-5.0}\npoint var2 <- -{1.0,6.0,7.0}; \t// var2 equals {-1.0,-6.0,-7.0}\nmap var3 <- ['a'::1,'b'::2] - ['b'::2]; \t// var3 equals ['a'::1]\nmap var4 <- ['a'::1,'b'::2] - ['b'::2,'c'::3]; \t// var4 equals ['a'::1]\nmap var5 <- ['a'::1,'b'::2] - ('b'::2); \t// var5 equals ['a'::1]\nmap var6 <- ['a'::1,'b'::2] - ('c'::3); \t// var6 equals ['a'::1,'b'::2]\n```\n      \n\n#### See also: \n[+](OperatorsAC#+), [*](OperatorsAC#*), [/](OperatorsAC#/), [milliseconds_between](OperatorsDM#milliseconds_between), [-](OperatorsAC#-), \n    \t\n----\n\n[//]: # (keyword|operator_:)\n### `:`\n\n#### Possible use: \n  * `unknown` **`:`** `unknown` --->  `unknown`\n  *  **`:`** (`unknown` , `unknown`) --->  `unknown`    \n\n#### See also: \n[?](OperatorsAC#?), \n    \t\n----\n\n[//]: # (keyword|operator_::)\n### `::`\n\n#### Possible use: \n  * `any expression` **`::`** `any expression` --->  `pair`\n  *  **`::`** (`any expression` , `any expression`) --->  `pair` \n\n#### Result: \nproduces a new pair combining the left and the right operands\n\n#### Special cases:     \n  * nil is not acceptable as a key (although it is as a value). If such a case happens, :: will throw an appropriate error\n    \t\n----\n\n[//]: # (keyword|operator_!)\n### `!`\n\n#### Possible use: \n  *  **`!`** (`bool`) --->  `bool` \n\n#### Result: \nopposite boolean value.\n\n#### Special cases:     \n  * if the parameter is not boolean, it is casted to a boolean value.\n\n#### Examples: \n```\nbool var0 <- ! (true); \t// var0 equals false\n```\n      \n\n#### See also: \n[bool](OperatorsAC#bool), [and](OperatorsAC#and), [or](OperatorsNZ#or), \n    \t\n----\n\n[//]: # (keyword|operator_!=)\n### `!=`\n\n#### Possible use: \n  * `float` **`!=`** `float` --->  `bool`\n  *  **`!=`** (`float` , `float`) --->  `bool`\n  * `unknown` **`!=`** `unknown` --->  `bool`\n  *  **`!=`** (`unknown` , `unknown`) --->  `bool`\n  * `date` **`!=`** `date` --->  `bool`\n  *  **`!=`** (`date` , `date`) --->  `bool`\n  * `float` **`!=`** `int` --->  `bool`\n  *  **`!=`** (`float` , `int`) --->  `bool`\n  * `int` **`!=`** `float` --->  `bool`\n  *  **`!=`** (`int` , `float`) --->  `bool` \n\n#### Result: \ntrue if both operands are different, false otherwise\n\n#### Examples: \n```\nbool var0 <- 3.0 != 3.0; \t// var0 equals false\nbool var1 <- 4.0 != 4.7; \t// var1 equals true\nbool var2 <- [2,3] != [2,3]; \t// var2 equals false\nbool var3 <- [2,4] != [2,3]; \t// var3 equals true\n#now != #now minus_hours 1 :- true\nbool var5 <- 3.0 != 3; \t// var5 equals false\nbool var6 <- 4.7 != 4; \t// var6 equals true\nbool var7 <- 3 != 3.0; \t// var7 equals false\nbool var8 <- 4 != 4.7; \t// var8 equals true\n```\n      \n\n#### See also: \n[=](OperatorsAC#=), [>](OperatorsAC#>), [<](OperatorsAC#<), [>=](OperatorsAC#>=), [<=](OperatorsAC#<=), \n    \t\n----\n\n[//]: # (keyword|operator_?)\n### `?`\n\n#### Possible use: \n  * `bool` **`?`** `any expression` --->  `unknown`\n  *  **`?`** (`bool` , `any expression`) --->  `unknown` \n\n#### Result: \nIt is used in combination with the : operator: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :  \n\n#### Comment: \nThese functional tests can be combined together.\n\n#### Examples: \n```\nlist<string> var0 <- [10, 19, 43, 12, 7, 22] collect ((each > 20) ? 'above' : 'below'); \t// var0 equals ['below', 'below', 'above', 'below', 'below', 'above']\nrgb color <- (flip(0.3) ? #red : (flip(0.9) ? #blue : #green));\n```\n      \n\n#### See also: \n[:](OperatorsAC#:), \n    \t\n----\n\n[//]: # (keyword|operator_/)\n### `/`\n\n#### Possible use: \n  * `rgb` **`/`** `float` --->  `rgb`\n  *  **`/`** (`rgb` , `float`) --->  `rgb`\n  * `float` **`/`** `int` --->  `float`\n  *  **`/`** (`float` , `int`) --->  `float`\n  * `point` **`/`** `float` --->  `point`\n  *  **`/`** (`point` , `float`) --->  `point`\n  * `int` **`/`** `int` --->  `float`\n  *  **`/`** (`int` , `int`) --->  `float`\n  * `int` **`/`** `float` --->  `float`\n  *  **`/`** (`int` , `float`) --->  `float`\n  * `matrix` **`/`** `float` --->  `matrix`\n  *  **`/`** (`matrix` , `float`) --->  `matrix`\n  * `point` **`/`** `int` --->  `point`\n  *  **`/`** (`point` , `int`) --->  `point`\n  * `matrix` **`/`** `matrix` --->  `matrix`\n  *  **`/`** (`matrix` , `matrix`) --->  `matrix`\n  * `matrix` **`/`** `int` --->  `matrix`\n  *  **`/`** (`matrix` , `int`) --->  `matrix`\n  * `float` **`/`** `float` --->  `float`\n  *  **`/`** (`float` , `float`) --->  `float`\n  * `rgb` **`/`** `int` --->  `rgb`\n  *  **`/`** (`rgb` , `int`) --->  `rgb` \n\n#### Result: \nReturns the division of the two operands.\n\n#### Special cases:     \n  * if the right-hand operand is equal to zero, raises a \"Division by zero\" exception    \n  * if one operand is a color and the other a double, returns a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated. \n  \n```\nrgb var0 <- rgb([255, 128, 32]) / 2.5; \t// var0 equals rgb([102,51,13])\n\n``` \n\n    \n  * if the left operand is a point, returns a new point with coordinates divided by the right operand \n  \n```\npoint var1 <- {5, 7.5} / 2.5; \t// var1 equals {2, 3}\npoint var2 <- {2,5} / 4; \t// var2 equals {0.5,1.25}\n\n``` \n\n    \n  * if both operands are numbers (float or int), performs a normal arithmetic division and returns a float. \n  \n```\nfloat var3 <- 3 / 5.0; \t// var3 equals 0.6\n\n``` \n\n    \n  * if one operand is a color and the other an integer, returns a new color resulting from the division of each component of the color by the right operand \n  \n```\nrgb var4 <- rgb([255, 128, 32]) / 2; \t// var4 equals rgb([127,64,16])\n\n``` \n\n    \n\n#### See also: \n[*](OperatorsAC#*), [+](OperatorsAC#+), [-](OperatorsAC#-), \n    \t\n----\n\n[//]: # (keyword|operator_.)\n### `.`\n\n#### Possible use: \n  * `matrix` **`.`** `matrix` --->  `matrix`\n  *  **`.`** (`matrix` , `matrix`) --->  `matrix`\n  * `agent` **`.`** `any expression` --->  `unknown`\n  *  **`.`** (`agent` , `any expression`) --->  `unknown` \n\n#### Result: \nIt has two different uses: it can be the dot product between 2 matrices or return an evaluation of the expression (right-hand operand) in the scope the given agent.\n\n#### Special cases:     \n  * if the agent is nil or dead, throws an exception    \n  * if both operands are matrix, returns the dot product of them \n  \n```\nmatrix var0 <- matrix([[1,1],[1,2]]) . matrix([[1,1],[1,2]]); \t// var0 equals matrix([[2,3],[3,5]])\n\n``` \n\n    \n  * if the left operand is an agent, it evaluates of the expression (right-hand operand) in the scope the given agent \n  \n```\nunknown var1 <- agent1.location; \t// var1 equals the location of the agent agent1\nmap(nil).keys\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_^)\n### `^`\n\n#### Possible use: \n  * `int` **`^`** `float` --->  `float`\n  *  **`^`** (`int` , `float`) --->  `float`\n  * `float` **`^`** `float` --->  `float`\n  *  **`^`** (`float` , `float`) --->  `float`\n  * `int` **`^`** `int` --->  `float`\n  *  **`^`** (`int` , `int`) --->  `float`\n  * `float` **`^`** `int` --->  `float`\n  *  **`^`** (`float` , `int`) --->  `float` \n\n#### Result: \nReturns the value (always a float) of the left operand raised to the power of the right operand.\n\n#### Special cases:     \n  * if the right-hand operand is equal to 0, returns 1    \n  * if it is equal to 1, returns the left-hand operand.    \n  * Various examples of power \n  \n```\nfloat var1 <- 2 ^ 3; \t// var1 equals 8.0\n\n``` \n\n\n\n#### Examples: \n```\nfloat var0 <- 4.84 ^ 0.5; \t// var0 equals 2.2\n```\n      \n\n#### See also: \n[*](OperatorsAC#*), [sqrt](OperatorsNZ#sqrt), \n    \t\n----\n\n[//]: # (keyword|operator_@)\n### `@`\nSame signification as [at](OperatorsAC#at)\n    \t\n----\n\n[//]: # (keyword|operator_*)\n### `*`\n\n#### Possible use: \n  * `int` **`*`** `int` --->  `int`\n  *  **`*`** (`int` , `int`) --->  `int`\n  * `matrix` **`*`** `int` --->  `matrix`\n  *  **`*`** (`matrix` , `int`) --->  `matrix`\n  * `point` **`*`** `point` --->  `float`\n  *  **`*`** (`point` , `point`) --->  `float`\n  * `int` **`*`** `float` --->  `float`\n  *  **`*`** (`int` , `float`) --->  `float`\n  * `float` **`*`** `float` --->  `float`\n  *  **`*`** (`float` , `float`) --->  `float`\n  * `matrix` **`*`** `matrix` --->  `matrix`\n  *  **`*`** (`matrix` , `matrix`) --->  `matrix`\n  * `point` **`*`** `int` --->  `point`\n  *  **`*`** (`point` , `int`) --->  `point`\n  * `float` **`*`** `matrix` --->  `matrix`\n  *  **`*`** (`float` , `matrix`) --->  `matrix`\n  * `geometry` **`*`** `point` --->  `geometry`\n  *  **`*`** (`geometry` , `point`) --->  `geometry`\n  * `point` **`*`** `float` --->  `point`\n  *  **`*`** (`point` , `float`) --->  `point`\n  * `int` **`*`** `matrix` --->  `matrix`\n  *  **`*`** (`int` , `matrix`) --->  `matrix`\n  * `float` **`*`** `int` --->  `float`\n  *  **`*`** (`float` , `int`) --->  `float`\n  * `rgb` **`*`** `int` --->  `rgb`\n  *  **`*`** (`rgb` , `int`) --->  `rgb`\n  * `matrix` **`*`** `float` --->  `matrix`\n  *  **`*`** (`matrix` , `float`) --->  `matrix`\n  * `geometry` **`*`** `float` --->  `geometry`\n  *  **`*`** (`geometry` , `float`) --->  `geometry` \n\n#### Result: \nReturns the product of the two operands.\n\n#### Special cases:     \n  * if both operands are numbers (float or int), performs a normal arithmetic product and returns a float if one of them is a float. \n  \n```\nint var1 <- 1 * 1; \t// var1 equals 1\n\n``` \n\n    \n  * if both operands are points, returns their scalar product \n  \n```\nfloat var2 <- {2,5} * {4.5, 5}; \t// var2 equals 34.0\n\n``` \n\n    \n  * if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the number \n  \n```\npoint var3 <- {2,5} * 4; \t// var3 equals {8.0, 20.0}\npoint var4 <- {2, 4} * 2.5; \t// var4 equals {5.0, 10.0}\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operand a point, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficients in the 3 dimensions \n  \n```\ngeometry var5 <- shape * {0.5,0.5,2}; \t// var5 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z\n\n``` \n\n    \n  * if one operand is a matrix and the other a number (float or int), performs a normal arithmetic product of the number with each element of the matrix (results are float if the number is a float. \n  \n```\nmatrix<float> m <- (3.5 * matrix([[2,5],[3,4]]));\t//m equals matrix([[7.0,17.5],[10.5,14]])\n\n``` \n\n    \n  * if one operand is a color and the other an integer, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255) \n  \n```\nrgb var7 <- rgb([255, 128, 32]) * 2; \t// var7 equals rgb([255,255,64])\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficient \n  \n```\ngeometry var8 <- circle(10) * 2; \t// var8 equals circle(20)\n\n``` \n\n\n\n#### Examples: \n```\nfloat var0 <- 2.5 * 2; \t// var0 equals 5.0\n```\n      \n\n#### See also: \n[+](OperatorsAC#+), [-](OperatorsAC#-), [/](OperatorsAC#/), \n    \t\n----\n\n[//]: # (keyword|operator_+)\n### `+`\n\n#### Possible use: \n  * `string` **`+`** `string` --->  `string`\n  *  **`+`** (`string` , `string`) --->  `string`\n  * `date` **`+`** `float` --->  `date`\n  *  **`+`** (`date` , `float`) --->  `date`\n  * `map` **`+`** `pair` --->  `map`\n  *  **`+`** (`map` , `pair`) --->  `map`\n  * `int` **`+`** `matrix` --->  `matrix`\n  *  **`+`** (`int` , `matrix`) --->  `matrix`\n  * `point` **`+`** `int` --->  `point`\n  *  **`+`** (`point` , `int`) --->  `point`\n  * `rgb` **`+`** `rgb` --->  `rgb`\n  *  **`+`** (`rgb` , `rgb`) --->  `rgb`\n  * `geometry` **`+`** `float` --->  `geometry`\n  *  **`+`** (`geometry` , `float`) --->  `geometry`\n  * `matrix` **`+`** `float` --->  `matrix`\n  *  **`+`** (`matrix` , `float`) --->  `matrix`\n  * `geometry` **`+`** `geometry` --->  `geometry`\n  *  **`+`** (`geometry` , `geometry`) --->  `geometry`\n  * `map` **`+`** `map` --->  `map`\n  *  **`+`** (`map` , `map`) --->  `map`\n  * `float` **`+`** `float` --->  `float`\n  *  **`+`** (`float` , `float`) --->  `float`\n  * `float` **`+`** `int` --->  `float`\n  *  **`+`** (`float` , `int`) --->  `float`\n  * `matrix` **`+`** `matrix` --->  `matrix`\n  *  **`+`** (`matrix` , `matrix`) --->  `matrix`\n  * `date` **`+`** `string` --->  `string`\n  *  **`+`** (`date` , `string`) --->  `string`\n  * `matrix` **`+`** `int` --->  `matrix`\n  *  **`+`** (`matrix` , `int`) --->  `matrix`\n  * `int` **`+`** `int` --->  `int`\n  *  **`+`** (`int` , `int`) --->  `int`\n  * `string` **`+`** `unknown` --->  `string`\n  *  **`+`** (`string` , `unknown`) --->  `string`\n  * `point` **`+`** `point` --->  `point`\n  *  **`+`** (`point` , `point`) --->  `point`\n  * `float` **`+`** `matrix` --->  `matrix`\n  *  **`+`** (`float` , `matrix`) --->  `matrix`\n  * `int` **`+`** `float` --->  `float`\n  *  **`+`** (`int` , `float`) --->  `float`\n  * `point` **`+`** `float` --->  `point`\n  *  **`+`** (`point` , `float`) --->  `point`\n  * `rgb` **`+`** `int` --->  `rgb`\n  *  **`+`** (`rgb` , `int`) --->  `rgb`\n  * `date` **`+`** `int` --->  `date`\n  *  **`+`** (`date` , `int`) --->  `date`\n  * `container` **`+`** `container` --->  `container`\n  *  **`+`** (`container` , `container`) --->  `container`\n  * `container` **`+`** `unknown` --->  `container`\n  *  **`+`** (`container` , `unknown`) --->  `container`\n  *  **`+`** (`geometry`, `float`, `int`) --->  `geometry`\n  *  **`+`** (`geometry`, `float`, `int`, `int`) --->  `geometry` \n\n#### Result: \nReturns the sum, union or concatenation of the two operands.\n\n#### Special cases:     \n  * if one of the operands is nil, + throws an error    \n  * if both operands are species, returns a special type of list called meta-population    \n  * if the left-hand operand is a geometry and the right-hand operands a float and an integer, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand \n  \n```\ngeometry var4 <- circle(5) + (5,32); \t// var4 equals circle(10)\n\n``` \n\n    \n  * if one operand is a matrix and the other a number (float or int), performs a normal arithmetic sum of the number with each element of the matrix (results are float if the number is a float. \n  \n```\nmatrix var5 <- 3.5 + matrix([[2,5],[3,4]]); \t// var5 equals matrix([[5.5,8.5],[6.5,7.5]])\n\n``` \n\n    \n  * if both operands are colors, returns a new color resulting from the sum of the two operands, component by component \n  \n```\nrgb var6 <- rgb([255, 128, 32]) + rgb('red'); \t// var6 equals rgb([255,128,32])\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance. The number of segments used by default is 8 and the end cap style is #round \n  \n```\ngeometry var7 <- circle(5) + 5; \t// var7 equals circle(10)\n\n``` \n\n    \n  * if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometries \n  \n```\ngeometry var8 <- geom1 + geom2; \t// var8 equals a geometry corresponding to union between geom1 and geom2\n\n``` \n\n    \n  * if both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float. \n  \n```\nint var9 <- 1 + 1; \t// var9 equals 2\nint var10 <- 1.0 + 1; \t// var10 equals 2.0\nint var11 <- 1.0 + 2.5; \t// var11 equals 3.5\n\n``` \n\n    \n  * if the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string) \n  \n```\nstring var12 <- \"hello \" + 12; \t// var12 equals \"hello 12\"\n\n``` \n\n    \n  * if both operands are points, returns their sum. \n  \n```\npoint var13 <- {1, 2} + {4, 5}; \t// var13 equals {5.0, 7.0}\n\n``` \n\n    \n  * if the left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number. \n  \n```\npoint var14 <- {1, 2} + 4; \t// var14 equals {5.0, 6.0,4.0}\npoint var15 <- {1, 2} + 4.5; \t// var15 equals {5.5, 6.5,4.5}\n\n``` \n\n    \n  * if one operand is a color and the other an integer, returns a new color resulting from the sum of each component of the color with the right operand \n  \n```\nrgb var16 <- rgb([255, 128, 32]) + 3; \t// var16 equals rgb([255,131,35])\n\n``` \n\n    \n  * if the left-hand operand is a geometry and the right-hand operands a float, an integer and one of #round, #square or #flat, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap style \n  \n```\ngeometry var17 <- circle(5) + (5,32,#round); \t// var17 equals circle(10)\n\n``` \n\n    \n  * if one of the operands is a date and the other a number, returns a date corresponding to the date plus the given number as duration (in seconds) \n  \n```\ndate1 + 200\n\n``` \n\n    \n  * if both operands are list, +returns the concatenation of both lists. \n  \n```\nlist<int> var19 <- [1,2,3,4,5,6] + [2,4,9]; \t// var19 equals [1,2,3,4,5,6,2,4,9]\nlist<int> var20 <- [1,2,3,4,5,6] + [0,8]; \t// var20 equals [1,2,3,4,5,6,0,8]\n\n``` \n\n    \n  * if the right operand is an object of any type (except a container), + returns a list of the elements of the left operand, to which this object has been added \n  \n```\nlist<int> var21 <- [1,2,3,4,5,6] + 2; \t// var21 equals [1,2,3,4,5,6,2]\nlist<int> var22 <- [1,2,3,4,5,6] + 0; \t// var22 equals [1,2,3,4,5,6,0]\n\n``` \n\n\n\n#### Examples: \n```\nmap var0 <- ['a'::1,'b'::2] + ('c'::3); \t// var0 equals ['a'::1,'b'::2,'c'::3]\nmap var1 <- ['a'::1,'b'::2] + ('c'::3); \t// var1 equals ['a'::1,'b'::2,'c'::3]\nmap var2 <- ['a'::1,'b'::2] + ['c'::3]; \t// var2 equals ['a'::1,'b'::2,'c'::3]\nmap var3 <- ['a'::1,'b'::2] + [5::3.0]; \t// var3 equals ['a'::1.0,'b'::2.0,5::3.0]\n```\n      \n\n#### See also: \n[-](OperatorsAC#-), [*](OperatorsAC#*), [/](OperatorsAC#/), \n    \t\n----\n\n[//]: # (keyword|operator_<)\n### `<`\n\n#### Possible use: \n  * `float` **`<`** `int` --->  `bool`\n  *  **`<`** (`float` , `int`) --->  `bool`\n  * `int` **`<`** `int` --->  `bool`\n  *  **`<`** (`int` , `int`) --->  `bool`\n  * `point` **`<`** `point` --->  `bool`\n  *  **`<`** (`point` , `point`) --->  `bool`\n  * `int` **`<`** `float` --->  `bool`\n  *  **`<`** (`int` , `float`) --->  `bool`\n  * `date` **`<`** `date` --->  `bool`\n  *  **`<`** (`date` , `date`) --->  `bool`\n  * `float` **`<`** `float` --->  `bool`\n  *  **`<`** (`float` , `float`) --->  `bool`\n  * `string` **`<`** `string` --->  `bool`\n  *  **`<`** (`string` , `string`) --->  `bool` \n\n#### Result: \ntrue if the left-hand operand is less than the right-hand operand, false otherwise.\n\n#### Special cases:     \n  * if one of the operands is nil, returns false    \n  * if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one. \n  \n```\nbool var5 <- {5,7} < {4,6}; \t// var5 equals false\nbool var6 <- {5,7} < {4,8}; \t// var6 equals false\n\n``` \n\n    \n  * if both operands are String, uses a lexicographic comparison of two strings \n  \n```\nbool var7 <- 'abc' < 'aeb'; \t// var7 equals true\n\n``` \n\n\n\n#### Examples: \n```\nbool var0 <- 3.5 < 7; \t// var0 equals true\nbool var1 <- 3 < 7; \t// var1 equals true\nbool var2 <- 3 < 2.5; \t// var2 equals false\n#now < #now minus_hours 1 :- false\nbool var4 <- 3.5 < 7.6; \t// var4 equals true\n```\n      \n\n#### See also: \n[>](OperatorsAC#>), [>=](OperatorsAC#>=), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [!=](OperatorsAC#!=), \n    \t\n----\n\n[//]: # (keyword|operator_<=)\n### `<=`\n\n#### Possible use: \n  * `string` **`<=`** `string` --->  `bool`\n  *  **`<=`** (`string` , `string`) --->  `bool`\n  * `date` **`<=`** `date` --->  `bool`\n  *  **`<=`** (`date` , `date`) --->  `bool`\n  * `float` **`<=`** `float` --->  `bool`\n  *  **`<=`** (`float` , `float`) --->  `bool`\n  * `int` **`<=`** `int` --->  `bool`\n  *  **`<=`** (`int` , `int`) --->  `bool`\n  * `int` **`<=`** `float` --->  `bool`\n  *  **`<=`** (`int` , `float`) --->  `bool`\n  * `float` **`<=`** `int` --->  `bool`\n  *  **`<=`** (`float` , `int`) --->  `bool`\n  * `point` **`<=`** `point` --->  `bool`\n  *  **`<=`** (`point` , `point`) --->  `bool` \n\n#### Result: \ntrue if the left-hand operand is less or equal than the right-hand operand, false otherwise.\n\n#### Special cases:     \n  * if one of the operands is nil, returns false    \n  * if both operands are String, uses a lexicographic comparison of two strings \n  \n```\nbool var5 <- 'abc' <= 'aeb'; \t// var5 equals true\n\n``` \n\n    \n  * if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one. \n  \n```\nbool var6 <- {5,7} <= {4,6}; \t// var6 equals false\nbool var7 <- {5,7} <= {4,8}; \t// var7 equals false\n\n``` \n\n\n\n#### Examples: \n```\n#now <= #now minus_hours 1 :- false\nbool var1 <- 3.5 <= 3.5; \t// var1 equals true\nbool var2 <- 3 <= 7; \t// var2 equals true\nbool var3 <- 3 <= 2.5; \t// var3 equals false\nbool var4 <- 7.0 <= 7; \t// var4 equals true\n```\n      \n\n#### See also: \n[>](OperatorsAC#>), [<](OperatorsAC#<), [>=](OperatorsAC#>=), [=](OperatorsAC#=), [!=](OperatorsAC#!=), \n    \t\n----\n\n[//]: # (keyword|operator_<>)\n### `<>`\nSame signification as [!=](OperatorsAC#!=)\n    \t\n----\n\n[//]: # (keyword|operator_=)\n### `=`\n\n#### Possible use: \n  * `date` **`=`** `date` --->  `bool`\n  *  **`=`** (`date` , `date`) --->  `bool`\n  * `int` **`=`** `float` --->  `bool`\n  *  **`=`** (`int` , `float`) --->  `bool`\n  * `unknown` **`=`** `unknown` --->  `bool`\n  *  **`=`** (`unknown` , `unknown`) --->  `bool`\n  * `float` **`=`** `float` --->  `bool`\n  *  **`=`** (`float` , `float`) --->  `bool`\n  * `float` **`=`** `int` --->  `bool`\n  *  **`=`** (`float` , `int`) --->  `bool`\n  * `int` **`=`** `int` --->  `bool`\n  *  **`=`** (`int` , `int`) --->  `bool` \n\n#### Result: \nreturns true if both operands are equal, false otherwise\nreturns true if both operands are equal, false otherwise\n\n#### Special cases:     \n  * if both operands are any kind of objects, returns true if they are identical (i.e., the same object) or equal (comparisons between nil values are permitted) \n  \n```\nbool var0 <- [2,3] = [2,3]; \t// var0 equals true\n\n``` \n\n\n\n#### Examples: \n```\n#now = #now minus_hours 1 :- false\nbool var2 <- 3 = 3.0; \t// var2 equals true\nbool var3 <- 4 = 4.7; \t// var3 equals false\nbool var4 <- 4.5 = 4.7; \t// var4 equals false\nbool var5 <- 4.7 = 4; \t// var5 equals false\nbool var6 <- 4 = 5; \t// var6 equals false\n```\n      \n\n#### See also: \n[!=](OperatorsAC#!=), [>](OperatorsAC#>), [<](OperatorsAC#<), [>=](OperatorsAC#>=), [<=](OperatorsAC#<=), \n    \t\n----\n\n[//]: # (keyword|operator_>)\n### `>`\n\n#### Possible use: \n  * `int` **`>`** `float` --->  `bool`\n  *  **`>`** (`int` , `float`) --->  `bool`\n  * `float` **`>`** `float` --->  `bool`\n  *  **`>`** (`float` , `float`) --->  `bool`\n  * `string` **`>`** `string` --->  `bool`\n  *  **`>`** (`string` , `string`) --->  `bool`\n  * `int` **`>`** `int` --->  `bool`\n  *  **`>`** (`int` , `int`) --->  `bool`\n  * `date` **`>`** `date` --->  `bool`\n  *  **`>`** (`date` , `date`) --->  `bool`\n  * `point` **`>`** `point` --->  `bool`\n  *  **`>`** (`point` , `point`) --->  `bool`\n  * `float` **`>`** `int` --->  `bool`\n  *  **`>`** (`float` , `int`) --->  `bool` \n\n#### Result: \ntrue if the left-hand operand is greater than the right-hand operand, false otherwise.\n\n#### Special cases:     \n  * if one of the operands is nil, returns false    \n  * if both operands are String, uses a lexicographic comparison of two strings \n  \n```\nbool var0 <- 'abc' > 'aeb'; \t// var0 equals false\n\n``` \n\n    \n  * if both operands are points, returns true if and only if the left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one. \n  \n```\nbool var1 <- {5,7} > {4,6}; \t// var1 equals true\nbool var2 <- {5,7} > {4,8}; \t// var2 equals false\n\n``` \n\n\n\n#### Examples: \n```\nbool var3 <- 3 > 2.5; \t// var3 equals true\nbool var4 <- 3.5 > 7.6; \t// var4 equals false\nbool var5 <- 3 > 7; \t// var5 equals false\n#now > #now minus_hours 1 :- true\nbool var7 <- 3.5 > 7; \t// var7 equals false\n```\n      \n\n#### See also: \n[<](OperatorsAC#<), [>=](OperatorsAC#>=), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [!=](OperatorsAC#!=), \n    \t\n----\n\n[//]: # (keyword|operator_>=)\n### `>=`\n\n#### Possible use: \n  * `float` **`>=`** `int` --->  `bool`\n  *  **`>=`** (`float` , `int`) --->  `bool`\n  * `int` **`>=`** `int` --->  `bool`\n  *  **`>=`** (`int` , `int`) --->  `bool`\n  * `int` **`>=`** `float` --->  `bool`\n  *  **`>=`** (`int` , `float`) --->  `bool`\n  * `string` **`>=`** `string` --->  `bool`\n  *  **`>=`** (`string` , `string`) --->  `bool`\n  * `date` **`>=`** `date` --->  `bool`\n  *  **`>=`** (`date` , `date`) --->  `bool`\n  * `float` **`>=`** `float` --->  `bool`\n  *  **`>=`** (`float` , `float`) --->  `bool`\n  * `point` **`>=`** `point` --->  `bool`\n  *  **`>=`** (`point` , `point`) --->  `bool` \n\n#### Result: \ntrue if the left-hand operand is greater or equal than the right-hand operand, false otherwise.\n\n#### Special cases:     \n  * if one of the operands is nil, returns false    \n  * if both operands are string, uses a lexicographic comparison of the two strings \n  \n```\nbool var5 <- 'abc' >= 'aeb'; \t// var5 equals false\nbool var6 <- 'abc' >= 'abc'; \t// var6 equals true\n\n``` \n\n    \n  * if both operands are points, returns true if and only if the left component (x) of the left operand if greater or equal than x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one. \n  \n```\nbool var7 <- {5,7} >= {4,6}; \t// var7 equals true\nbool var8 <- {5,7} >= {4,8}; \t// var8 equals false\n\n``` \n\n\n\n#### Examples: \n```\nbool var0 <- 3.5 >= 7; \t// var0 equals false\nbool var1 <- 3 >= 7; \t// var1 equals false\nbool var2 <- 3 >= 2.5; \t// var2 equals true\n#now >= #now minus_hours 1 :- true\nbool var4 <- 3.5 >= 3.5; \t// var4 equals true\n```\n      \n\n#### See also: \n[>](OperatorsAC#>), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [!=](OperatorsAC#!=), \n    \t\n----\n\n[//]: # (keyword|operator_abs)\n### `abs`\n\n#### Possible use: \n  *  **`abs`** (`int`) --->  `int`\n  *  **`abs`** (`float`) --->  `float` \n\n#### Result: \nReturns the absolute value of the operand (so a positive int or float depending on the type of the operand).\n\n#### Examples: \n```\nint var0 <- abs (-10); \t// var0 equals 10\nint var1 <- abs (10); \t// var1 equals 10\nfloat var3 <- abs (200 * -1 + 0.5); \t// var3 equals 199.5\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_accumulate)\n### `accumulate`\n\n#### Possible use: \n  * `container` **`accumulate`** `any expression` --->  `container`\n  *  **`accumulate`** (`container` , `any expression`) --->  `container` \n\n#### Result: \nreturns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned  \n\n#### Comment: \naccumulate is dedicated to the application of a same computation on each element of a container (and returns a list). In the right-hand operand, the keyword each can be used to represent, in turn, each of the left-hand operand elements.\n\n#### Examples: \n```\ncontainer var0 <- [a1,a2,a3] accumulate (each neighbors_at 10); \t// var0 equals a flat list of all the neighbors of these three agents\nlist<int> var1 <- [1,2,4] accumulate ([2,4]); \t// var1 equals [2,4,2,4,2,4]\nlist<int> var2 <- [1,2,4] accumulate (each * 2); \t// var2 equals [2,4,8]\n```\n      \n\n#### See also: \n[collect](OperatorsAC#collect), \n    \t\n----\n\n[//]: # (keyword|operator_acos)\n### `acos`\n\n#### Possible use: \n  *  **`acos`** (`float`) --->  `float`\n  *  **`acos`** (`int`) --->  `float` \n\n#### Result: \nReturns the value (in the interval [0,180], in decimal degrees) of the arccos of the operand (which should be in [-1,1]).\n\n#### Special cases:     \n  * if the right-hand operand is outside of the [-1,1] interval, returns NaN\n\n#### Examples: \n```\nfloat var0 <- acos (0); \t// var0 equals 90.0\n```\n      \n\n#### See also: \n[asin](OperatorsAC#asin), [atan](OperatorsAC#atan), [cos](OperatorsAC#cos), \n    \t\n----\n\n[//]: # (keyword|operator_action)\n### `action`\n\n#### Possible use: \n  *  **`action`** (`any`) --->  `action` \n\n#### Result: \nCasts the operand into the type action\n    \t\n----\n\n[//]: # (keyword|operator_add_days)\n### `add_days`\nSame signification as [plus_days](OperatorsNZ#plus_days)\n    \t\n----\n\n[//]: # (keyword|operator_add_edge)\n### `add_edge`\n\n#### Possible use: \n  * `graph` **`add_edge`** `pair` --->  `graph`\n  *  **`add_edge`** (`graph` , `pair`) --->  `graph` \n\n#### Result: \nadd an edge between a source vertex and a target vertex (resp. the left and the right element of the pair operand)  \n\n#### Comment: \nif the edge already exists, the graph is unchanged\n\n#### Examples: \n```\ngraph <- graph add_edge (source::target);\n```\n      \n\n#### See also: \n[add_node](OperatorsAC#add_node), [graph](OperatorsDM#graph), \n    \t\n----\n\n[//]: # (keyword|operator_add_hours)\n### `add_hours`\nSame signification as [plus_hours](OperatorsNZ#plus_hours)\n    \t\n----\n\n[//]: # (keyword|operator_add_minutes)\n### `add_minutes`\nSame signification as [plus_minutes](OperatorsNZ#plus_minutes)\n    \t\n----\n\n[//]: # (keyword|operator_add_months)\n### `add_months`\nSame signification as [plus_months](OperatorsNZ#plus_months)\n    \t\n----\n\n[//]: # (keyword|operator_add_ms)\n### `add_ms`\nSame signification as [plus_ms](OperatorsNZ#plus_ms)\n    \t\n----\n\n[//]: # (keyword|operator_add_node)\n### `add_node`\n\n#### Possible use: \n  * `graph` **`add_node`** `geometry` --->  `graph`\n  *  **`add_node`** (`graph` , `geometry`) --->  `graph` \n\n#### Result: \nadds a node in a graph.\n\n#### Examples: \n```\ngraph var0 <- graph add_node node(0) ; \t// var0 equals the graph with node(0)\n```\n      \n\n#### See also: \n[add_edge](OperatorsAC#add_edge), [graph](OperatorsDM#graph), \n    \t\n----\n\n[//]: # (keyword|operator_add_point)\n### `add_point`\n\n#### Possible use: \n  * `geometry` **`add_point`** `point` --->  `geometry`\n  *  **`add_point`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nA new geometry resulting from the addition of the right point (coordinate) to the left-hand geometry. Note that adding a point to a line or polyline will always return a closed contour. Also note that the position at which the added point will appear in the geometry is not necessarily the last one, as points are always ordered in a clockwise fashion in geometries\n\n#### Examples: \n```\ngeometry var0 <- polygon([{10,10},{10,20},{20,20}]) add_point {20,10}; \t// var0 equals polygon([{10,10},{10,20},{20,20},{20,10}])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_add_seconds)\n### `add_seconds`\nSame signification as [+](OperatorsAC#+)\n    \t\n----\n\n[//]: # (keyword|operator_add_weeks)\n### `add_weeks`\nSame signification as [plus_weeks](OperatorsNZ#plus_weeks)\n    \t\n----\n\n[//]: # (keyword|operator_add_years)\n### `add_years`\nSame signification as [plus_years](OperatorsNZ#plus_years)\n    \t\n----\n\n[//]: # (keyword|operator_adjacency)\n### `adjacency`\n\n#### Possible use: \n  *  **`adjacency`** (`graph`) --->  `matrix<float>` \n\n#### Result: \nadjacency matrix of the given graph.\n    \t\n----\n\n[//]: # (keyword|operator_after)\n### `after`\n\n#### Possible use: \n  *  **`after`** (`date`) --->  `bool`\n  * `any expression` **`after`** `date` --->  `bool`\n  *  **`after`** (`any expression` , `date`) --->  `bool` \n\n#### Result: \nReturns true if the current_date of the model is strictly after the date passed in argument. Synonym of 'current_date > argument'. Can be used in its composed form with 2 arguments to express the lower boundary for the computation of a frequency. Note that only dates strictly after this one will be tested against the frequency\n\n#### Examples: \n```\nreflex when: after(starting_date) {} -: will always be run after the first step\nreflex when: false after(starting date + #10days) {} -: will not be run after this date. Better to use 'until' or 'before' in that case\nevery(2#days) after (starting_date + 1#day) // the computation will return true every two days (using the starting_date of the model as the starting point) only for the dates strictly after this starting_date + 1#day\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_agent)\n### `agent`\n\n#### Possible use: \n  *  **`agent`** (`any`) --->  `agent` \n\n#### Result: \nCasts the operand into the type agent\n    \t\n----\n\n[//]: # (keyword|operator_agent_closest_to)\n### `agent_closest_to`\n\n#### Possible use: \n  *  **`agent_closest_to`** (`unknown`) --->  `agent` \n\n#### Result: \nAn agent, the closest to the operand (casted as a geometry).  \n\n#### Comment: \nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\n\n#### Examples: \n```\nagent var0 <- agent_closest_to(self); \t// var0 equals the closest agent to the agent applying the operator.\n```\n      \n\n#### See also: \n[neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [agents_inside](OperatorsAC#agents_inside), [agents_overlapping](OperatorsAC#agents_overlapping), [closest_to](OperatorsAC#closest_to), [inside](OperatorsDM#inside), [overlapping](OperatorsNZ#overlapping), \n    \t\n----\n\n[//]: # (keyword|operator_agent_farthest_to)\n### `agent_farthest_to`\n\n#### Possible use: \n  *  **`agent_farthest_to`** (`unknown`) --->  `agent` \n\n#### Result: \nAn agent, the farthest to the operand (casted as a geometry).  \n\n#### Comment: \nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\n\n#### Examples: \n```\nagent var0 <- agent_farthest_to(self); \t// var0 equals the farthest agent to the agent applying the operator.\n```\n      \n\n#### See also: \n[neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [agents_inside](OperatorsAC#agents_inside), [agents_overlapping](OperatorsAC#agents_overlapping), [closest_to](OperatorsAC#closest_to), [inside](OperatorsDM#inside), [overlapping](OperatorsNZ#overlapping), [agent_closest_to](OperatorsAC#agent_closest_to), [farthest_to](OperatorsDM#farthest_to), \n    \t\n----\n\n[//]: # (keyword|operator_agent_from_geometry)\n### `agent_from_geometry`\n\n#### Possible use: \n  * `path` **`agent_from_geometry`** `geometry` --->  `agent`\n  *  **`agent_from_geometry`** (`path` , `geometry`) --->  `agent` \n\n#### Result: \nreturns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).\n\n#### Special cases:     \n  * if the left-hand operand is nil, returns nil\n\n#### Examples: \n```\ngeometry line <- one_of(path_followed.segments);\nroad ag <- road(path_followed agent_from_geometry line);\n```\n      \n\n#### See also: \n[path](OperatorsNZ#path), \n    \t\n----\n\n[//]: # (keyword|operator_agents_at_distance)\n### `agents_at_distance`\n\n#### Possible use: \n  *  **`agents_at_distance`** (`float`) --->  `container` \n\n#### Result: \nA list of agents situated at a distance lower than the right argument.\n\n#### Examples: \n```\ncontainer var0 <- agents_at_distance(20); \t// var0 equals all the agents (excluding the caller) which distance to the caller is lower than 20\n```\n      \n\n#### See also: \n[neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [agent_closest_to](OperatorsAC#agent_closest_to), [agents_inside](OperatorsAC#agents_inside), [closest_to](OperatorsAC#closest_to), [inside](OperatorsDM#inside), [overlapping](OperatorsNZ#overlapping), [at_distance](OperatorsAC#at_distance), \n    \t\n----\n\n[//]: # (keyword|operator_agents_inside)\n### `agents_inside`\n\n#### Possible use: \n  *  **`agents_inside`** (`unknown`) --->  `list<agent>` \n\n#### Result: \nA list of agents covered by the operand (casted as a geometry).\n\n#### Examples: \n```\nlist<agent> var0 <- agents_inside(self); \t// var0 equals the agents that are covered by the shape of the agent applying the operator.\n```\n      \n\n#### See also: \n[agent_closest_to](OperatorsAC#agent_closest_to), [agents_overlapping](OperatorsAC#agents_overlapping), [closest_to](OperatorsAC#closest_to), [inside](OperatorsDM#inside), [overlapping](OperatorsNZ#overlapping), \n    \t\n----\n\n[//]: # (keyword|operator_agents_overlapping)\n### `agents_overlapping`\n\n#### Possible use: \n  *  **`agents_overlapping`** (`unknown`) --->  `list<agent>` \n\n#### Result: \nA list of agents overlapping the operand (casted as a geometry).\n\n#### Examples: \n```\nlist<agent> var0 <- agents_overlapping(self); \t// var0 equals the agents that overlap the shape of the agent applying the operator.\n```\n      \n\n#### See also: \n[neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [agent_closest_to](OperatorsAC#agent_closest_to), [agents_inside](OperatorsAC#agents_inside), [closest_to](OperatorsAC#closest_to), [inside](OperatorsDM#inside), [overlapping](OperatorsNZ#overlapping), [at_distance](OperatorsAC#at_distance), \n    \t\n----\n\n[//]: # (keyword|operator_all_pairs_shortest_path)\n### `all_pairs_shortest_path`\n\n#### Possible use: \n  *  **`all_pairs_shortest_path`** (`graph`) --->  `matrix<int>` \n\n#### Result: \nreturns the successor matrix of shortest paths between all node pairs (rows: source, columns: target): a cell (i,j) will thus contains the next node in the shortest path between i and j.\n\n#### Examples: \n```\nmatrix<int> var0 <- all_pairs_shortest_paths(my_graph); \t// var0 equals shortest_paths_matrix will contain all pairs of shortest paths\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_alpha_index)\n### `alpha_index`\n\n#### Possible use: \n  *  **`alpha_index`** (`graph`) --->  `float` \n\n#### Result: \nreturns the alpha index of the graph (measure of connectivity which evaluates the number of cycles in a graph in comparison with the maximum number of cycles. The higher the alpha index, the more a network is connected: alpha = nb_cycles / (2`*`S-5) - planar graph)\n\n#### Examples: \n```\nfloat var1 <- alpha_index(graphEpidemio); \t// var1 equals the alpha index of the graph\n```\n      \n\n#### See also: \n[beta_index](OperatorsAC#beta_index), [gamma_index](OperatorsDM#gamma_index), [nb_cycles](OperatorsNZ#nb_cycles), [connectivity_index](OperatorsAC#connectivity_index), \n    \t\n----\n\n[//]: # (keyword|operator_among)\n### `among`\n\n#### Possible use: \n  * `int` **`among`** `container` --->  `container`\n  *  **`among`** (`int` , `container`) --->  `container` \n\n#### Result: \nReturns a list of length the value of the left-hand operand, containing random elements from the right-hand operand. As of GAMA 1.6, the order in which the elements are returned can be different than the order in which they appear in the right-hand container\n\n#### Special cases:     \n  * if the right-hand operand is empty, among returns a new empty list. If it is nil, it throws an error.    \n  * if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand (converted as a list). If it is smaller or equal to zero, it returns an empty list\n\n#### Examples: \n```\nlist<int> var0 <- 3 among [1,2,4,3,5,7,6,8]; \t// var0 equals [1,2,8] (for example)\ncontainer var1 <- 3 among g2; \t// var1 equals [node6,node11,node7]\ncontainer var2 <- 3 among list(node); \t// var2 equals [node1,node11,node4]\nlist<int> var3 <- 1 among [1::2,3::4]; \t// var3 equals 2 or 4\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_and)\n### `and`\n\n#### Possible use: \n  * `bool` **`and`** `any expression` --->  `bool`\n  *  **`and`** (`bool` , `any expression`) --->  `bool` \n\n#### Result: \na bool value, equal to the logical and between the left-hand operand and the right-hand operand.  \n\n#### Comment: \nboth operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.    \n\n#### See also: \n[bool](OperatorsAC#bool), [or](OperatorsNZ#or), [!](OperatorsAC#!), \n    \t\n----\n\n[//]: # (keyword|operator_and)\n### `and`\n\n#### Possible use: \n  * `predicate` **`and`** `predicate` --->  `predicate`\n  *  **`and`** (`predicate` , `predicate`) --->  `predicate` \n\n#### Result: \ncreate a new predicate from two others by including them as subintentions\n\n#### Examples: \n```\npredicate1 and predicate2\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_angle_between)\n### `angle_between`\n\n#### Possible use: \n  *  **`angle_between`** (`point`, `point`, `point`) --->  `int` \n\n#### Result: \nthe angle between vectors P0P1 and P0P2 (P0, P1, P2 being the three point operands)\n\n#### Examples: \n```\nint var0 <- angle_between({5,5},{10,5},{5,10}); \t// var0 equals 90\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_any)\n### `any`\nSame signification as [one_of](OperatorsNZ#one_of)\n    \t\n----\n\n[//]: # (keyword|operator_any_location_in)\n### `any_location_in`\n\n#### Possible use: \n  *  **`any_location_in`** (`geometry`) --->  `point` \n\n#### Result: \nA point inside (or touching) the operand-geometry.\n\n#### Examples: \n```\npoint var0 <- any_location_in(square(5)); \t// var0 equals a point in the square, for example : {3,4.6}.\n```\n      \n\n#### See also: \n[closest_points_with](OperatorsAC#closest_points_with), [farthest_point_to](OperatorsDM#farthest_point_to), [points_at](OperatorsNZ#points_at), \n    \t\n----\n\n[//]: # (keyword|operator_any_point_in)\n### `any_point_in`\nSame signification as [any_location_in](OperatorsAC#any_location_in)\n    \t\n----\n\n[//]: # (keyword|operator_append_horizontally)\n### `append_horizontally`\n\n#### Possible use: \n  * `matrix` **`append_horizontally`** `matrix` --->  `matrix`\n  *  **`append_horizontally`** (`matrix` , `matrix`) --->  `matrix`\n  * `matrix` **`append_horizontally`** `matrix` --->  `matrix`\n  *  **`append_horizontally`** (`matrix` , `matrix`) --->  `matrix` \n\n#### Result: \nA matrix resulting from the concatenation of the rows of the two given matrices. If not both numerical or both object matrices, returns the first matrix.\n\n#### Examples: \n```\nmatrix var0 <- matrix([[1.0,2.0],[3.0,4.0]]) append_horizontally matrix([[1,2],[3,4]]); \t// var0 equals matrix([[1.0,2.0],[3.0,4.0],[1.0,2.0],[3.0,4.0]])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_append_vertically)\n### `append_vertically`\n\n#### Possible use: \n  * `matrix` **`append_vertically`** `matrix` --->  `matrix`\n  *  **`append_vertically`** (`matrix` , `matrix`) --->  `matrix`\n  * `matrix` **`append_vertically`** `matrix` --->  `matrix`\n  *  **`append_vertically`** (`matrix` , `matrix`) --->  `matrix` \n\n#### Result: \nA matrix resulting from the concatenation of the columns  of the two given matrices. If not both numerical or both object matrices, returns the first matrix.\n\n#### Examples: \n```\nmatrix var0 <- matrix([[1,2],[3,4]]) append_vertically matrix([[1,2],[3,4]]); \t// var0 equals matrix([[1,2,1,2],[3,4,3,4]])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_arc)\n### `arc`\n\n#### Possible use: \n  *  **`arc`** (`float`, `float`, `float`) --->  `geometry`\n  *  **`arc`** (`float`, `float`, `float`, `bool`) --->  `geometry` \n\n#### Result: \nAn arc, which radius is equal to the first operand, heading to the second and amplitude the third\nAn arc, which radius is equal to the first operand, heading to the second, amplitude to the third and a boolean indicating whether to return a linestring or a polygon to the fourth  \n\n#### Comment: \nthe center of the arc is by default the location of the current agent in which has been called this operator. This operator returns a polygon by default.the center of the arc is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the radius operand is lower or equal to 0.    \n  * returns a point if the radius operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- arc(4,45,90); \t// var0 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°\ngeometry var1 <- arc(4,45,90, false); \t// var1 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°, which only contains the points on the arc\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [super_ellipse](OperatorsNZ#super_ellipse), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [circle](OperatorsAC#circle), [ellipse](OperatorsDM#ellipse), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_around)\n### `around`\n\n#### Possible use: \n  * `float` **`around`** `unknown` --->  `geometry`\n  *  **`around`** (`float` , `unknown`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.\n\n#### Special cases:     \n  * returns a circle geometry of radius right-operand if the left-operand is nil\n\n#### Examples: \n```\ngeometry var0 <- 10 around circle(5); \t// var0 equals the ring geometry between 5 and 10.\n```\n      \n\n#### See also: \n[circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_as)\n### `as`\n\n#### Possible use: \n  * `unknown` **`as`** `any expression` --->  `unknown`\n  *  **`as`** (`unknown` , `any expression`) --->  `unknown` \n\n#### Result: \ncasting of the first argument into a given type  \n\n#### Comment: \nIt is equivalent to the application of the type operator on the left operand.\n\n#### Examples: \n```\nint var0 <- 3.5 as int; \t// var0 equals int(3.5)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_as_4_grid)\n### `as_4_grid`\n\n#### Possible use: \n  * `geometry` **`as_4_grid`** `point` --->  `matrix`\n  *  **`as_4_grid`** (`geometry` , `point`) --->  `matrix` \n\n#### Result: \nA matrix of square geometries (grid with 4-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)\n\n#### Examples: \n```\nmatrix var0 <- self as_4_grid {10, 5}; \t// var0 equals the matrix of square geometries (grid with 4-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.\n```\n      \n\n#### See also: \n[as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), \n    \t\n----\n\n[//]: # (keyword|operator_as_distance_graph)\n### `as_distance_graph`\n\n#### Possible use: \n  * `container` **`as_distance_graph`** `map` --->  `graph`\n  *  **`as_distance_graph`** (`container` , `map`) --->  `graph`\n  * `container` **`as_distance_graph`** `float` --->  `graph`\n  *  **`as_distance_graph`** (`container` , `float`) --->  `graph`\n  *  **`as_distance_graph`** (`container`, `float`, `species`) --->  `graph` \n\n#### Result: \ncreates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).  \n\n#### Comment: \nas_distance_graph is more efficient for a list of points than as_intersection_graph.\n\n#### Examples: \n```\nlist(ant) as_distance_graph 3.0\n```\n      \n\n#### See also: \n[as_intersection_graph](OperatorsAC#as_intersection_graph), [as_edge_graph](OperatorsAC#as_edge_graph), \n    \t\n----\n\n[//]: # (keyword|operator_as_driving_graph)\n### `as_driving_graph`\n\n#### Possible use: \n  * `container` **`as_driving_graph`** `container` --->  `graph`\n  *  **`as_driving_graph`** (`container` , `container`) --->  `graph` \n\n#### Result: \ncreates a graph from the list/map of edges given as operand and connect the node to the edge\n\n#### Examples: \n```\nas_driving_graph(road,node)  --:  build a graph while using the road agents as edges and the node agents as nodes\n```\n      \n\n#### See also: \n[as_intersection_graph](OperatorsAC#as_intersection_graph), [as_distance_graph](OperatorsAC#as_distance_graph), [as_edge_graph](OperatorsAC#as_edge_graph), \n    \t\n----\n\n[//]: # (keyword|operator_as_edge_graph)\n### `as_edge_graph`\n\n#### Possible use: \n  *  **`as_edge_graph`** (`map`) --->  `graph`\n  *  **`as_edge_graph`** (`container`) --->  `graph`\n  * `container` **`as_edge_graph`** `float` --->  `graph`\n  *  **`as_edge_graph`** (`container` , `float`) --->  `graph` \n\n#### Result: \ncreates a graph from the list/map of edges given as operand\n\n#### Special cases:     \n  * if the operand is a map, the graph will be built by creating edges from pairs of the map \n  \n```\ngraph var0 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); \t// var0 equals a graph with these three vertices and two edges\n\n``` \n\n    \n  * if the operand is a list and a tolerance (max distance in meters to consider that 2 points are the same node) is given, the graph will be built with elements of the list as edges and two edges will be connected by a node if the distance between their extremity (first or last points) are at distance lower or equal to the tolerance \n  \n```\ngraph var1 <- as_edge_graph([line([{1,5},{12,45}]),line([{13,45},{34,56}])],1);; \t// var1 equals a graph with two edges and three vertices\n\n``` \n\n    \n  * if the operand is a list, the graph will be built with elements of the list as edges \n  \n```\ngraph var2 <- as_edge_graph([line([{1,5},{12,45}]),line([{12,45},{34,56}])]); \t// var2 equals a graph with two edges and three vertices\n\n``` \n\n    \n\n#### See also: \n[as_intersection_graph](OperatorsAC#as_intersection_graph), [as_distance_graph](OperatorsAC#as_distance_graph), \n    \t\n----\n\n[//]: # (keyword|operator_as_grid)\n### `as_grid`\n\n#### Possible use: \n  * `geometry` **`as_grid`** `point` --->  `matrix`\n  *  **`as_grid`** (`geometry` , `point`) --->  `matrix` \n\n#### Result: \nA matrix of square geometries (grid with 8-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)\n\n#### Examples: \n```\nmatrix var0 <- self as_grid {10, 5}; \t// var0 equals a matrix of square geometries (grid with 8-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.\n```\n      \n\n#### See also: \n[as_4_grid](OperatorsAC#as_4_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), \n    \t\n----\n\n[//]: # (keyword|operator_as_hexagonal_grid)\n### `as_hexagonal_grid`\n\n#### Possible use: \n  * `geometry` **`as_hexagonal_grid`** `point` --->  `list<geometry>`\n  *  **`as_hexagonal_grid`** (`geometry` , `point`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry\n\n#### Examples: \n```\nlist<geometry> var0 <- self as_hexagonal_grid {10, 5}; \t// var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry\n```\n      \n\n#### See also: \n[as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), \n    \t\n----\n\n[//]: # (keyword|operator_as_int)\n### `as_int`\n\n#### Possible use: \n  * `string` **`as_int`** `int` --->  `int`\n  *  **`as_int`** (`string` , `int`) --->  `int` \n\n#### Result: \nparses the string argument as a signed integer in the radix specified by the second argument.\n\n#### Special cases:     \n  * if the left operand is nil or empty, as_int returns 0    \n  * if the left operand does not represent an integer in the specified radix, as_int throws an exception \n\n#### Examples: \n```\nint var0 <- '20' as_int 10; \t// var0 equals 20\nint var1 <- '20' as_int 8; \t// var1 equals 16\nint var2 <- '20' as_int 16; \t// var2 equals 32\nint var3 <- '1F' as_int 16; \t// var3 equals 31\nint var4 <- 'hello' as_int 32; \t// var4 equals 18306744\n```\n      \n\n#### See also: \n[int](OperatorsDM#int), \n    \t\n----\n\n[//]: # (keyword|operator_as_intersection_graph)\n### `as_intersection_graph`\n\n#### Possible use: \n  * `container` **`as_intersection_graph`** `float` --->  `graph`\n  *  **`as_intersection_graph`** (`container` , `float`) --->  `graph` \n\n#### Result: \ncreates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).  \n\n#### Comment: \nas_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.\n\n#### Examples: \n```\nlist(ant) as_intersection_graph 0.5\n```\n      \n\n#### See also: \n[as_distance_graph](OperatorsAC#as_distance_graph), [as_edge_graph](OperatorsAC#as_edge_graph), \n    \t\n----\n\n[//]: # (keyword|operator_as_map)\n### `as_map`\n\n#### Possible use: \n  * `container` **`as_map`** `any expression` --->  `map`\n  *  **`as_map`** (`container` , `any expression`) --->  `map` \n\n#### Result: \nproduces a new map from the evaluation of the right-hand operand for each element of the left-hand operand  \n\n#### Comment: \nthe right-hand operand should be a pair\n\n#### Special cases:     \n  * if the left-hand operand is nil, as_map throws an error.\n\n#### Examples: \n```\nmap<int,int> var0 <- [1,2,3,4,5,6,7,8] as_map (each::(each * 2)); \t// var0 equals [1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16]\nmap<int,int> var1 <- [1::2,3::4,5::6] as_map (each::(each * 2)); \t// var1 equals [2::4, 4::8, 6::12] \n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_as_matrix)\n### `as_matrix`\n\n#### Possible use: \n  * `unknown` **`as_matrix`** `point` --->  `matrix`\n  *  **`as_matrix`** (`unknown` , `point`) --->  `matrix` \n\n#### Result: \ncasts the left operand into a matrix with right operand as preferred size  \n\n#### Comment: \nThis operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.\n\n#### Special cases:     \n  * if the right operand is nil, as_matrix is equivalent to the matrix operator    \n\n#### See also: \n[matrix](OperatorsDM#matrix), \n    \t\n----\n\n[//]: # (keyword|operator_as_path)\n### `as_path`\n\n#### Possible use: \n  * `list<geometry>` **`as_path`** `graph` --->  `path`\n  *  **`as_path`** (`list<geometry>` , `graph`) --->  `path` \n\n#### Result: \ncreate a graph path from the list of shape\n\n#### Examples: \n```\npath var0 <- [road1,road2,road3] as_path my_graph; \t// var0 equals a path road1->road2->road3 of my_graph\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_asin)\n### `asin`\n\n#### Possible use: \n  *  **`asin`** (`float`) --->  `float`\n  *  **`asin`** (`int`) --->  `float` \n\n#### Result: \nthe arcsin of the operand\n\n#### Special cases:     \n  * if the right-hand operand is outside of the [-1,1] interval, returns NaN\n\n#### Examples: \n```\nfloat var0 <- asin (0); \t// var0 equals 0.0\nfloat var1 <- asin (90); \t// var1 equals #nan\n```\n      \n\n#### See also: \n[acos](OperatorsAC#acos), [atan](OperatorsAC#atan), [sin](OperatorsNZ#sin), \n    \t\n----\n\n[//]: # (keyword|operator_at)\n### `at`\n\n#### Possible use: \n  * `string` **`at`** `int` --->  `string`\n  *  **`at`** (`string` , `int`) --->  `string`\n  * `container<KeyType,ValueType>` **`at`** `KeyType` --->  `ValueType`\n  *  **`at`** (`container<KeyType,ValueType>` , `KeyType`) --->  `ValueType` \n\n#### Result: \nthe element at the right operand index of the container  \n\n#### Comment: \nThe first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a file, at returns the element of the file content at the index specified by the right operand    \n  * if it is a population, at returns the agent at the index specified by the right operand    \n  * if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node    \n  * if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge    \n  * if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph    \n  * if it is a list or a matrix, at returns the element at the index specified by the right operand \n  \n```\nint var1 <- [1, 2, 3] at 2; \t// var1 equals 3\npoint var2 <- [{1,2}, {3,4}, {5,6}] at 0; \t// var2 equals {1.0,2.0}\n\n``` \n\n\n\n#### Examples: \n```\nstring var0 <- 'abcdef' at 0; \t// var0 equals 'a'\n```\n      \n\n#### See also: \n[contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), \n    \t\n----\n\n[//]: # (keyword|operator_at_distance)\n### `at_distance`\n\n#### Possible use: \n  * `container<agent>` **`at_distance`** `float` --->  `list<geometry>`\n  *  **`at_distance`** (`container<agent>` , `float`) --->  `list<geometry>` \n\n#### Result: \nA list of agents or geometries among the left-operand list that are located at a distance <= the right operand from the caller agent (in its topology)\n\n#### Examples: \n```\nlist<geometry> var0 <- [ag1, ag2, ag3] at_distance 20; \t// var0 equals the agents of the list located at a distance <= 20 from the caller agent (in the same order).\n```\n      \n\n#### See also: \n[neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [agent_closest_to](OperatorsAC#agent_closest_to), [agents_inside](OperatorsAC#agents_inside), [closest_to](OperatorsAC#closest_to), [inside](OperatorsDM#inside), [overlapping](OperatorsNZ#overlapping), \n    \t\n----\n\n[//]: # (keyword|operator_at_location)\n### `at_location`\n\n#### Possible use: \n  * `geometry` **`at_location`** `point` --->  `geometry`\n  *  **`at_location`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)\n\n#### Examples: \n```\ngeometry var0 <- self at_location {10, 20}; \t// var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent).\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_atan)\n### `atan`\n\n#### Possible use: \n  *  **`atan`** (`float`) --->  `float`\n  *  **`atan`** (`int`) --->  `float` \n\n#### Result: \nReturns the value (in the interval [-90,90], in decimal degrees) of the arctan of the operand (which can be any real number).\n\n#### Examples: \n```\nfloat var0 <- atan (1); \t// var0 equals 45.0\n```\n      \n\n#### See also: \n[acos](OperatorsAC#acos), [asin](OperatorsAC#asin), [tan](OperatorsNZ#tan), \n    \t\n----\n\n[//]: # (keyword|operator_atan2)\n### `atan2`\n\n#### Possible use: \n  * `float` **`atan2`** `float` --->  `float`\n  *  **`atan2`** (`float` , `float`) --->  `float` \n\n#### Result: \nthe atan2 value of the two operands.  \n\n#### Comment: \nThe function atan2 is the arctangent function with two arguments. The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument arctangent function.\n\n#### Examples: \n```\nfloat var0 <- atan2 (0,0); \t// var0 equals 0.0\n```\n      \n\n#### See also: \n[atan](OperatorsAC#atan), [acos](OperatorsAC#acos), [asin](OperatorsAC#asin), \n    \t\n----\n\n[//]: # (keyword|operator_attributes)\n### `attributes`\n\n#### Possible use: \n  *  **`attributes`** (`any`) --->  `attributes` \n\n#### Result: \nCasts the operand into the type attributes\n    \t\n----\n\n[//]: # (keyword|operator_BDIPlan)\n### `BDIPlan`\n\n#### Possible use: \n  *  **`BDIPlan`** (`any`) --->  `BDIPlan` \n\n#### Result: \nCasts the operand into the type BDIPlan\n    \t\n----\n\n[//]: # (keyword|operator_before)\n### `before`\n\n#### Possible use: \n  *  **`before`** (`date`) --->  `bool`\n  * `any expression` **`before`** `date` --->  `bool`\n  *  **`before`** (`any expression` , `date`) --->  `bool` \n\n#### Result: \nReturns true if the current_date of the model is strictly before the date passed in argument. Synonym of 'current_date < argument'\n\n#### Examples: \n```\nreflex when: before(starting_date) {} -: will never be run\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_beta_index)\n### `beta_index`\n\n#### Possible use: \n  *  **`beta_index`** (`graph`) --->  `float` \n\n#### Result: \nreturns the beta index of the graph (Measures the level of connectivity in a graph and is expressed by the relationship between the number of links (e) over the number of nodes (v) : beta = e/v.\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nfloat var1 <- beta_index(graphEpidemio); \t// var1 equals the beta index of the graph\n```\n      \n\n#### See also: \n[alpha_index](OperatorsAC#alpha_index), [gamma_index](OperatorsDM#gamma_index), [nb_cycles](OperatorsNZ#nb_cycles), [connectivity_index](OperatorsAC#connectivity_index), \n    \t\n----\n\n[//]: # (keyword|operator_between)\n### `between`\n\n#### Possible use: \n  * `date` **`between`** `date` --->  `bool`\n  *  **`between`** (`date` , `date`) --->  `bool`\n  *  **`between`** (`int`, `int`, `int`) --->  `bool`\n  *  **`between`** (`any expression`, `date`, `date`) --->  `bool`\n  *  **`between`** (`float`, `float`, `float`) --->  `bool`\n  *  **`between`** (`date`, `date`, `date`) --->  `bool` \n\n#### Result: \nreturns true the first integer operand is bigger than the second integer operand and smaller than the third integer operand\nreturns true if the first float operand is bigger than the second float operand and smaller than the third float operand\n\n#### Special cases:     \n  * returns true if the first operand is between the two dates passed in arguments (both exclusive). Can be combined with 'every' to express a frequency between two dates \n  \n```\n(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: true\nevery #day between(date('2000-01-01'), date('2020-02-02') // will return true every new day between these two dates, taking the first one as the starting point\n\n``` \n\n    \n  * returns true if the first operand is between the two dates passed in arguments (both exclusive). The version with 2 arguments compares the current_date with the 2 others \n  \n```\n(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: true\nbetween(date('2000-01-01'), date('2020-02-02') // will return true if the current_date of the model is in_between the 2\n\n``` \n\n\n\n#### Examples: \n```\nbool var0 <- between(5, 1, 10); \t// var0 equals true\nbool var1 <- between(5.0, 1.0, 10.0); \t// var1 equals true\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_betweenness_centrality)\n### `betweenness_centrality`\n\n#### Possible use: \n  *  **`betweenness_centrality`** (`graph`) --->  `map` \n\n#### Result: \nreturns a map containing for each vertex (key), its betweenness centrality (value): number of shortest paths passing through each vertex\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nmap var1 <- betweenness_centrality(graphEpidemio); \t// var1 equals the betweenness centrality index of the graph\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_biggest_cliques_of)\n### `biggest_cliques_of`\n\n#### Possible use: \n  *  **`biggest_cliques_of`** (`graph`) --->  `list<list>` \n\n#### Result: \nreturns the biggest cliques of a graph using the Bron-Kerbosch clique detection algorithm\n\n#### Examples: \n```\ngraph my_graph <- graph([]);\nlist<list> var1 <- biggest_cliques_of (my_graph); \t// var1 equals the list of the biggest cliques as list\n```\n      \n\n#### See also: \n[maximal_cliques_of](OperatorsDM#maximal_cliques_of), \n    \t\n----\n\n[//]: # (keyword|operator_binomial)\n### `binomial`\n\n#### Possible use: \n  * `int` **`binomial`** `float` --->  `int`\n  *  **`binomial`** (`int` , `float`) --->  `int` \n\n#### Result: \nA value from a random variable following a binomial distribution. The operands represent the number of experiments n and the success probability p.  \n\n#### Comment: \nThe binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.\n\n#### Examples: \n```\nint var0 <- binomial(15,0.6); \t// var0 equals a random positive integer\n```\n      \n\n#### See also: \n[poisson](OperatorsNZ#poisson), [gauss](OperatorsDM#gauss), \n    \t\n----\n\n[//]: # (keyword|operator_blend)\n### `blend`\n\n#### Possible use: \n  * `rgb` **`blend`** `rgb` --->  `rgb`\n  *  **`blend`** (`rgb` , `rgb`) --->  `rgb`\n  *  **`blend`** (`rgb`, `rgb`, `float`) --->  `rgb` \n\n#### Result: \nBlend two colors with an optional ratio (c1 `*` r + c2 `*` (1 - r)) between 0 and 1\n\n#### Special cases:     \n  * If the ratio is omitted, an even blend is done \n  \n```\nrgb var3 <- blend(#red, #blue); \t// var3 equals to a color very close to the purple\n\n``` \n\n\n\n#### Examples: \n```\nrgb var1 <- blend(#red, #blue, 0.3); \t// var1 equals to a color between the purple and the blue\n```\n      \n\n#### See also: \n[rgb](OperatorsNZ#rgb), [hsb](OperatorsDM#hsb), \n    \t\n----\n\n[//]: # (keyword|operator_bool)\n### `bool`\n\n#### Possible use: \n  *  **`bool`** (`any`) --->  `bool` \n\n#### Result: \nCasts the operand into the type bool\n    \t\n----\n\n[//]: # (keyword|operator_box)\n### `box`\n\n#### Possible use: \n  *  **`box`** (`point`) --->  `geometry`\n  *  **`box`** (`float`, `float`, `float`) --->  `geometry` \n\n#### Result: \nA box geometry which side sizes are given by the operands.  \n\n#### Comment: \nthe center of the box is by default the location of the current agent in which has been called this operator.the center of the box is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- box(10, 5 , 5); \t// var0 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.\ngeometry var1 <- box({10, 5 , 5}); \t// var1 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [sphere](OperatorsNZ#sphere), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [square](OperatorsNZ#square), [cube](OperatorsAC#cube), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_brewer_colors)\n### `brewer_colors`\n\n#### Possible use: \n  *  **`brewer_colors`** (`string`) --->  `list<rgb>`\n  * `string` **`brewer_colors`** `int` --->  `list<rgb>`\n  *  **`brewer_colors`** (`string` , `int`) --->  `list<rgb>` \n\n#### Result: \nBuild a list of colors of a given type (see website http://colorbrewer2.org/)\nBuild a list of colors of a given type (see website http://colorbrewer2.org/) with a given number of classes\n\n#### Examples: \n```\nlist<rgb> var0 <- list<rgb> colors <- brewer_colors(\"OrRd\");; \t// var0 equals a list of 6 blue colors\nlist<rgb> var1 <- list<rgb> colors <- brewer_colors(\"Pastel1\", 10);; \t// var1 equals a list of 10 sequential colors\n```\n      \n\n#### See also: \n[brewer_palettes](OperatorsAC#brewer_palettes), \n    \t\n----\n\n[//]: # (keyword|operator_brewer_palettes)\n### `brewer_palettes`\n\n#### Possible use: \n  *  **`brewer_palettes`** (`int`) --->  `list<string>`\n  * `int` **`brewer_palettes`** `int` --->  `list<string>`\n  *  **`brewer_palettes`** (`int` , `int`) --->  `list<string>` \n\n#### Result: \nreturns the list a palette with a given min number of classes and max number of classes)\nreturns the list a palette with a given min number of classes and max number of classes)\n\n#### Examples: \n```\nlist<string> var0 <- list<rgb> colors <- brewer_palettes(5,10);; \t// var0 equals a list of palettes that are composed of a min of 5 colors and a max of 10 colors\nlist<string> var1 <- list<rgb> colors <- brewer_palettes();; \t// var1 equals a list of palettes that are composed of a min of 5 colors\n```\n      \n\n#### See also: \n[brewer_colors](OperatorsAC#brewer_colors), \n    \t\n----\n\n[//]: # (keyword|operator_buffer)\n### `buffer`\nSame signification as [+](OperatorsAC#+)\n    \t\n----\n\n[//]: # (keyword|operator_build)\n### `build`\n\n#### Possible use: \n  *  **`build`** (`matrix<float>`) --->  `regression`\n  * `matrix<float>` **`build`** `string` --->  `regression`\n  *  **`build`** (`matrix<float>` , `string`) --->  `regression` \n\n#### Result: \nreturns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given ordinary least squares method. Usage: build(data)\nreturns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given method (\"GLS\" or \"OLS\"). Usage: build(data,method)\n\n#### Examples: \n```\nmatrix([[1,2,3,4],[2,3,4,2]])\nbuild(matrix([[1,2,3,4],[2,3,4,2]]),\"GLS\")\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_ceil)\n### `ceil`\n\n#### Possible use: \n  *  **`ceil`** (`float`) --->  `float` \n\n#### Result: \nMaps the operand to the smallest following integer, i.e. the smallest integer not less than x.\n\n#### Examples: \n```\nfloat var0 <- ceil(3); \t// var0 equals 3.0\nfloat var1 <- ceil(3.5); \t// var1 equals 4.0\nfloat var2 <- ceil(-4.7); \t// var2 equals -4.0\n```\n      \n\n#### See also: \n[floor](OperatorsDM#floor), [round](OperatorsNZ#round), \n    \t\n----\n\n[//]: # (keyword|operator_centroid)\n### `centroid`\n\n#### Possible use: \n  *  **`centroid`** (`geometry`) --->  `point` \n\n#### Result: \nCentroid (weighted sum of the centroids of a decomposition of the area into triangles) of the operand-geometry. Can be different to the location of the geometry\n\n#### Examples: \n```\npoint var0 <- centroid(world); \t// var0 equals the centroid of the square, for example : {50.0,50.0}.\n```\n      \n\n#### See also: \n[any_location_in](OperatorsAC#any_location_in), [closest_points_with](OperatorsAC#closest_points_with), [farthest_point_to](OperatorsDM#farthest_point_to), [points_at](OperatorsNZ#points_at), \n    \t\n----\n\n[//]: # (keyword|operator_char)\n### `char`\n\n#### Possible use: \n  *  **`char`** (`int`) --->  `string`\n\n#### Special cases:     \n  * converts ACSII integer value to character \n  \n```\nstring var0 <- char (34); \t// var0 equals '\"'\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_circle)\n### `circle`\n\n#### Possible use: \n  *  **`circle`** (`float`) --->  `geometry`\n  * `float` **`circle`** `point` --->  `geometry`\n  *  **`circle`** (`float` , `point`) --->  `geometry` \n\n#### Result: \nA circle geometry which radius is equal to the first operand, and the center has the location equal to the second operand.\nA circle geometry which radius is equal to the operand.  \n\n#### Comment: \nthe center of the circle is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.    \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- circle(10,{80,30}); \t// var0 equals a geometry as a circle of radius 10, the center will be in the location {80,30}.\ngeometry var1 <- circle(10); \t// var1 equals a geometry as a circle of radius 10.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_clean)\n### `clean`\n\n#### Possible use: \n  *  **`clean`** (`geometry`) --->  `geometry` \n\n#### Result: \nA geometry corresponding to the cleaning of the operand (geometry, agent, point)  \n\n#### Comment: \nThe cleaning corresponds to a buffer with a distance of 0.0\n\n#### Examples: \n```\ngeometry var0 <- clean(self); \t// var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_closest_points_with)\n### `closest_points_with`\n\n#### Possible use: \n  * `geometry` **`closest_points_with`** `geometry` --->  `list<point>`\n  *  **`closest_points_with`** (`geometry` , `geometry`) --->  `list<point>` \n\n#### Result: \nA list of two closest points between the two geometries.\n\n#### Examples: \n```\nlist<point> var0 <- geom1 closest_points_with(geom2); \t// var0 equals [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1\n```\n      \n\n#### See also: \n[any_location_in](OperatorsAC#any_location_in), [any_point_in](OperatorsAC#any_point_in), [farthest_point_to](OperatorsDM#farthest_point_to), [points_at](OperatorsNZ#points_at), \n    \t\n----\n\n[//]: # (keyword|operator_closest_to)\n### `closest_to`\n\n#### Possible use: \n  * `container<agent>` **`closest_to`** `geometry` --->  `geometry`\n  *  **`closest_to`** (`container<agent>` , `geometry`) --->  `geometry` \n\n#### Result: \nAn agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the closest to the operand (casted as a geometry).  \n\n#### Comment: \nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\n\n#### Examples: \n```\ngeometry var0 <- [ag1, ag2, ag3] closest_to(self); \t// var0 equals return the closest agent among ag1, ag2 and ag3 to the agent applying the operator.\n(species1 + species2) closest_to self\n```\n      \n\n#### See also: \n[neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [inside](OperatorsDM#inside), [overlapping](OperatorsNZ#overlapping), [agents_overlapping](OperatorsAC#agents_overlapping), [agents_inside](OperatorsAC#agents_inside), [agent_closest_to](OperatorsAC#agent_closest_to), \n    \t\n----\n\n[//]: # (keyword|operator_collect)\n### `collect`\n\n#### Possible use: \n  * `container` **`collect`** `any expression` --->  `container`\n  *  **`collect`** (`container` , `any expression`) --->  `container` \n\n#### Result: \nreturns a new list, in which each element is the evaluation of the right-hand operand.  \n\n#### Comment: \ncollect is similar to accumulate except that accumulate always produces flat lists if the right-hand operand returns a list.In addition, collect can be applied to any container.\n\n#### Special cases:     \n  * if the left-hand operand is nil, collect throws an error\n\n#### Examples: \n```\ncontainer var0 <- [1,2,4] collect (each *2); \t// var0 equals [2,4,8]\ncontainer var1 <- [1,2,4] collect ([2,4]); \t// var1 equals [[2,4],[2,4],[2,4]]\ncontainer var2 <- [1::2, 3::4, 5::6] collect (each + 2); \t// var2 equals [4,6,8]\ncontainer var3 <- (list(node) collect (node(each).location.x * 2); \t// var3 equals the list of nodes with their x multiplied by 2\n```\n      \n\n#### See also: \n[accumulate](OperatorsAC#accumulate), \n    \t\n----\n\n[//]: # (keyword|operator_column_at)\n### `column_at`\n\n#### Possible use: \n  * `matrix` **`column_at`** `int` --->  `list`\n  *  **`column_at`** (`matrix` , `int`) --->  `list` \n\n#### Result: \nreturns the column at a num_col (right-hand operand)\n\n#### Examples: \n```\nlist var0 <- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) column_at 2; \t// var0 equals [\"el31\",\"el32\",\"el33\"]\n```\n      \n\n#### See also: \n[row_at](OperatorsNZ#row_at), [rows_list](OperatorsNZ#rows_list), \n    \t\n----\n\n[//]: # (keyword|operator_columns_list)\n### `columns_list`\n\n#### Possible use: \n  *  **`columns_list`** (`matrix`) --->  `list<list>` \n\n#### Result: \nreturns a list of the columns of the matrix, with each column as a list of elements\n\n#### Examples: \n```\nlist<list> var0 <- columns_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); \t// var0 equals [[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]\n```\n      \n\n#### See also: \n[rows_list](OperatorsNZ#rows_list), \n    \t\n----\n\n[//]: # (keyword|operator_command)\n### `command`\n\n#### Possible use: \n  *  **`command`** (`string`) --->  `string` \n\n#### Result: \ncommand allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence ' &' is used at the end. In this case, the result of the operator is an empty string\n    \t\n----\n\n[//]: # (keyword|operator_cone)\n### `cone`\n\n#### Possible use: \n  *  **`cone`** (`point`) --->  `geometry`\n  * `int` **`cone`** `int` --->  `geometry`\n  *  **`cone`** (`int` , `int`) --->  `geometry` \n\n#### Result: \nA cone geometry which min and max angles are given by the operands.\nA cone geometry which min and max angles are given by the operands.  \n\n#### Comment: \nthe center of the cone is by default the location of the current agent in which has been called this operator.the center of the cone is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- cone({0, 45}); \t// var0 equals a geometry as a cone with min angle is 0 and max angle is 45.\ngeometry var1 <- cone(0, 45); \t// var1 equals a geometry as a cone with min angle is 0 and max angle is 45.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_cone3D)\n### `cone3D`\n\n#### Possible use: \n  * `float` **`cone3D`** `float` --->  `geometry`\n  *  **`cone3D`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nA cone geometry which base radius size is equal to the first operand, and which the height is equal to the second operand.  \n\n#### Comment: \nthe center of the cone is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- cone3D(10.0,5.0); \t// var0 equals a geometry as a cone with a base circle of radius 10 and a height of 5.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_connected_components_of)\n### `connected_components_of`\n\n#### Possible use: \n  *  **`connected_components_of`** (`graph`) --->  `list<list>` \n\n#### Result: \nreturns the connected components of of a graph, i.e. the list of all vertices that are in the maximally connected component together with the specified vertex.\n\n#### Examples: \n```\ngraph my_graph <- graph([]);\nlist<list> var1 <- connected_components_of (my_graph); \t// var1 equals the list of all the components as list\n```\n      \n\n#### See also: \n[alpha_index](OperatorsAC#alpha_index), [connectivity_index](OperatorsAC#connectivity_index), [nb_cycles](OperatorsNZ#nb_cycles), \n    \t\n----\n\n[//]: # (keyword|operator_connectivity_index)\n### `connectivity_index`\n\n#### Possible use: \n  *  **`connectivity_index`** (`graph`) --->  `float` \n\n#### Result: \nreturns a simple connectivity index. This number is estimated through the number of nodes (v) and of sub-graphs (p) : IC = (v - p) /(v - 1).\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nfloat var1 <- connectivity_index(graphEpidemio); \t// var1 equals the connectivity index of the graph\n```\n      \n\n#### See also: \n[alpha_index](OperatorsAC#alpha_index), [beta_index](OperatorsAC#beta_index), [gamma_index](OperatorsDM#gamma_index), [nb_cycles](OperatorsNZ#nb_cycles), \n    \t\n----\n\n[//]: # (keyword|operator_container)\n### `container`\n\n#### Possible use: \n  *  **`container`** (`any`) --->  `container` \n\n#### Result: \nCasts the operand into the type container\n    \t\n----\n\n[//]: # (keyword|operator_contains)\n### `contains`\n\n#### Possible use: \n  * `container<KeyType,ValueType>` **`contains`** `unknown` --->  `bool`\n  *  **`contains`** (`container<KeyType,ValueType>` , `unknown`) --->  `bool`\n  * `string` **`contains`** `string` --->  `bool`\n  *  **`contains`** (`string` , `string`) --->  `bool` \n\n#### Result: \ntrue, if the container contains the right operand, false otherwise  \n\n#### Comment: \nthe contains operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a map, contains returns true if the operand is a key of the map    \n  * if it is a file, contains returns true it the operand is contained in the file content    \n  * if it is a population, contains returns true if the operand is an agent of the population, false otherwise    \n  * if it is a graph, contains returns true if the operand is a node or an edge of the graph, false otherwise    \n  * if both operands are strings, returns true if the right-hand operand contains the right-hand pattern;    \n  * if it is a list or a matrix, contains returns true if the list or matrix contains the right operand \n  \n```\nbool var0 <- [1, 2, 3] contains 2; \t// var0 equals true\nbool var1 <- [{1,2}, {3,4}, {5,6}] contains {3,4}; \t// var1 equals true\n\n``` \n\n\n\n#### Examples: \n```\nbool var2 <- 'abcded' contains 'bc'; \t// var2 equals true\n```\n      \n\n#### See also: \n[contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), \n    \t\n----\n\n[//]: # (keyword|operator_contains_all)\n### `contains_all`\n\n#### Possible use: \n  * `container` **`contains_all`** `container` --->  `bool`\n  *  **`contains_all`** (`container` , `container`) --->  `bool`\n  * `string` **`contains_all`** `list` --->  `bool`\n  *  **`contains_all`** (`string` , `list`) --->  `bool` \n\n#### Result: \ntrue if the left operand contains all the elements of the right operand, false otherwise  \n\n#### Comment: \nthe definition of contains depends on the container\n\n#### Special cases:     \n  * if the right operand is nil or empty, contains_all returns true    \n  * if the left-operand is a string, test whether the string contains all the element of the list; \n  \n```\nbool var4 <- \"abcabcabc\" contains_all [\"ca\",\"xy\"]; \t// var4 equals false\n\n``` \n\n\n\n#### Examples: \n```\nbool var0 <- [1,2,3,4,5,6] contains_all [2,4]; \t// var0 equals true \nbool var1 <- [1,2,3,4,5,6] contains_all [2,8]; \t// var1 equals false\nbool var2 <- [1::2, 3::4, 5::6] contains_all [1,3]; \t// var2 equals false \nbool var3 <- [1::2, 3::4, 5::6] contains_all [2,4]; \t// var3 equals true\n```\n      \n\n#### See also: \n[contains](OperatorsAC#contains), [contains_any](OperatorsAC#contains_any), \n    \t\n----\n\n[//]: # (keyword|operator_contains_any)\n### `contains_any`\n\n#### Possible use: \n  * `container` **`contains_any`** `container` --->  `bool`\n  *  **`contains_any`** (`container` , `container`) --->  `bool`\n  * `string` **`contains_any`** `list` --->  `bool`\n  *  **`contains_any`** (`string` , `list`) --->  `bool` \n\n#### Result: \ntrue if the left operand contains one of the elements of the right operand, false otherwise  \n\n#### Comment: \nthe definition of contains depends on the container\n\n#### Special cases:     \n  * if the right operand is nil or empty, contains_any returns false\n\n#### Examples: \n```\nbool var0 <- [1,2,3,4,5,6] contains_any [2,4]; \t// var0 equals true \nbool var1 <- [1,2,3,4,5,6] contains_any [2,8]; \t// var1 equals true\nbool var2 <- [1::2, 3::4, 5::6] contains_any [1,3]; \t// var2 equals false\nbool var3 <- [1::2, 3::4, 5::6] contains_any [2,4]; \t// var3 equals true\nbool var4 <- \"abcabcabc\" contains_any [\"ca\",\"xy\"]; \t// var4 equals true\n```\n      \n\n#### See also: \n[contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), \n    \t\n----\n\n[//]: # (keyword|operator_contains_edge)\n### `contains_edge`\n\n#### Possible use: \n  * `graph` **`contains_edge`** `unknown` --->  `bool`\n  *  **`contains_edge`** (`graph` , `unknown`) --->  `bool`\n  * `graph` **`contains_edge`** `pair` --->  `bool`\n  *  **`contains_edge`** (`graph` , `pair`) --->  `bool` \n\n#### Result: \nreturns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwise\n\n#### Special cases:     \n  * if the left-hand operand is nil, returns false    \n  * if the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graph \n  \n```\nbool var2 <- graphEpidemio contains_edge (node(0)::node(3)); \t// var2 equals true\n\n``` \n\n\n\n#### Examples: \n```\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nbool var1 <- graphFromMap contains_edge link({1,5}::{12,45}); \t// var1 equals true\n```\n      \n\n#### See also: \n[contains_vertex](OperatorsAC#contains_vertex), \n    \t\n----\n\n[//]: # (keyword|operator_contains_vertex)\n### `contains_vertex`\n\n#### Possible use: \n  * `graph` **`contains_vertex`** `unknown` --->  `bool`\n  *  **`contains_vertex`** (`graph` , `unknown`) --->  `bool` \n\n#### Result: \nreturns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwise\n\n#### Special cases:     \n  * if the left-hand operand is nil, returns false\n\n#### Examples: \n```\ngraph graphFromMap<-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nbool var1 <- graphFromMap contains_vertex {1,5}; \t// var1 equals true\n```\n      \n\n#### See also: \n[contains_edge](OperatorsAC#contains_edge), \n    \t\n----\n\n[//]: # (keyword|operator_conversation)\n### `conversation`\n\n#### Possible use: \n  *  **`conversation`** (`unknown`) --->  `conversation`\n    \t\n----\n\n[//]: # (keyword|operator_convex_hull)\n### `convex_hull`\n\n#### Possible use: \n  *  **`convex_hull`** (`geometry`) --->  `geometry` \n\n#### Result: \nA geometry corresponding to the convex hull of the operand.\n\n#### Examples: \n```\ngeometry var0 <- convex_hull(self); \t// var0 equals the convex hull of the geometry of the agent applying the operator\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_copy)\n### `copy`\n\n#### Possible use: \n  *  **`copy`** (`unknown`) --->  `unknown` \n\n#### Result: \nreturns a copy of the operand.\n    \t\n----\n\n[//]: # (keyword|operator_copy_between)\n### `copy_between`\n\n#### Possible use: \n  *  **`copy_between`** (`string`, `int`, `int`) --->  `string`\n  *  **`copy_between`** (`container`, `int`, `int`) --->  `container` \n\n#### Result: \nReturns a copy of the first operand between the indexes determined by the second (inclusive) and third operands (exclusive)\n\n#### Special cases:     \n  * If the first operand is empty, returns an empty object of the same type    \n  * If the second operand is greater than or equal to the third operand, return an empty object of the same type    \n  * If the first operand is nil, raises an error\n\n#### Examples: \n```\nstring var0 <- copy_between(\"abcabcabc\", 2,6); \t// var0 equals \"cabc\"\ncontainer var1 <-  copy_between ([4, 1, 6, 9 ,7], 1, 3); \t// var1 equals [1, 6]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_corR)\n### `corR`\n\n#### Possible use: \n  * `container` **`corR`** `container` --->  `unknown`\n  *  **`corR`** (`container` , `container`) --->  `unknown` \n\n#### Result: \nreturns the Pearson correlation coefficient of two given vectors (right-hand operands) in given variable  (left-hand operand).\n\n#### Special cases:     \n  * if the lengths of two vectors in the right-hand aren't equal, returns 0\n\n#### Examples: \n```\nlist X <- [1, 2, 3];\nlist Y <- [1, 2, 4];\nunknown var2 <- corR(X, Y); \t// var2 equals 0.981980506061966\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_cos)\n### `cos`\n\n#### Possible use: \n  *  **`cos`** (`int`) --->  `float`\n  *  **`cos`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized.\n\n#### Examples: \n```\nfloat var0 <- cos (0); \t// var0 equals 1.0\nfloat var1 <- cos(360); \t// var1 equals 1.0\nfloat var2 <- cos(-720); \t// var2 equals 1.0\n```\n      \n\n#### See also: \n[sin](OperatorsNZ#sin), [tan](OperatorsNZ#tan), \n    \t\n----\n\n[//]: # (keyword|operator_cos_rad)\n### `cos_rad`\n\n#### Possible use: \n  *  **`cos_rad`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized.    \n\n#### See also: \n[sin](OperatorsNZ#sin), [tan](OperatorsNZ#tan), \n    \t\n----\n\n[//]: # (keyword|operator_count)\n### `count`\n\n#### Possible use: \n  * `container` **`count`** `any expression` --->  `int`\n  *  **`count`** (`container` , `any expression`) --->  `int` \n\n#### Result: \nreturns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, count throws an error\n\n#### Examples: \n```\nint var0 <- [1,2,3,4,5,6,7,8] count (each > 3); \t// var0 equals 5\n// Number of nodes of graph g2 without any out edge\ngraph g2 <- graph([]);\nint var3 <- g2 count (length(g2 out_edges_of each) = 0  ) ; \t// var3 equals the total number of out edges\n// Number of agents node with x > 32\nint n <- (list(node) count (round(node(each).location.x) > 32);\nint var6 <- [1::2, 3::4, 5::6] count (each > 4); \t// var6 equals 1\n```\n      \n\n#### See also: \n[group_by](OperatorsDM#group_by), \n    \t\n----\n\n[//]: # (keyword|operator_covers)\n### `covers`\n\n#### Possible use: \n  * `geometry` **`covers`** `geometry` --->  `bool`\n  *  **`covers`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) covers the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.\n\n#### Examples: \n```\nbool var0 <- square(5) covers square(2); \t// var0 equals true\n```\n      \n\n#### See also: \n[disjoint_from](OperatorsDM#disjoint_from), [crosses](OperatorsAC#crosses), [overlaps](OperatorsNZ#overlaps), [partially_overlaps](OperatorsNZ#partially_overlaps), [touches](OperatorsNZ#touches), \n    \t\n----\n\n[//]: # (keyword|operator_cross)\n### `cross`\n\n#### Possible use: \n  *  **`cross`** (`float`) --->  `geometry`\n  * `float` **`cross`** `float` --->  `geometry`\n  *  **`cross`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nA cross, which radius is equal to the first operand\nA cross, which radius is equal to the first operand and the width of the lines for the second\n\n#### Examples: \n```\ngeometry var0 <- cross(10); \t// var0 equals a geometry as a cross of radius 10\ngeometry var1 <- cross(10,2); \t// var1 equals a geometry as a cross of radius 10, and with a width of 2 for the lines \n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [super_ellipse](OperatorsNZ#super_ellipse), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [circle](OperatorsAC#circle), [ellipse](OperatorsDM#ellipse), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_crosses)\n### `crosses`\n\n#### Possible use: \n  * `geometry` **`crosses`** `geometry` --->  `bool`\n  *  **`crosses`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.    \n  * if one operand is a point, returns false.\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]); \t// var0 equals true\nbool var1 <- polyline([{10,10},{20,20}]) crosses {15,15}; \t// var1 equals true\nbool var2 <- polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]); \t// var2 equals true\n```\n      \n\n#### See also: \n[disjoint_from](OperatorsDM#disjoint_from), [intersects](OperatorsDM#intersects), [overlaps](OperatorsNZ#overlaps), [partially_overlaps](OperatorsNZ#partially_overlaps), [touches](OperatorsNZ#touches), \n    \t\n----\n\n[//]: # (keyword|operator_crs)\n### `crs`\n\n#### Possible use: \n  *  **`crs`** (`file`) --->  `string` \n\n#### Result: \nthe Coordinate Reference System (CRS) of the GIS file\n\n#### Examples: \n```\nstring var0 <- crs(my_shapefile); \t// var0 equals the crs of the shapefile\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_CRS_transform)\n### `CRS_transform`\n\n#### Possible use: \n  *  **`CRS_transform`** (`geometry`) --->  `geometry`\n  * `geometry` **`CRS_transform`** `string` --->  `geometry`\n  *  **`CRS_transform`** (`geometry` , `string`) --->  `geometry`\n\n#### Special cases:     \n  * returns the geometry corresponding to the transformation of the given geometry by the left operand CRS (Coordinate Reference System) \n  \n```\ngeometry var0 <- shape CRS_transform(\"EPSG:4326\"); \t// var0 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS\n\n``` \n\n    \n  * returns the geometry corresponding to the transformation of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world's agent one \n  \n```\ngeometry var1 <- CRS_transform(shape); \t// var1 equals a geometry corresponding to the agent geometry transformed into the current CRS\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_csv_file)\n### `csv_file`\n\n#### Possible use: \n  *  **`csv_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type csv. Allowed extensions are limited to csv, tsv\n    \t\n----\n\n[//]: # (keyword|operator_cube)\n### `cube`\n\n#### Possible use: \n  *  **`cube`** (`float`) --->  `geometry` \n\n#### Result: \nA cube geometry which side size is equal to the operand.  \n\n#### Comment: \nthe center of the cube is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- cube(10); \t// var0 equals a geometry as a square of side size 10.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_curve)\n### `curve`\n\n#### Possible use: \n  *  **`curve`** (`point`, `point`, `point`) --->  `geometry`\n  *  **`curve`** (`point`, `point`, `point`, `int`) --->  `geometry`\n  *  **`curve`** (`point`, `point`, `point`, `point`) --->  `geometry`\n  *  **`curve`** (`point`, `point`, `point`, `point`, `int`) --->  `geometry` \n\n#### Result: \nA quadratic Bezier curve geometry built from the three given points composed of a given numnber of points.\nA quadratic Bezier curve geometry built from the three given points composed of 10 points.\nA cubic Bezier curve geometry built from the four given points composed of a given number of points.\nA cubic Bezier curve geometry built from the four given points composed of 10 points.\n\n#### Special cases:     \n  * if the operand is nil, returns nil    \n  * if the last operand (number of points) is inferior to 2, returns nil    \n  * if the operand is nil, returns nil    \n  * if the operand is nil, returns nil    \n  * if the last operand (number of points) is inferior to 2, returns nil    \n  * if the operand is nil, returns nil\n\n#### Examples: \n```\ngeometry var0 <- curve({0,0}, {0,10}, {10,10}, 20); \t// var0 equals a quadratic Bezier curve geometry composed of 20 points from p0 to p2.\ngeometry var1 <- curve({0,0}, {0,10}, {10,10}); \t// var1 equals a quadratic Bezier curve geometry composed of 10 points from p0 to p2.\ngeometry var2 <- curve({0,0}, {0,10}, {10,10}); \t// var2 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.\ngeometry var3 <- curve({0,0}, {0,10}, {10,10}); \t// var3 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygone](OperatorsNZ#polygone), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), [line](OperatorsDM#line), \n    \t\n----\n\n[//]: # (keyword|operator_cylinder)\n### `cylinder`\n\n#### Possible use: \n  * `float` **`cylinder`** `float` --->  `geometry`\n  *  **`cylinder`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nA cylinder geometry which radius is equal to the operand.  \n\n#### Comment: \nthe center of the cylinder is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- cylinder(10,10); \t// var0 equals a geometry as a circle of radius 10.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_IDW)\n### `IDW`\n\n#### Possible use: \n  *  **`IDW`** (`container<agent>`, `map<point,float>`, `int`) --->  `map<agent,float>` \n\n#### Result: \nInverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter)\n\n#### Examples: \n```\nmap<agent,float> var0 <- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2); \t// var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_R_correlation)\n### `R_correlation`\nSame signification as [corR](OperatorsAC#corR)\n    \t\n----\n\n[//]: # (keyword|operator_R_file)\n### `R_file`\n\n#### Possible use: \n  *  **`R_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type R. Allowed extensions are limited to r\n    \t\n----\n\n[//]: # (keyword|operator_R_mean)\n### `R_mean`\nSame signification as [meanR](OperatorsDM#meanR)\n    \t\n----\n\n[//]: # (keyword|operator_TGauss)\n### `TGauss`\nSame signification as [truncated_gauss](OperatorsNZ#truncated_gauss)\n    \t\n----\n\n[//]: # (keyword|operator_URL_file)\n### `URL_file`\n\n#### Possible use: \n  *  **`URL_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type URL. Allowed extensions are limited to url","url":"wiki/OperatorsAC.md"},"OperatorsDM.md":{"title":" Operators (D to M)","content":"#Operators (D to M)\n \t\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Definition \n\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. \n\nMost of them use a classical prefixed functional syntax (i.e. `operator_name(operand1, operand2, operand3)`, see below), with the exception of arithmetic (e.g. `+`, `/`), logical (`and`, `or`), comparison (e.g. `>`, `<`), access (`.`, `[..]`) and pair (`::`) operators, which require an infixed notation (i.e. `operand1 operator_symbol operand1`). \n\nThe ternary functional if-else operator, `? :`, uses a special infixed syntax composed with two symbols (e.g. `operand1 ? operand2 : operand3`). Two unary operators (`-` and `!`) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10`, `! (operand1 or operand2)`). \n\nFinally, special constructor operators (`{...}` for constructing points, `[...]` for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. `{1,2,3}`, `[operand1, operand2, ..., operandn]` or `[key1::value1, key2::value2... keyn::valuen]`).\n\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n* if they only have one operand, the functional prefixed syntax is mandatory (e.g. `operator_name(operand1)`)\n* if they have two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2)`) or the infixed syntax (e.g. `operand1 operator_name operand2`) can be used.\n* if they have more than two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2, ..., operand)`) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. `operand1 operator_name(operand2, ..., operand)`) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\n\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the `shuffle` operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\n<br/>\n----\n\n## Priority between operators\n\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\n\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n* the constructor operators, like `::`, used to compose pairs of operands, have the lowest priority of all operators (e.g. `a > b :: b > c` will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, `[a > 10, b > 5]` will return a list of boolean values.\n* it is followed by the `?:` operator, the functional if-else (e.g. ` a > b ? a + 10 : a - 10` will return the result of the if-else).\n* next are the logical operators, `and` and `or` (e.g. `a > b or b > c` will return the value of the test)\n* next are the comparison operators (i.e. `>`, `<`, `<=`, `>=`, `=`, `!=`)\n* next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\n* next the unary operators `-` and `!`\n* next the access operators `.` and `[]` (e.g. `{1,2,3}.x > 20 + {4,5,6}.y` will return the result of the comparison between the x and y ordinates of the two points)\n* and finally the functional operators, which have the highest priority of all.\n\n----\n\n## Using actions as operators\n\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\n\nFor instance, if the following species is defined:\n\n```\nspecies spec1 {\n        int min(int x, int y) {\n                return x > y ? x : y;\n        }\n}\n```\n\nAny agent instance of spec1 can use `min` as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\n\n```\nglobal {\n        init {\n                create spec1;\n                spec1 my_agent <- spec1[0];\n                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);\n        }\n}\n```\n\nIf the action doesn't have any operands, the syntax to use is `my_agent the_action()`. Finally, if it does not return a value, it might still be used but is considering as returning a value of type `unknown` (e.g. `unknown result <- my_agent the_action(op1, op2);`).\n\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\n\t\n\n----\n\n## Table of Contents\n\n----\n\n## Operators by categories\n\t\n\n----\n\n### 3D\n[box](OperatorsAC#box), [cone3D](OperatorsAC#cone3d), [cube](OperatorsAC#cube), [cylinder](OperatorsAC#cylinder), [dem](OperatorsDM#dem), [hexagon](OperatorsDM#hexagon), [pyramid](OperatorsNZ#pyramid), [rgb_to_xyz](OperatorsNZ#rgb_to_xyz), [set_z](OperatorsNZ#set_z), [sphere](OperatorsNZ#sphere), [teapot](OperatorsNZ#teapot), \n\n----\n\n### Arithmetic operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [^](OperatorsAC#^), [*](OperatorsAC#*), [+](OperatorsAC#+), [abs](OperatorsAC#abs), [acos](OperatorsAC#acos), [asin](OperatorsAC#asin), [atan](OperatorsAC#atan), [atan2](OperatorsAC#atan2), [ceil](OperatorsAC#ceil), [cos](OperatorsAC#cos), [cos_rad](OperatorsAC#cos_rad), [div](OperatorsDM#div), [even](OperatorsDM#even), [exp](OperatorsDM#exp), [fact](OperatorsDM#fact), [floor](OperatorsDM#floor), [hypot](OperatorsDM#hypot), [is_finite](OperatorsDM#is_finite), [is_number](OperatorsDM#is_number), [ln](OperatorsDM#ln), [log](OperatorsDM#log), [mod](OperatorsDM#mod), [round](OperatorsNZ#round), [signum](OperatorsNZ#signum), [sin](OperatorsNZ#sin), [sin_rad](OperatorsNZ#sin_rad), [sqrt](OperatorsNZ#sqrt), [tan](OperatorsNZ#tan), [tan_rad](OperatorsNZ#tan_rad), [tanh](OperatorsNZ#tanh), [with_precision](OperatorsNZ#with_precision), \n\n----\n\n### BDI\n[and](OperatorsAC#and), [eval_when](OperatorsDM#eval_when), [get_about](OperatorsDM#get_about), [get_agent](OperatorsDM#get_agent), [get_agent_cause](OperatorsDM#get_agent_cause), [get_decay](OperatorsDM#get_decay), [get_dominance](OperatorsDM#get_dominance), [get_familiarity](OperatorsDM#get_familiarity), [get_intensity](OperatorsDM#get_intensity), [get_lifetime](OperatorsDM#get_lifetime), [get_liking](OperatorsDM#get_liking), [get_praiseworthiness](OperatorsDM#get_praiseworthiness), [get_priority](OperatorsDM#get_priority), [get_solidarity](OperatorsDM#get_solidarity), [get_super_intention](OperatorsDM#get_super_intention), [new_emotion](OperatorsNZ#new_emotion), [new_predicate](OperatorsNZ#new_predicate), [new_social_link](OperatorsNZ#new_social_link), [or](OperatorsNZ#or), [set_about](OperatorsNZ#set_about), [set_agent](OperatorsNZ#set_agent), [set_agent_cause](OperatorsNZ#set_agent_cause), [set_decay](OperatorsNZ#set_decay), [set_dominance](OperatorsNZ#set_dominance), [set_familiarity](OperatorsNZ#set_familiarity), [set_intensity](OperatorsNZ#set_intensity), [set_liking](OperatorsNZ#set_liking), [set_solidarity](OperatorsNZ#set_solidarity), [set_truth](OperatorsNZ#set_truth), [with_lifetime](OperatorsNZ#with_lifetime), [with_praiseworthiness](OperatorsNZ#with_praiseworthiness), [with_priority](OperatorsNZ#with_priority), [with_values](OperatorsNZ#with_values), \n\n----\n\n### Casting operators\n[as](OperatorsAC#as), [as_int](OperatorsAC#as_int), [as_matrix](OperatorsAC#as_matrix), [font](OperatorsDM#font), [is](OperatorsDM#is), [is_skill](OperatorsDM#is_skill), [list_with](OperatorsDM#list_with), [matrix_with](OperatorsDM#matrix_with), [species](OperatorsNZ#species), [to_gaml](OperatorsNZ#to_gaml), [topology](OperatorsNZ#topology), \n\n----\n\n### Color-related operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [*](OperatorsAC#*), [+](OperatorsAC#+), [blend](OperatorsAC#blend), [brewer_colors](OperatorsAC#brewer_colors), [brewer_palettes](OperatorsAC#brewer_palettes), [grayscale](OperatorsDM#grayscale), [hsb](OperatorsDM#hsb), [mean](OperatorsDM#mean), [median](OperatorsDM#median), [rgb](OperatorsNZ#rgb), [rnd_color](OperatorsNZ#rnd_color), [sum](OperatorsNZ#sum), \n\n----\n\n### Comparison operators\n[!=](OperatorsAC#!=), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [between](OperatorsAC#between), \n\n----\n\n### Containers-related operators\n[-](OperatorsAC#-), [::](OperatorsAC#::), [+](OperatorsAC#+), [accumulate](OperatorsAC#accumulate), [among](OperatorsAC#among), [at](OperatorsAC#at), [collect](OperatorsAC#collect), [contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), [count](OperatorsAC#count), [distinct](OperatorsDM#distinct), [empty](OperatorsDM#empty), [every](OperatorsDM#every), [first](OperatorsDM#first), [first_with](OperatorsDM#first_with), [get](OperatorsDM#get), [group_by](OperatorsDM#group_by), [in](OperatorsDM#in), [index_by](OperatorsDM#index_by), [inter](OperatorsDM#inter), [interleave](OperatorsDM#interleave), [internal_at](OperatorsDM#internal_at), [internal_integrated_value](OperatorsDM#internal_integrated_value), [last](OperatorsDM#last), [last_with](OperatorsDM#last_with), [length](OperatorsDM#length), [max](OperatorsDM#max), [max_of](OperatorsDM#max_of), [mean](OperatorsDM#mean), [mean_of](OperatorsDM#mean_of), [median](OperatorsDM#median), [min](OperatorsDM#min), [min_of](OperatorsDM#min_of), [mul](OperatorsDM#mul), [one_of](OperatorsNZ#one_of), [product_of](OperatorsNZ#product_of), [range](OperatorsNZ#range), [reverse](OperatorsNZ#reverse), [shuffle](OperatorsNZ#shuffle), [sort_by](OperatorsNZ#sort_by), [sum](OperatorsNZ#sum), [sum_of](OperatorsNZ#sum_of), [union](OperatorsNZ#union), [variance_of](OperatorsNZ#variance_of), [where](OperatorsNZ#where), [with_max_of](OperatorsNZ#with_max_of), [with_min_of](OperatorsNZ#with_min_of), \n\n----\n\n### Date-related operators\n[-](OperatorsAC#-), [!=](OperatorsAC#!=), [+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [after](OperatorsAC#after), [before](OperatorsAC#before), [between](OperatorsAC#between), [every](OperatorsDM#every), [milliseconds_between](OperatorsDM#milliseconds_between), [minus_days](OperatorsDM#minus_days), [minus_hours](OperatorsDM#minus_hours), [minus_minutes](OperatorsDM#minus_minutes), [minus_months](OperatorsDM#minus_months), [minus_ms](OperatorsDM#minus_ms), [minus_weeks](OperatorsDM#minus_weeks), [minus_years](OperatorsDM#minus_years), [months_between](OperatorsDM#months_between), [plus_days](OperatorsNZ#plus_days), [plus_hours](OperatorsNZ#plus_hours), [plus_minutes](OperatorsNZ#plus_minutes), [plus_months](OperatorsNZ#plus_months), [plus_ms](OperatorsNZ#plus_ms), [plus_weeks](OperatorsNZ#plus_weeks), [plus_years](OperatorsNZ#plus_years), [since](OperatorsNZ#since), [to](OperatorsNZ#to), [until](OperatorsNZ#until), [years_between](OperatorsNZ#years_between), \n\n----\n\n### Dates\n\n\n----\n\n### Driving operators\n[as_driving_graph](OperatorsAC#as_driving_graph), \n\n----\n\n### edge\n[edge_between](OperatorsDM#edge_between), \n\n----\n\n### EDP-related operators\n[diff](OperatorsDM#diff), [diff2](OperatorsDM#diff2), [internal_zero_order_equation](OperatorsDM#internal_zero_order_equation), \n\n----\n\n### Files-related operators\n[crs](OperatorsAC#crs), [file](OperatorsDM#file), [file_exists](OperatorsDM#file_exists), [folder](OperatorsDM#folder), [get](OperatorsDM#get), [new_folder](OperatorsNZ#new_folder), [osm_file](OperatorsNZ#osm_file), [read](OperatorsNZ#read), [writable](OperatorsNZ#writable), \n\n----\n\n### FIPA-related operators\n[conversation](OperatorsAC#conversation), [message](OperatorsDM#message), \n\n----\n\n### Graphs-related operators\n[add_edge](OperatorsAC#add_edge), [add_node](OperatorsAC#add_node), [adjacency](OperatorsAC#adjacency), [agent_from_geometry](OperatorsAC#agent_from_geometry), [all_pairs_shortest_path](OperatorsAC#all_pairs_shortest_path), [alpha_index](OperatorsAC#alpha_index), [as_distance_graph](OperatorsAC#as_distance_graph), [as_edge_graph](OperatorsAC#as_edge_graph), [as_intersection_graph](OperatorsAC#as_intersection_graph), [as_path](OperatorsAC#as_path), [beta_index](OperatorsAC#beta_index), [betweenness_centrality](OperatorsAC#betweenness_centrality), [biggest_cliques_of](OperatorsAC#biggest_cliques_of), [connected_components_of](OperatorsAC#connected_components_of), [connectivity_index](OperatorsAC#connectivity_index), [contains_edge](OperatorsAC#contains_edge), [contains_vertex](OperatorsAC#contains_vertex), [degree_of](OperatorsDM#degree_of), [directed](OperatorsDM#directed), [edge](OperatorsDM#edge), [edge_between](OperatorsDM#edge_between), [edge_betweenness](OperatorsDM#edge_betweenness), [edges](OperatorsDM#edges), [gamma_index](OperatorsDM#gamma_index), [generate_barabasi_albert](OperatorsDM#generate_barabasi_albert), [generate_complete_graph](OperatorsDM#generate_complete_graph), [generate_watts_strogatz](OperatorsDM#generate_watts_strogatz), [grid_cells_to_graph](OperatorsDM#grid_cells_to_graph), [in_degree_of](OperatorsDM#in_degree_of), [in_edges_of](OperatorsDM#in_edges_of), [layout](OperatorsDM#layout), [load_graph_from_file](OperatorsDM#load_graph_from_file), [load_shortest_paths](OperatorsDM#load_shortest_paths), [maximal_cliques_of](OperatorsDM#maximal_cliques_of), [nb_cycles](OperatorsNZ#nb_cycles), [neighbors_of](OperatorsNZ#neighbors_of), [node](OperatorsNZ#node), [nodes](OperatorsNZ#nodes), [out_degree_of](OperatorsNZ#out_degree_of), [out_edges_of](OperatorsNZ#out_edges_of), [path_between](OperatorsNZ#path_between), [paths_between](OperatorsNZ#paths_between), [predecessors_of](OperatorsNZ#predecessors_of), [remove_node_from](OperatorsNZ#remove_node_from), [rewire_n](OperatorsNZ#rewire_n), [source_of](OperatorsNZ#source_of), [spatial_graph](OperatorsNZ#spatial_graph), [successors_of](OperatorsNZ#successors_of), [sum](OperatorsNZ#sum), [target_of](OperatorsNZ#target_of), [undirected](OperatorsNZ#undirected), [use_cache](OperatorsNZ#use_cache), [weight_of](OperatorsNZ#weight_of), [with_optimizer_type](OperatorsNZ#with_optimizer_type), [with_weights](OperatorsNZ#with_weights), \n\n----\n\n### Grid-related operators\n[as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [grid_at](OperatorsDM#grid_at), [path_between](OperatorsNZ#path_between), \n\n----\n\n### Iterator operators\n[accumulate](OperatorsAC#accumulate), [as_map](OperatorsAC#as_map), [collect](OperatorsAC#collect), [count](OperatorsAC#count), [distribution_of](OperatorsDM#distribution_of), [distribution_of](OperatorsDM#distribution_of), [distribution_of](OperatorsDM#distribution_of), [distribution2d_of](OperatorsDM#distribution2d_of), [distribution2d_of](OperatorsDM#distribution2d_of), [distribution2d_of](OperatorsDM#distribution2d_of), [first_with](OperatorsDM#first_with), [frequency_of](OperatorsDM#frequency_of), [group_by](OperatorsDM#group_by), [index_by](OperatorsDM#index_by), [last_with](OperatorsDM#last_with), [max_of](OperatorsDM#max_of), [mean_of](OperatorsDM#mean_of), [min_of](OperatorsDM#min_of), [product_of](OperatorsNZ#product_of), [sort_by](OperatorsNZ#sort_by), [sum_of](OperatorsNZ#sum_of), [variance_of](OperatorsNZ#variance_of), [where](OperatorsNZ#where), [with_max_of](OperatorsNZ#with_max_of), [with_min_of](OperatorsNZ#with_min_of), \n\n----\n\n### List-related operators\n[copy_between](OperatorsAC#copy_between), [index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), \n\n----\n\n### Logical operators\n[:](OperatorsAC#:), [!](OperatorsAC#!), [?](OperatorsAC#?), [and](OperatorsAC#and), [or](OperatorsNZ#or), \n\n----\n\n### Map comparaison operators\n[fuzzy_kappa](OperatorsDM#fuzzy_kappa), [fuzzy_kappa_sim](OperatorsDM#fuzzy_kappa_sim), [kappa](OperatorsDM#kappa), [kappa_sim](OperatorsDM#kappa_sim), [percent_absolute_deviation](OperatorsNZ#percent_absolute_deviation), \n\n----\n\n### Map-related operators\n[as_map](OperatorsAC#as_map), [index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), \n\n----\n\n### Material\n[material](OperatorsDM#material), \n\n----\n\n### Matrix-related operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [.](OperatorsAC#.), [*](OperatorsAC#*), [+](OperatorsAC#+), [append_horizontally](OperatorsAC#append_horizontally), [append_vertically](OperatorsAC#append_vertically), [column_at](OperatorsAC#column_at), [columns_list](OperatorsAC#columns_list), [determinant](OperatorsDM#determinant), [eigenvalues](OperatorsDM#eigenvalues), [index_of](OperatorsDM#index_of), [inverse](OperatorsDM#inverse), [last_index_of](OperatorsDM#last_index_of), [row_at](OperatorsNZ#row_at), [rows_list](OperatorsNZ#rows_list), [shuffle](OperatorsNZ#shuffle), [trace](OperatorsNZ#trace), [transpose](OperatorsNZ#transpose), \n\n----\n\n### multicriteria operators\n[electre_DM](OperatorsDM#electre_dm), [evidence_theory_DM](OperatorsDM#evidence_theory_dm), [promethee_DM](OperatorsNZ#promethee_dm), [weighted_means_DM](OperatorsNZ#weighted_means_dm), \n\n----\n\n### Path-related operators\n[agent_from_geometry](OperatorsAC#agent_from_geometry), [all_pairs_shortest_path](OperatorsAC#all_pairs_shortest_path), [as_path](OperatorsAC#as_path), [load_shortest_paths](OperatorsDM#load_shortest_paths), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [paths_between](OperatorsNZ#paths_between), [use_cache](OperatorsNZ#use_cache), \n\n----\n\n### Points-related operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [*](OperatorsAC#*), [+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [add_point](OperatorsAC#add_point), [angle_between](OperatorsAC#angle_between), [any_location_in](OperatorsAC#any_location_in), [centroid](OperatorsAC#centroid), [closest_points_with](OperatorsAC#closest_points_with), [farthest_point_to](OperatorsDM#farthest_point_to), [grid_at](OperatorsDM#grid_at), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [points_along](OperatorsNZ#points_along), [points_at](OperatorsNZ#points_at), [points_on](OperatorsNZ#points_on), \n\n----\n\n### Random operators\n[binomial](OperatorsAC#binomial), [flip](OperatorsDM#flip), [gauss](OperatorsDM#gauss), [poisson](OperatorsNZ#poisson), [rnd](OperatorsNZ#rnd), [rnd_choice](OperatorsNZ#rnd_choice), [sample](OperatorsNZ#sample), [shuffle](OperatorsNZ#shuffle), [skew_gauss](OperatorsNZ#skew_gauss), [truncated_gauss](OperatorsNZ#truncated_gauss), \n\n----\n\n### ReverseOperators\n\n\n----\n\n### Shape\n[arc](OperatorsAC#arc), [box](OperatorsAC#box), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [cone3D](OperatorsAC#cone3d), [cross](OperatorsAC#cross), [cube](OperatorsAC#cube), [curve](OperatorsAC#curve), [cylinder](OperatorsAC#cylinder), [ellipse](OperatorsDM#ellipse), [envelope](OperatorsDM#envelope), [geometry_collection](OperatorsDM#geometry_collection), [hexagon](OperatorsDM#hexagon), [line](OperatorsDM#line), [link](OperatorsDM#link), [plan](OperatorsNZ#plan), [polygon](OperatorsNZ#polygon), [polyhedron](OperatorsNZ#polyhedron), [pyramid](OperatorsNZ#pyramid), [rectangle](OperatorsNZ#rectangle), [sphere](OperatorsNZ#sphere), [square](OperatorsNZ#square), [squircle](OperatorsNZ#squircle), [teapot](OperatorsNZ#teapot), [triangle](OperatorsNZ#triangle), \n\n----\n\n### Spatial operators\n[-](OperatorsAC#-), [*](OperatorsAC#*), [+](OperatorsAC#+), [add_point](OperatorsAC#add_point), [agent_closest_to](OperatorsAC#agent_closest_to), [agent_farthest_to](OperatorsAC#agent_farthest_to), [agents_at_distance](OperatorsAC#agents_at_distance), [agents_inside](OperatorsAC#agents_inside), [agents_overlapping](OperatorsAC#agents_overlapping), [angle_between](OperatorsAC#angle_between), [any_location_in](OperatorsAC#any_location_in), [arc](OperatorsAC#arc), [around](OperatorsAC#around), [as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [at_distance](OperatorsAC#at_distance), [at_location](OperatorsAC#at_location), [box](OperatorsAC#box), [centroid](OperatorsAC#centroid), [circle](OperatorsAC#circle), [clean](OperatorsAC#clean), [closest_points_with](OperatorsAC#closest_points_with), [closest_to](OperatorsAC#closest_to), [cone](OperatorsAC#cone), [cone3D](OperatorsAC#cone3d), [convex_hull](OperatorsAC#convex_hull), [covers](OperatorsAC#covers), [cross](OperatorsAC#cross), [crosses](OperatorsAC#crosses), [crs](OperatorsAC#crs), [CRS_transform](OperatorsAC#crs_transform), [cube](OperatorsAC#cube), [curve](OperatorsAC#curve), [cylinder](OperatorsAC#cylinder), [dem](OperatorsDM#dem), [direction_between](OperatorsDM#direction_between), [disjoint_from](OperatorsDM#disjoint_from), [distance_between](OperatorsDM#distance_between), [distance_to](OperatorsDM#distance_to), [ellipse](OperatorsDM#ellipse), [envelope](OperatorsDM#envelope), [farthest_point_to](OperatorsDM#farthest_point_to), [farthest_to](OperatorsDM#farthest_to), [geometry_collection](OperatorsDM#geometry_collection), [gini](OperatorsDM#gini), [hexagon](OperatorsDM#hexagon), [hierarchical_clustering](OperatorsDM#hierarchical_clustering), [IDW](OperatorsAC#idw), [inside](OperatorsDM#inside), [inter](OperatorsDM#inter), [intersects](OperatorsDM#intersects), [line](OperatorsDM#line), [link](OperatorsDM#link), [masked_by](OperatorsDM#masked_by), [moran](OperatorsDM#moran), [neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [overlapping](OperatorsNZ#overlapping), [overlaps](OperatorsNZ#overlaps), [partially_overlaps](OperatorsNZ#partially_overlaps), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [plan](OperatorsNZ#plan), [points_along](OperatorsNZ#points_along), [points_at](OperatorsNZ#points_at), [points_on](OperatorsNZ#points_on), [polygon](OperatorsNZ#polygon), [polyhedron](OperatorsNZ#polyhedron), [pyramid](OperatorsNZ#pyramid), [rectangle](OperatorsNZ#rectangle), [rgb_to_xyz](OperatorsNZ#rgb_to_xyz), [rotated_by](OperatorsNZ#rotated_by), [round](OperatorsNZ#round), [scaled_to](OperatorsNZ#scaled_to), [set_z](OperatorsNZ#set_z), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), [simplification](OperatorsNZ#simplification), [skeletonize](OperatorsNZ#skeletonize), [smooth](OperatorsNZ#smooth), [sphere](OperatorsNZ#sphere), [split_at](OperatorsNZ#split_at), [split_geometry](OperatorsNZ#split_geometry), [split_lines](OperatorsNZ#split_lines), [square](OperatorsNZ#square), [squircle](OperatorsNZ#squircle), [teapot](OperatorsNZ#teapot), [to_GAMA_CRS](OperatorsNZ#to_gama_crs), [to_rectangles](OperatorsNZ#to_rectangles), [to_squares](OperatorsNZ#to_squares), [touches](OperatorsNZ#touches), [towards](OperatorsNZ#towards), [transformed_by](OperatorsNZ#transformed_by), [translated_by](OperatorsNZ#translated_by), [triangle](OperatorsNZ#triangle), [triangulate](OperatorsNZ#triangulate), [union](OperatorsNZ#union), [using](OperatorsNZ#using), [voronoi](OperatorsNZ#voronoi), [with_precision](OperatorsNZ#with_precision), [without_holes](OperatorsNZ#without_holes), \n\n----\n\n### Spatial properties operators\n[covers](OperatorsAC#covers), [crosses](OperatorsAC#crosses), [intersects](OperatorsDM#intersects), [partially_overlaps](OperatorsNZ#partially_overlaps), [touches](OperatorsNZ#touches), \n\n----\n\n### Spatial queries operators\n[agent_closest_to](OperatorsAC#agent_closest_to), [agent_farthest_to](OperatorsAC#agent_farthest_to), [agents_at_distance](OperatorsAC#agents_at_distance), [agents_inside](OperatorsAC#agents_inside), [agents_overlapping](OperatorsAC#agents_overlapping), [at_distance](OperatorsAC#at_distance), [closest_to](OperatorsAC#closest_to), [farthest_to](OperatorsDM#farthest_to), [inside](OperatorsDM#inside), [neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [overlapping](OperatorsNZ#overlapping), \n\n----\n\n### Spatial relations operators\n[direction_between](OperatorsDM#direction_between), [distance_between](OperatorsDM#distance_between), [distance_to](OperatorsDM#distance_to), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [towards](OperatorsNZ#towards), \n\n----\n\n### Spatial statistical operators\n[hierarchical_clustering](OperatorsDM#hierarchical_clustering), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), \n\n----\n\n### Spatial transformations operators\n[-](OperatorsAC#-), [*](OperatorsAC#*), [+](OperatorsAC#+), [as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [at_location](OperatorsAC#at_location), [clean](OperatorsAC#clean), [convex_hull](OperatorsAC#convex_hull), [CRS_transform](OperatorsAC#crs_transform), [rotated_by](OperatorsNZ#rotated_by), [scaled_to](OperatorsNZ#scaled_to), [simplification](OperatorsNZ#simplification), [skeletonize](OperatorsNZ#skeletonize), [smooth](OperatorsNZ#smooth), [split_geometry](OperatorsNZ#split_geometry), [split_lines](OperatorsNZ#split_lines), [to_GAMA_CRS](OperatorsNZ#to_gama_crs), [to_rectangles](OperatorsNZ#to_rectangles), [to_squares](OperatorsNZ#to_squares), [transformed_by](OperatorsNZ#transformed_by), [translated_by](OperatorsNZ#translated_by), [triangulate](OperatorsNZ#triangulate), [voronoi](OperatorsNZ#voronoi), [without_holes](OperatorsNZ#without_holes), \n\n----\n\n### Species-related operators\n[index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), [of_generic_species](OperatorsNZ#of_generic_species), [of_species](OperatorsNZ#of_species), \n\n----\n\n### Statistical operators\n[build](OperatorsAC#build), [corR](OperatorsAC#corr), [dbscan](OperatorsDM#dbscan), [distribution_of](OperatorsDM#distribution_of), [distribution2d_of](OperatorsDM#distribution2d_of), [frequency_of](OperatorsDM#frequency_of), [gamma_rnd](OperatorsDM#gamma_rnd), [geometric_mean](OperatorsDM#geometric_mean), [gini](OperatorsDM#gini), [harmonic_mean](OperatorsDM#harmonic_mean), [hierarchical_clustering](OperatorsDM#hierarchical_clustering), [kmeans](OperatorsDM#kmeans), [kurtosis](OperatorsDM#kurtosis), [max](OperatorsDM#max), [mean](OperatorsDM#mean), [mean_deviation](OperatorsDM#mean_deviation), [meanR](OperatorsDM#meanr), [median](OperatorsDM#median), [min](OperatorsDM#min), [moran](OperatorsDM#moran), [mul](OperatorsDM#mul), [predict](OperatorsNZ#predict), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), [skewness](OperatorsNZ#skewness), [standard_deviation](OperatorsNZ#standard_deviation), [sum](OperatorsNZ#sum), [variance](OperatorsNZ#variance), \n\n----\n\n### Strings-related operators\n[+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [at](OperatorsAC#at), [char](OperatorsAC#char), [contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), [copy_between](OperatorsAC#copy_between), [date](OperatorsDM#date), [empty](OperatorsDM#empty), [first](OperatorsDM#first), [in](OperatorsDM#in), [indented_by](OperatorsDM#indented_by), [index_of](OperatorsDM#index_of), [is_number](OperatorsDM#is_number), [last](OperatorsDM#last), [last_index_of](OperatorsDM#last_index_of), [length](OperatorsDM#length), [lower_case](OperatorsDM#lower_case), [replace](OperatorsNZ#replace), [replace_regex](OperatorsNZ#replace_regex), [reverse](OperatorsNZ#reverse), [sample](OperatorsNZ#sample), [shuffle](OperatorsNZ#shuffle), [split_with](OperatorsNZ#split_with), [string](OperatorsNZ#string), [upper_case](OperatorsNZ#upper_case), \n\n----\n\n### System\n[.](OperatorsAC#.), [command](OperatorsAC#command), [copy](OperatorsAC#copy), [dead](OperatorsDM#dead), [eval_gaml](OperatorsDM#eval_gaml), [every](OperatorsDM#every), [user_input](OperatorsNZ#user_input), \n\n----\n\n### Time-related operators\n[date](OperatorsDM#date), [string](OperatorsNZ#string), \n\n----\n\n### Types-related operators\n\n\n----\n\n### User control operators\n[user_input](OperatorsNZ#user_input), \n\t\n----\n\n## Operators\n\t\n    \t\n----\n\n[//]: # (keyword|operator_date)\n### `date`\n\n#### Possible use: \n  * `string` **`date`** `string` --->  `date`\n  *  **`date`** (`string` , `string`) --->  `date` \n\n#### Result: \nconverts a string to a date following a custom pattern. The pattern can use \"%Y %M %N %D %E %h %m %s %z\" for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will parse the date using one of the ISO date & time formats (similar to date('...') in that case). The pattern can also follow the pattern definition found here, which gives much more control over what will be parsed: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constant: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences\n\n#### Examples: \n```\ndate(\"1999-12-30\", 'yyyy-MM-dd')\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_dbscan)\n### `dbscan`\n\n#### Possible use: \n  *  **`dbscan`** (`list`, `float`, `int`) --->  `list<list>` \n\n#### Result: \nreturns the list of clusters (list of instance indices) computed with the dbscan (density-based spatial clustering of applications with noise) algorithm from the first operand data according to the maximum radius of the neighborhood to be considered (eps) and the minimum number of points needed for a cluster (minPts). Usage: dbscan(data,eps,minPoints)\n\n#### Special cases:     \n  * if the lengths of two vectors in the right-hand aren't equal, returns 0\n\n#### Examples: \n```\ndbscan ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],10,2)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_dead)\n### `dead`\n\n#### Possible use: \n  *  **`dead`** (`agent`) --->  `bool` \n\n#### Result: \ntrue if the agent is dead (or null), false otherwise.\n\n#### Examples: \n```\nbool var0 <- dead(agent_A); \t// var0 equals true or false\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_degree_of)\n### `degree_of`\n\n#### Possible use: \n  * `graph` **`degree_of`** `unknown` --->  `int`\n  *  **`degree_of`** (`graph` , `unknown`) --->  `int` \n\n#### Result: \nreturns the degree (in+out) of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\nint var1 <- graphFromMap degree_of (node(3)); \t// var1 equals 3\n```\n      \n\n#### See also: \n[in_degree_of](OperatorsDM#in_degree_of), [out_degree_of](OperatorsNZ#out_degree_of), \n    \t\n----\n\n[//]: # (keyword|operator_dem)\n### `dem`\n\n#### Possible use: \n  *  **`dem`** (`file`) --->  `geometry`\n  * `file` **`dem`** `file` --->  `geometry`\n  *  **`dem`** (`file` , `file`) --->  `geometry`\n  * `file` **`dem`** `float` --->  `geometry`\n  *  **`dem`** (`file` , `float`) --->  `geometry`\n  *  **`dem`** (`file`, `file`, `float`) --->  `geometry` \n\n#### Result: \nA polygon that is equivalent to the surface of the texture\n\n#### Examples: \n```\ngeometry var0 <- dem(dem,texture,z_factor); \t// var0 equals a geometry as a rectangle of width and height equal to the texture.\ngeometry var1 <- dem(dem,texture); \t// var1 equals a geometry as a rectangle of weight and height equal to the texture.\ngeometry var2 <- dem(dem,z_factor); \t// var2 equals a geometry as a rectangle of weight and height equal to the texture.\ngeometry var3 <- dem(dem); \t// var3 equals returns a geometry as a rectangle of width and height equal to the texture.\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_det)\n### `det`\nSame signification as [determinant](OperatorsDM#determinant)\n    \t\n----\n\n[//]: # (keyword|operator_determinant)\n### `determinant`\n\n#### Possible use: \n  *  **`determinant`** (`matrix`) --->  `float` \n\n#### Result: \nThe determinant of the given matrix\n\n#### Examples: \n```\nfloat var0 <- determinant(matrix([[1,2],[3,4]])); \t// var0 equals -2\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_diff)\n### `diff`\n\n#### Possible use: \n  * `float` **`diff`** `float` --->  `float`\n  *  **`diff`** (`float` , `float`) --->  `float`\n    \t\n----\n\n[//]: # (keyword|operator_diff2)\n### `diff2`\n\n#### Possible use: \n  * `float` **`diff2`** `float` --->  `float`\n  *  **`diff2`** (`float` , `float`) --->  `float`\n    \t\n----\n\n[//]: # (keyword|operator_directed)\n### `directed`\n\n#### Possible use: \n  *  **`directed`** (`graph`) --->  `graph` \n\n#### Result: \nthe operand graph becomes a directed graph.  \n\n#### Comment: \nthe operator alters the operand graph, it does not create a new one.    \n\n#### See also: \n[undirected](OperatorsNZ#undirected), \n    \t\n----\n\n[//]: # (keyword|operator_direction_between)\n### `direction_between`\n\n#### Possible use: \n  * `topology` **`direction_between`** `container<geometry>` --->  `int`\n  *  **`direction_between`** (`topology` , `container<geometry>`) --->  `int` \n\n#### Result: \nA direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.\n\n#### Examples: \n```\nint var0 <- my_topology direction_between [ag1, ag2]; \t// var0 equals the direction between ag1 and ag2 considering the topology my_topology\n```\n      \n\n#### See also: \n[towards](OperatorsNZ#towards), [direction_to](OperatorsDM#direction_to), [distance_to](OperatorsDM#distance_to), [distance_between](OperatorsDM#distance_between), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), \n    \t\n----\n\n[//]: # (keyword|operator_direction_to)\n### `direction_to`\nSame signification as [towards](OperatorsNZ#towards)\n    \t\n----\n\n[//]: # (keyword|operator_disjoint_from)\n### `disjoint_from`\n\n#### Possible use: \n  * `geometry` **`disjoint_from`** `geometry` --->  `bool`\n  *  **`disjoint_from`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns true.    \n  * if one operand is a point, returns false if the point is included in the geometry.\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]); \t// var0 equals false\nbool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals false\nbool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {15,15}; \t// var2 equals false\nbool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {25,25}; \t// var3 equals true\nbool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var4 equals true\n```\n      \n\n#### See also: \n[intersects](OperatorsDM#intersects), [crosses](OperatorsAC#crosses), [overlaps](OperatorsNZ#overlaps), [partially_overlaps](OperatorsNZ#partially_overlaps), [touches](OperatorsNZ#touches), \n    \t\n----\n\n[//]: # (keyword|operator_distance_between)\n### `distance_between`\n\n#### Possible use: \n  * `topology` **`distance_between`** `container<geometry>` --->  `float`\n  *  **`distance_between`** (`topology` , `container<geometry>`) --->  `float` \n\n#### Result: \nA distance between a list of geometries (geometries, agents, points) considering a topology.\n\n#### Examples: \n```\nfloat var0 <- my_topology distance_between [ag1, ag2, ag3]; \t// var0 equals the distance between ag1, ag2 and ag3 considering the topology my_topology\n```\n      \n\n#### See also: \n[towards](OperatorsNZ#towards), [direction_to](OperatorsDM#direction_to), [distance_to](OperatorsDM#distance_to), [direction_between](OperatorsDM#direction_between), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), \n    \t\n----\n\n[//]: # (keyword|operator_distance_to)\n### `distance_to`\n\n#### Possible use: \n  * `geometry` **`distance_to`** `geometry` --->  `float`\n  *  **`distance_to`** (`geometry` , `geometry`) --->  `float`\n  * `point` **`distance_to`** `point` --->  `float`\n  *  **`distance_to`** (`point` , `point`) --->  `float` \n\n#### Result: \nA distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.\n\n#### Examples: \n```\nfloat var0 <- ag1 distance_to ag2; \t// var0 equals the distance between ag1 and ag2 considering the topology of the agent applying the operator\n```\n      \n\n#### See also: \n[towards](OperatorsNZ#towards), [direction_to](OperatorsDM#direction_to), [distance_between](OperatorsDM#distance_between), [direction_between](OperatorsDM#direction_between), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), \n    \t\n----\n\n[//]: # (keyword|operator_distinct)\n### `distinct`\n\n#### Possible use: \n  *  **`distinct`** (`container`) --->  `container` \n\n#### Result: \nproduces a set from the elements of the operand (i.e. a list without duplicated elements)\n\n#### Special cases:     \n  * if the operand is nil, remove_duplicates returns nil    \n  * if the operand is a graph, remove_duplicates returns the set of nodes    \n  * if the operand is a matrix, remove_duplicates returns a matrix without duplicated row    \n  * if the operand is a map, remove_duplicates returns the set of values without duplicate \n  \n```\ncontainer var1 <- remove_duplicates([1::3,2::4,3::3,5::7]); \t// var1 equals [3,4,7]\n\n``` \n\n\n\n#### Examples: \n```\ncontainer var0 <- remove_duplicates([3,2,5,1,2,3,5,5,5]); \t// var0 equals [3,2,5,1]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_distribution_of)\n### `distribution_of`\n\n#### Possible use: \n  *  **`distribution_of`** (`container`) --->  `map`\n  * `container` **`distribution_of`** `int` --->  `map`\n  *  **`distribution_of`** (`container` , `int`) --->  `map`\n  *  **`distribution_of`** (`container`, `int`, `float`, `float`) --->  `map` \n\n#### Result: \nDiscretize a list of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)\n\n#### Examples: \n```\nmap var0 <- distribution_of([1,1,2,12.5]); \t// var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nmap var1 <- distribution_of([1,1,2,12.5],10); \t// var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nmap var2 <- distribution_of([1,1,2,12.5]); \t// var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\n```\n      \n\n#### See also: \n[as_map](OperatorsAC#as_map), \n    \t\n----\n\n[//]: # (keyword|operator_distribution2d_of)\n### `distribution2d_of`\n\n#### Possible use: \n  * `container` **`distribution2d_of`** `container` --->  `map`\n  *  **`distribution2d_of`** (`container` , `container`) --->  `map`\n  *  **`distribution2d_of`** (`container`, `container`, `int`, `int`) --->  `map`\n  *  **`distribution2d_of`** (`container`, `container`, `int`, `float`, `float`, `int`, `float`, `float`) --->  `map` \n\n#### Result: \nDiscretize two lists of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)\n\n#### Examples: \n```\nmap var0 <- distribution_of([1,1,2,12.5],10); \t// var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nmap var1 <- distribution2d_of([1,1,2,12.5]); \t// var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nmap var2 <- distribution_of([1,1,2,12.5],10); \t// var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\n```\n      \n\n#### See also: \n[as_map](OperatorsAC#as_map), \n    \t\n----\n\n[//]: # (keyword|operator_div)\n### `div`\n\n#### Possible use: \n  * `float` **`div`** `float` --->  `int`\n  *  **`div`** (`float` , `float`) --->  `int`\n  * `int` **`div`** `int` --->  `int`\n  *  **`div`** (`int` , `int`) --->  `int`\n  * `float` **`div`** `int` --->  `int`\n  *  **`div`** (`float` , `int`) --->  `int`\n  * `int` **`div`** `float` --->  `int`\n  *  **`div`** (`int` , `float`) --->  `int` \n\n#### Result: \nReturns the truncation of the division of the left-hand operand by the right-hand operand.\n\n#### Special cases:     \n  * if the right-hand operand is equal to zero, raises an exception.    \n  * if the right-hand operand is equal to zero, raises an exception.    \n  * if the right-hand operand is equal to zero, raises an exception.\n\n#### Examples: \n```\nint var0 <- 40.1 div 4.5; \t// var0 equals 8\nint var1 <- 40 div 3; \t// var1 equals 13\nint var2 <- 40.5 div 3; \t// var2 equals 13\nint var3 <- 40 div 4.1; \t// var3 equals 9\n```\n      \n\n#### See also: \n[mod](OperatorsDM#mod), \n    \t\n----\n\n[//]: # (keyword|operator_dxf_file)\n### `dxf_file`\n\n#### Possible use: \n  *  **`dxf_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type dxf. Allowed extensions are limited to dxf\n    \t\n----\n\n[//]: # (keyword|operator_edge)\n### `edge`\n\n#### Possible use: \n  *  **`edge`** (`pair`) --->  `unknown`\n  *  **`edge`** (`unknown`) --->  `unknown`\n  * `unknown` **`edge`** `unknown` --->  `unknown`\n  *  **`edge`** (`unknown` , `unknown`) --->  `unknown`\n  * `pair` **`edge`** `float` --->  `unknown`\n  *  **`edge`** (`pair` , `float`) --->  `unknown`\n  * `unknown` **`edge`** `float` --->  `unknown`\n  *  **`edge`** (`unknown` , `float`) --->  `unknown`\n  *  **`edge`** (`unknown`, `unknown`, `unknown`) --->  `unknown`\n  *  **`edge`** (`unknown`, `unknown`, `float`) --->  `unknown`\n  *  **`edge`** (`pair`, `unknown`, `float`) --->  `unknown`\n  *  **`edge`** (`unknown`, `unknown`, `unknown`, `float`) --->  `unknown`\n    \t\n----\n\n[//]: # (keyword|operator_edge_between)\n### `edge_between`\n\n#### Possible use: \n  * `graph` **`edge_between`** `pair` --->  `unknown`\n  *  **`edge_between`** (`graph` , `pair`) --->  `unknown` \n\n#### Result: \nreturns the edge linking two nodes\n\n#### Examples: \n```\nunknown var0 <- graphFromMap edge_between node1::node2; \t// var0 equals edge1\n```\n      \n\n#### See also: \n[out_edges_of](OperatorsNZ#out_edges_of), [in_edges_of](OperatorsDM#in_edges_of), \n    \t\n----\n\n[//]: # (keyword|operator_edge_betweenness)\n### `edge_betweenness`\n\n#### Possible use: \n  *  **`edge_betweenness`** (`graph`) --->  `map` \n\n#### Result: \nreturns a map containing for each edge (key), its betweenness centrality (value): number of shortest paths passing through each edge\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nmap var1 <- edge_betweenness(graphEpidemio); \t// var1 equals the edge betweenness index of the graph\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_edges)\n### `edges`\n\n#### Possible use: \n  *  **`edges`** (`container`) --->  `container`\n    \t\n----\n\n[//]: # (keyword|operator_eigenvalues)\n### `eigenvalues`\n\n#### Possible use: \n  *  **`eigenvalues`** (`matrix`) --->  `list<float>` \n\n#### Result: \nThe eigen values (matrix) of the given matrix\n\n#### Examples: \n```\nlist<float> var0 <- eigenvalues(matrix([[5,-3],[6,-4]])); \t// var0 equals [2.0000000000000004,-0.9999999999999998]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_electre_DM)\n### `electre_DM`\n\n#### Possible use: \n  *  **`electre_DM`** (`list<list>`, `list<map<string,object>>`, `float`) --->  `int` \n\n#### Result: \nThe index of the best candidate according to a method based on the ELECTRE methods. The principle of the ELECTRE methods is to compare the possible candidates by pair. These methods analyses the possible outranking relation existing between two candidates. An candidate outranks another if this one is at least as good as the other one. The ELECTRE methods are based on two concepts: the concordance and the discordance. The concordance characterizes the fact that, for an outranking relation to be validated, a sufficient majority of criteria should be in favor of this assertion. The discordance characterizes the fact that, for an outranking relation to be validated, none of the criteria in the minority should oppose too strongly this assertion. These two conditions must be true for validating the outranking assertion. More information about the ELECTRE methods can be found in [http://www.springerlink.com/content/g367r44322876223/\tFigueira,  J., Mousseau, V., Roy, B.: ELECTRE Methods. In: Figueira, J., Greco, S., and Ehrgott, M., (Eds.), Multiple Criteria Decision Analysis: State of the Art Surveys, Springer, New York, 133--162 (2005)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fives elements: a name, a weight, a preference value (p), an indifference value (q) and a veto value (v). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant. The veto value represents the threshold from which the difference between two criterion values disqualifies the candidate that obtained the smaller value; the last operand is the fuzzy cut.\n\n#### Special cases:     \n  * returns -1 is the list of candidates is nil or empty\n\n#### Examples: \n```\nint var0 <- electre_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]]); \t// var0 equals 0\n```\n      \n\n#### See also: \n[weighted_means_DM](OperatorsNZ#weighted_means_dm), [promethee_DM](OperatorsNZ#promethee_dm), [evidence_theory_DM](OperatorsDM#evidence_theory_dm), \n    \t\n----\n\n[//]: # (keyword|operator_ellipse)\n### `ellipse`\n\n#### Possible use: \n  * `float` **`ellipse`** `float` --->  `geometry`\n  *  **`ellipse`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nAn ellipse geometry which x-radius is equal to the first operand and y-radius is equal to the second operand  \n\n#### Comment: \nthe center of the ellipse is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if both operands are lower or equal to 0, a line if only one is.\n\n#### Examples: \n```\ngeometry var0 <- ellipse(10, 10); \t// var0 equals a geometry as an ellipse of width 10 and height 10.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [circle](OperatorsAC#circle), [squircle](OperatorsNZ#squircle), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_emotion)\n### `emotion`\n\n#### Possible use: \n  *  **`emotion`** (`any`) --->  `emotion` \n\n#### Result: \nCasts the operand into the type emotion\n    \t\n----\n\n[//]: # (keyword|operator_empty)\n### `empty`\n\n#### Possible use: \n  *  **`empty`** (`container<KeyType,ValueType>`) --->  `bool`\n  *  **`empty`** (`string`) --->  `bool` \n\n#### Result: \ntrue if the operand is empty, false otherwise.  \n\n#### Comment: \nthe empty operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a map, empty returns true if the map contains no key-value mappings, and false otherwise    \n  * if it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise    \n  * if it is a population, empty returns true if there is no agent in the population, and false otherwise    \n  * if it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise    \n  * if it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise    \n  * if it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise    \n  * if it is a list, empty returns true if there is no element in the list, and false otherwise \n  \n```\nbool var0 <- empty([]); \t// var0 equals true\n\n``` \n\n    \n  * if it is a string, empty returns true if the string does not contain any character, and false otherwise \n  \n```\nbool var1 <- empty ('abced'); \t// var1 equals false\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_enlarged_by)\n### `enlarged_by`\nSame signification as [+](OperatorsAC#+)\n    \t\n----\n\n[//]: # (keyword|operator_envelope)\n### `envelope`\n\n#### Possible use: \n  *  **`envelope`** (`unknown`) --->  `geometry` \n\n#### Result: \nA 3D geometry that represents the box that surrounds the geometries or the surface described by the arguments. More general than geometry(arguments).envelope, as it allows to pass int, double, point, image files, shape files, asc files, or any list combining these arguments, in which case the envelope will be correctly expanded. If an envelope cannot be determined from the arguments, a default one of dimensions (0,100, 0, 100, 0, 100) is returned\n    \t\n----\n\n[//]: # (keyword|operator_eval_gaml)\n### `eval_gaml`\n\n#### Possible use: \n  *  **`eval_gaml`** (`string`) --->  `unknown` \n\n#### Result: \nevaluates the given GAML string.\n\n#### Examples: \n```\nunknown var0 <- eval_gaml(\"2+3\"); \t// var0 equals 5\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_eval_when)\n### `eval_when`\n\n#### Possible use: \n  *  **`eval_when`** (`BDIPlan`) --->  `bool` \n\n#### Result: \nevaluate the facet when of a given plan\n\n#### Examples: \n```\neval_when(plan1)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_even)\n### `even`\n\n#### Possible use: \n  *  **`even`** (`int`) --->  `bool` \n\n#### Result: \nReturns true if the operand is even and false if it is odd.\n\n#### Special cases:     \n  * if the operand is equal to 0, it returns true.    \n  * if the operand is a float, it is truncated before\n\n#### Examples: \n```\nbool var0 <- even (3); \t// var0 equals false\nbool var1 <- even(-12); \t// var1 equals true\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_every)\n### `every`\n\n#### Possible use: \n  *  **`every`** (`int`) --->  `bool`\n  *  **`every`** (`any expression`) --->  `bool`\n  * `msi.gama.util.GamaDateInterval` **`every`** `any expression` --->  `msi.gama.util.IList<msi.gama.util.GamaDate>`\n  *  **`every`** (`msi.gama.util.GamaDateInterval` , `any expression`) --->  `msi.gama.util.IList<msi.gama.util.GamaDate>`\n  * `container` **`every`** `int` --->  `container`\n  *  **`every`** (`container` , `int`) --->  `container` \n\n#### Result: \ntrue every operand * cycle, false otherwise\napplies a step to an interval of dates defined by 'date1 to date2'\nexpects a frequency (expressed in seconds of simulated time) as argument. Will return true every time the current_date matches with this frequency\nRetrieves elements from the first argument every `step` (second argument) elements. Raises an error if the step is negative or equal to zero  \n\n#### Comment: \nthe value of the every operator depends on the cycle. It can be used to do something every x cycle.Used to do something at regular intervals of time. Can be used in conjunction with 'since', 'after', 'before', 'until' or 'between', so that this computation only takes place in the temporal segment defined by these operators. In all cases, the starting_date of the model is used as a reference starting point\n\n#### Examples: \n```\nif every(2) {write \"the cycle number is even\";}\n\t     else {write \"the cycle number is odd\";}\n(date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval\nreflex when: every(2#days) since date('2000-01-01') { .. }\nstate a { transition to: b when: every(2#mn);} state b { transition to: a when: every(30#s);} // This oscillatory behavior will use the starting_date of the model as its starting point in time\n```\n      \n\n#### See also: \n[to](OperatorsNZ#to), [since](OperatorsNZ#since), [after](OperatorsAC#after), \n    \t\n----\n\n[//]: # (keyword|operator_every_cycle)\n### `every_cycle`\nSame signification as [every](OperatorsDM#every)\n    \t\n----\n\n[//]: # (keyword|operator_evidence_theory_DM)\n### `evidence_theory_DM`\n\n#### Possible use: \n  * `list<list>` **`evidence_theory_DM`** `list<map<string,object>>` --->  `int`\n  *  **`evidence_theory_DM`** (`list<list>` , `list<map<string,object>>`) --->  `int`\n  *  **`evidence_theory_DM`** (`list<list>`, `list<map<string,object>>`, `bool`) --->  `int` \n\n#### Result: \nThe index of the best candidate according to a method based on the Evidence theory. This theory, which was proposed by Shafer ([http://www.glennshafer.com/books/amte.html Shafer G (1976) A mathematical theory of evidence, Princeton University Press]), is based on the work of Dempster ([http://projecteuclid.org/DPubS?service=UI&version=1.0&verb=Display&handle=euclid.aoms/1177698950 Dempster A (1967) Upper and lower probabilities induced by multivalued mapping. Annals of Mathematical Statistics, vol.  38, pp. 325--339]) on lower and upper probability distributions. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains seven elements: a name, a first threshold s1, a second threshold s2, a value for the assertion \"this candidate is the best\" at threshold s1 (v1p), a value for the assertion \"this candidate is the best\" at threshold s2 (v2p), a value for the assertion \"this candidate is not the best\" at threshold s1 (v1c), a value for the assertion \"this candidate is not the best\" at threshold s2 (v2c). v1p, v2p, v1c and v2c have to been defined in order that: v1p + v1c <= 1.0; v2p + v2c <= 1.0.; the last operand allows to use a simple version of this multi-criteria decision making method (simple if true)\n\n#### Special cases:     \n  * if the operator is used with only 2 operands (the candidates and the criteria), the last parameter (use simple method) is set to true    \n  * returns -1 is the list of candidates is nil or empty\n\n#### Examples: \n```\nint var0 <- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true],[\"name\"::\"price\",  \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true]], true); \t// var0 equals 0\n```\n      \n\n#### See also: \n[weighted_means_DM](OperatorsNZ#weighted_means_dm), [electre_DM](OperatorsDM#electre_dm), \n    \t\n----\n\n[//]: # (keyword|operator_exp)\n### `exp`\n\n#### Possible use: \n  *  **`exp`** (`float`) --->  `float`\n  *  **`exp`** (`int`) --->  `float` \n\n#### Result: \nReturns Euler's number e raised to the power of the operand.\n\n#### Special cases:     \n  * the operand is casted to a float before being evaluated.    \n  * the operand is casted to a float before being evaluated.\n\n#### Examples: \n```\nfloat var0 <- exp (0); \t// var0 equals 1.0\n```\n      \n\n#### See also: \n[ln](OperatorsDM#ln), \n    \t\n----\n\n[//]: # (keyword|operator_fact)\n### `fact`\n\n#### Possible use: \n  *  **`fact`** (`int`) --->  `float` \n\n#### Result: \nReturns the factorial of the operand.\n\n#### Special cases:     \n  * if the operand is less than 0, fact returns 0.\n\n#### Examples: \n```\nfloat var0 <- fact(4); \t// var0 equals 24\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_farthest_point_to)\n### `farthest_point_to`\n\n#### Possible use: \n  * `geometry` **`farthest_point_to`** `point` --->  `point`\n  *  **`farthest_point_to`** (`geometry` , `point`) --->  `point` \n\n#### Result: \nthe farthest point of the left-operand to the left-point.\n\n#### Examples: \n```\npoint var0 <- geom farthest_point_to(pt); \t// var0 equals the farthest point of geom to pt\n```\n      \n\n#### See also: \n[any_location_in](OperatorsAC#any_location_in), [any_point_in](OperatorsAC#any_point_in), [closest_points_with](OperatorsAC#closest_points_with), [points_at](OperatorsNZ#points_at), \n    \t\n----\n\n[//]: # (keyword|operator_farthest_to)\n### `farthest_to`\n\n#### Possible use: \n  * `container<agent>` **`farthest_to`** `geometry` --->  `geometry`\n  *  **`farthest_to`** (`container<agent>` , `geometry`) --->  `geometry` \n\n#### Result: \nAn agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the farthest to the operand (casted as a geometry).  \n\n#### Comment: \nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\n\n#### Examples: \n```\ngeometry var0 <- [ag1, ag2, ag3] closest_to(self); \t// var0 equals return the farthest agent among ag1, ag2 and ag3 to the agent applying the operator.\n(species1 + species2) closest_to self\n```\n      \n\n#### See also: \n[neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [inside](OperatorsDM#inside), [overlapping](OperatorsNZ#overlapping), [agents_overlapping](OperatorsAC#agents_overlapping), [agents_inside](OperatorsAC#agents_inside), [agent_closest_to](OperatorsAC#agent_closest_to), [closest_to](OperatorsAC#closest_to), [agent_farthest_to](OperatorsAC#agent_farthest_to), \n    \t\n----\n\n[//]: # (keyword|operator_file)\n### `file`\n\n#### Possible use: \n  *  **`file`** (`string`) --->  `file`\n  * `string` **`file`** `container` --->  `file`\n  *  **`file`** (`string` , `container`) --->  `file` \n\n#### Result: \nopens a file in read only mode, creates a GAML file object, and tries to determine and store the file content in the contents attribute.\nCreates a file in read/write mode, setting its contents to the container passed in parameter  \n\n#### Comment: \nThe file should have a supported extension, see file type definition for supported file extensions.The type of container to pass will depend on the type of file (see the management of files in the documentation). Can be used to copy files since files are considered as containers. For example: save file('image_copy.png', file('image.png')); will copy image.png to image_copy.png\n\n#### Special cases:     \n  * If the specified string does not refer to an existing file, an exception is risen when the variable is used.\n\n#### Examples: \n```\nlet fileT type: file value: file(\"../includes/Stupid_Cell.Data\"); \n\t\t\t// fileT represents the file \"../includes/Stupid_Cell.Data\"\n\t\t\t// fileT.contents here contains a matrix storing all the data of the text file\n```\n      \n\n#### See also: \n[folder](OperatorsDM#folder), [new_folder](OperatorsNZ#new_folder), \n    \t\n----\n\n[//]: # (keyword|operator_file_exists)\n### `file_exists`\n\n#### Possible use: \n  *  **`file_exists`** (`string`) --->  `bool` \n\n#### Result: \nTest whether the parameter is the path to an existing file.\n    \t\n----\n\n[//]: # (keyword|operator_first)\n### `first`\n\n#### Possible use: \n  *  **`first`** (`string`) --->  `string`\n  *  **`first`** (`container<KeyType,ValueType>`) --->  `ValueType`\n  * `int` **`first`** `container` --->  `container`\n  *  **`first`** (`int` , `container`) --->  `container` \n\n#### Result: \nthe first value of the operand  \n\n#### Comment: \nthe first operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a map, first returns the first value of the first pair (in insertion order)    \n  * if it is a file, first returns the first element of the content of the file (that is also a container)    \n  * if it is a population, first returns the first agent of the population    \n  * if it is a graph, first returns the first edge (in creation order)    \n  * if it is a matrix, first returns the element at {0,0} in the matrix    \n  * for a matrix of int or float, it will return 0 if the matrix is empty    \n  * for a matrix of object or geometry, it will return nil if the matrix is empty    \n  * if it is a string, first returns a string composed of its first character \n  \n```\nstring var0 <- first ('abce'); \t// var0 equals 'a'\n\n``` \n\n    \n  * if it is a list, first returns the first element of the list, or nil if the list is empty \n  \n```\nint var1 <- first ([1, 2, 3]); \t// var1 equals 1\n\n``` \n\n    \n\n#### See also: \n[last](OperatorsDM#last), \n    \t\n----\n\n[//]: # (keyword|operator_first_of)\n### `first_of`\nSame signification as [first](OperatorsDM#first)\n    \t\n----\n\n[//]: # (keyword|operator_first_with)\n### `first_with`\n\n#### Possible use: \n  * `container` **`first_with`** `any expression` --->  `unknown`\n  *  **`first_with`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe first element of the left-hand operand that makes the right-hand operand evaluate to true.  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, first_with throws an error. If there is no element that satisfies the condition, it returns nil    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var4 <- [1::2, 3::4, 5::6] first_with (each >= 4); \t// var4 equals 4\nunknown var5 <- [1::2, 3::4, 5::6].pairs first_with (each.value >= 4); \t// var5 equals 3::4\n\n``` \n\n\n\n#### Examples: \n```\nunknown var0 <- [1,2,3,4,5,6,7,8] first_with (each > 3); \t// var0 equals 4\nunknown var2 <- g2 first_with (length(g2 out_edges_of each) = 0); \t// var2 equals node9\nunknown var3 <- (list(node) first_with (round(node(each).location.x) > 32); \t// var3 equals node2\n```\n      \n\n#### See also: \n[group_by](OperatorsDM#group_by), [last_with](OperatorsDM#last_with), [where](OperatorsNZ#where), \n    \t\n----\n\n[//]: # (keyword|operator_flip)\n### `flip`\n\n#### Possible use: \n  *  **`flip`** (`float`) --->  `bool` \n\n#### Result: \ntrue or false given the probability represented by the operand\n\n#### Special cases:     \n  * flip 0 always returns false, flip 1 true\n\n#### Examples: \n```\nbool var0 <- flip (0.66666); \t// var0 equals 2/3 chances to return true.\n```\n      \n\n#### See also: \n[rnd](OperatorsNZ#rnd), \n    \t\n----\n\n[//]: # (keyword|operator_float)\n### `float`\n\n#### Possible use: \n  *  **`float`** (`any`) --->  `float` \n\n#### Result: \nCasts the operand into the type float\n    \t\n----\n\n[//]: # (keyword|operator_floor)\n### `floor`\n\n#### Possible use: \n  *  **`floor`** (`float`) --->  `float` \n\n#### Result: \nMaps the operand to the largest previous following integer, i.e. the largest integer not greater than x.\n\n#### Examples: \n```\nfloat var0 <- floor(3); \t// var0 equals 3.0\nfloat var1 <- floor(3.5); \t// var1 equals 3.0\nfloat var2 <- floor(-4.7); \t// var2 equals -5.0\n```\n      \n\n#### See also: \n[ceil](OperatorsAC#ceil), [round](OperatorsNZ#round), \n    \t\n----\n\n[//]: # (keyword|operator_folder)\n### `folder`\n\n#### Possible use: \n  *  **`folder`** (`string`) --->  `file` \n\n#### Result: \nopens an existing repository\n\n#### Special cases:     \n  * If the specified string does not refer to an existing repository, an exception is risen.\n\n#### Examples: \n```\nfolder(\"../includes/\")\nfile dirT <- folder(\"../includes/\");\n\t\t\t\t// dirT represents the repository \"../includes/\"\n\t\t\t\t// dirT.contents here contains the list of the names of included files\n```\n      \n\n#### See also: \n[file](OperatorsDM#file), [new_folder](OperatorsNZ#new_folder), \n    \t\n----\n\n[//]: # (keyword|operator_font)\n### `font`\n\n#### Possible use: \n  *  **`font`** (`string`, `int`, `int`) --->  `font` \n\n#### Result: \nCreates a new font, by specifying its name (either a font face name like 'Lucida Grande Bold' or 'Helvetica', or a logical name like 'Dialog', 'SansSerif', 'Serif', etc.), a size in points and a style, either #bold, #italic or #plain or a combination (addition) of them.\n\n#### Examples: \n```\nfont var0 <- font ('Helvetica Neue',12, #bold + #italic); \t// var0 equals a bold and italic face of the Helvetica Neue family\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_frequency_of)\n### `frequency_of`\n\n#### Possible use: \n  * `container` **`frequency_of`** `any expression` --->  `map`\n  *  **`frequency_of`** (`container` , `any expression`) --->  `map` \n\n#### Result: \nReturns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)\n\n#### Examples: \n```\nmap var0 <- [ag1, ag2, ag3, ag4] frequency_of each.size; \t// var0 equals the different sizes as keys and the number of agents of this size as values\n```\n      \n\n#### See also: \n[as_map](OperatorsAC#as_map), \n    \t\n----\n\n[//]: # (keyword|operator_from)\n### `from`\nSame signification as [since](OperatorsNZ#since)\n    \t\n----\n\n[//]: # (keyword|operator_fuzzy_kappa)\n### `fuzzy_kappa`\n\n#### Possible use: \n  *  **`fuzzy_kappa`** (`list<agent>`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`) --->  `float`\n  *  **`fuzzy_kappa`** (`list<agent>`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`, `list`) --->  `float` \n\n#### Result: \nfuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21\nfuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21\n\n#### Examples: \n```\nfuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])\nfuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_fuzzy_kappa_sim)\n### `fuzzy_kappa_sim`\n\n#### Possible use: \n  *  **`fuzzy_kappa_sim`** (`list<agent>`, `list`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`) --->  `float`\n  *  **`fuzzy_kappa_sim`** (`list<agent>`, `list`, `list`, `list`, `list<float>`, `list`, `matrix<float>`, `float`, `list`) --->  `float` \n\n#### Result: \nfuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, \nfuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,\n\n#### Examples: \n```\nfuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2)\nfuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_gaml_file)\n### `gaml_file`\n\n#### Possible use: \n  *  **`gaml_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type gaml. Allowed extensions are limited to gaml, experiment\n    \t\n----\n\n[//]: # (keyword|operator_gamma_index)\n### `gamma_index`\n\n#### Possible use: \n  *  **`gamma_index`** (`graph`) --->  `float` \n\n#### Result: \nreturns the gamma index of the graph (A measure of connectivity that considers the relationship between the number of observed links and the number of possible links: gamma = e/(3 `*` (v - 2)) - for planar graph.\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nfloat var1 <- gamma_index(graphEpidemio); \t// var1 equals the gamma index of the graph\n```\n      \n\n#### See also: \n[alpha_index](OperatorsAC#alpha_index), [beta_index](OperatorsAC#beta_index), [nb_cycles](OperatorsNZ#nb_cycles), [connectivity_index](OperatorsAC#connectivity_index), \n    \t\n----\n\n[//]: # (keyword|operator_gamma_rnd)\n### `gamma_rnd`\n\n#### Possible use: \n  * `float` **`gamma_rnd`** `float` --->  `float`\n  *  **`gamma_rnd`** (`float` , `float`) --->  `float` \n\n#### Result: \nreturns a random value from a gamma distribution with specified values of the shape and scale parameters\n\n#### Examples: \n```\ngamma_rnd(10.0,5.0)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_gauss)\n### `gauss`\n\n#### Possible use: \n  *  **`gauss`** (`point`) --->  `float`\n  * `float` **`gauss`** `float` --->  `float`\n  *  **`gauss`** (`float` , `float`) --->  `float` \n\n#### Result: \nA value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.\nA value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.\n\n#### Special cases:     \n  * when the operand is a point, it is read as {mean, standardDeviation}    \n  * when standardDeviation value is 0.0, it always returns the mean value    \n  * when the operand is a point, it is read as {mean, standardDeviation}    \n  * when standardDeviation value is 0.0, it always returns the mean value\n\n#### Examples: \n```\nfloat var0 <- gauss(0,0.3); \t// var0 equals 0.22354\nfloat var1 <- gauss(0,0.3); \t// var1 equals -0.1357\nfloat var2 <- gauss({0,0.3}); \t// var2 equals 0.22354\nfloat var3 <- gauss({0,0.3}); \t// var3 equals -0.1357\n```\n      \n\n#### See also: \n[skew_gauss](OperatorsNZ#skew_gauss), [truncated_gauss](OperatorsNZ#truncated_gauss), [poisson](OperatorsNZ#poisson), \n    \t\n----\n\n[//]: # (keyword|operator_generate_barabasi_albert)\n### `generate_barabasi_albert`\n\n#### Possible use: \n  *  **`generate_barabasi_albert`** (`container<agent>`, `species`, `int`, `bool`) --->  `graph`\n  *  **`generate_barabasi_albert`** (`species`, `species`, `int`, `int`, `bool`) --->  `graph` \n\n#### Result: \nreturns a random scale-free network (following Barabasi-Albert (BA) model).\nreturns a random scale-free network (following Barabasi-Albert (BA) model).  \n\n#### Comment: \nThe Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:\n\n#### Special cases:     \n  * \"vertices_specy\": the species of vertices    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain (size + 1) nodes    \n  * \"m\": the number of edges added per novel node    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"agents\": list of existing node agents    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain (size + 1) nodes    \n  * \"m\": the number of edges added per novel node    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?\n\n#### Examples: \n```\ngraph<yourNodeSpecy,yourEdgeSpecy> graphEpidemio <- generate_barabasi_albert(\n\t\tyourNodeSpecy,\n\t\tyourEdgeSpecy,\n\t\t3,\n\t\t5,\n\t\ttrue);\ngraph<yourNodeSpecy,yourEdgeSpecy> graphEpidemio <- generate_barabasi_albert(\n\t\tyourListOfNodes,\n\t\tyourEdgeSpecy,\n\t\t3,\n\t\t5,\n\t\ttrue);\n```\n      \n\n#### See also: \n[generate_watts_strogatz](OperatorsDM#generate_watts_strogatz), \n    \t\n----\n\n[//]: # (keyword|operator_generate_complete_graph)\n### `generate_complete_graph`\n\n#### Possible use: \n  *  **`generate_complete_graph`** (`container<agent>`, `species`, `bool`) --->  `graph`\n  *  **`generate_complete_graph`** (`container<agent>`, `species`, `float`, `bool`) --->  `graph`\n  *  **`generate_complete_graph`** (`species`, `species`, `int`, `bool`) --->  `graph`\n  *  **`generate_complete_graph`** (`species`, `species`, `int`, `float`, `bool`) --->  `graph` \n\n#### Result: \nreturns a fully connected graph.\nreturns a fully connected graph.\nreturns a fully connected graph.\nreturns a fully connected graph.  \n\n#### Comment: \nArguments should include following elements:Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:\n\n#### Special cases:     \n  * \"agents\": list of existing node agents    \n  * \"edges_species\": the species of edges    \n  * \"layoutRadius\": nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"vertices_specy\": the species of vertices    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain size nodes.    \n  * \"layoutRadius\": nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"vertices_specy\": the species of vertices    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain size nodes.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"agents\": list of existing node agents    \n  * \"edges_species\": the species of edges    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?\n\n#### Examples: \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(\n\t\t\tmyListOfNodes,\n\t\t\tmyEdgeSpecy,\n\t\t\t25,\n\t\ttrue);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy,\n\t\t\t10, 25,\n\t\ttrue);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy,\n\t\t\t10,\n\t\ttrue);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(\n\t\t\tmyListOfNodes,\n\t\t\tmyEdgeSpecy,\n\t\ttrue);\n```\n      \n\n#### See also: \n[generate_barabasi_albert](OperatorsDM#generate_barabasi_albert), [generate_watts_strogatz](OperatorsDM#generate_watts_strogatz), \n    \t\n----\n\n[//]: # (keyword|operator_generate_watts_strogatz)\n### `generate_watts_strogatz`\n\n#### Possible use: \n  *  **`generate_watts_strogatz`** (`container<agent>`, `species`, `float`, `int`, `bool`) --->  `graph`\n  *  **`generate_watts_strogatz`** (`species`, `species`, `int`, `float`, `int`, `bool`) --->  `graph` \n\n#### Result: \nreturns a random small-world network (following Watts-Strogatz model).\nreturns a random small-world network (following Watts-Strogatz model).  \n\n#### Comment: \nThe Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:\n\n#### Special cases:     \n  * \"vertices_specy\": the species of vertices    \n  * \"edges_species\": the species of edges    \n  * \"size\": the graph will contain (size + 1) nodes. Size must be greater than k.    \n  * \"p\": probability to \"rewire\" an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.    \n  * \"k\": the base degree of each node. k must be greater than 2 and even.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?    \n  * \"agents\": list of existing node agents    \n  * \"edges_species\": the species of edges    \n  * \"p\": probability to \"rewire\" an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.    \n  * \"k\": the base degree of each node. k must be greater than 2 and even.    \n  * \"synchronized\": is the graph and the species of vertices and edges synchronized?\n\n#### Examples: \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz(\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy,\n\t\t\t2,\n\t\t\t0.3,\n\t\t\t2,\n\t\ttrue);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz(\n\t\t\tmyListOfNodes,\n\t\t\tmyEdgeSpecy,\n\t\t\t0.3,\n\t\t\t2,\n\t\ttrue);\n```\n      \n\n#### See also: \n[generate_barabasi_albert](OperatorsDM#generate_barabasi_albert), \n    \t\n----\n\n[//]: # (keyword|operator_geojson_file)\n### `geojson_file`\n\n#### Possible use: \n  *  **`geojson_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type geojson. Allowed extensions are limited to json, geojson, geo.json\n    \t\n----\n\n[//]: # (keyword|operator_geometric_mean)\n### `geometric_mean`\n\n#### Possible use: \n  *  **`geometric_mean`** (`container`) --->  `float` \n\n#### Result: \nthe geometric mean of the elements of the operand. See <A href=\"http://en.wikipedia.org/wiki/Geometric_mean\">Geometric_mean</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- geometric_mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 4.962326343467649\n```\n      \n\n#### See also: \n[mean](OperatorsDM#mean), [median](OperatorsDM#median), [harmonic_mean](OperatorsDM#harmonic_mean), \n    \t\n----\n\n[//]: # (keyword|operator_geometry)\n### `geometry`\n\n#### Possible use: \n  *  **`geometry`** (`any`) --->  `geometry` \n\n#### Result: \nCasts the operand into the type geometry\n    \t\n----\n\n[//]: # (keyword|operator_geometry_collection)\n### `geometry_collection`\n\n#### Possible use: \n  *  **`geometry_collection`** (`container<geometry>`) --->  `geometry` \n\n#### Result: \nA geometry collection (multi-geometry) composed of the given list of geometries.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single geometry, returns a copy of the geometry.\n\n#### Examples: \n```\ngeometry var0 <- geometry_collection([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var0 equals a geometry composed of the 4 points (multi-point).\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygone](OperatorsNZ#polygone), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), [line](OperatorsDM#line), \n    \t\n----\n\n[//]: # (keyword|operator_get)\n### `get`\n\n#### Possible use: \n  * `geometry` **`get`** `string` --->  `unknown`\n  *  **`get`** (`geometry` , `string`) --->  `unknown`\n  * `agent` **`get`** `string` --->  `unknown`\n  *  **`get`** (`agent` , `string`) --->  `unknown` \n\n#### Result: \nReads an attribute of the specified geometry (left operand). The attribute name is specified by the right operand.\nReads an attribute of the specified agent (left operand). The attribute name is specified by the right operand.\n\n#### Special cases:     \n  * Reading the attribute of a geometry \n  \n```\nstring geom_area <- a_geometry get('area');     // reads then 'area' attribute of 'a_geometry' variable then assigns the returned value to the geom_area variable\n\n``` \n\n    \n  * Reading the attribute of another agent \n  \n```\nstring agent_name <- an_agent get('name');     // reads then 'name' attribute of an_agent then assigns the returned value to the agent_name variable\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_get_about)\n### `get_about`\n\n#### Possible use: \n  *  **`get_about`** (`emotion`) --->  `predicate` \n\n#### Result: \nget the about value of the given emotion\n\n#### Examples: \n```\nget_about(emotion)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_get_agent)\n### `get_agent`\n\n#### Possible use: \n  *  **`get_agent`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `agent` \n\n#### Result: \nget the agent value of the given social link\n\n#### Examples: \n```\nget_agent(social_link1)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_get_agent_cause)\n### `get_agent_cause`\n\n#### Possible use: \n  *  **`get_agent_cause`** (`emotion`) --->  `agent`\n  *  **`get_agent_cause`** (`predicate`) --->  `agent` \n\n#### Result: \nget the agent cause value of the given emotion\n\n#### Examples: \n```\nget_agent_cause(emotion)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_get_decay)\n### `get_decay`\n\n#### Possible use: \n  *  **`get_decay`** (`emotion`) --->  `float` \n\n#### Result: \nget the decay value of the given emotion\n\n#### Examples: \n```\nget_decay(emotion)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_get_dominance)\n### `get_dominance`\n\n#### Possible use: \n  *  **`get_dominance`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `float` \n\n#### Result: \nget the dominance value of the given social link\n\n#### Examples: \n```\nget_dominance(social_link1)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_get_familiarity)\n### `get_familiarity`\n\n#### Possible use: \n  *  **`get_familiarity`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `float` \n\n#### Result: \nget the familiarity value of the given social link\n\n#### Examples: \n```\nget_familiarity(social_link1)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_get_intensity)\n### `get_intensity`\n\n#### Possible use: \n  *  **`get_intensity`** (`emotion`) --->  `float` \n\n#### Result: \nget the intensity value of the given emotion\n\n#### Examples: \n```\nemotion set_intensity 12\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_get_lifetime)\n### `get_lifetime`\n\n#### Possible use: \n  *  **`get_lifetime`** (`predicate`) --->  `int`\n    \t\n----\n\n[//]: # (keyword|operator_get_liking)\n### `get_liking`\n\n#### Possible use: \n  *  **`get_liking`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `float` \n\n#### Result: \nget the liking value of the given social link\n\n#### Examples: \n```\nget_liking(social_link1)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_get_praiseworthiness)\n### `get_praiseworthiness`\n\n#### Possible use: \n  *  **`get_praiseworthiness`** (`predicate`) --->  `float`\n    \t\n----\n\n[//]: # (keyword|operator_get_priority)\n### `get_priority`\n\n#### Possible use: \n  *  **`get_priority`** (`predicate`) --->  `float`\n    \t\n----\n\n[//]: # (keyword|operator_get_solidarity)\n### `get_solidarity`\n\n#### Possible use: \n  *  **`get_solidarity`** (`msi.gaml.architecture.simplebdi.SocialLink`) --->  `float` \n\n#### Result: \nget the solidarity value of the given social link\n\n#### Examples: \n```\nget_solidarity(social_link1)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_get_super_intention)\n### `get_super_intention`\n\n#### Possible use: \n  *  **`get_super_intention`** (`predicate`) --->  `predicate`\n    \t\n----\n\n[//]: # (keyword|operator_gif_file)\n### `gif_file`\n\n#### Possible use: \n  *  **`gif_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type gif. Allowed extensions are limited to gif\n    \t\n----\n\n[//]: # (keyword|operator_gini)\n### `gini`\n\n#### Possible use: \n  *  **`gini`** (`list<float>`) --->  `float`\n\n#### Special cases:     \n  * return the Gini Index of the given list of values (list of floats) \n  \n```\nfloat var0 <- gini([1.0, 0.5, 2.0]); \t// var0 equals the gini index computed\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_graph)\n### `graph`\n\n#### Possible use: \n  *  **`graph`** (`any`) --->  `graph` \n\n#### Result: \nCasts the operand into the type graph\n    \t\n----\n\n[//]: # (keyword|operator_grayscale)\n### `grayscale`\n\n#### Possible use: \n  *  **`grayscale`** (`rgb`) --->  `rgb` \n\n#### Result: \nConverts rgb color to grayscale value  \n\n#### Comment: \nr=red, g=green, b=blue. Between 0 and 255 and gray = 0.299 `*` red + 0.587 `*` green + 0.114 `*` blue (Photoshop value)\n\n#### Examples: \n```\nrgb var0 <- grayscale (rgb(255,0,0)); \t// var0 equals to a dark grey\n```\n      \n\n#### See also: \n[rgb](OperatorsNZ#rgb), [hsb](OperatorsDM#hsb), \n    \t\n----\n\n[//]: # (keyword|operator_grid_at)\n### `grid_at`\n\n#### Possible use: \n  * `species` **`grid_at`** `point` --->  `agent`\n  *  **`grid_at`** (`species` , `point`) --->  `agent` \n\n#### Result: \nreturns the cell of the grid (right-hand operand) at the position given by the right-hand operand  \n\n#### Comment: \nIf the left-hand operand is a point of floats, it is used as a point of ints.\n\n#### Special cases:     \n  * if the left-hand operand is not a grid cell species, returns nil\n\n#### Examples: \n```\nagent var0 <- grid_cell grid_at {1,2}; \t// var0 equals the agent grid_cell with grid_x=1 and grid_y = 2\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_grid_cells_to_graph)\n### `grid_cells_to_graph`\n\n#### Possible use: \n  *  **`grid_cells_to_graph`** (`container`) --->  `graph` \n\n#### Result: \ncreates a graph from a list of cells (operand). An edge is created between neighbors.\n\n#### Examples: \n```\nmy_cell_graph<-grid_cells_to_graph(cells_list)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_grid_file)\n### `grid_file`\n\n#### Possible use: \n  *  **`grid_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type grid. Allowed extensions are limited to asc, tif\n    \t\n----\n\n[//]: # (keyword|operator_group_by)\n### `group_by`\n\n#### Possible use: \n  * `container` **`group_by`** `any expression` --->  `map`\n  *  **`group_by`** (`container` , `any expression`) --->  `map` \n\n#### Result: \nReturns a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key value  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, group_by throws an error\n\n#### Examples: \n```\nmap var0 <- [1,2,3,4,5,6,7,8] group_by (each > 3); \t// var0 equals [false::[1, 2, 3], true::[4, 5, 6, 7, 8]]\nmap var1 <- g2 group_by (length(g2 out_edges_of each) ); \t// var1 equals [ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]]\nmap var2 <- (list(node) group_by (round(node(each).location.x)); \t// var2 equals [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]]\nmap var3 <- [1::2, 3::4, 5::6] group_by (each > 4); \t// var3 equals [false::[2, 4], true::[6]]\n```\n      \n\n#### See also: \n[first_with](OperatorsDM#first_with), [last_with](OperatorsDM#last_with), [where](OperatorsNZ#where), \n    \t\n----\n\n[//]: # (keyword|operator_harmonic_mean)\n### `harmonic_mean`\n\n#### Possible use: \n  *  **`harmonic_mean`** (`container`) --->  `float` \n\n#### Result: \nthe harmonic mean of the elements of the operand. See <A href=\"http://en.wikipedia.org/wiki/Harmonic_mean\">Harmonic_mean</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- harmonic_mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 4.804159445407279\n```\n      \n\n#### See also: \n[mean](OperatorsDM#mean), [median](OperatorsDM#median), [geometric_mean](OperatorsDM#geometric_mean), \n    \t\n----\n\n[//]: # (keyword|operator_hexagon)\n### `hexagon`\n\n#### Possible use: \n  *  **`hexagon`** (`point`) --->  `geometry`\n  *  **`hexagon`** (`float`) --->  `geometry` \n\n#### Result: \nA hexagon geometry which the given with and height  \n\n#### Comment: \nthe center of the hexagon is by default the location of the current agent in which has been called this operator.the center of the hexagon is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- hexagon({10,5}); \t// var0 equals a geometry as a hexagon of width of 10 and height of 5.\ngeometry var1 <- hexagon(10); \t// var1 equals a geometry as a hexagon of width of 10 and height of 10.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_hierarchical_clustering)\n### `hierarchical_clustering`\n\n#### Possible use: \n  * `container<agent>` **`hierarchical_clustering`** `float` --->  `container`\n  *  **`hierarchical_clustering`** (`container<agent>` , `float`) --->  `container` \n\n#### Result: \nA tree (list of list) contained groups of agents clustered by distance considering a distance min between two groups.  \n\n#### Comment: \nuse of hierarchical clustering with Minimum for linkage criterion between two groups of agents.\n\n#### Examples: \n```\ncontainer var0 <- [ag1, ag2, ag3, ag4, ag5] hierarchical_clustering 20.0; \t// var0 equals for example, can return [[[ag1],[ag3]], [ag2], [[[ag4],[ag5]],[ag6]]\n```\n      \n\n#### See also: \n[simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), \n    \t\n----\n\n[//]: # (keyword|operator_hsb)\n### `hsb`\n\n#### Possible use: \n  *  **`hsb`** (`float`, `float`, `float`) --->  `rgb`\n  *  **`hsb`** (`float`, `float`, `float`, `int`) --->  `rgb`\n  *  **`hsb`** (`float`, `float`, `float`, `float`) --->  `rgb` \n\n#### Result: \nConverts hsb (h=hue, s=saturation, b=brightness) value to Gama color  \n\n#### Comment: \nh,s and b components should be floating-point values between 0.0 and 1.0 and when used alpha should be an integer (between 0 and 255) or a float (between 0 and 1) . Examples: Red=(0.0,1.0,1.0), Yellow=(0.16,1.0,1.0), Green=(0.33,1.0,1.0), Cyan=(0.5,1.0,1.0), Blue=(0.66,1.0,1.0), Magenta=(0.83,1.0,1.0)\n\n#### Examples: \n```\nrgb var0 <- hsb (0.5,1.0,1.0,0.0); \t// var0 equals rgb(\"cyan\",0)\nrgb var1 <- hsb (0.0,1.0,1.0); \t// var1 equals rgb(\"red\")\n```\n      \n\n#### See also: \n[rgb](OperatorsNZ#rgb), \n    \t\n----\n\n[//]: # (keyword|operator_hypot)\n### `hypot`\n\n#### Possible use: \n  *  **`hypot`** (`float`, `float`, `float`, `float`) --->  `float` \n\n#### Result: \nReturns sqrt(x2 +y2) without intermediate overflow or underflow.\n\n#### Special cases:     \n  * If either argument is infinite, then the result is positive infinity. If either argument is NaN and neither argument is infinite, then the result is NaN.\n\n#### Examples: \n```\nfloat var0 <- hypot(0,1,0,1); \t// var0 equals sqrt(2)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_image_file)\n### `image_file`\n\n#### Possible use: \n  *  **`image_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type image. Allowed extensions are limited to tiff, jpg, jpeg, png, pict, bmp\n    \t\n----\n\n[//]: # (keyword|operator_in)\n### `in`\n\n#### Possible use: \n  * `unknown` **`in`** `container` --->  `bool`\n  *  **`in`** (`unknown` , `container`) --->  `bool`\n  * `string` **`in`** `string` --->  `bool`\n  *  **`in`** (`string` , `string`) --->  `bool` \n\n#### Result: \ntrue if the right operand contains the left operand, false otherwise  \n\n#### Comment: \nthe definition of in depends on the container\n\n#### Special cases:     \n  * if the right operand is nil or empty, in returns false    \n  * if both operands are strings, returns true if the left-hand operand patterns is included in to the right-hand string;\n\n#### Examples: \n```\nbool var0 <- 2 in [1,2,3,4,5,6]; \t// var0 equals true\nbool var1 <- 7 in [1,2,3,4,5,6]; \t// var1 equals false\nbool var2 <- 3 in [1::2, 3::4, 5::6]; \t// var2 equals false\nbool var3 <- 6 in [1::2, 3::4, 5::6]; \t// var3 equals true\nbool var4 <-  'bc' in 'abcded'; \t// var4 equals true\n```\n      \n\n#### See also: \n[contains](OperatorsAC#contains), \n    \t\n----\n\n[//]: # (keyword|operator_in_degree_of)\n### `in_degree_of`\n\n#### Possible use: \n  * `graph` **`in_degree_of`** `unknown` --->  `int`\n  *  **`in_degree_of`** (`graph` , `unknown`) --->  `int` \n\n#### Result: \nreturns the in degree of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\nint var1 <- graphFromMap in_degree_of (node(3)); \t// var1 equals 2\n```\n      \n\n#### See also: \n[out_degree_of](OperatorsNZ#out_degree_of), [degree_of](OperatorsDM#degree_of), \n    \t\n----\n\n[//]: # (keyword|operator_in_edges_of)\n### `in_edges_of`\n\n#### Possible use: \n  * `graph` **`in_edges_of`** `unknown` --->  `container`\n  *  **`in_edges_of`** (`graph` , `unknown`) --->  `container` \n\n#### Result: \nreturns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\ncontainer var1 <- graphFromMap in_edges_of node({12,45}); \t// var1 equals [LineString]\n```\n      \n\n#### See also: \n[out_edges_of](OperatorsNZ#out_edges_of), \n    \t\n----\n\n[//]: # (keyword|operator_indented_by)\n### `indented_by`\n\n#### Possible use: \n  * `string` **`indented_by`** `int` --->  `string`\n  *  **`indented_by`** (`string` , `int`) --->  `string` \n\n#### Result: \nConverts a (possibly multiline) string by indenting it by a number -- specified by the second operand -- of tabulations to the right\n    \t\n----\n\n[//]: # (keyword|operator_index_by)\n### `index_by`\n\n#### Possible use: \n  * `container` **`index_by`** `any expression` --->  `map`\n  *  **`index_by`** (`container` , `any expression`) --->  `map` \n\n#### Result: \nproduces a new map from the evaluation of the right-hand operand for each element of the left-hand operand\n\n#### Special cases:     \n  * if the left-hand operand is nil, index_by throws an error. If the operation results in duplicate keys, only the first value corresponding to the key is kept\n\n#### Examples: \n```\nmap var0 <- [1,2,3,4,5,6,7,8] index_by (each - 1); \t// var0 equals [0::1, 1::2, 2::3, 3::4, 4::5, 5::6, 6::7, 7::8]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_index_of)\n### `index_of`\n\n#### Possible use: \n  * `container` **`index_of`** `unknown` --->  `int`\n  *  **`index_of`** (`container` , `unknown`) --->  `int`\n  * `map` **`index_of`** `unknown` --->  `unknown`\n  *  **`index_of`** (`map` , `unknown`) --->  `unknown`\n  * `matrix` **`index_of`** `unknown` --->  `point`\n  *  **`index_of`** (`matrix` , `unknown`) --->  `point`\n  * `string` **`index_of`** `string` --->  `int`\n  *  **`index_of`** (`string` , `string`) --->  `int`\n  * `species` **`index_of`** `unknown` --->  `int`\n  *  **`index_of`** (`species` , `unknown`) --->  `int` \n\n#### Result: \nthe index of the first occurence of the right operand in the left operand container\nthe index of the first occurence of the right operand in the left operand container  \n\n#### Comment: \nThe definition of index_of and the type of the index depend on the container\n\n#### Special cases:     \n  * if the left operand is a map, index_of returns the index of a value or nil if the value is not mapped    \n  * if the left operator is a species, returns the index of an agent in a species. If the argument is not an agent of this species, returns -1. Use int(agent) instead    \n  * if the left operand is a list, index_of returns the index as an integer \n  \n```\nint var1 <- [1,2,3,4,5,6] index_of 4; \t// var1 equals 3\nint var2 <- [4,2,3,4,5,4] index_of 4; \t// var2 equals 0\n\n``` \n\n    \n  * if the left operand is a matrix, index_of returns the index as a point \n  \n```\npoint var3 <- matrix([[1,2,3],[4,5,6]]) index_of 4; \t// var3 equals {1.0,0.0}\n\n``` \n\n    \n  * if both operands are strings, returns the index within the left-hand string of the first occurrence of the given right-hand string \n  \n```\nint var4 <-  \"abcabcabc\" index_of \"ca\"; \t// var4 equals 2\n\n``` \n\n\n\n#### Examples: \n```\nunknown var0 <- [1::2, 3::4, 5::6] index_of 4; \t// var0 equals 3\n```\n      \n\n#### See also: \n[at](OperatorsAC#at), [last_index_of](OperatorsDM#last_index_of), \n    \t\n----\n\n[//]: # (keyword|operator_inside)\n### `inside`\n\n#### Possible use: \n  * `container<agent>` **`inside`** `geometry` --->  `list<geometry>`\n  *  **`inside`** (`container<agent>` , `geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), covered by the operand (casted as a geometry).\n\n#### Examples: \n```\nlist<geometry> var0 <- [ag1, ag2, ag3] inside(self); \t// var0 equals the agents among ag1, ag2 and ag3 that are covered by the shape of the right-hand argument.\nlist<geometry> var1 <- (species1 + species2) inside (self); \t// var1 equals the agents among species species1 and species2 that are covered by the shape of the right-hand argument.\n```\n      \n\n#### See also: \n[neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [closest_to](OperatorsAC#closest_to), [overlapping](OperatorsNZ#overlapping), [agents_overlapping](OperatorsAC#agents_overlapping), [agents_inside](OperatorsAC#agents_inside), [agent_closest_to](OperatorsAC#agent_closest_to), \n    \t\n----\n\n[//]: # (keyword|operator_int)\n### `int`\n\n#### Possible use: \n  *  **`int`** (`any`) --->  `int` \n\n#### Result: \nCasts the operand into the type int\n    \t\n----\n\n[//]: # (keyword|operator_inter)\n### `inter`\n\n#### Possible use: \n  * `container` **`inter`** `container` --->  `container`\n  *  **`inter`** (`container` , `container`) --->  `container`\n  * `geometry` **`inter`** `geometry` --->  `geometry`\n  *  **`inter`** (`geometry` , `geometry`) --->  `geometry` \n\n#### Result: \nthe intersection of the two operands\nA geometry resulting from the intersection between the two geometries  \n\n#### Comment: \nboth containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.\n\n#### Special cases:     \n  * if an operand is a graph, it will be transformed into the set of its nodes    \n  * returns nil if one of the operands is nil    \n  * if an operand is a map, it will be transformed into the set of its values \n  \n```\ncontainer var0 <- [1::2, 3::4, 5::6] inter [2,4]; \t// var0 equals [2,4]\ncontainer var1 <- [1::2, 3::4, 5::6] inter [1,3]; \t// var1 equals []\n\n``` \n\n    \n  * if an operand is a matrix, it will be transformed into the set of the lines \n  \n```\ncontainer var2 <- matrix([[1,2,3],[4,5,4]]) inter [3,4]; \t// var2 equals [3,4]\n\n``` \n\n\n\n#### Examples: \n```\ncontainer var3 <- [1,2,3,4,5,6] inter [2,4]; \t// var3 equals [2,4]\ncontainer var4 <- [1,2,3,4,5,6] inter [0,8]; \t// var4 equals []\ngeometry var5 <- square(10) inter circle(5); \t// var5 equals circle(5)\n```\n      \n\n#### See also: \n[remove_duplicates](OperatorsNZ#remove_duplicates), [union](OperatorsNZ#union), [+](OperatorsAC#+), [-](OperatorsAC#-), \n    \t\n----\n\n[//]: # (keyword|operator_interleave)\n### `interleave`\n\n#### Possible use: \n  *  **`interleave`** (`container`) --->  `container` \n\n#### Result: \na new list containing the interleaved elements of the containers contained in the operand  \n\n#### Comment: \nthe operand should be a list of lists of elements. The result is a list of elements.\n\n#### Examples: \n```\ncontainer var0 <- interleave([1,2,4,3,5,7,6,8]); \t// var0 equals [1,2,4,3,5,7,6,8]\ncontainer var1 <- interleave([['e11','e12','e13'],['e21','e22','e23'],['e31','e32','e33']]); \t// var1 equals ['e11','e21','e31','e12','e22','e32','e13','e23','e33']\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_internal_at)\n### `internal_at`\n\n#### Possible use: \n  * `agent` **`internal_at`** `container` --->  `unknown`\n  *  **`internal_at`** (`agent` , `container`) --->  `unknown`\n  * `geometry` **`internal_at`** `container` --->  `unknown`\n  *  **`internal_at`** (`geometry` , `container`) --->  `unknown`\n  * `container<KeyType,ValueType>` **`internal_at`** `list<KeyType>` --->  `ValueType`\n  *  **`internal_at`** (`container<KeyType,ValueType>` , `list<KeyType>`) --->  `ValueType` \n\n#### Result: \nFor internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]\nFor internal use only. Corresponds to the implementation, for geometries, of the access to containers with [index]\nFor internal use only. Corresponds to the implementation of the access to containers with [index]    \n\n#### See also: \n[at](OperatorsAC#at), \n    \t\n----\n\n[//]: # (keyword|operator_internal_integrated_value)\n### `internal_integrated_value`\n\n#### Possible use: \n  * `any expression` **`internal_integrated_value`** `any expression` --->  `container`\n  *  **`internal_integrated_value`** (`any expression` , `any expression`) --->  `container` \n\n#### Result: \nFor internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]\n    \t\n----\n\n[//]: # (keyword|operator_internal_zero_order_equation)\n### `internal_zero_order_equation`\n\n#### Possible use: \n  *  **`internal_zero_order_equation`** (`any expression`) --->  `float`\n    \t\n----\n\n[//]: # (keyword|operator_intersection)\n### `intersection`\nSame signification as [inter](OperatorsDM#inter)\n    \t\n----\n\n[//]: # (keyword|operator_intersects)\n### `intersects`\n\n#### Possible use: \n  * `geometry` **`intersects`** `geometry` --->  `bool`\n  *  **`intersects`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.\n\n#### Examples: \n```\nbool var0 <- square(5) intersects {10,10}; \t// var0 equals false\n```\n      \n\n#### See also: \n[disjoint_from](OperatorsDM#disjoint_from), [crosses](OperatorsAC#crosses), [overlaps](OperatorsNZ#overlaps), [partially_overlaps](OperatorsNZ#partially_overlaps), [touches](OperatorsNZ#touches), \n    \t\n----\n\n[//]: # (keyword|operator_inverse)\n### `inverse`\n\n#### Possible use: \n  *  **`inverse`** (`matrix`) --->  `matrix<float>` \n\n#### Result: \nThe inverse matrix of the given matrix. If no inverse exists, returns a matrix that has properties that resemble that of an inverse.\n\n#### Examples: \n```\nmatrix<float> var0 <- inverse(matrix([[5,-3],[6,-4]])); \t// var0 equals [2.0000000000000004,-0.9999999999999998]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_inverse_distance_weighting)\n### `inverse_distance_weighting`\nSame signification as [IDW](OperatorsAC#IDW)\n    \t\n----\n\n[//]: # (keyword|operator_is)\n### `is`\n\n#### Possible use: \n  * `unknown` **`is`** `any expression` --->  `bool`\n  *  **`is`** (`unknown` , `any expression`) --->  `bool` \n\n#### Result: \nreturns true if the left operand is of the right operand type, false otherwise\n\n#### Examples: \n```\nbool var0 <- 0 is int; \t// var0 equals true\nbool var1 <- an_agent is node; \t// var1 equals true\nbool var2 <- 1 is float; \t// var2 equals false\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_is_csv)\n### `is_csv`\n\n#### Possible use: \n  *  **`is_csv`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a csv file.\n    \t\n----\n\n[//]: # (keyword|operator_is_dxf)\n### `is_dxf`\n\n#### Possible use: \n  *  **`is_dxf`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a dxf file.\n    \t\n----\n\n[//]: # (keyword|operator_is_finite)\n### `is_finite`\n\n#### Possible use: \n  *  **`is_finite`** (`float`) --->  `bool` \n\n#### Result: \nReturns whether the argument is a finite number or not\n\n#### Examples: \n```\nbool var0 <- is_finite(4.66); \t// var0 equals true\nbool var1 <- is_finite(#infinity); \t// var1 equals false\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_is_gaml)\n### `is_gaml`\n\n#### Possible use: \n  *  **`is_gaml`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a gaml file.\n    \t\n----\n\n[//]: # (keyword|operator_is_geojson)\n### `is_geojson`\n\n#### Possible use: \n  *  **`is_geojson`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a geojson file.\n    \t\n----\n\n[//]: # (keyword|operator_is_gif)\n### `is_gif`\n\n#### Possible use: \n  *  **`is_gif`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a gif file.\n    \t\n----\n\n[//]: # (keyword|operator_is_grid)\n### `is_grid`\n\n#### Possible use: \n  *  **`is_grid`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a grid file.\n    \t\n----\n\n[//]: # (keyword|operator_is_image)\n### `is_image`\n\n#### Possible use: \n  *  **`is_image`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a image file.\n    \t\n----\n\n[//]: # (keyword|operator_is_json)\n### `is_json`\n\n#### Possible use: \n  *  **`is_json`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a json file.\n    \t\n----\n\n[//]: # (keyword|operator_is_number)\n### `is_number`\n\n#### Possible use: \n  *  **`is_number`** (`string`) --->  `bool`\n  *  **`is_number`** (`float`) --->  `bool` \n\n#### Result: \ntests whether the operand represents a numerical value\nReturns whether the argument is a real number or not  \n\n#### Comment: \nNote that the symbol . should be used for a float value (a string with , will not be considered as a numeric value). Symbols e and E are also accepted. A hexadecimal value should begin with #.\n\n#### Examples: \n```\nbool var0 <- is_number(\"test\"); \t// var0 equals false\nbool var1 <- is_number(\"123.56\"); \t// var1 equals true\nbool var2 <- is_number(\"-1.2e5\"); \t// var2 equals true\nbool var3 <- is_number(\"1,2\"); \t// var3 equals false\nbool var4 <- is_number(\"#12FA\"); \t// var4 equals true\nbool var5 <- is_number(4.66); \t// var5 equals true\nbool var6 <- is_number(#infinity); \t// var6 equals true\nbool var7 <- is_number(#nan); \t// var7 equals false\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_is_obj)\n### `is_obj`\n\n#### Possible use: \n  *  **`is_obj`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a obj file.\n    \t\n----\n\n[//]: # (keyword|operator_is_osm)\n### `is_osm`\n\n#### Possible use: \n  *  **`is_osm`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a osm file.\n    \t\n----\n\n[//]: # (keyword|operator_is_pgm)\n### `is_pgm`\n\n#### Possible use: \n  *  **`is_pgm`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a pgm file.\n    \t\n----\n\n[//]: # (keyword|operator_is_property)\n### `is_property`\n\n#### Possible use: \n  *  **`is_property`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a property file.\n    \t\n----\n\n[//]: # (keyword|operator_is_R)\n### `is_R`\n\n#### Possible use: \n  *  **`is_R`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a R file.\n    \t\n----\n\n[//]: # (keyword|operator_is_shape)\n### `is_shape`\n\n#### Possible use: \n  *  **`is_shape`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a shape file.\n    \t\n----\n\n[//]: # (keyword|operator_is_skill)\n### `is_skill`\n\n#### Possible use: \n  * `unknown` **`is_skill`** `string` --->  `bool`\n  *  **`is_skill`** (`unknown` , `string`) --->  `bool` \n\n#### Result: \nreturns true if the left operand is an agent whose species implements the right-hand skill name\n\n#### Examples: \n```\nbool var0 <- agentA is_skill 'moving'; \t// var0 equals true\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_is_svg)\n### `is_svg`\n\n#### Possible use: \n  *  **`is_svg`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a svg file.\n    \t\n----\n\n[//]: # (keyword|operator_is_text)\n### `is_text`\n\n#### Possible use: \n  *  **`is_text`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a text file.\n    \t\n----\n\n[//]: # (keyword|operator_is_threeds)\n### `is_threeds`\n\n#### Possible use: \n  *  **`is_threeds`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a threeds file.\n    \t\n----\n\n[//]: # (keyword|operator_is_URL)\n### `is_URL`\n\n#### Possible use: \n  *  **`is_URL`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a URL file.\n    \t\n----\n\n[//]: # (keyword|operator_is_xml)\n### `is_xml`\n\n#### Possible use: \n  *  **`is_xml`** (`any`) --->  `bool` \n\n#### Result: \nTests whether the operand is a xml file.\n    \t\n----\n\n[//]: # (keyword|operator_json_file)\n### `json_file`\n\n#### Possible use: \n  *  **`json_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type json. Allowed extensions are limited to json\n    \t\n----\n\n[//]: # (keyword|operator_kappa)\n### `kappa`\n\n#### Possible use: \n  *  **`kappa`** (`list`, `list`, `list`) --->  `float`\n  *  **`kappa`** (`list`, `list`, `list`, `list`) --->  `float` \n\n#### Result: \nkappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.\nkappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.\n\n#### Examples: \n```\nkappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3])\nfloat var1 <- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]); \t// var1 equals the similarity between 0 and 1\nfloat var2 <- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]); \t// var2 equals 1.0\nkappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_kappa_sim)\n### `kappa_sim`\n\n#### Possible use: \n  *  **`kappa_sim`** (`list`, `list`, `list`, `list`) --->  `float`\n  *  **`kappa_sim`** (`list`, `list`, `list`, `list`, `list`) --->  `float` \n\n#### Result: \nkappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8).\nkappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8)\n\n#### Examples: \n```\nkappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3])\nkappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_kmeans)\n### `kmeans`\n\n#### Possible use: \n  * `list` **`kmeans`** `int` --->  `list<list>`\n  *  **`kmeans`** (`list` , `int`) --->  `list<list>`\n  *  **`kmeans`** (`list`, `int`, `int`) --->  `list<list>` \n\n#### Result: \nreturns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k) and the maximum number of iterations to run the algorithm for (If negative, no maximum will be used) (maxIt). Usage: kmeans(data,k,maxit)\nreturns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k). Usage: kmeans(data,k)\n\n#### Special cases:     \n  * if the lengths of two vectors in the right-hand aren't equal, returns 0    \n  * if the lengths of two vectors in the right-hand aren't equal, returns 0\n\n#### Examples: \n```\nkmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2,10)\nkmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_kurtosis)\n### `kurtosis`\n\n#### Possible use: \n  *  **`kurtosis`** (`list`) --->  `float` \n\n#### Result: \nreturns kurtosis value computed from the operand list of values\n\n#### Special cases:     \n  * if the length of the list is lower than 3, returns NaN\n\n#### Examples: \n```\nkurtosis ([1,2,3,4,5])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_last)\n### `last`\n\n#### Possible use: \n  *  **`last`** (`string`) --->  `string`\n  *  **`last`** (`container<KeyType,ValueType>`) --->  `ValueType`\n  * `int` **`last`** `container` --->  `container`\n  *  **`last`** (`int` , `container`) --->  `container` \n\n#### Result: \nthe last element of the operand  \n\n#### Comment: \nthe last operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a map, last returns the value of the last pair (in insertion order)    \n  * if it is a file, last returns the last element of the content of the file (that is also a container)    \n  * if it is a population, last returns the last agent of the population    \n  * if it is a graph, last returns a list containing the last edge created    \n  * if it is a matrix, last returns the element at {length-1,length-1} in the matrix    \n  * for a matrix of int or float, it will return 0 if the matrix is empty    \n  * for a matrix of object or geometry, it will return nil if the matrix is empty    \n  * if it is a string, last returns a string composed of its last character, or an empty string if the operand is empty \n  \n```\nstring var0 <- last ('abce'); \t// var0 equals 'e'\n\n``` \n\n    \n  * if it is a list, last returns the last element of the list, or nil if the list is empty \n  \n```\nint var1 <- last ([1, 2, 3]); \t// var1 equals 3\n\n``` \n\n    \n\n#### See also: \n[first](OperatorsDM#first), \n    \t\n----\n\n[//]: # (keyword|operator_last_index_of)\n### `last_index_of`\n\n#### Possible use: \n  * `map` **`last_index_of`** `unknown` --->  `unknown`\n  *  **`last_index_of`** (`map` , `unknown`) --->  `unknown`\n  * `string` **`last_index_of`** `string` --->  `int`\n  *  **`last_index_of`** (`string` , `string`) --->  `int`\n  * `species` **`last_index_of`** `unknown` --->  `int`\n  *  **`last_index_of`** (`species` , `unknown`) --->  `int`\n  * `container` **`last_index_of`** `unknown` --->  `int`\n  *  **`last_index_of`** (`container` , `unknown`) --->  `int`\n  * `matrix` **`last_index_of`** `unknown` --->  `point`\n  *  **`last_index_of`** (`matrix` , `unknown`) --->  `point` \n\n#### Result: \nthe index of the last occurence of the right operand in the left operand container  \n\n#### Comment: \nThe definition of last_index_of and the type of the index depend on the container\n\n#### Special cases:     \n  * if the left operand is a species, the last index of an agent is the same as its index    \n  * if the left operand is a map, last_index_of returns the index as an int (the key of the pair) \n  \n```\nunknown var0 <- [1::2, 3::4, 5::4] last_index_of 4; \t// var0 equals 5\n\n``` \n\n    \n  * if both operands are strings, returns the index within the left-hand string of the rightmost occurrence of the given right-hand string \n  \n```\nint var1 <- \"abcabcabc\" last_index_of \"ca\"; \t// var1 equals 5\n\n``` \n\n    \n  * if the left operand is a list, last_index_of returns the index as an integer \n  \n```\nint var2 <- [1,2,3,4,5,6] last_index_of 4; \t// var2 equals 3\nint var3 <- [4,2,3,4,5,4] last_index_of 4; \t// var3 equals 5\n\n``` \n\n    \n  * if the left operand is a matrix, last_index_of returns the index as a point \n  \n```\npoint var4 <- matrix([[1,2,3],[4,5,4]]) last_index_of 4; \t// var4 equals {1.0,2.0}\n\n``` \n\n    \n\n#### See also: \n[at](OperatorsAC#at), [index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), \n    \t\n----\n\n[//]: # (keyword|operator_last_of)\n### `last_of`\nSame signification as [last](OperatorsDM#last)\n    \t\n----\n\n[//]: # (keyword|operator_last_with)\n### `last_with`\n\n#### Possible use: \n  * `container` **`last_with`** `any expression` --->  `unknown`\n  *  **`last_with`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe last element of the left-hand operand that makes the right-hand operand evaluate to true.  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, last_with throws an error.    \n  * If there is no element that satisfies the condition, it returns nil    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var4 <- [1::2, 3::4, 5::6] last_with (each >= 4); \t// var4 equals 6\nunknown var5 <- [1::2, 3::4, 5::6].pairs last_with (each.value >= 4); \t// var5 equals 5::6\n\n``` \n\n\n\n#### Examples: \n```\nunknown var0 <- [1,2,3,4,5,6,7,8] last_with (each > 3); \t// var0 equals 8\nunknown var2 <- g2 last_with (length(g2 out_edges_of each) = 0 ); \t// var2 equals node11\nunknown var3 <- (list(node) last_with (round(node(each).location.x) > 32); \t// var3 equals node3\n```\n      \n\n#### See also: \n[group_by](OperatorsDM#group_by), [first_with](OperatorsDM#first_with), [where](OperatorsNZ#where), \n    \t\n----\n\n[//]: # (keyword|operator_layout)\n### `layout`\n\n#### Possible use: \n  * `graph` **`layout`** `string` --->  `graph`\n  *  **`layout`** (`graph` , `string`) --->  `graph`\n  *  **`layout`** (`graph`, `string`, `int`) --->  `graph`\n  *  **`layout`** (`graph`, `string`, `int`, `map<string,unknown>`) --->  `graph` \n\n#### Result: \nlayouts a GAMA graph.\n    \t\n----\n\n[//]: # (keyword|operator_length)\n### `length`\n\n#### Possible use: \n  *  **`length`** (`string`) --->  `int`\n  *  **`length`** (`container<KeyType,ValueType>`) --->  `int` \n\n#### Result: \nthe number of elements contained in the operand  \n\n#### Comment: \nthe length operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a population, length returns number of agents of the population    \n  * if it is a graph, length returns the number of vertexes or of edges (depending on the way it was created)    \n  * if it is a string, length returns the number of characters \n  \n```\nint var0 <- length ('I am an agent'); \t// var0 equals 13\n\n``` \n\n    \n  * if it is a list or a map, length returns the number of elements in the list or map \n  \n```\nint var1 <- length([12,13]); \t// var1 equals 2\nint var2 <- length([]); \t// var2 equals 0\n\n``` \n\n    \n  * if it is a matrix, length returns the number of cells \n  \n```\nint var3 <- length(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var3 equals 6\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_line)\n### `line`\n\n#### Possible use: \n  *  **`line`** (`container<geometry>`) --->  `geometry`\n  * `container<geometry>` **`line`** `float` --->  `geometry`\n  *  **`line`** (`container<geometry>` , `float`) --->  `geometry` \n\n#### Result: \nA polyline geometry from the given list of points represented as a cylinder of radius r.\nA polyline geometry from the given list of points.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry.    \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry.    \n  * if a radius is added, the given list of points represented as a cylinder of radius r \n  \n```\ngeometry var0 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}],0.2); \t// var0 equals a polyline geometry composed of the 4 points.\n\n``` \n\n\n\n#### Examples: \n```\ngeometry var1 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var1 equals a polyline geometry composed of the 4 points.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygone](OperatorsNZ#polygone), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_link)\n### `link`\n\n#### Possible use: \n  * `geometry` **`link`** `geometry` --->  `geometry`\n  *  **`link`** (`geometry` , `geometry`) --->  `geometry` \n\n#### Result: \nA dynamic line geometry between the location of the two operands  \n\n#### Comment: \nThe geometry of the link is a line between the locations of the two operands, which is built and maintained dynamically\n\n#### Special cases:     \n  * if one of the operands is nil, link returns a point geometry at the location of the other. If both are null, it returns a point geometry at {0,0}\n\n#### Examples: \n```\ngeometry var0 <- link (geom1,geom2); \t// var0 equals a link geometry between geom1 and geom2.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_list)\n### `list`\n\n#### Possible use: \n  *  **`list`** (`any`) --->  `list` \n\n#### Result: \nCasts the operand into the type list\n    \t\n----\n\n[//]: # (keyword|operator_list_with)\n### `list_with`\n\n#### Possible use: \n  * `int` **`list_with`** `any expression` --->  `container`\n  *  **`list_with`** (`int` , `any expression`) --->  `container` \n\n#### Result: \ncreates a list with a size provided by the first operand, and filled with the second operand  \n\n#### Comment: \nNote that the right operand  should be positive, and that the second one is evaluated for each position  in the list.    \n\n#### See also: \n[list](OperatorsDM#list), \n    \t\n----\n\n[//]: # (keyword|operator_ln)\n### `ln`\n\n#### Possible use: \n  *  **`ln`** (`int`) --->  `float`\n  *  **`ln`** (`float`) --->  `float` \n\n#### Result: \nReturns the natural logarithm (base e) of the operand.\n\n#### Special cases:     \n  * an exception is raised if the operand is less than zero.\n\n#### Examples: \n```\nfloat var0 <- ln(1); \t// var0 equals 0.0\nfloat var1 <- ln(exp(1)); \t// var1 equals 1.0\n```\n      \n\n#### See also: \n[exp](OperatorsDM#exp), \n    \t\n----\n\n[//]: # (keyword|operator_load_graph_from_file)\n### `load_graph_from_file`\n\n#### Possible use: \n  *  **`load_graph_from_file`** (`string`) --->  `graph`\n  * `string` **`load_graph_from_file`** `file` --->  `graph`\n  *  **`load_graph_from_file`** (`string` , `file`) --->  `graph`\n  * `string` **`load_graph_from_file`** `string` --->  `graph`\n  *  **`load_graph_from_file`** (`string` , `string`) --->  `graph`\n  *  **`load_graph_from_file`** (`string`, `species`, `species`) --->  `graph`\n  *  **`load_graph_from_file`** (`string`, `file`, `species`, `species`) --->  `graph`\n  *  **`load_graph_from_file`** (`string`, `string`, `species`, `species`) --->  `graph`\n  *  **`load_graph_from_file`** (`string`, `string`, `species`, `species`, `bool`) --->  `graph` \n\n#### Result: \nloads a graph from a file\nreturns a graph loaded from a given file encoded into a given format. The last boolean parameter indicates whether the resulting graph will be considered as spatial or not by GAMA  \n\n#### Comment: \nAvailable formats: \"pajek\": Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.\"lgl\": LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.\"dot\": DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.\"edge\": This format is a simple text file with numeric vertex ids defining the edges.\"gexf\": GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.\"graphml\": GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details.\"tlp\" or \"tulip\": TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details. \"ncol\": This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:Available formats: \"pajek\": Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.\"lgl\": LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.\"dot\": DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.\"edge\": This format is a simple text file with numeric vertex ids defining the edges.\"gexf\": GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.\"graphml\": GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details.\"tlp\" or \"tulip\": TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details. \"ncol\": This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:\n\n#### Special cases:     \n  * \"format\": the format of the file    \n  * \"filename\": the filename of the file containing the network    \n  * \"edges_species\": the species of edges    \n  * \"vertices_specy\": the species of vertices    \n  * \"format\": the format of the file    \n  * \"filename\": the filename of the file containing the network    \n  * \"edges_species\": the species of edges    \n  * \"vertices_specy\": the species of vertices    \n  * \"format\": the format of the file, \"file\": the file containing the network, \"edges_species\": the species of edges, \"vertices_specy\": the species of vertices \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"example_of_Pajek_file\",\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy );\n\n``` \n\n    \n  * \"filename\": the filename of the file containing the network, \"edges_species\": the species of edges, \"vertices_specy\": the species of vertices \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"./example_of_Pajek_file\",\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy );\n\n``` \n\n    \n  * \"file\": the file containing the network \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"example_of_Pajek_file\");\n\n``` \n\n    \n  * \"format\": the format of the file, \"file\": the file containing the network \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"example_of_Pajek_file\");\n\n``` \n\n    \n  * \"format\": the format of the file, \"filename\": the filename of the file containing the network \n  \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"example_of_Pajek_file\");\n\n``` \n\n\n\n#### Examples: \n```\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"./example_of_Pajek_file\",\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy);\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(\n\t\t\t\"pajek\",\n\t\t\t\"./example_of_Pajek_file\",\n\t\t\tmyVertexSpecy,\n\t\t\tmyEdgeSpecy , true);\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_load_shortest_paths)\n### `load_shortest_paths`\n\n#### Possible use: \n  * `graph` **`load_shortest_paths`** `matrix` --->  `graph`\n  *  **`load_shortest_paths`** (`graph` , `matrix`) --->  `graph` \n\n#### Result: \nput in the graph cache the computed shortest paths contained in the matrix (rows: source, columns: target)\n\n#### Examples: \n```\ngraph var0 <- load_shortest_paths(shortest_paths_matrix); \t// var0 equals return my_graph with all the shortest paths computed\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_log)\n### `log`\n\n#### Possible use: \n  *  **`log`** (`float`) --->  `float`\n  *  **`log`** (`int`) --->  `float` \n\n#### Result: \nReturns the logarithm (base 10) of the operand.\n\n#### Special cases:     \n  * an exception is raised if the operand is equals or less than zero.\n\n#### Examples: \n```\nfloat var0 <- log(10); \t// var0 equals 1.0\nfloat var1 <- log(1); \t// var1 equals 0.0\n```\n      \n\n#### See also: \n[ln](OperatorsDM#ln), \n    \t\n----\n\n[//]: # (keyword|operator_lower_case)\n### `lower_case`\n\n#### Possible use: \n  *  **`lower_case`** (`string`) --->  `string` \n\n#### Result: \nConverts all of the characters in the string operand to lower case\n\n#### Examples: \n```\nstring var0 <- lower_case(\"Abc\"); \t// var0 equals 'abc'\n```\n      \n\n#### See also: \n[upper_case](OperatorsNZ#upper_case), \n    \t\n----\n\n[//]: # (keyword|operator_map)\n### `map`\n\n#### Possible use: \n  *  **`map`** (`any`) --->  `map` \n\n#### Result: \nCasts the operand into the type map\n    \t\n----\n\n[//]: # (keyword|operator_masked_by)\n### `masked_by`\n\n#### Possible use: \n  * `geometry` **`masked_by`** `container<geometry>` --->  `geometry`\n  *  **`masked_by`** (`geometry` , `container<geometry>`) --->  `geometry`\n  *  **`masked_by`** (`geometry`, `container<geometry>`, `int`) --->  `geometry`\n\n#### Examples: \n```\ngeometry var0 <- perception_geom masked_by obstacle_list; \t// var0 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.\ngeometry var1 <- perception_geom masked_by obstacle_list; \t// var1 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_material)\n### `material`\n\n#### Possible use: \n  * `float` **`material`** `float` --->  `msi.gama.util.GamaMaterial`\n  *  **`material`** (`float` , `float`) --->  `msi.gama.util.GamaMaterial` \n\n#### Result: \nReturns\n\n#### Examples: \n```\n\n```\n      \n\n#### See also: \n[](OperatorsNZ#), \n    \t\n----\n\n[//]: # (keyword|operator_matrix)\n### `matrix`\n\n#### Possible use: \n  *  **`matrix`** (`any`) --->  `matrix` \n\n#### Result: \nCasts the operand into the type matrix\n    \t\n----\n\n[//]: # (keyword|operator_matrix_with)\n### `matrix_with`\n\n#### Possible use: \n  * `point` **`matrix_with`** `any expression` --->  `matrix`\n  *  **`matrix_with`** (`point` , `any expression`) --->  `matrix` \n\n#### Result: \ncreates a matrix with a size provided by the first operand, and filled with the second operand  \n\n#### Comment: \nNote that both components of the right operand point should be positive, otherwise an exception is raised.    \n\n#### See also: \n[matrix](OperatorsDM#matrix), [as_matrix](OperatorsAC#as_matrix), \n    \t\n----\n\n[//]: # (keyword|operator_max)\n### `max`\n\n#### Possible use: \n  *  **`max`** (`container`) --->  `unknown` \n\n#### Result: \nthe maximum element found in the operand  \n\n#### Comment: \nthe max operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them    \n  * if it is a map, max returns the maximum among the list of all elements value    \n  * if it is a file, max returns the maximum of the content of the file (that is also a container)    \n  * if it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)    \n  * if it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices)    \n  * if it is a matrix of geometry, max returns the maximum of the list of the geometries    \n  * if it is a matrix of another type, max returns the maximum of the elements transformed into float    \n  * if it is a list of int of float, max returns the maximum of all the elements \n  \n```\nunknown var0 <- max ([100, 23.2, 34.5]); \t// var0 equals 100.0\n\n``` \n\n    \n  * if it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. ) \n  \n```\nunknown var1 <- max([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); \t// var1 equals {9.0,1.0}\n\n``` \n\n    \n\n#### See also: \n[min](OperatorsDM#min), \n    \t\n----\n\n[//]: # (keyword|operator_max_of)\n### `max_of`\n\n#### Possible use: \n  * `container` **`max_of`** `any expression` --->  `unknown`\n  *  **`max_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe maximum value of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * As of GAMA 1.6, if the left-hand operand is nil or empty, max_of throws an error    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var5 <- [1::2, 3::4, 5::6] max_of (each + 3); \t// var5 equals 6\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2,4,3,5,7,6,8] max_of (each * 100 ); \t// var1 equals 800\ngraph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nunknown var3 <- g2.vertices max_of (g2 degree_of( each )); \t// var3 equals 2\nunknown var4 <- (list(node) max_of (round(node(each).location.x)); \t// var4 equals 96\n```\n      \n\n#### See also: \n[min_of](OperatorsDM#min_of), \n    \t\n----\n\n[//]: # (keyword|operator_maximal_cliques_of)\n### `maximal_cliques_of`\n\n#### Possible use: \n  *  **`maximal_cliques_of`** (`graph`) --->  `list<list>` \n\n#### Result: \nreturns the maximal cliques of a graph using the Bron-Kerbosch clique detection algorithm: A clique is maximal if it is impossible to enlarge it by adding another vertex from the graph. Note that a maximal clique is not necessarily the biggest clique in the graph.\n\n#### Examples: \n```\ngraph my_graph <- graph([]);\nlist<list> var1 <- maximal_cliques_of (my_graph); \t// var1 equals the list of all the maximal cliques as list\n```\n      \n\n#### See also: \n[biggest_cliques_of](OperatorsAC#biggest_cliques_of), \n    \t\n----\n\n[//]: # (keyword|operator_mean)\n### `mean`\n\n#### Possible use: \n  *  **`mean`** (`container`) --->  `unknown` \n\n#### Result: \nthe mean of all the elements of the operand  \n\n#### Comment: \nthe elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.\n\n#### Special cases:     \n  * if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color\n\n#### Examples: \n```\nunknown var0 <- mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 5.125 \n```\n      \n\n#### See also: \n[sum](OperatorsNZ#sum), \n    \t\n----\n\n[//]: # (keyword|operator_mean_deviation)\n### `mean_deviation`\n\n#### Possible use: \n  *  **`mean_deviation`** (`container`) --->  `float` \n\n#### Result: \nthe deviation from the mean of all the elements of the operand. See <A href= \"http://en.wikipedia.org/wiki/Absolute_deviation\" >Mean_deviation</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- mean_deviation ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.125\n```\n      \n\n#### See also: \n[mean](OperatorsDM#mean), [standard_deviation](OperatorsNZ#standard_deviation), \n    \t\n----\n\n[//]: # (keyword|operator_mean_of)\n### `mean_of`\n\n#### Possible use: \n  * `container` **`mean_of`** `any expression` --->  `unknown`\n  *  **`mean_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe mean of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var2 <- [1::2, 3::4, 5::6] mean_of (each); \t// var2 equals 4\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2] mean_of (each * 10 ); \t// var1 equals 15\n```\n      \n\n#### See also: \n[min_of](OperatorsDM#min_of), [max_of](OperatorsDM#max_of), [sum_of](OperatorsNZ#sum_of), [product_of](OperatorsNZ#product_of), \n    \t\n----\n\n[//]: # (keyword|operator_meanR)\n### `meanR`\n\n#### Possible use: \n  *  **`meanR`** (`container`) --->  `unknown` \n\n#### Result: \nreturns the mean value of given vector (right-hand operand) in given variable  (left-hand operand).\n\n#### Examples: \n```\nlist<int> X <- [2, 3, 1];\nint var1 <- meanR(X); \t// var1 equals 2\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_median)\n### `median`\n\n#### Possible use: \n  *  **`median`** (`container`) --->  `unknown` \n\n#### Result: \nthe median of all the elements of the operand.\n\n#### Special cases:     \n  * if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color\n\n#### Examples: \n```\nunknown var0 <- median ([4.5, 3.5, 5.5, 3.4, 7.0]); \t// var0 equals 5.0\n```\n      \n\n#### See also: \n[mean](OperatorsDM#mean), \n    \t\n----\n\n[//]: # (keyword|operator_message)\n### `message`\n\n#### Possible use: \n  *  **`message`** (`unknown`) --->  `msi.gama.extensions.messaging.GamaMessage` \n\n#### Result: \nto be added\n    \t\n----\n\n[//]: # (keyword|operator_milliseconds_between)\n### `milliseconds_between`\n\n#### Possible use: \n  * `date` **`milliseconds_between`** `date` --->  `float`\n  *  **`milliseconds_between`** (`date` , `date`) --->  `float` \n\n#### Result: \nProvide the exact number of milliseconds between two dates. This number can be positive or negative (if the second operand is smaller than the first one)\n\n#### Examples: \n```\nmilliseconds_between(d1, d2) -: 10 \n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_min)\n### `min`\n\n#### Possible use: \n  *  **`min`** (`container`) --->  `unknown` \n\n#### Result: \nthe minimum element found in the operand.  \n\n#### Comment: \nthe min operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )    \n  * if it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them    \n  * if it is a map, min returns the minimum among the list of all elements value    \n  * if it is a file, min returns the minimum of the content of the file (that is also a container)    \n  * if it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)    \n  * if it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices)    \n  * if it is a matrix of geometry, min returns the minimum of the list of the geometries    \n  * if it is a matrix of another type, min returns the minimum of the elements transformed into float    \n  * if it is a list of int or float: min returns the minimum of all the elements \n  \n```\nunknown var0 <- min ([100, 23.2, 34.5]); \t// var0 equals 23.2\n\n``` \n\n    \n\n#### See also: \n[max](OperatorsDM#max), \n    \t\n----\n\n[//]: # (keyword|operator_min_of)\n### `min_of`\n\n#### Possible use: \n  * `container` **`min_of`** `any expression` --->  `unknown`\n  *  **`min_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe minimum value of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil or empty, min_of throws an error    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var5 <- [1::2, 3::4, 5::6] min_of (each + 3); \t// var5 equals 5\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2,4,3,5,7,6,8] min_of (each * 100 ); \t// var1 equals 100\ngraph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nunknown var3 <- g2 min_of (length(g2 out_edges_of each) ); \t// var3 equals 0\nunknown var4 <- (list(node) min_of (round(node(each).location.x)); \t// var4 equals 4\n```\n      \n\n#### See also: \n[max_of](OperatorsDM#max_of), \n    \t\n----\n\n[//]: # (keyword|operator_minus_days)\n### `minus_days`\n\n#### Possible use: \n  * `date` **`minus_days`** `int` --->  `date`\n  *  **`minus_days`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of days from a date\n\n#### Examples: \n```\ndate1 minus_days 20\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_minus_hours)\n### `minus_hours`\n\n#### Possible use: \n  * `date` **`minus_hours`** `int` --->  `date`\n  *  **`minus_hours`** (`date` , `int`) --->  `date` \n\n#### Result: \nRemove a given number of hours from a date\n\n#### Examples: \n```\ndate1 minus_hours 15 // equivalent to date1 - 15 #h\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_minus_minutes)\n### `minus_minutes`\n\n#### Possible use: \n  * `date` **`minus_minutes`** `int` --->  `date`\n  *  **`minus_minutes`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of minutes from a date\n\n#### Examples: \n```\ndate1 minus_minutes 5 // equivalent to date1 - 5#mn\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_minus_months)\n### `minus_months`\n\n#### Possible use: \n  * `date` **`minus_months`** `int` --->  `date`\n  *  **`minus_months`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of months from a date\n\n#### Examples: \n```\ndate1 minus_months 5\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_minus_ms)\n### `minus_ms`\n\n#### Possible use: \n  * `date` **`minus_ms`** `int` --->  `date`\n  *  **`minus_ms`** (`date` , `int`) --->  `date` \n\n#### Result: \nRemove a given number of milliseconds from a date\n\n#### Examples: \n```\ndate1 minus_ms 15 // equivalent to date1 - 15 #ms\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_minus_seconds)\n### `minus_seconds`\nSame signification as [-](OperatorsAC#-)\n    \t\n----\n\n[//]: # (keyword|operator_minus_weeks)\n### `minus_weeks`\n\n#### Possible use: \n  * `date` **`minus_weeks`** `int` --->  `date`\n  *  **`minus_weeks`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of weeks from a date\n\n#### Examples: \n```\ndate1 minus_weeks 15\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_minus_years)\n### `minus_years`\n\n#### Possible use: \n  * `date` **`minus_years`** `int` --->  `date`\n  *  **`minus_years`** (`date` , `int`) --->  `date` \n\n#### Result: \nSubtract a given number of year from a date\n\n#### Examples: \n```\ndate1 minus_years 3\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_mod)\n### `mod`\n\n#### Possible use: \n  * `int` **`mod`** `int` --->  `int`\n  *  **`mod`** (`int` , `int`) --->  `int` \n\n#### Result: \nReturns the remainder of the integer division of the left-hand operand by the right-hand operand.\n\n#### Special cases:     \n  * if operands are float, they are truncated    \n  * if the right-hand operand is equal to zero, raises an exception.\n\n#### Examples: \n```\nint var0 <- 40 mod 3; \t// var0 equals 1\n```\n      \n\n#### See also: \n[div](OperatorsDM#div), \n    \t\n----\n\n[//]: # (keyword|operator_months_between)\n### `months_between`\n\n#### Possible use: \n  * `date` **`months_between`** `date` --->  `int`\n  *  **`months_between`** (`date` , `date`) --->  `int` \n\n#### Result: \nProvide the exact number of months between two dates. This number can be positive or negative (if the second operand is smaller than the first one)\n\n#### Examples: \n```\nmonths_between(d1, d2) -: 10 \n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_moran)\n### `moran`\n\n#### Possible use: \n  * `list<float>` **`moran`** `matrix<float>` --->  `float`\n  *  **`moran`** (`list<float>` , `matrix<float>`) --->  `float`\n\n#### Special cases:     \n  * return the Moran Index of the given list of interest points (list of floats) and the weight matrix (matrix of float) \n  \n```\nfloat var0 <- moran([1.0, 0.5, 2.0], weight_matrix); \t// var0 equals the Moran index computed\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_mul)\n### `mul`\n\n#### Possible use: \n  *  **`mul`** (`container`) --->  `unknown` \n\n#### Result: \nthe product of all the elements of the operand  \n\n#### Comment: \nthe mul operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element)    \n  * if it is a list of other types: mul transforms all elements into integer and multiplies them    \n  * if it is a map, mul returns the product of the value of all elements    \n  * if it is a file, mul returns the product of the content of the file (that is also a container)    \n  * if it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)    \n  * if it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices)    \n  * if it is a matrix of geometry, mul returns the product of the list of the geometries    \n  * if it is a matrix of other types: mul transforms all elements into float and multiplies them    \n  * if it is a list of int or float: mul returns the product of all the elements \n  \n```\nunknown var0 <- mul ([100, 23.2, 34.5]); \t// var0 equals 80040.0\n\n``` \n\n    \n\n#### See also: \n[sum](OperatorsNZ#sum), ","url":"wiki/OperatorsDM.md"},"OperatorsNZ.md":{"title":" Operators (N to Z)","content":"#Operators (N to Z)\n \t\n----\n\n**This file is automatically generated from java files. Do Not Edit It.**\n\n----\n\n## Definition \n\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. \n\nMost of them use a classical prefixed functional syntax (i.e. `operator_name(operand1, operand2, operand3)`, see below), with the exception of arithmetic (e.g. `+`, `/`), logical (`and`, `or`), comparison (e.g. `>`, `<`), access (`.`, `[..]`) and pair (`::`) operators, which require an infixed notation (i.e. `operand1 operator_symbol operand1`). \n\nThe ternary functional if-else operator, `? :`, uses a special infixed syntax composed with two symbols (e.g. `operand1 ? operand2 : operand3`). Two unary operators (`-` and `!`) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10`, `! (operand1 or operand2)`). \n\nFinally, special constructor operators (`{...}` for constructing points, `[...]` for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. `{1,2,3}`, `[operand1, operand2, ..., operandn]` or `[key1::value1, key2::value2... keyn::valuen]`).\n\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n* if they only have one operand, the functional prefixed syntax is mandatory (e.g. `operator_name(operand1)`)\n* if they have two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2)`) or the infixed syntax (e.g. `operand1 operator_name operand2`) can be used.\n* if they have more than two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2, ..., operand)`) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. `operand1 operator_name(operand2, ..., operand)`) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\n\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the `shuffle` operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\n<br/>\n----\n\n## Priority between operators\n\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\n\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n* the constructor operators, like `::`, used to compose pairs of operands, have the lowest priority of all operators (e.g. `a > b :: b > c` will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, `[a > 10, b > 5]` will return a list of boolean values.\n* it is followed by the `?:` operator, the functional if-else (e.g. ` a > b ? a + 10 : a - 10` will return the result of the if-else).\n* next are the logical operators, `and` and `or` (e.g. `a > b or b > c` will return the value of the test)\n* next are the comparison operators (i.e. `>`, `<`, `<=`, `>=`, `=`, `!=`)\n* next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\n* next the unary operators `-` and `!`\n* next the access operators `.` and `[]` (e.g. `{1,2,3}.x > 20 + {4,5,6}.y` will return the result of the comparison between the x and y ordinates of the two points)\n* and finally the functional operators, which have the highest priority of all.\n\n----\n\n## Using actions as operators\n\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\n\nFor instance, if the following species is defined:\n\n```\nspecies spec1 {\n        int min(int x, int y) {\n                return x > y ? x : y;\n        }\n}\n```\n\nAny agent instance of spec1 can use `min` as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\n\n```\nglobal {\n        init {\n                create spec1;\n                spec1 my_agent <- spec1[0];\n                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);\n        }\n}\n```\n\nIf the action doesn't have any operands, the syntax to use is `my_agent the_action()`. Finally, if it does not return a value, it might still be used but is considering as returning a value of type `unknown` (e.g. `unknown result <- my_agent the_action(op1, op2);`).\n\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\n\t\n\n----\n\n## Table of Contents\n\n----\n\n## Operators by categories\n\t\n\n----\n\n### 3D\n[box](OperatorsAC#box), [cone3D](OperatorsAC#cone3d), [cube](OperatorsAC#cube), [cylinder](OperatorsAC#cylinder), [dem](OperatorsDM#dem), [hexagon](OperatorsDM#hexagon), [pyramid](OperatorsNZ#pyramid), [rgb_to_xyz](OperatorsNZ#rgb_to_xyz), [set_z](OperatorsNZ#set_z), [sphere](OperatorsNZ#sphere), [teapot](OperatorsNZ#teapot), \n\n----\n\n### Arithmetic operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [^](OperatorsAC#^), [*](OperatorsAC#*), [+](OperatorsAC#+), [abs](OperatorsAC#abs), [acos](OperatorsAC#acos), [asin](OperatorsAC#asin), [atan](OperatorsAC#atan), [atan2](OperatorsAC#atan2), [ceil](OperatorsAC#ceil), [cos](OperatorsAC#cos), [cos_rad](OperatorsAC#cos_rad), [div](OperatorsDM#div), [even](OperatorsDM#even), [exp](OperatorsDM#exp), [fact](OperatorsDM#fact), [floor](OperatorsDM#floor), [hypot](OperatorsDM#hypot), [is_finite](OperatorsDM#is_finite), [is_number](OperatorsDM#is_number), [ln](OperatorsDM#ln), [log](OperatorsDM#log), [mod](OperatorsDM#mod), [round](OperatorsNZ#round), [signum](OperatorsNZ#signum), [sin](OperatorsNZ#sin), [sin_rad](OperatorsNZ#sin_rad), [sqrt](OperatorsNZ#sqrt), [tan](OperatorsNZ#tan), [tan_rad](OperatorsNZ#tan_rad), [tanh](OperatorsNZ#tanh), [with_precision](OperatorsNZ#with_precision), \n\n----\n\n### BDI\n[and](OperatorsAC#and), [eval_when](OperatorsDM#eval_when), [get_about](OperatorsDM#get_about), [get_agent](OperatorsDM#get_agent), [get_agent_cause](OperatorsDM#get_agent_cause), [get_decay](OperatorsDM#get_decay), [get_dominance](OperatorsDM#get_dominance), [get_familiarity](OperatorsDM#get_familiarity), [get_intensity](OperatorsDM#get_intensity), [get_lifetime](OperatorsDM#get_lifetime), [get_liking](OperatorsDM#get_liking), [get_praiseworthiness](OperatorsDM#get_praiseworthiness), [get_priority](OperatorsDM#get_priority), [get_solidarity](OperatorsDM#get_solidarity), [get_super_intention](OperatorsDM#get_super_intention), [new_emotion](OperatorsNZ#new_emotion), [new_predicate](OperatorsNZ#new_predicate), [new_social_link](OperatorsNZ#new_social_link), [or](OperatorsNZ#or), [set_about](OperatorsNZ#set_about), [set_agent](OperatorsNZ#set_agent), [set_agent_cause](OperatorsNZ#set_agent_cause), [set_decay](OperatorsNZ#set_decay), [set_dominance](OperatorsNZ#set_dominance), [set_familiarity](OperatorsNZ#set_familiarity), [set_intensity](OperatorsNZ#set_intensity), [set_liking](OperatorsNZ#set_liking), [set_solidarity](OperatorsNZ#set_solidarity), [set_truth](OperatorsNZ#set_truth), [with_lifetime](OperatorsNZ#with_lifetime), [with_praiseworthiness](OperatorsNZ#with_praiseworthiness), [with_priority](OperatorsNZ#with_priority), [with_values](OperatorsNZ#with_values), \n\n----\n\n### Casting operators\n[as](OperatorsAC#as), [as_int](OperatorsAC#as_int), [as_matrix](OperatorsAC#as_matrix), [font](OperatorsDM#font), [is](OperatorsDM#is), [is_skill](OperatorsDM#is_skill), [list_with](OperatorsDM#list_with), [matrix_with](OperatorsDM#matrix_with), [species](OperatorsNZ#species), [to_gaml](OperatorsNZ#to_gaml), [topology](OperatorsNZ#topology), \n\n----\n\n### Color-related operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [*](OperatorsAC#*), [+](OperatorsAC#+), [blend](OperatorsAC#blend), [brewer_colors](OperatorsAC#brewer_colors), [brewer_palettes](OperatorsAC#brewer_palettes), [grayscale](OperatorsDM#grayscale), [hsb](OperatorsDM#hsb), [mean](OperatorsDM#mean), [median](OperatorsDM#median), [rgb](OperatorsNZ#rgb), [rnd_color](OperatorsNZ#rnd_color), [sum](OperatorsNZ#sum), \n\n----\n\n### Comparison operators\n[!=](OperatorsAC#!=), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [between](OperatorsAC#between), \n\n----\n\n### Containers-related operators\n[-](OperatorsAC#-), [::](OperatorsAC#::), [+](OperatorsAC#+), [accumulate](OperatorsAC#accumulate), [among](OperatorsAC#among), [at](OperatorsAC#at), [collect](OperatorsAC#collect), [contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), [count](OperatorsAC#count), [distinct](OperatorsDM#distinct), [empty](OperatorsDM#empty), [every](OperatorsDM#every), [first](OperatorsDM#first), [first_with](OperatorsDM#first_with), [get](OperatorsDM#get), [group_by](OperatorsDM#group_by), [in](OperatorsDM#in), [index_by](OperatorsDM#index_by), [inter](OperatorsDM#inter), [interleave](OperatorsDM#interleave), [internal_at](OperatorsDM#internal_at), [internal_integrated_value](OperatorsDM#internal_integrated_value), [last](OperatorsDM#last), [last_with](OperatorsDM#last_with), [length](OperatorsDM#length), [max](OperatorsDM#max), [max_of](OperatorsDM#max_of), [mean](OperatorsDM#mean), [mean_of](OperatorsDM#mean_of), [median](OperatorsDM#median), [min](OperatorsDM#min), [min_of](OperatorsDM#min_of), [mul](OperatorsDM#mul), [one_of](OperatorsNZ#one_of), [product_of](OperatorsNZ#product_of), [range](OperatorsNZ#range), [reverse](OperatorsNZ#reverse), [shuffle](OperatorsNZ#shuffle), [sort_by](OperatorsNZ#sort_by), [sum](OperatorsNZ#sum), [sum_of](OperatorsNZ#sum_of), [union](OperatorsNZ#union), [variance_of](OperatorsNZ#variance_of), [where](OperatorsNZ#where), [with_max_of](OperatorsNZ#with_max_of), [with_min_of](OperatorsNZ#with_min_of), \n\n----\n\n### Date-related operators\n[-](OperatorsAC#-), [!=](OperatorsAC#!=), [+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [after](OperatorsAC#after), [before](OperatorsAC#before), [between](OperatorsAC#between), [every](OperatorsDM#every), [milliseconds_between](OperatorsDM#milliseconds_between), [minus_days](OperatorsDM#minus_days), [minus_hours](OperatorsDM#minus_hours), [minus_minutes](OperatorsDM#minus_minutes), [minus_months](OperatorsDM#minus_months), [minus_ms](OperatorsDM#minus_ms), [minus_weeks](OperatorsDM#minus_weeks), [minus_years](OperatorsDM#minus_years), [months_between](OperatorsDM#months_between), [plus_days](OperatorsNZ#plus_days), [plus_hours](OperatorsNZ#plus_hours), [plus_minutes](OperatorsNZ#plus_minutes), [plus_months](OperatorsNZ#plus_months), [plus_ms](OperatorsNZ#plus_ms), [plus_weeks](OperatorsNZ#plus_weeks), [plus_years](OperatorsNZ#plus_years), [since](OperatorsNZ#since), [to](OperatorsNZ#to), [until](OperatorsNZ#until), [years_between](OperatorsNZ#years_between), \n\n----\n\n### Dates\n\n\n----\n\n### Driving operators\n[as_driving_graph](OperatorsAC#as_driving_graph), \n\n----\n\n### edge\n[edge_between](OperatorsDM#edge_between), \n\n----\n\n### EDP-related operators\n[diff](OperatorsDM#diff), [diff2](OperatorsDM#diff2), [internal_zero_order_equation](OperatorsDM#internal_zero_order_equation), \n\n----\n\n### Files-related operators\n[crs](OperatorsAC#crs), [file](OperatorsDM#file), [file_exists](OperatorsDM#file_exists), [folder](OperatorsDM#folder), [get](OperatorsDM#get), [new_folder](OperatorsNZ#new_folder), [osm_file](OperatorsNZ#osm_file), [read](OperatorsNZ#read), [writable](OperatorsNZ#writable), \n\n----\n\n### FIPA-related operators\n[conversation](OperatorsAC#conversation), [message](OperatorsDM#message), \n\n----\n\n### Graphs-related operators\n[add_edge](OperatorsAC#add_edge), [add_node](OperatorsAC#add_node), [adjacency](OperatorsAC#adjacency), [agent_from_geometry](OperatorsAC#agent_from_geometry), [all_pairs_shortest_path](OperatorsAC#all_pairs_shortest_path), [alpha_index](OperatorsAC#alpha_index), [as_distance_graph](OperatorsAC#as_distance_graph), [as_edge_graph](OperatorsAC#as_edge_graph), [as_intersection_graph](OperatorsAC#as_intersection_graph), [as_path](OperatorsAC#as_path), [beta_index](OperatorsAC#beta_index), [betweenness_centrality](OperatorsAC#betweenness_centrality), [biggest_cliques_of](OperatorsAC#biggest_cliques_of), [connected_components_of](OperatorsAC#connected_components_of), [connectivity_index](OperatorsAC#connectivity_index), [contains_edge](OperatorsAC#contains_edge), [contains_vertex](OperatorsAC#contains_vertex), [degree_of](OperatorsDM#degree_of), [directed](OperatorsDM#directed), [edge](OperatorsDM#edge), [edge_between](OperatorsDM#edge_between), [edge_betweenness](OperatorsDM#edge_betweenness), [edges](OperatorsDM#edges), [gamma_index](OperatorsDM#gamma_index), [generate_barabasi_albert](OperatorsDM#generate_barabasi_albert), [generate_complete_graph](OperatorsDM#generate_complete_graph), [generate_watts_strogatz](OperatorsDM#generate_watts_strogatz), [grid_cells_to_graph](OperatorsDM#grid_cells_to_graph), [in_degree_of](OperatorsDM#in_degree_of), [in_edges_of](OperatorsDM#in_edges_of), [layout](OperatorsDM#layout), [load_graph_from_file](OperatorsDM#load_graph_from_file), [load_shortest_paths](OperatorsDM#load_shortest_paths), [maximal_cliques_of](OperatorsDM#maximal_cliques_of), [nb_cycles](OperatorsNZ#nb_cycles), [neighbors_of](OperatorsNZ#neighbors_of), [node](OperatorsNZ#node), [nodes](OperatorsNZ#nodes), [out_degree_of](OperatorsNZ#out_degree_of), [out_edges_of](OperatorsNZ#out_edges_of), [path_between](OperatorsNZ#path_between), [paths_between](OperatorsNZ#paths_between), [predecessors_of](OperatorsNZ#predecessors_of), [remove_node_from](OperatorsNZ#remove_node_from), [rewire_n](OperatorsNZ#rewire_n), [source_of](OperatorsNZ#source_of), [spatial_graph](OperatorsNZ#spatial_graph), [successors_of](OperatorsNZ#successors_of), [sum](OperatorsNZ#sum), [target_of](OperatorsNZ#target_of), [undirected](OperatorsNZ#undirected), [use_cache](OperatorsNZ#use_cache), [weight_of](OperatorsNZ#weight_of), [with_optimizer_type](OperatorsNZ#with_optimizer_type), [with_weights](OperatorsNZ#with_weights), \n\n----\n\n### Grid-related operators\n[as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [grid_at](OperatorsDM#grid_at), [path_between](OperatorsNZ#path_between), \n\n----\n\n### Iterator operators\n[accumulate](OperatorsAC#accumulate), [as_map](OperatorsAC#as_map), [collect](OperatorsAC#collect), [count](OperatorsAC#count), [distribution_of](OperatorsDM#distribution_of), [distribution_of](OperatorsDM#distribution_of), [distribution_of](OperatorsDM#distribution_of), [distribution2d_of](OperatorsDM#distribution2d_of), [distribution2d_of](OperatorsDM#distribution2d_of), [distribution2d_of](OperatorsDM#distribution2d_of), [first_with](OperatorsDM#first_with), [frequency_of](OperatorsDM#frequency_of), [group_by](OperatorsDM#group_by), [index_by](OperatorsDM#index_by), [last_with](OperatorsDM#last_with), [max_of](OperatorsDM#max_of), [mean_of](OperatorsDM#mean_of), [min_of](OperatorsDM#min_of), [product_of](OperatorsNZ#product_of), [sort_by](OperatorsNZ#sort_by), [sum_of](OperatorsNZ#sum_of), [variance_of](OperatorsNZ#variance_of), [where](OperatorsNZ#where), [with_max_of](OperatorsNZ#with_max_of), [with_min_of](OperatorsNZ#with_min_of), \n\n----\n\n### List-related operators\n[copy_between](OperatorsAC#copy_between), [index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), \n\n----\n\n### Logical operators\n[:](OperatorsAC#:), [!](OperatorsAC#!), [?](OperatorsAC#?), [and](OperatorsAC#and), [or](OperatorsNZ#or), \n\n----\n\n### Map comparaison operators\n[fuzzy_kappa](OperatorsDM#fuzzy_kappa), [fuzzy_kappa_sim](OperatorsDM#fuzzy_kappa_sim), [kappa](OperatorsDM#kappa), [kappa_sim](OperatorsDM#kappa_sim), [percent_absolute_deviation](OperatorsNZ#percent_absolute_deviation), \n\n----\n\n### Map-related operators\n[as_map](OperatorsAC#as_map), [index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), \n\n----\n\n### Material\n[material](OperatorsDM#material), \n\n----\n\n### Matrix-related operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [.](OperatorsAC#.), [*](OperatorsAC#*), [+](OperatorsAC#+), [append_horizontally](OperatorsAC#append_horizontally), [append_vertically](OperatorsAC#append_vertically), [column_at](OperatorsAC#column_at), [columns_list](OperatorsAC#columns_list), [determinant](OperatorsDM#determinant), [eigenvalues](OperatorsDM#eigenvalues), [index_of](OperatorsDM#index_of), [inverse](OperatorsDM#inverse), [last_index_of](OperatorsDM#last_index_of), [row_at](OperatorsNZ#row_at), [rows_list](OperatorsNZ#rows_list), [shuffle](OperatorsNZ#shuffle), [trace](OperatorsNZ#trace), [transpose](OperatorsNZ#transpose), \n\n----\n\n### multicriteria operators\n[electre_DM](OperatorsDM#electre_dm), [evidence_theory_DM](OperatorsDM#evidence_theory_dm), [promethee_DM](OperatorsNZ#promethee_dm), [weighted_means_DM](OperatorsNZ#weighted_means_dm), \n\n----\n\n### Path-related operators\n[agent_from_geometry](OperatorsAC#agent_from_geometry), [all_pairs_shortest_path](OperatorsAC#all_pairs_shortest_path), [as_path](OperatorsAC#as_path), [load_shortest_paths](OperatorsDM#load_shortest_paths), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [paths_between](OperatorsNZ#paths_between), [use_cache](OperatorsNZ#use_cache), \n\n----\n\n### Points-related operators\n[-](OperatorsAC#-), [/](OperatorsAC#/), [*](OperatorsAC#*), [+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [add_point](OperatorsAC#add_point), [angle_between](OperatorsAC#angle_between), [any_location_in](OperatorsAC#any_location_in), [centroid](OperatorsAC#centroid), [closest_points_with](OperatorsAC#closest_points_with), [farthest_point_to](OperatorsDM#farthest_point_to), [grid_at](OperatorsDM#grid_at), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [points_along](OperatorsNZ#points_along), [points_at](OperatorsNZ#points_at), [points_on](OperatorsNZ#points_on), \n\n----\n\n### Random operators\n[binomial](OperatorsAC#binomial), [flip](OperatorsDM#flip), [gauss](OperatorsDM#gauss), [poisson](OperatorsNZ#poisson), [rnd](OperatorsNZ#rnd), [rnd_choice](OperatorsNZ#rnd_choice), [sample](OperatorsNZ#sample), [shuffle](OperatorsNZ#shuffle), [skew_gauss](OperatorsNZ#skew_gauss), [truncated_gauss](OperatorsNZ#truncated_gauss), \n\n----\n\n### ReverseOperators\n\n\n----\n\n### Shape\n[arc](OperatorsAC#arc), [box](OperatorsAC#box), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [cone3D](OperatorsAC#cone3d), [cross](OperatorsAC#cross), [cube](OperatorsAC#cube), [curve](OperatorsAC#curve), [cylinder](OperatorsAC#cylinder), [ellipse](OperatorsDM#ellipse), [envelope](OperatorsDM#envelope), [geometry_collection](OperatorsDM#geometry_collection), [hexagon](OperatorsDM#hexagon), [line](OperatorsDM#line), [link](OperatorsDM#link), [plan](OperatorsNZ#plan), [polygon](OperatorsNZ#polygon), [polyhedron](OperatorsNZ#polyhedron), [pyramid](OperatorsNZ#pyramid), [rectangle](OperatorsNZ#rectangle), [sphere](OperatorsNZ#sphere), [square](OperatorsNZ#square), [squircle](OperatorsNZ#squircle), [teapot](OperatorsNZ#teapot), [triangle](OperatorsNZ#triangle), \n\n----\n\n### Spatial operators\n[-](OperatorsAC#-), [*](OperatorsAC#*), [+](OperatorsAC#+), [add_point](OperatorsAC#add_point), [agent_closest_to](OperatorsAC#agent_closest_to), [agent_farthest_to](OperatorsAC#agent_farthest_to), [agents_at_distance](OperatorsAC#agents_at_distance), [agents_inside](OperatorsAC#agents_inside), [agents_overlapping](OperatorsAC#agents_overlapping), [angle_between](OperatorsAC#angle_between), [any_location_in](OperatorsAC#any_location_in), [arc](OperatorsAC#arc), [around](OperatorsAC#around), [as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [at_distance](OperatorsAC#at_distance), [at_location](OperatorsAC#at_location), [box](OperatorsAC#box), [centroid](OperatorsAC#centroid), [circle](OperatorsAC#circle), [clean](OperatorsAC#clean), [closest_points_with](OperatorsAC#closest_points_with), [closest_to](OperatorsAC#closest_to), [cone](OperatorsAC#cone), [cone3D](OperatorsAC#cone3d), [convex_hull](OperatorsAC#convex_hull), [covers](OperatorsAC#covers), [cross](OperatorsAC#cross), [crosses](OperatorsAC#crosses), [crs](OperatorsAC#crs), [CRS_transform](OperatorsAC#crs_transform), [cube](OperatorsAC#cube), [curve](OperatorsAC#curve), [cylinder](OperatorsAC#cylinder), [dem](OperatorsDM#dem), [direction_between](OperatorsDM#direction_between), [disjoint_from](OperatorsDM#disjoint_from), [distance_between](OperatorsDM#distance_between), [distance_to](OperatorsDM#distance_to), [ellipse](OperatorsDM#ellipse), [envelope](OperatorsDM#envelope), [farthest_point_to](OperatorsDM#farthest_point_to), [farthest_to](OperatorsDM#farthest_to), [geometry_collection](OperatorsDM#geometry_collection), [gini](OperatorsDM#gini), [hexagon](OperatorsDM#hexagon), [hierarchical_clustering](OperatorsDM#hierarchical_clustering), [IDW](OperatorsAC#idw), [inside](OperatorsDM#inside), [inter](OperatorsDM#inter), [intersects](OperatorsDM#intersects), [line](OperatorsDM#line), [link](OperatorsDM#link), [masked_by](OperatorsDM#masked_by), [moran](OperatorsDM#moran), [neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [overlapping](OperatorsNZ#overlapping), [overlaps](OperatorsNZ#overlaps), [partially_overlaps](OperatorsNZ#partially_overlaps), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [plan](OperatorsNZ#plan), [points_along](OperatorsNZ#points_along), [points_at](OperatorsNZ#points_at), [points_on](OperatorsNZ#points_on), [polygon](OperatorsNZ#polygon), [polyhedron](OperatorsNZ#polyhedron), [pyramid](OperatorsNZ#pyramid), [rectangle](OperatorsNZ#rectangle), [rgb_to_xyz](OperatorsNZ#rgb_to_xyz), [rotated_by](OperatorsNZ#rotated_by), [round](OperatorsNZ#round), [scaled_to](OperatorsNZ#scaled_to), [set_z](OperatorsNZ#set_z), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), [simplification](OperatorsNZ#simplification), [skeletonize](OperatorsNZ#skeletonize), [smooth](OperatorsNZ#smooth), [sphere](OperatorsNZ#sphere), [split_at](OperatorsNZ#split_at), [split_geometry](OperatorsNZ#split_geometry), [split_lines](OperatorsNZ#split_lines), [square](OperatorsNZ#square), [squircle](OperatorsNZ#squircle), [teapot](OperatorsNZ#teapot), [to_GAMA_CRS](OperatorsNZ#to_gama_crs), [to_rectangles](OperatorsNZ#to_rectangles), [to_squares](OperatorsNZ#to_squares), [touches](OperatorsNZ#touches), [towards](OperatorsNZ#towards), [transformed_by](OperatorsNZ#transformed_by), [translated_by](OperatorsNZ#translated_by), [triangle](OperatorsNZ#triangle), [triangulate](OperatorsNZ#triangulate), [union](OperatorsNZ#union), [using](OperatorsNZ#using), [voronoi](OperatorsNZ#voronoi), [with_precision](OperatorsNZ#with_precision), [without_holes](OperatorsNZ#without_holes), \n\n----\n\n### Spatial properties operators\n[covers](OperatorsAC#covers), [crosses](OperatorsAC#crosses), [intersects](OperatorsDM#intersects), [partially_overlaps](OperatorsNZ#partially_overlaps), [touches](OperatorsNZ#touches), \n\n----\n\n### Spatial queries operators\n[agent_closest_to](OperatorsAC#agent_closest_to), [agent_farthest_to](OperatorsAC#agent_farthest_to), [agents_at_distance](OperatorsAC#agents_at_distance), [agents_inside](OperatorsAC#agents_inside), [agents_overlapping](OperatorsAC#agents_overlapping), [at_distance](OperatorsAC#at_distance), [closest_to](OperatorsAC#closest_to), [farthest_to](OperatorsDM#farthest_to), [inside](OperatorsDM#inside), [neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [overlapping](OperatorsNZ#overlapping), \n\n----\n\n### Spatial relations operators\n[direction_between](OperatorsDM#direction_between), [distance_between](OperatorsDM#distance_between), [distance_to](OperatorsDM#distance_to), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), [towards](OperatorsNZ#towards), \n\n----\n\n### Spatial statistical operators\n[hierarchical_clustering](OperatorsDM#hierarchical_clustering), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), \n\n----\n\n### Spatial transformations operators\n[-](OperatorsAC#-), [*](OperatorsAC#*), [+](OperatorsAC#+), [as_4_grid](OperatorsAC#as_4_grid), [as_grid](OperatorsAC#as_grid), [as_hexagonal_grid](OperatorsAC#as_hexagonal_grid), [at_location](OperatorsAC#at_location), [clean](OperatorsAC#clean), [convex_hull](OperatorsAC#convex_hull), [CRS_transform](OperatorsAC#crs_transform), [rotated_by](OperatorsNZ#rotated_by), [scaled_to](OperatorsNZ#scaled_to), [simplification](OperatorsNZ#simplification), [skeletonize](OperatorsNZ#skeletonize), [smooth](OperatorsNZ#smooth), [split_geometry](OperatorsNZ#split_geometry), [split_lines](OperatorsNZ#split_lines), [to_GAMA_CRS](OperatorsNZ#to_gama_crs), [to_rectangles](OperatorsNZ#to_rectangles), [to_squares](OperatorsNZ#to_squares), [transformed_by](OperatorsNZ#transformed_by), [translated_by](OperatorsNZ#translated_by), [triangulate](OperatorsNZ#triangulate), [voronoi](OperatorsNZ#voronoi), [without_holes](OperatorsNZ#without_holes), \n\n----\n\n### Species-related operators\n[index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), [of_generic_species](OperatorsNZ#of_generic_species), [of_species](OperatorsNZ#of_species), \n\n----\n\n### Statistical operators\n[build](OperatorsAC#build), [corR](OperatorsAC#corr), [dbscan](OperatorsDM#dbscan), [distribution_of](OperatorsDM#distribution_of), [distribution2d_of](OperatorsDM#distribution2d_of), [frequency_of](OperatorsDM#frequency_of), [gamma_rnd](OperatorsDM#gamma_rnd), [geometric_mean](OperatorsDM#geometric_mean), [gini](OperatorsDM#gini), [harmonic_mean](OperatorsDM#harmonic_mean), [hierarchical_clustering](OperatorsDM#hierarchical_clustering), [kmeans](OperatorsDM#kmeans), [kurtosis](OperatorsDM#kurtosis), [max](OperatorsDM#max), [mean](OperatorsDM#mean), [mean_deviation](OperatorsDM#mean_deviation), [meanR](OperatorsDM#meanr), [median](OperatorsDM#median), [min](OperatorsDM#min), [moran](OperatorsDM#moran), [mul](OperatorsDM#mul), [predict](OperatorsNZ#predict), [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance), [skewness](OperatorsNZ#skewness), [standard_deviation](OperatorsNZ#standard_deviation), [sum](OperatorsNZ#sum), [variance](OperatorsNZ#variance), \n\n----\n\n### Strings-related operators\n[+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [at](OperatorsAC#at), [char](OperatorsAC#char), [contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), [copy_between](OperatorsAC#copy_between), [date](OperatorsDM#date), [empty](OperatorsDM#empty), [first](OperatorsDM#first), [in](OperatorsDM#in), [indented_by](OperatorsDM#indented_by), [index_of](OperatorsDM#index_of), [is_number](OperatorsDM#is_number), [last](OperatorsDM#last), [last_index_of](OperatorsDM#last_index_of), [length](OperatorsDM#length), [lower_case](OperatorsDM#lower_case), [replace](OperatorsNZ#replace), [replace_regex](OperatorsNZ#replace_regex), [reverse](OperatorsNZ#reverse), [sample](OperatorsNZ#sample), [shuffle](OperatorsNZ#shuffle), [split_with](OperatorsNZ#split_with), [string](OperatorsNZ#string), [upper_case](OperatorsNZ#upper_case), \n\n----\n\n### System\n[.](OperatorsAC#.), [command](OperatorsAC#command), [copy](OperatorsAC#copy), [dead](OperatorsDM#dead), [eval_gaml](OperatorsDM#eval_gaml), [every](OperatorsDM#every), [user_input](OperatorsNZ#user_input), \n\n----\n\n### Time-related operators\n[date](OperatorsDM#date), [string](OperatorsNZ#string), \n\n----\n\n### Types-related operators\n\n\n----\n\n### User control operators\n[user_input](OperatorsNZ#user_input), \n\t\n----\n\n## Operators\n\t\n    \t\n----\n\n[//]: # (keyword|operator_nb_cycles)\n### `nb_cycles`\n\n#### Possible use: \n  *  **`nb_cycles`** (`graph`) --->  `int` \n\n#### Result: \nreturns the maximum number of independent cycles in a graph. This number (u) is estimated through the number of nodes (v), links (e) and of sub-graphs (p): u = e - v + p.\n\n#### Examples: \n```\ngraph graphEpidemio <- graph([]);\nint var1 <- nb_cycles(graphEpidemio); \t// var1 equals the number of cycles in the graph\n```\n      \n\n#### See also: \n[alpha_index](OperatorsAC#alpha_index), [beta_index](OperatorsAC#beta_index), [gamma_index](OperatorsDM#gamma_index), [connectivity_index](OperatorsAC#connectivity_index), \n    \t\n----\n\n[//]: # (keyword|operator_neighbors_at)\n### `neighbors_at`\n\n#### Possible use: \n  * `geometry` **`neighbors_at`** `float` --->  `container`\n  *  **`neighbors_at`** (`geometry` , `float`) --->  `container` \n\n#### Result: \na list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).  \n\n#### Comment: \nThe topology used to compute the neighborhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.\n\n#### Examples: \n```\ncontainer var0 <- (self neighbors_at (10)); \t// var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator.\n```\n      \n\n#### See also: \n[neighbors_of](OperatorsNZ#neighbors_of), [closest_to](OperatorsAC#closest_to), [overlapping](OperatorsNZ#overlapping), [agents_overlapping](OperatorsAC#agents_overlapping), [agents_inside](OperatorsAC#agents_inside), [agent_closest_to](OperatorsAC#agent_closest_to), [at_distance](OperatorsAC#at_distance), \n    \t\n----\n\n[//]: # (keyword|operator_neighbors_of)\n### `neighbors_of`\n\n#### Possible use: \n  * `graph` **`neighbors_of`** `unknown` --->  `container`\n  *  **`neighbors_of`** (`graph` , `unknown`) --->  `container`\n  * `topology` **`neighbors_of`** `agent` --->  `container`\n  *  **`neighbors_of`** (`topology` , `agent`) --->  `container`\n  *  **`neighbors_of`** (`topology`, `geometry`, `float`) --->  `container` \n\n#### Result: \na list, containing all the agents of the same species than the argument (if it is an agent) located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.\n\n#### Special cases:     \n  * a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the third argument to the second argument (agent, geometry or point) considering the first operand topology. \n  \n```\ncontainer var3 <- neighbors_of (topology(self), self,10); \t// var3 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.\n\n``` \n\n\n\n#### Examples: \n```\ncontainer var0 <- graphEpidemio neighbors_of (node(3)); \t// var0 equals [node0,node2]\ncontainer var1 <- graphFromMap neighbors_of node({12,45}); \t// var1 equals [{1.0,5.0},{34.0,56.0}]\ncontainer var2 <- topology(self) neighbors_of self; \t// var2 equals returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology.\n```\n      \n\n#### See also: \n[predecessors_of](OperatorsNZ#predecessors_of), [successors_of](OperatorsNZ#successors_of), [neighbors_at](OperatorsNZ#neighbors_at), [closest_to](OperatorsAC#closest_to), [overlapping](OperatorsNZ#overlapping), [agents_overlapping](OperatorsAC#agents_overlapping), [agents_inside](OperatorsAC#agents_inside), [agent_closest_to](OperatorsAC#agent_closest_to), \n    \t\n----\n\n[//]: # (keyword|operator_new_emotion)\n### `new_emotion`\n\n#### Possible use: \n  *  **`new_emotion`** (`string`) --->  `emotion`\n  * `string` **`new_emotion`** `agent` --->  `emotion`\n  *  **`new_emotion`** (`string` , `agent`) --->  `emotion`\n  * `string` **`new_emotion`** `float` --->  `emotion`\n  *  **`new_emotion`** (`string` , `float`) --->  `emotion`\n  * `string` **`new_emotion`** `predicate` --->  `emotion`\n  *  **`new_emotion`** (`string` , `predicate`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `predicate`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `float`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `predicate`, `agent`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `agent`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `float`, `agent`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `predicate`, `float`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `predicate`, `agent`) --->  `emotion`\n  *  **`new_emotion`** (`string`, `float`, `predicate`, `float`, `agent`) --->  `emotion` \n\n#### Result: \na new emotion with the given properties (name)\na new emotion with the given properties (name)\na new emotion with the given properties (name,intensity,about)\na new emotion with the given properties (name,intensity,decay)\na new emotion with the given properties (name)\na new emotion with the given properties (name, intensity)\na new emotion with the given properties (name,about)\na new emotion with the given properties (name)\na new emotion with the given properties (name)\na new emotion with the given properties (name)\na new emotion with the given properties (name)\na new emotion with the given properties (name)\n\n#### Examples: \n```\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood)\nemotion(\"joy\",12.3,4)\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3)\nemotion(\"joy\",eatFood)\nemotion(\"joy\")\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood,4)\nemotion(\"joy\",12.3,eatFood,4)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_new_folder)\n### `new_folder`\n\n#### Possible use: \n  *  **`new_folder`** (`string`) --->  `file` \n\n#### Result: \nopens an existing repository or create a new folder if it does not exist.\n\n#### Special cases:     \n  * If the specified string does not refer to an existing repository, the repository is created.    \n  * If the string refers to an existing file, an exception is risen.\n\n#### Examples: \n```\nfile dirNewT <- new_folder(\"incl/\");   \t// dirNewT represents the repository \"../incl/\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// eventually creates the directory ../incl\n```\n      \n\n#### See also: \n[folder](OperatorsDM#folder), [file](OperatorsDM#file), \n    \t\n----\n\n[//]: # (keyword|operator_new_predicate)\n### `new_predicate`\n\n#### Possible use: \n  *  **`new_predicate`** (`string`) --->  `predicate`\n  * `string` **`new_predicate`** `agent` --->  `predicate`\n  *  **`new_predicate`** (`string` , `agent`) --->  `predicate`\n  * `string` **`new_predicate`** `float` --->  `predicate`\n  *  **`new_predicate`** (`string` , `float`) --->  `predicate`\n  * `string` **`new_predicate`** `int` --->  `predicate`\n  *  **`new_predicate`** (`string` , `int`) --->  `predicate`\n  * `string` **`new_predicate`** `map` --->  `predicate`\n  *  **`new_predicate`** (`string` , `map`) --->  `predicate`\n  * `string` **`new_predicate`** `bool` --->  `predicate`\n  *  **`new_predicate`** (`string` , `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `int`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `int`, `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `bool`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `int`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `int`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `int`, `bool`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `int`, `bool`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `bool`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `int`, `agent`) --->  `predicate`\n  *  **`new_predicate`** (`string`, `map`, `float`, `int`, `bool`, `agent`) --->  `predicate` \n\n#### Result: \na new predicate with the given properties (name, values, lifetime, is_true)\na new predicate with the given properties (name, values, priority)\na new predicate with the given properties (name, values, priority, lifetime, is_true, agentCause)\na new predicate with the given properties (name, values, is_true, agentCause)\na new predicate with the given properties (name, values, lifetime)\na new predicate with the given properties (name, values, priority, lifetime, is_true)\na new predicate with the given properties (name, values, lifetime, is_true, agentCause)\na new predicate with the given is_true (name, priority)\na new predicate with the given is_true (name, lifetime)\na new predicate with the given properties (name, values)\na new predicate with the given properties (name, values, lifetime)\na new predicate with the given is_true (name, is_true)\na new predicate with the given properties (name, values, priority,lifetime)\na new predicate with the given properties (name, values, priority, is_true, agentCause)\na new predicate with the given properties (name, values, \tagentCause)\na new predicate with the given properties (name, values, lifetime, agentCause)\na new predicate with the given properties (name)\na new predicate with the given properties (name, values, priority, agentCause)\na new predicate with the given properties (name, values, priority, is_true)\na new predicate with the given properties (name, values, priority, lifetime, agentCause)\na new predicate with the given properties (name, values, is_true)\n\n#### Examples: \n```\npredicate(\"people to meet\", [\"time\"::10], 10,true)\npredicate(\"people to meet\", people1, [\"time\"::10])\npredicate(\"people to meet\", [\"time\"::10],2.0,10, true, agentA)\npredicate(\"people to meet\", [\"time\"::10], true, agentA)\npredicate(\"people to meet\", [\"time\"::10], true)\npredicate(\"people to meet\", [\"time\"::10],2.0,10, true)\npredicate(\"people to meet\", [\"time\"::10], 10, true, agentA)\npredicate(\"hasWater\", 2.0 )\npredicate(\"hasWater\", 10 \npredicate(\"people to meet\", people1 )\npredicate(\"people to meet\", [\"time\"::10], true)\npredicate(\"hasWater\", true)\npredicate(\"people to meet\", [\"time\"::10], 2.0,10)\npredicate(\"people to meet\", [\"time\"::10], 2.0, true, agentA)\npredicate(\"people to meet\", [\"time\"::10], agentA)\npredicate(\"people to meet\", [\"time\"::10], 10, agentA)\npredicate(\"people to meet\")\npredicate(\"people to meet\", [\"time\"::10], 2.0,agentA)\npredicate(\"people to meet\", [\"time\"::10],2.0, true)\npredicate(\"people to meet\", [\"time\"::10], 2.0,10,agentA)\npredicate(\"people to meet\", [\"time\"::10], true)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_new_social_link)\n### `new_social_link`\n\n#### Possible use: \n  *  **`new_social_link`** (`agent`) --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`new_social_link`** (`agent`, `float`, `float`, `float`, `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \na new social link\na new social link\n\n#### Examples: \n```\nnew_social_link(agentA)\nnew_social_link(agentA,0.0,-0.1,0.2,0.1)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_node)\n### `node`\n\n#### Possible use: \n  *  **`node`** (`unknown`) --->  `unknown`\n  * `unknown` **`node`** `float` --->  `unknown`\n  *  **`node`** (`unknown` , `float`) --->  `unknown`\n    \t\n----\n\n[//]: # (keyword|operator_nodes)\n### `nodes`\n\n#### Possible use: \n  *  **`nodes`** (`container`) --->  `container`\n    \t\n----\n\n[//]: # (keyword|operator_norm)\n### `norm`\n\n#### Possible use: \n  *  **`norm`** (`point`) --->  `float` \n\n#### Result: \nthe norm of the vector with the coordinates of the point operand.\n\n#### Examples: \n```\nfloat var0 <- norm({3,4}); \t// var0 equals 5.0\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_not)\n### `not`\nSame signification as [!](OperatorsAC#!)\n    \t\n----\n\n[//]: # (keyword|operator_obj_file)\n### `obj_file`\n\n#### Possible use: \n  *  **`obj_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type obj. Allowed extensions are limited to obj, OBJ\n    \t\n----\n\n[//]: # (keyword|operator_of)\n### `of`\nSame signification as [.](OperatorsAC#.)\n    \t\n----\n\n[//]: # (keyword|operator_of_generic_species)\n### `of_generic_species`\n\n#### Possible use: \n  * `container` **`of_generic_species`** `species` --->  `container`\n  *  **`of_generic_species`** (`container` , `species`) --->  `container` \n\n#### Result: \na list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand species\n\n#### Examples: \n```\n// species test {}\n// species sous_test parent: test {}\ncontainer var2 <- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species test; \t// var2 equals [sous_test0,sous_test1,test2,test3]\ncontainer var3 <- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species sous_test; \t// var3 equals [sous_test0,sous_test1]\ncontainer var4 <- [sous_test(0),sous_test(1),test(2),test(3)] of_species test; \t// var4 equals [test2,test3]\ncontainer var5 <- [sous_test(0),sous_test(1),test(2),test(3)] of_species sous_test; \t// var5 equals [sous_test0,sous_test1]\n```\n      \n\n#### See also: \n[of_species](OperatorsNZ#of_species), \n    \t\n----\n\n[//]: # (keyword|operator_of_species)\n### `of_species`\n\n#### Possible use: \n  * `container` **`of_species`** `species` --->  `container`\n  *  **`of_species`** (`container` , `species`) --->  `container` \n\n#### Result: \na list, containing the agents of the left-hand operand whose species is the one denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitly if it is to be used in an ask statement, for instance).\n\n#### Special cases:     \n  * if the right operand is nil, of_species returns the right operand\n\n#### Examples: \n```\ncontainer var0 <- (self neighbors_at 10) of_species (species (self)); \t// var0 equals all the neighboring agents of the same species.\ncontainer var1 <- [test(0),test(1),node(1),node(2)] of_species test; \t// var1 equals [test0,test1]\n```\n      \n\n#### See also: \n[of_generic_species](OperatorsNZ#of_generic_species), \n    \t\n----\n\n[//]: # (keyword|operator_one_of)\n### `one_of`\n\n#### Possible use: \n  *  **`one_of`** (`container<KeyType,ValueType>`) --->  `ValueType` \n\n#### Result: \none of the values stored in this container  at a random key  \n\n#### Comment: \nthe one_of operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a graph, one_of returns one of the lists of edges    \n  * if it is a file, one_of returns one of the elements of the content of the file (that is also a container)    \n  * if the operand is empty, one_of returns nil \n  \n```\n\n``` \n\n    \n  * if it is a list or a matrix, one_of returns one of the values of the list or of the matrix \n  \n```\nint i <- any ([1,2,3]); \t// i equals 1, 2 or 3\nstring sMat <- one_of(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// sMat equals \"c11\",\"c12\",\"c13\", \"c21\",\"c22\" or \"c23\"\n\n``` \n\n    \n  * if it is a map, one_of returns one the value of a random pair of the map \n  \n```\nint im <- one_of ([2::3, 4::5, 6::7]);\t// im equals 3, 5 or 7\nbool var6 <- [2::3, 4::5, 6::7].values contains im; \t// var6 equals true\n\n``` \n\n    \n  * if it is a population, one_of returns one of the agents of the population \n  \n```\nbug b <- one_of(bug);  \t// Given a previously defined species bug, b is one of the created bugs, e.g. bug3\n\n``` \n\n    \n\n#### See also: \n[contains](OperatorsAC#contains), \n    \t\n----\n\n[//]: # (keyword|operator_or)\n### `or`\n\n#### Possible use: \n  * `bool` **`or`** `any expression` --->  `bool`\n  *  **`or`** (`bool` , `any expression`) --->  `bool` \n\n#### Result: \na bool value, equal to the logical or between the left-hand operand and the right-hand operand.  \n\n#### Comment: \nboth operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.    \n\n#### See also: \n[bool](OperatorsAC#bool), [and](OperatorsAC#and), [!](OperatorsAC#!), \n    \t\n----\n\n[//]: # (keyword|operator_or)\n### `or`\n\n#### Possible use: \n  * `predicate` **`or`** `predicate` --->  `predicate`\n  *  **`or`** (`predicate` , `predicate`) --->  `predicate` \n\n#### Result: \ncreate a new predicate from two others by including them as subintentions. It's an exclusive \"or\"\n\n#### Examples: \n```\npredicate1 or predicate2\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_osm_file)\n### `osm_file`\n\n#### Possible use: \n  * `string` **`osm_file`** `map<string,list>` --->  `file`\n  *  **`osm_file`** (`string` , `map<string,list>`) --->  `file`\n  *  **`osm_file`** (`string`, `map<string,list>`, `int`) --->  `file` \n\n#### Result: \nopens a file that a is a kind of OSM file with some filtering.\nopens a file that a is a kind of OSM file with some filtering, forcing the initial CRS to be the one indicated by the second int parameter (see http://spatialreference.org/ref/epsg/). If this int parameter is equal to 0, the data is considered as already projected.  \n\n#### Comment: \nThe file should have a OSM file extension, cf. file type definition for supported file extensions.The file should have a OSM file extension, cf. file type definition for supported file extensions.\n\n#### Special cases:     \n  * If the specified string does not refer to an existing OSM file, an exception is risen.    \n  * If the specified string does not refer to an existing OSM file, an exception is risen.\n\n#### Examples: \n```\nfile myOSMfile <- osm_file(\"../includes/rouen.osm\", [\"highway\"::[\"primary\",\"motorway\"]]);\nfile myOSMfile2 <- osm_file(\"../includes/rouen.osm\",[\"highway\"::[\"primary\",\"motorway\"]], 0);\n```\n      \n\n#### See also: \n[file](OperatorsDM#file), \n    \t\n----\n\n[//]: # (keyword|operator_out_degree_of)\n### `out_degree_of`\n\n#### Possible use: \n  * `graph` **`out_degree_of`** `unknown` --->  `int`\n  *  **`out_degree_of`** (`graph` , `unknown`) --->  `int` \n\n#### Result: \nreturns the out degree of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\nint var1 <- graphFromMap out_degree_of (node(3)); \t// var1 equals 4\n```\n      \n\n#### See also: \n[in_degree_of](OperatorsDM#in_degree_of), [degree_of](OperatorsDM#degree_of), \n    \t\n----\n\n[//]: # (keyword|operator_out_edges_of)\n### `out_edges_of`\n\n#### Possible use: \n  * `graph` **`out_edges_of`** `unknown` --->  `container`\n  *  **`out_edges_of`** (`graph` , `unknown`) --->  `container` \n\n#### Result: \nreturns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.\n\n#### Examples: \n```\ncontainer var1 <- graphFromMap out_edges_of (node(3)); \t// var1 equals 3\n```\n      \n\n#### See also: \n[in_edges_of](OperatorsDM#in_edges_of), \n    \t\n----\n\n[//]: # (keyword|operator_overlapping)\n### `overlapping`\n\n#### Possible use: \n  * `container<agent>` **`overlapping`** `geometry` --->  `list<geometry>`\n  *  **`overlapping`** (`container<agent>` , `geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), overlapping the operand (casted as a geometry).\n\n#### Examples: \n```\nlist<geometry> var0 <- [ag1, ag2, ag3] overlapping(self); \t// var0 equals return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator.\n(species1 + species2) overlapping self\n```\n      \n\n#### See also: \n[neighbors_at](OperatorsNZ#neighbors_at), [neighbors_of](OperatorsNZ#neighbors_of), [agent_closest_to](OperatorsAC#agent_closest_to), [agents_inside](OperatorsAC#agents_inside), [closest_to](OperatorsAC#closest_to), [inside](OperatorsDM#inside), [agents_overlapping](OperatorsAC#agents_overlapping), \n    \t\n----\n\n[//]: # (keyword|operator_overlaps)\n### `overlaps`\n\n#### Possible use: \n  * `geometry` **`overlaps`** `geometry` --->  `bool`\n  *  **`overlaps`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.    \n  * if one operand is a point, returns true if the point is included in the geometry\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]); \t// var0 equals true\nbool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals true\nbool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {25,25}; \t// var2 equals false\nbool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var3 equals false\nbool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]); \t// var4 equals true\nbool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {15,15}; \t// var5 equals true\nbool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); \t// var6 equals true\nbool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var7 equals true\nbool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var8 equals true\n```\n      \n\n#### See also: \n[disjoint_from](OperatorsDM#disjoint_from), [crosses](OperatorsAC#crosses), [intersects](OperatorsDM#intersects), [partially_overlaps](OperatorsNZ#partially_overlaps), [touches](OperatorsNZ#touches), \n    \t\n----\n\n[//]: # (keyword|operator_pair)\n### `pair`\n\n#### Possible use: \n  *  **`pair`** (`any`) --->  `pair` \n\n#### Result: \nCasts the operand into the type pair\n    \t\n----\n\n[//]: # (keyword|operator_partially_overlaps)\n### `partially_overlaps`\n\n#### Possible use: \n  * `geometry` **`partially_overlaps`** `geometry` --->  `bool`\n  *  **`partially_overlaps`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).  \n\n#### Comment: \nif one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).\n\n#### Special cases:     \n  * if one of the operand is null, returns false.\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]); \t// var0 equals true\nbool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals true\nbool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {25,25}; \t// var2 equals false\nbool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var3 equals false\nbool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]); \t// var4 equals false\nbool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {15,15}; \t// var5 equals false\nbool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); \t// var6 equals false\nbool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var7 equals true\nbool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var8 equals false\n```\n      \n\n#### See also: \n[disjoint_from](OperatorsDM#disjoint_from), [crosses](OperatorsAC#crosses), [overlaps](OperatorsNZ#overlaps), [intersects](OperatorsDM#intersects), [touches](OperatorsNZ#touches), \n    \t\n----\n\n[//]: # (keyword|operator_path)\n### `path`\n\n#### Possible use: \n  *  **`path`** (`any`) --->  `path` \n\n#### Result: \nCasts the operand into the type path\n    \t\n----\n\n[//]: # (keyword|operator_path_between)\n### `path_between`\n\n#### Possible use: \n  * `topology` **`path_between`** `container<geometry>` --->  `path`\n  *  **`path_between`** (`topology` , `container<geometry>`) --->  `path`\n  * `list<agent>` **`path_between`** `container<geometry>` --->  `path`\n  *  **`path_between`** (`list<agent>` , `container<geometry>`) --->  `path`\n  *  **`path_between`** (`graph`, `geometry`, `geometry`) --->  `path`\n  *  **`path_between`** (`list<agent>`, `geometry`, `geometry`) --->  `path`\n  *  **`path_between`** (`topology`, `geometry`, `geometry`) --->  `path` \n\n#### Result: \nThe shortest path between a list of two objects in a graph\nThe shortest path between two objects according to set of cells\nThe shortest path between several objects according to set of cells\n\n#### Examples: \n```\npath var0 <- path_between (my_graph, ag1, ag2); \t// var0 equals A path between ag1 and ag2\npath var1 <- my_topology path_between [ag1, ag2]; \t// var1 equals A path between ag1 and ag2\npath var2 <- path_between (cell_grid where each.is_free, ag1, ag2); \t// var2 equals A path between ag1 and ag2 passing through the given cell_grid agents\npath var3 <- my_topology path_between (ag1, ag2); \t// var3 equals A path between ag1 and ag2\npath var4 <- path_between (cell_grid where each.is_free, [ag1, ag2, ag3]); \t// var4 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agents\n```\n      \n\n#### See also: \n[towards](OperatorsNZ#towards), [direction_to](OperatorsDM#direction_to), [distance_between](OperatorsDM#distance_between), [direction_between](OperatorsDM#direction_between), [path_to](OperatorsNZ#path_to), [distance_to](OperatorsDM#distance_to), \n    \t\n----\n\n[//]: # (keyword|operator_path_to)\n### `path_to`\n\n#### Possible use: \n  * `geometry` **`path_to`** `geometry` --->  `path`\n  *  **`path_to`** (`geometry` , `geometry`) --->  `path`\n  * `point` **`path_to`** `point` --->  `path`\n  *  **`path_to`** (`point` , `point`) --->  `path` \n\n#### Result: \nA path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.\n\n#### Examples: \n```\npath var0 <- ag1 path_to ag2; \t// var0 equals the path between ag1 and ag2 considering the topology of the agent applying the operator\n```\n      \n\n#### See also: \n[towards](OperatorsNZ#towards), [direction_to](OperatorsDM#direction_to), [distance_between](OperatorsDM#distance_between), [direction_between](OperatorsDM#direction_between), [path_between](OperatorsNZ#path_between), [distance_to](OperatorsDM#distance_to), \n    \t\n----\n\n[//]: # (keyword|operator_paths_between)\n### `paths_between`\n\n#### Possible use: \n  *  **`paths_between`** (`graph`, `pair`, `int`) --->  `list<path>` \n\n#### Result: \nThe K shortest paths between a list of two objects in a graph\n\n#### Examples: \n```\nlist<path> var0 <- paths_between(my_graph, ag1:: ag2, 2); \t// var0 equals the 2 shortest paths (ordered by length) between ag1 and ag2\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_percent_absolute_deviation)\n### `percent_absolute_deviation`\n\n#### Possible use: \n  * `list<float>` **`percent_absolute_deviation`** `list<float>` --->  `float`\n  *  **`percent_absolute_deviation`** (`list<float>` , `list<float>`) --->  `float` \n\n#### Result: \npercent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)\n\n#### Examples: \n```\npercent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_pgm_file)\n### `pgm_file`\n\n#### Possible use: \n  *  **`pgm_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type pgm. Allowed extensions are limited to pgm\n    \t\n----\n\n[//]: # (keyword|operator_plan)\n### `plan`\n\n#### Possible use: \n  * `container<geometry>` **`plan`** `float` --->  `geometry`\n  *  **`plan`** (`container<geometry>` , `float`) --->  `geometry` \n\n#### Result: \nA polyline geometry from the given list of points.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry.\n\n#### Examples: \n```\ngeometry var0 <- polyplan([{0,0}, {0,10}, {10,10}, {10,0}],10); \t// var0 equals a polyline geometry composed of the 4 points with a depth of 10.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygone](OperatorsNZ#polygone), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_plus_days)\n### `plus_days`\n\n#### Possible use: \n  * `date` **`plus_days`** `int` --->  `date`\n  *  **`plus_days`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of days to a date\n\n#### Examples: \n```\ndate1 plus_days 20\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_plus_hours)\n### `plus_hours`\n\n#### Possible use: \n  * `date` **`plus_hours`** `int` --->  `date`\n  *  **`plus_hours`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of hours to a date\n\n#### Examples: \n```\ndate1 plus_hours 15 // equivalent to date1 + 15 #h\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_plus_minutes)\n### `plus_minutes`\n\n#### Possible use: \n  * `date` **`plus_minutes`** `int` --->  `date`\n  *  **`plus_minutes`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of minutes to a date\n\n#### Examples: \n```\ndate1 plus_minutes 5 // equivalent to date1 + 5 #mn\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_plus_months)\n### `plus_months`\n\n#### Possible use: \n  * `date` **`plus_months`** `int` --->  `date`\n  *  **`plus_months`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of months to a date\n\n#### Examples: \n```\ndate1 plus_months 5\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_plus_ms)\n### `plus_ms`\n\n#### Possible use: \n  * `date` **`plus_ms`** `int` --->  `date`\n  *  **`plus_ms`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of milliseconds to a date\n\n#### Examples: \n```\ndate1 plus_ms 15 // equivalent to date1 + 15 #ms\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_plus_seconds)\n### `plus_seconds`\nSame signification as [+](OperatorsAC#+)\n    \t\n----\n\n[//]: # (keyword|operator_plus_weeks)\n### `plus_weeks`\n\n#### Possible use: \n  * `date` **`plus_weeks`** `int` --->  `date`\n  *  **`plus_weeks`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of weeks to a date\n\n#### Examples: \n```\ndate1 plus_weeks 15\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_plus_years)\n### `plus_years`\n\n#### Possible use: \n  * `date` **`plus_years`** `int` --->  `date`\n  *  **`plus_years`** (`date` , `int`) --->  `date` \n\n#### Result: \nAdd a given number of years to a date\n\n#### Examples: \n```\ndate1 plus_years 3\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_point)\n### `point`\n\n#### Possible use: \n  * `float` **`point`** `int` --->  `point`\n  *  **`point`** (`float` , `int`) --->  `point`\n  * `int` **`point`** `float` --->  `point`\n  *  **`point`** (`int` , `float`) --->  `point`\n  * `int` **`point`** `int` --->  `point`\n  *  **`point`** (`int` , `int`) --->  `point`\n  * `float` **`point`** `float` --->  `point`\n  *  **`point`** (`float` , `float`) --->  `point`\n  *  **`point`** (`float`, `int`, `int`) --->  `point`\n  *  **`point`** (`int`, `int`, `int`) --->  `point`\n  *  **`point`** (`float`, `int`, `float`) --->  `point`\n  *  **`point`** (`int`, `int`, `float`) --->  `point`\n  *  **`point`** (`int`, `float`, `float`) --->  `point`\n  *  **`point`** (`float`, `float`, `float`) --->  `point`\n  *  **`point`** (`float`, `float`, `int`) --->  `point` \n\n#### Result: \ninternal use only. Use the standard construction {x,y} instead.\ninternal use only. Use the standard construction {x,y} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y} instead.\ninternal use only. Use the standard construction {x,y} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\ninternal use only. Use the standard construction {x,y, z} instead.\n    \t\n----\n\n[//]: # (keyword|operator_points_along)\n### `points_along`\n\n#### Possible use: \n  * `geometry` **`points_along`** `list<float>` --->  `container`\n  *  **`points_along`** (`geometry` , `list<float>`) --->  `container` \n\n#### Result: \nA list of points along the operand-geometry given its location in terms of rate of distance from the starting points of the geometry.\n\n#### Examples: \n```\ncontainer var0 <-  line([{10,10},{80,80}]) points_along ([0.3, 0.5, 0.9]); \t// var0 equals the list of following points: [{31.0,31.0,0.0},{45.0,45.0,0.0},{73.0,73.0,0.0}]\n```\n      \n\n#### See also: \n[closest_points_with](OperatorsAC#closest_points_with), [farthest_point_to](OperatorsDM#farthest_point_to), [points_at](OperatorsNZ#points_at), [points_on](OperatorsNZ#points_on), \n    \t\n----\n\n[//]: # (keyword|operator_points_at)\n### `points_at`\n\n#### Possible use: \n  * `int` **`points_at`** `float` --->  `list<point>`\n  *  **`points_at`** (`int` , `float`) --->  `list<point>` \n\n#### Result: \nA list of left-operand number of points located at a the right-operand distance to the agent location.\n\n#### Examples: \n```\nlist<point> var0 <- 3 points_at(20.0); \t// var0 equals returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent location\n```\n      \n\n#### See also: \n[any_location_in](OperatorsAC#any_location_in), [any_point_in](OperatorsAC#any_point_in), [closest_points_with](OperatorsAC#closest_points_with), [farthest_point_to](OperatorsDM#farthest_point_to), \n    \t\n----\n\n[//]: # (keyword|operator_points_on)\n### `points_on`\n\n#### Possible use: \n  * `geometry` **`points_on`** `float` --->  `container`\n  *  **`points_on`** (`geometry` , `float`) --->  `container` \n\n#### Result: \nA list of points of the operand-geometry distant from each other to the float right-operand .\n\n#### Examples: \n```\ncontainer var0 <-  square(5) points_on(2); \t// var0 equals a list of points belonging to the exterior ring of the square distant from each other of 2.\n```\n      \n\n#### See also: \n[closest_points_with](OperatorsAC#closest_points_with), [farthest_point_to](OperatorsDM#farthest_point_to), [points_at](OperatorsNZ#points_at), \n    \t\n----\n\n[//]: # (keyword|operator_poisson)\n### `poisson`\n\n#### Possible use: \n  *  **`poisson`** (`float`) --->  `int` \n\n#### Result: \nA value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).  \n\n#### Comment: \nThe Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.\n\n#### Examples: \n```\nint var0 <- poisson(3.5); \t// var0 equals a random positive integer\n```\n      \n\n#### See also: \n[binomial](OperatorsAC#binomial), [gauss](OperatorsDM#gauss), \n    \t\n----\n\n[//]: # (keyword|operator_polygon)\n### `polygon`\n\n#### Possible use: \n  *  **`polygon`** (`container<agent>`) --->  `geometry` \n\n#### Result: \nA polygon geometry from the given list of points.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry    \n  * if the operand is composed of 2 points, returns a polyline geometry.\n\n#### Examples: \n```\ngeometry var0 <- polygon([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var0 equals a polygon geometry composed of the 4 points.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_polyhedron)\n### `polyhedron`\n\n#### Possible use: \n  * `container<geometry>` **`polyhedron`** `float` --->  `geometry`\n  *  **`polyhedron`** (`container<geometry>` , `float`) --->  `geometry` \n\n#### Result: \nA polyhedron geometry from the given list of points.\n\n#### Special cases:     \n  * if the operand is nil, returns the point geometry {0,0}    \n  * if the operand is composed of a single point, returns a point geometry    \n  * if the operand is composed of 2 points, returns a polyline geometry.\n\n#### Examples: \n```\ngeometry var0 <- polyhedron([{0,0}, {0,10}, {10,10}, {10,0}],10); \t// var0 equals a polygon geometry composed of the 4 points and of depth 10.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_polyline)\n### `polyline`\nSame signification as [line](OperatorsDM#line)\n    \t\n----\n\n[//]: # (keyword|operator_polyplan)\n### `polyplan`\nSame signification as [plan](OperatorsNZ#plan)\n    \t\n----\n\n[//]: # (keyword|operator_predecessors_of)\n### `predecessors_of`\n\n#### Possible use: \n  * `graph` **`predecessors_of`** `unknown` --->  `container`\n  *  **`predecessors_of`** (`graph` , `unknown`) --->  `container` \n\n#### Result: \nreturns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)\n\n#### Examples: \n```\ncontainer var1 <- graphEpidemio predecessors_of ({1,5}); \t// var1 equals []\ncontainer var2 <- graphEpidemio predecessors_of node({34,56}); \t// var2 equals [{12;45}]\n```\n      \n\n#### See also: \n[neighbors_of](OperatorsNZ#neighbors_of), [successors_of](OperatorsNZ#successors_of), \n    \t\n----\n\n[//]: # (keyword|operator_predicate)\n### `predicate`\n\n#### Possible use: \n  *  **`predicate`** (`any`) --->  `predicate` \n\n#### Result: \nCasts the operand into the type predicate\n    \t\n----\n\n[//]: # (keyword|operator_predict)\n### `predict`\n\n#### Possible use: \n  * `regression` **`predict`** `list<float>` --->  `float`\n  *  **`predict`** (`regression` , `list<float>`) --->  `float` \n\n#### Result: \nreturns the value predict by the regression parameters for a given instance. Usage: predict(regression, instance)\n\n#### Examples: \n```\npredict(my_regression, [1,2,3]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_product)\n### `product`\nSame signification as [mul](OperatorsDM#mul)\n    \t\n----\n\n[//]: # (keyword|operator_product_of)\n### `product_of`\n\n#### Possible use: \n  * `container` **`product_of`** `any expression` --->  `unknown`\n  *  **`product_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe product of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var2 <- [1::2, 3::4, 5::6] product_of (each); \t// var2 equals 48\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2] product_of (each * 10 ); \t// var1 equals 200\n```\n      \n\n#### See also: \n[min_of](OperatorsDM#min_of), [max_of](OperatorsDM#max_of), [sum_of](OperatorsNZ#sum_of), [mean_of](OperatorsDM#mean_of), \n    \t\n----\n\n[//]: # (keyword|operator_promethee_DM)\n### `promethee_DM`\n\n#### Possible use: \n  * `list<list>` **`promethee_DM`** `list<map<string,object>>` --->  `int`\n  *  **`promethee_DM`** (`list<list>` , `list<map<string,object>>`) --->  `int` \n\n#### Result: \nThe index of the best candidate according to the Promethee II method. This method is based on a comparison per pair of possible candidates along each criterion: all candidates are compared to each other by pair and ranked. More information about this method can be found in [http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6VCT-4VF56TV-1&_user=10&_coverDate=01%2F01%2F2010&_rdoc=1&_fmt=high&_orig=search&_sort=d&_docanchor=&view=c&_searchStrId=1389284642&_rerunOrigin=google&_acct=C000050221&_version=1&_urlVersion=0&_userid=10&md5=d334de2a4e0d6281199a39857648cd36 Behzadian, M., Kazemzadeh, R., Albadvi, A., M., A.: PROMETHEE: A comprehensive literature review on methodologies and applications. European Journal of Operational Research(2009)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fours elements: a name, a weight, a preference value (p) and an indifference value (q). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant.\n\n#### Special cases:     \n  * returns -1 is the list of candidates is nil or empty\n\n#### Examples: \n```\nint var0 <- promethee_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]]); \t// var0 equals 1\n```\n      \n\n#### See also: \n[weighted_means_DM](OperatorsNZ#weighted_means_dm), [electre_DM](OperatorsDM#electre_dm), [evidence_theory_DM](OperatorsDM#evidence_theory_dm), \n    \t\n----\n\n[//]: # (keyword|operator_property_file)\n### `property_file`\n\n#### Possible use: \n  *  **`property_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type property. Allowed extensions are limited to properties\n    \t\n----\n\n[//]: # (keyword|operator_pyramid)\n### `pyramid`\n\n#### Possible use: \n  *  **`pyramid`** (`float`) --->  `geometry` \n\n#### Result: \nA square geometry which side size is given by the operand.  \n\n#### Comment: \nthe center of the pyramid is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- pyramid(5); \t// var0 equals a geometry as a square with side_size = 5.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), \n    \t\n----\n\n[//]: # (keyword|operator_range)\n### `range`\n\n#### Possible use: \n  *  **`range`** (`int`) --->  `container`\n  * `int` **`range`** `int` --->  `container`\n  *  **`range`** (`int` , `int`) --->  `container`\n  *  **`range`** (`int`, `int`, `int`) --->  `container` \n\n#### Result: \nAllows to build a list of int representing all contiguous values from zero to the argument. The range can be increasing or decreasing. Passing 0 will return a singleton list with 0\nAllows to build a list of int representing all contiguous values from the first to the second argument, using the step represented by the third argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value. Passing a step of 0 will result in an exception. Attempting to build infinite ranges (e.g. end > start with a negative step) will similarly not be accepted and yield an exception\nAllows to build a list of int representing all contiguous values from the first to the second argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value\n    \t\n----\n\n[//]: # (keyword|operator_read)\n### `read`\n\n#### Possible use: \n  *  **`read`** (`string`) --->  `unknown` \n\n#### Result: \nReads an attribute of the agent. The attribute's name is specified by the operand.\n\n#### Examples: \n```\nunknown agent_name <- read ('name'); \t// agent_name equals reads the 'name' variable of agent then assigns the returned value to the 'agent_name' variable. \n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_rectangle)\n### `rectangle`\n\n#### Possible use: \n  *  **`rectangle`** (`point`) --->  `geometry`\n  * `float` **`rectangle`** `float` --->  `geometry`\n  *  **`rectangle`** (`float` , `float`) --->  `geometry`\n  * `point` **`rectangle`** `point` --->  `geometry`\n  *  **`rectangle`** (`point` , `point`) --->  `geometry` \n\n#### Result: \nA rectangle geometry which side sizes are given by the operands.  \n\n#### Comment: \nthe center of the rectangle is by default the location of the current agent in which has been called this operator.the center of the rectangle is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.    \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- rectangle(10, 5); \t// var0 equals a geometry as a rectangle with width = 10 and height = 5.\ngeometry var1 <- rectangle({2.0,6.0}, {6.0,20.0}); \t// var1 equals a geometry as a rectangle with {2.0,6.0} as the upper-left corner, {6.0,20.0} as the lower-right corner.\ngeometry var2 <- rectangle({10, 5}); \t// var2 equals a geometry as a rectangle with width = 10 and height = 5.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_reduced_by)\n### `reduced_by`\nSame signification as [-](OperatorsAC#-)\n    \t\n----\n\n[//]: # (keyword|operator_regression)\n### `regression`\n\n#### Possible use: \n  *  **`regression`** (`any`) --->  `regression` \n\n#### Result: \nCasts the operand into the type regression\n    \t\n----\n\n[//]: # (keyword|operator_remove_duplicates)\n### `remove_duplicates`\nSame signification as [distinct](OperatorsDM#distinct)\n    \t\n----\n\n[//]: # (keyword|operator_remove_node_from)\n### `remove_node_from`\n\n#### Possible use: \n  * `geometry` **`remove_node_from`** `graph` --->  `graph`\n  *  **`remove_node_from`** (`geometry` , `graph`) --->  `graph` \n\n#### Result: \nremoves a node from a graph.  \n\n#### Comment: \nall the edges containing this node are also removed.\n\n#### Examples: \n```\ngraph var0 <- node(0) remove_node_from graphEpidemio; \t// var0 equals the graph without node(0)\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_replace)\n### `replace`\n\n#### Possible use: \n  *  **`replace`** (`string`, `string`, `string`) --->  `string` \n\n#### Result: \nReturns the String resulting by replacing for the first operand all the sub-strings corresponding the second operand by the third operand\n\n#### Examples: \n```\nstring var0 <- replace('to be or not to be,that is the question','to', 'do'); \t// var0 equals 'do be or not do be,that is the question'\n```\n      \n\n#### See also: \n[replace_regex](OperatorsNZ#replace_regex), \n    \t\n----\n\n[//]: # (keyword|operator_replace_regex)\n### `replace_regex`\n\n#### Possible use: \n  *  **`replace_regex`** (`string`, `string`, `string`) --->  `string` \n\n#### Result: \nReturns the String resulting by replacing for the first operand all the sub-strings corresponding to the regular expression given in the second operand by the third operand\n\n#### Examples: \n```\nstring var0 <- replace_regex(\"colour, color\", \"colou?r\", \"col\"); \t// var0 equals 'col, col'\n```\n      \n\n#### See also: \n[replace](OperatorsNZ#replace), \n    \t\n----\n\n[//]: # (keyword|operator_reverse)\n### `reverse`\n\n#### Possible use: \n  *  **`reverse`** (`string`) --->  `string`\n  *  **`reverse`** (`container<KeyType,ValueType>`) --->  `msi.gama.util.IContainer<?,?>` \n\n#### Result: \nthe operand elements in the reversed order in a copy of the operand.  \n\n#### Comment: \nthe reverse operator behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a file, reverse returns a copy of the file with a reversed content    \n  * if it is a population, reverse returns a copy of the population with elements in the reversed order    \n  * if it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed    \n  * if it is a string, reverse returns a new string with characters in the reversed order \n  \n```\nstring var0 <- reverse ('abcd'); \t// var0 equals 'dcba'\n\n``` \n\n    \n  * if it is a list, reverse returns a copy of the operand list with elements in the reversed order \n  \n```\nmsi.gama.util.IContainer<?,?> var1 <- reverse ([10,12,14]); \t// var1 equals [14, 12, 10]\n\n``` \n\n    \n  * if it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys) \n  \n```\nmsi.gama.util.IContainer<?,?> var2 <- reverse (['k1'::44, 'k2'::32, 'k3'::12]); \t// var2 equals [12::'k3',  32::'k2', 44::'k1']\n\n``` \n\n    \n  * if it is a matrix, reverse returns a new matrix containing the transpose of the operand. \n  \n```\nmsi.gama.util.IContainer<?,?> var3 <- reverse(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var3 equals matrix([[\"c11\",\"c21\"],[\"c12\",\"c22\"],[\"c13\",\"c23\"]])\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_rewire_n)\n### `rewire_n`\n\n#### Possible use: \n  * `graph` **`rewire_n`** `int` --->  `graph`\n  *  **`rewire_n`** (`graph` , `int`) --->  `graph` \n\n#### Result: \nrewires the given count of edges.  \n\n#### Comment: \nIf there are too many edges, all the edges will be rewired.\n\n#### Examples: \n```\ngraph var1 <- graphEpidemio rewire_n 10; \t// var1 equals the graph with 3 edges rewired\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_rgb)\n### `rgb`\n\n#### Possible use: \n  * `rgb` **`rgb`** `float` --->  `rgb`\n  *  **`rgb`** (`rgb` , `float`) --->  `rgb`\n  * `rgb` **`rgb`** `int` --->  `rgb`\n  *  **`rgb`** (`rgb` , `int`) --->  `rgb`\n  * `string` **`rgb`** `int` --->  `rgb`\n  *  **`rgb`** (`string` , `int`) --->  `rgb`\n  *  **`rgb`** (`int`, `int`, `int`) --->  `rgb`\n  *  **`rgb`** (`int`, `int`, `int`, `float`) --->  `rgb`\n  *  **`rgb`** (`int`, `int`, `int`, `int`) --->  `rgb` \n\n#### Result: \nReturns a color defined by red, green, blue components and an alpha blending value.\n\n#### Special cases:     \n  * It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0.0 and 1.0)    \n  * It can be used with a color and an alpha between 0 and 1    \n  * It can be used with a color and an alpha between 0 and 255    \n  * It can be used with r=red, g=green, b=blue, each between 0 and 255    \n  * It can be used with a name of color and alpha (between 0 and 255)    \n  * It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0 and 255)\n\n#### Examples: \n```\nrgb var0 <- rgb (255,0,0,0.5); \t// var0 equals a light red color\nrgb var1 <- rgb(rgb(255,0,0),0.5); \t// var1 equals a light red color\nrgb var2 <- rgb(rgb(255,0,0),125); \t// var2 equals a light red color\nrgb var3 <- rgb (255,0,0); \t// var3 equals #red\nrgb var4 <- rgb (\"red\"); \t// var4 equals rgb(255,0,0)\nrgb var5 <- rgb (255,0,0,125); \t// var5 equals a light red color\n```\n      \n\n#### See also: \n[hsb](OperatorsDM#hsb), \n    \t\n----\n\n[//]: # (keyword|operator_rgb_to_xyz)\n### `rgb_to_xyz`\n\n#### Possible use: \n  *  **`rgb_to_xyz`** (`file`) --->  `list<point>` \n\n#### Result: \nA list of point corresponding to RGB value of an image (r:x , g:y, b:z)\n\n#### Examples: \n```\nlist<point> var0 <- rgb_to_xyz(texture); \t// var0 equals a list of points\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_rnd)\n### `rnd`\n\n#### Possible use: \n  *  **`rnd`** (`float`) --->  `float`\n  *  **`rnd`** (`int`) --->  `int`\n  *  **`rnd`** (`point`) --->  `point`\n  * `point` **`rnd`** `point` --->  `point`\n  *  **`rnd`** (`point` , `point`) --->  `point`\n  * `int` **`rnd`** `int` --->  `int`\n  *  **`rnd`** (`int` , `int`) --->  `int`\n  * `float` **`rnd`** `float` --->  `float`\n  *  **`rnd`** (`float` , `float`) --->  `float`\n  *  **`rnd`** (`point`, `point`, `float`) --->  `point`\n  *  **`rnd`** (`float`, `float`, `float`) --->  `float`\n  *  **`rnd`** (`int`, `int`, `int`) --->  `int` \n\n#### Result: \na random integer in the interval [0, operand]  \n\n#### Comment: \nto obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precision\n\n#### Special cases:     \n  * if the operand is a float, returns an uniformly distributed float random number in [0.0, to]    \n  * if the operand is a point, returns a point with three random float ordinates, each in the interval [0, ordinate of argument]\n\n#### Examples: \n```\nfloat var0 <- rnd(3.4); \t// var0 equals a random float between 0.0 and 3.4\npoint var1 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1); \t// var1 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0\npoint var2 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}); \t// var2 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0\nint var3 <- rnd (2, 4); \t// var3 equals 2, 3 or 4\nfloat var4 <- rnd (2.0, 4.0); \t// var4 equals a float number between 2.0 and 4.0\nfloat var5 <- rnd (2.0, 4.0, 0.5); \t// var5 equals a float number between 2.0 and 4.0 every 0.5\nint var6 <- rnd (2); \t// var6 equals 0, 1 or 2\nfloat var7 <- rnd (1000) / 1000; \t// var7 equals a float between 0 and 1 with a precision of 0.001\npoint var8 <- rnd ({2.5,3, 0.0}); \t// var8 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0\nint var9 <- rnd (2, 12, 4); \t// var9 equals 2, 6 or 10\n```\n      \n\n#### See also: \n[flip](OperatorsDM#flip), \n    \t\n----\n\n[//]: # (keyword|operator_rnd_choice)\n### `rnd_choice`\n\n#### Possible use: \n  *  **`rnd_choice`** (`container`) --->  `int` \n\n#### Result: \nreturns an index of the given list with a probability following the (normalized) distribution described in the list (a form of lottery)\n\n#### Examples: \n```\nint var0 <- rnd_choice([0.2,0.5,0.3]); \t// var0 equals 2/10 chances to return 0, 5/10 chances to return 1, 3/10 chances to return 2\n```\n      \n\n#### See also: \n[rnd](OperatorsNZ#rnd), \n    \t\n----\n\n[//]: # (keyword|operator_rnd_color)\n### `rnd_color`\n\n#### Possible use: \n  *  **`rnd_color`** (`int`) --->  `rgb` \n\n#### Result: \nrgb color  \n\n#### Comment: \nReturn a random color equivalent to rgb(rnd(operand),rnd(operand),rnd(operand))\n\n#### Examples: \n```\nrgb var0 <- rnd_color(255); \t// var0 equals a random color, equivalent to rgb(rnd(255),rnd(255),rnd(255))\n```\n      \n\n#### See also: \n[rgb](OperatorsNZ#rgb), [hsb](OperatorsDM#hsb), \n    \t\n----\n\n[//]: # (keyword|operator_rotated_by)\n### `rotated_by`\n\n#### Possible use: \n  * `geometry` **`rotated_by`** `float` --->  `geometry`\n  *  **`rotated_by`** (`geometry` , `float`) --->  `geometry`\n  * `geometry` **`rotated_by`** `int` --->  `geometry`\n  *  **`rotated_by`** (`geometry` , `int`) --->  `geometry`\n  *  **`rotated_by`** (`geometry`, `float`, `point`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point)\nA geometry resulting from the application of a rotation by the right-hand operand angles (degree) along the three axis (x,y,z) to the left-hand operand (geometry, agent, point)  \n\n#### Comment: \nthe right-hand operand can be a float or a int\n\n#### Examples: \n```\ngeometry var0 <- self rotated_by 45; \t// var0 equals the geometry resulting from a 45 degrees rotation to the geometry of the agent applying the operator.\ngeometry var1 <- rotated_by(pyramid(10),45, {1,0,0}); \t// var1 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator.\n```\n      \n\n#### See also: \n[transformed_by](OperatorsNZ#transformed_by), [translated_by](OperatorsNZ#translated_by), \n    \t\n----\n\n[//]: # (keyword|operator_round)\n### `round`\n\n#### Possible use: \n  *  **`round`** (`int`) --->  `int`\n  *  **`round`** (`point`) --->  `point`\n  *  **`round`** (`float`) --->  `int` \n\n#### Result: \nReturns the rounded value of the operand.\n\n#### Special cases:     \n  * if the operand is an int, round returns it\n\n#### Examples: \n```\npoint var0 <- {12345.78943,  12345.78943, 12345.78943} with_precision 2; \t// var0 equals {12345.79,12345.79,12345.79}\nint var1 <- round (0.51); \t// var1 equals 1\nint var2 <- round (100.2); \t// var2 equals 100\nint var3 <- round(-0.51); \t// var3 equals -1\n```\n      \n\n#### See also: \n[round](OperatorsNZ#round), [int](OperatorsDM#int), [with_precision](OperatorsNZ#with_precision), \n    \t\n----\n\n[//]: # (keyword|operator_row_at)\n### `row_at`\n\n#### Possible use: \n  * `matrix` **`row_at`** `int` --->  `list`\n  *  **`row_at`** (`matrix` , `int`) --->  `list` \n\n#### Result: \nreturns the row at a num_line (right-hand operand)\n\n#### Examples: \n```\nlist var0 <- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) row_at 2; \t// var0 equals [\"el13\",\"el23\",\"el33\"]\n```\n      \n\n#### See also: \n[column_at](OperatorsAC#column_at), [columns_list](OperatorsAC#columns_list), \n    \t\n----\n\n[//]: # (keyword|operator_rows_list)\n### `rows_list`\n\n#### Possible use: \n  *  **`rows_list`** (`matrix`) --->  `list<list>` \n\n#### Result: \nreturns a list of the rows of the matrix, with each row as a list of elements\n\n#### Examples: \n```\nlist<list> var0 <- rows_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); \t// var0 equals [[\"el11\",\"el21\",\"el31\"],[\"el12\",\"el22\",\"el32\"],[\"el13\",\"el23\",\"el33\"]]\n```\n      \n\n#### See also: \n[columns_list](OperatorsAC#columns_list), \n    \t\n----\n\n[//]: # (keyword|operator_sample)\n### `sample`\n\n#### Possible use: \n  *  **`sample`** (`any expression`) --->  `string`\n  * `string` **`sample`** `any expression` --->  `string`\n  *  **`sample`** (`string` , `any expression`) --->  `string`\n  *  **`sample`** (`container`, `int`, `bool`) --->  `container`\n  *  **`sample`** (`container`, `int`, `bool`, `container`) --->  `container` \n\n#### Result: \ntakes a sample of the specified size from the elements of x using either with or without replacement\ntakes a sample of the specified size from the elements of x using either with or without replacement with given weights\n\n#### Examples: \n```\ncontainer var0 <- sample([2,10,1],2,false); \t// var0 equals [1,2]\ncontainer var1 <- sample([2,10,1],2,false,[0.1,0.7,0.2]); \t// var1 equals [10,2]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_scaled_by)\n### `scaled_by`\nSame signification as [*](OperatorsAC#*)\n    \t\n----\n\n[//]: # (keyword|operator_scaled_to)\n### `scaled_to`\n\n#### Possible use: \n  * `geometry` **`scaled_to`** `point` --->  `geometry`\n  *  **`scaled_to`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nallows to restrict the size of a geometry so that it fits in the envelope {width, height, depth} defined by the second operand\n\n#### Examples: \n```\ngeometry var0 <- shape scaled_to {10,10}; \t// var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_select)\n### `select`\nSame signification as [where](OperatorsNZ#where)\n    \t\n----\n\n[//]: # (keyword|operator_set_about)\n### `set_about`\n\n#### Possible use: \n  * `emotion` **`set_about`** `predicate` --->  `emotion`\n  *  **`set_about`** (`emotion` , `predicate`) --->  `emotion` \n\n#### Result: \nchange the about value of the given emotion\n\n#### Examples: \n```\nemotion set_about predicate1\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_agent)\n### `set_agent`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_agent`** `agent` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_agent`** (`msi.gaml.architecture.simplebdi.SocialLink` , `agent`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the agent value of the given social link\n\n#### Examples: \n```\nsocial_link set_agent agentA\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_agent_cause)\n### `set_agent_cause`\n\n#### Possible use: \n  * `emotion` **`set_agent_cause`** `agent` --->  `emotion`\n  *  **`set_agent_cause`** (`emotion` , `agent`) --->  `emotion`\n  * `predicate` **`set_agent_cause`** `agent` --->  `predicate`\n  *  **`set_agent_cause`** (`predicate` , `agent`) --->  `predicate` \n\n#### Result: \nchange the agentCause value of the given emotion\nchange the agentCause value of the given predicate\n\n#### Examples: \n```\nemotion set_agent_cause agentA\npredicate set_agent_cause agentA\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_decay)\n### `set_decay`\n\n#### Possible use: \n  * `emotion` **`set_decay`** `float` --->  `emotion`\n  *  **`set_decay`** (`emotion` , `float`) --->  `emotion` \n\n#### Result: \nchange the decay value of the given emotion\n\n#### Examples: \n```\nemotion set_decay 12\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_dominance)\n### `set_dominance`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_dominance`** `float` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_dominance`** (`msi.gaml.architecture.simplebdi.SocialLink` , `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the dominance value of the given social link\n\n#### Examples: \n```\nsocial_link set_dominance 0.4\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_familiarity)\n### `set_familiarity`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_familiarity`** `float` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_familiarity`** (`msi.gaml.architecture.simplebdi.SocialLink` , `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the familiarity value of the given social link\n\n#### Examples: \n```\nsocial_link set_familiarity 0.4\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_intensity)\n### `set_intensity`\n\n#### Possible use: \n  * `emotion` **`set_intensity`** `float` --->  `emotion`\n  *  **`set_intensity`** (`emotion` , `float`) --->  `emotion` \n\n#### Result: \nchange the intensity value of the given emotion\n\n#### Examples: \n```\nemotion set_intensity 12\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_liking)\n### `set_liking`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_liking`** `float` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_liking`** (`msi.gaml.architecture.simplebdi.SocialLink` , `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the liking value of the given social link\n\n#### Examples: \n```\nsocial_link set_liking 0.4\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_solidarity)\n### `set_solidarity`\n\n#### Possible use: \n  * `msi.gaml.architecture.simplebdi.SocialLink` **`set_solidarity`** `float` --->  `msi.gaml.architecture.simplebdi.SocialLink`\n  *  **`set_solidarity`** (`msi.gaml.architecture.simplebdi.SocialLink` , `float`) --->  `msi.gaml.architecture.simplebdi.SocialLink` \n\n#### Result: \nchange the solidarity value of the given social link\n\n#### Examples: \n```\nsocial_link set_solidarity 0.4\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_truth)\n### `set_truth`\n\n#### Possible use: \n  * `predicate` **`set_truth`** `bool` --->  `predicate`\n  *  **`set_truth`** (`predicate` , `bool`) --->  `predicate` \n\n#### Result: \nchange the is_true value of the given predicate\n\n#### Examples: \n```\npredicate set_truth false\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_set_z)\n### `set_z`\n\n#### Possible use: \n  * `geometry` **`set_z`** `container<float>` --->  `geometry`\n  *  **`set_z`** (`geometry` , `container<float>`) --->  `geometry`\n  *  **`set_z`** (`geometry`, `int`, `float`) --->  `geometry` \n\n#### Result: \nSets the z ordinate of the n-th point of a geometry to the value provided by the third argument\n\n#### Examples: \n```\nloop i from: 0 to: length(shape.points) - 1{set shape <-  set_z (shape, i, 3.0);}\nshape <- triangle(3) set_z [5,10,14];\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_shape_file)\n### `shape_file`\n\n#### Possible use: \n  *  **`shape_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type shape. Allowed extensions are limited to shp\n    \t\n----\n\n[//]: # (keyword|operator_shuffle)\n### `shuffle`\n\n#### Possible use: \n  *  **`shuffle`** (`matrix`) --->  `matrix`\n  *  **`shuffle`** (`string`) --->  `string`\n  *  **`shuffle`** (`container`) --->  `container` \n\n#### Result: \nThe elements of the operand in random order.\n\n#### Special cases:     \n  * if the operand is empty, returns an empty list (or string, matrix)\n\n#### Examples: \n```\nmatrix var0 <- shuffle (matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var0 equals matrix([[\"c12\",\"c21\",\"c11\"],[\"c13\",\"c22\",\"c23\"]]) (for example)\nstring var1 <- shuffle ('abc'); \t// var1 equals 'bac' (for example)\ncontainer var2 <- shuffle ([12, 13, 14]); \t// var2 equals [14,12,13] (for example)\n```\n      \n\n#### See also: \n[reverse](OperatorsNZ#reverse), \n    \t\n----\n\n[//]: # (keyword|operator_signum)\n### `signum`\n\n#### Possible use: \n  *  **`signum`** (`float`) --->  `int` \n\n#### Result: \nReturns -1 if the argument is negative, +1 if it is positive, 0 if it is equal to zero or not a number\n\n#### Examples: \n```\nint var0 <- signum(-12); \t// var0 equals -1\nint var1 <- signum(14); \t// var1 equals 1\nint var2 <- signum(0); \t// var2 equals 0\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_simple_clustering_by_distance)\n### `simple_clustering_by_distance`\n\n#### Possible use: \n  * `container<agent>` **`simple_clustering_by_distance`** `float` --->  `list<list<agent>>`\n  *  **`simple_clustering_by_distance`** (`container<agent>` , `float`) --->  `list<list<agent>>` \n\n#### Result: \nA list of agent groups clustered by distance considering a distance min between two groups.\n\n#### Examples: \n```\nlist<list<agent>> var0 <- [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0; \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]\n```\n      \n\n#### See also: \n[hierarchical_clustering](OperatorsDM#hierarchical_clustering), \n    \t\n----\n\n[//]: # (keyword|operator_simple_clustering_by_envelope_distance)\n### `simple_clustering_by_envelope_distance`\nSame signification as [simple_clustering_by_distance](OperatorsNZ#simple_clustering_by_distance)\n    \t\n----\n\n[//]: # (keyword|operator_simplification)\n### `simplification`\n\n#### Possible use: \n  * `geometry` **`simplification`** `float` --->  `geometry`\n  *  **`simplification`** (`geometry` , `float`) --->  `geometry` \n\n#### Result: \nA geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.  \n\n#### Comment: \nThe algorithm used for the simplification is Douglas-Peucker\n\n#### Examples: \n```\ngeometry var0 <- self simplification 0.1; \t// var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_sin)\n### `sin`\n\n#### Possible use: \n  *  **`sin`** (`float`) --->  `float`\n  *  **`sin`** (`int`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized.\n\n#### Examples: \n```\nfloat var0 <- sin(360); \t// var0 equals 0.0\nfloat var1 <- sin (0); \t// var1 equals 0.0\n```\n      \n\n#### See also: \n[cos](OperatorsAC#cos), [tan](OperatorsNZ#tan), \n    \t\n----\n\n[//]: # (keyword|operator_sin_rad)\n### `sin_rad`\n\n#### Possible use: \n  *  **`sin_rad`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized.\n\n#### Examples: \n```\nfloat var0 <- sin(360); \t// var0 equals 0.0\n```\n      \n\n#### See also: \n[cos](OperatorsAC#cos), [tan](OperatorsNZ#tan), \n    \t\n----\n\n[//]: # (keyword|operator_since)\n### `since`\n\n#### Possible use: \n  *  **`since`** (`date`) --->  `bool`\n  * `any expression` **`since`** `date` --->  `bool`\n  *  **`since`** (`any expression` , `date`) --->  `bool` \n\n#### Result: \nReturns true if the current_date of the model is after (or equal to) the date passed in argument. Synonym of 'current_date >= argument'. Can be used, like 'after', in its composed form with 2 arguments to express the lowest boundary of the computation of a frequency. However, contrary to 'after', there is a subtle difference: the lowest boundary will be tested against the frequency as well\n\n#### Examples: \n```\nreflex when: since(starting_date) {} -: will always be run\nevery(2#days) since (starting_date + 1#day) // the computation will return true 1 day after the starting date and every two days after this reference date\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_skeletonize)\n### `skeletonize`\n\n#### Possible use: \n  *  **`skeletonize`** (`geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)\n\n#### Examples: \n```\nlist<geometry> var0 <- skeletonize(self); \t// var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_skew_gauss)\n### `skew_gauss`\n\n#### Possible use: \n  *  **`skew_gauss`** (`float`, `float`, `float`, `float`) --->  `float` \n\n#### Result: \nA value from a skew normally distributed random variable with min value (the minimum skewed value possible), max value (the maximum skewed value possible), skew (the degree to which the values cluster around the mode of the distribution; higher values mean tighter clustering) and bias (the tendency of the mode to approach the min, max or midpoint value; positive values bias toward max, negative values toward min).The algorithm was taken from http://stackoverflow.com/questions/5853187/skewing-java-random-number-generation-toward-a-certain-number\n\n#### Examples: \n```\nfloat var0 <- skew_gauss(0.0, 1.0, 0.7,0.1); \t// var0 equals 0.1729218460343077\n```\n      \n\n#### See also: \n[gauss](OperatorsDM#gauss), [truncated_gauss](OperatorsNZ#truncated_gauss), [poisson](OperatorsNZ#poisson), \n    \t\n----\n\n[//]: # (keyword|operator_skewness)\n### `skewness`\n\n#### Possible use: \n  *  **`skewness`** (`list`) --->  `float` \n\n#### Result: \nreturns skewness value computed from the operand list of values\n\n#### Special cases:     \n  * if the length of the list is lower than 3, returns NaN\n\n#### Examples: \n```\nskewness ([1,2,3,4,5])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_skill)\n### `skill`\n\n#### Possible use: \n  *  **`skill`** (`any`) --->  `skill` \n\n#### Result: \nCasts the operand into the type skill\n    \t\n----\n\n[//]: # (keyword|operator_smooth)\n### `smooth`\n\n#### Possible use: \n  * `geometry` **`smooth`** `float` --->  `geometry`\n  *  **`smooth`** (`geometry` , `float`) --->  `geometry` \n\n#### Result: \nReturns a 'smoothed' geometry, where straight lines are replaces by polynomial (bicubic) curves. The first parameter is the original geometry, the second is the 'fit' parameter which can be in the range 0 (loose fit) to 1 (tightest fit).\n\n#### Examples: \n```\ngeometry var0 <- smooth(square(10), 0.0); \t// var0 equals a 'rounded' square\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_social_link)\n### `social_link`\n\n#### Possible use: \n  *  **`social_link`** (`any`) --->  `social_link` \n\n#### Result: \nCasts the operand into the type social_link\n    \t\n----\n\n[//]: # (keyword|operator_solid)\n### `solid`\nSame signification as [without_holes](OperatorsNZ#without_holes)\n    \t\n----\n\n[//]: # (keyword|operator_sort)\n### `sort`\nSame signification as [sort_by](OperatorsNZ#sort_by)\n    \t\n----\n\n[//]: # (keyword|operator_sort_by)\n### `sort_by`\n\n#### Possible use: \n  * `container` **`sort_by`** `any expression` --->  `container`\n  *  **`sort_by`** (`container` , `any expression`) --->  `container` \n\n#### Result: \nReturns a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them.  \n\n#### Comment: \nthe left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, sort_by throws an error\n\n#### Examples: \n```\ncontainer var0 <- [1,2,4,3,5,7,6,8] sort_by (each); \t// var0 equals [1,2,3,4,5,6,7,8]\ncontainer var2 <- g2 sort_by (length(g2 out_edges_of each) ); \t// var2 equals [node9, node7, node10, node8, node11, node6, node5, node4]\ncontainer var3 <- (list(node) sort_by (round(node(each).location.x)); \t// var3 equals [node5, node1, node0, node2, node3]\ncontainer var4 <- [1::2, 5::6, 3::4] sort_by (each); \t// var4 equals [2, 4, 6]\n```\n      \n\n#### See also: \n[group_by](OperatorsDM#group_by), \n    \t\n----\n\n[//]: # (keyword|operator_source_of)\n### `source_of`\n\n#### Possible use: \n  * `graph` **`source_of`** `unknown` --->  `unknown`\n  *  **`source_of`** (`graph` , `unknown`) --->  `unknown` \n\n#### Result: \nreturns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.\n\n#### Special cases:     \n  * if the lef-hand operand (the graph) is nil, throws an Exception\n\n#### Examples: \n```\ngraph graphEpidemio <- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] );\nunknown var1 <- graphEpidemio source_of(edge(3)); \t// var1 equals node1\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\npoint var3 <- graphFromMap source_of(link({1,5}::{12,45})); \t// var3 equals {1,5}\n```\n      \n\n#### See also: \n[target_of](OperatorsNZ#target_of), \n    \t\n----\n\n[//]: # (keyword|operator_spatial_graph)\n### `spatial_graph`\n\n#### Possible use: \n  *  **`spatial_graph`** (`container`) --->  `graph` \n\n#### Result: \nallows to create a spatial graph from a container of vertices, without trying to wire them. The container can be empty. Emits an error if the contents of the container are not geometries, points or agents    \n\n#### See also: \n[graph](OperatorsDM#graph), \n    \t\n----\n\n[//]: # (keyword|operator_species)\n### `species`\n\n#### Possible use: \n  *  **`species`** (`unknown`) --->  `species` \n\n#### Result: \ncasting of the operand to a species.\n\n#### Special cases:     \n  * if the operand is nil, returns nil;    \n  * if the operand is an agent, returns its species;    \n  * if the operand is a string, returns the species with this name (nil if not found);    \n  * otherwise, returns nil\n\n#### Examples: \n```\nspecies var0 <- species(self); \t// var0 equals the species of the current agent\nspecies var1 <- species('node'); \t// var1 equals node\nspecies var2 <- species([1,5,9,3]); \t// var2 equals nil\nspecies var3 <- species(node1); \t// var3 equals node\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_species_of)\n### `species_of`\nSame signification as [species](OperatorsNZ#species)\n    \t\n----\n\n[//]: # (keyword|operator_sphere)\n### `sphere`\n\n#### Possible use: \n  *  **`sphere`** (`float`) --->  `geometry` \n\n#### Result: \nA sphere geometry which radius is equal to the operand.  \n\n#### Comment: \nthe centre of the sphere is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- sphere(10); \t// var0 equals a geometry as a circle of radius 10 but displays a sphere.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_split_at)\n### `split_at`\n\n#### Possible use: \n  * `geometry` **`split_at`** `point` --->  `list<geometry>`\n  *  **`split_at`** (`geometry` , `point`) --->  `list<geometry>` \n\n#### Result: \nThe two part of the left-operand lines split at the given right-operand point\n\n#### Special cases:     \n  * if the left-operand is a point or a polygon, returns an empty list\n\n#### Examples: \n```\nlist<geometry> var0 <- polyline([{1,2},{4,6}]) split_at {7,6}; \t// var0 equals [polyline([{1.0,2.0},{7.0,6.0}]), polyline([{7.0,6.0},{4.0,6.0}])]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_split_geometry)\n### `split_geometry`\n\n#### Possible use: \n  * `geometry` **`split_geometry`** `float` --->  `list<geometry>`\n  *  **`split_geometry`** (`geometry` , `float`) --->  `list<geometry>`\n  * `geometry` **`split_geometry`** `point` --->  `list<geometry>`\n  *  **`split_geometry`** (`geometry` , `point`) --->  `list<geometry>`\n  *  **`split_geometry`** (`geometry`, `int`, `int`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries that result from the decomposition of the geometry by square cells of the given side size (geometry, size)\nA list of geometries that result from the decomposition of the geometry by rectangle cells of the given dimension (geometry, {size_x, size_y})\nA list of geometries that result from the decomposition of the geometry according to a grid with the given number of rows and columns (geometry, nb_cols, nb_rows)\n\n#### Examples: \n```\nlist<geometry> var0 <- to_squares(self, 10.0); \t// var0 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0\nlist<geometry> var1 <- to_rectangles(self, {10.0, 15.0}); \t// var1 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0\nlist<geometry> var2 <- to_rectangles(self, 10,20); \t// var2 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operator\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_split_lines)\n### `split_lines`\n\n#### Possible use: \n  *  **`split_lines`** (`container<geometry>`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries resulting after cutting the lines at their intersections.\n\n#### Examples: \n```\nlist<geometry> var0 <- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); \t// var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_split_with)\n### `split_with`\n\n#### Possible use: \n  * `string` **`split_with`** `string` --->  `container`\n  *  **`split_with`** (`string` , `string`) --->  `container` \n\n#### Result: \nReturns a list containing the sub-strings (tokens) of the left-hand operand delimited by each of the characters of the right-hand operand.  \n\n#### Comment: \nDelimiters themselves are excluded from the resulting list.\n\n#### Examples: \n```\ncontainer var0 <- 'to be or not to be,that is the question' split_with ' ,'; \t// var0 equals ['to','be','or','not','to','be','that','is','the','question']\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_sqrt)\n### `sqrt`\n\n#### Possible use: \n  *  **`sqrt`** (`int`) --->  `float`\n  *  **`sqrt`** (`float`) --->  `float` \n\n#### Result: \nReturns the square root of the operand.\n\n#### Special cases:     \n  * if the operand is negative, an exception is raised\n\n#### Examples: \n```\nfloat var0 <- sqrt(4); \t// var0 equals 2.0\nfloat var1 <- sqrt(4); \t// var1 equals 2.0\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_square)\n### `square`\n\n#### Possible use: \n  *  **`square`** (`float`) --->  `geometry` \n\n#### Result: \nA square geometry which side size is equal to the operand.  \n\n#### Comment: \nthe centre of the square is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- square(10); \t// var0 equals a geometry as a square of side size 10.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_squircle)\n### `squircle`\n\n#### Possible use: \n  * `float` **`squircle`** `float` --->  `geometry`\n  *  **`squircle`** (`float` , `float`) --->  `geometry` \n\n#### Result: \nA mix of square and circle geometry (see : http://en.wikipedia.org/wiki/Squircle), which side size is equal to the first operand and power is equal to the second operand  \n\n#### Comment: \nthe center of the ellipse is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the side operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- squircle(4,4); \t// var0 equals a geometry as a squircle of side 4 with a power of 4.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [super_ellipse](OperatorsNZ#super_ellipse), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [circle](OperatorsAC#circle), [ellipse](OperatorsDM#ellipse), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_standard_deviation)\n### `standard_deviation`\n\n#### Possible use: \n  *  **`standard_deviation`** (`container`) --->  `float` \n\n#### Result: \nthe standard deviation on the elements of the operand. See <A href=\"http://en.wikipedia.org/wiki/Standard_deviation\">Standard_deviation</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- standard_deviation ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.2930100540985752\n```\n      \n\n#### See also: \n[mean](OperatorsDM#mean), [mean_deviation](OperatorsDM#mean_deviation), \n    \t\n----\n\n[//]: # (keyword|operator_string)\n### `string`\n\n#### Possible use: \n  * `date` **`string`** `string` --->  `string`\n  *  **`string`** (`date` , `string`) --->  `string` \n\n#### Result: \nconverts a date to astring following a custom pattern. The pattern can use \"%Y %M %N %D %E %h %m %s %z\" for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will return the complete date as defined by the ISO date & time format. The pattern can also follow the pattern definition found here, which gives much more control over the format of the date: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constants: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences\n\n#### Examples: \n```\nformat(#now, 'yyyy-MM-dd')\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_subtract_days)\n### `subtract_days`\nSame signification as [minus_days](OperatorsDM#minus_days)\n    \t\n----\n\n[//]: # (keyword|operator_subtract_hours)\n### `subtract_hours`\nSame signification as [minus_hours](OperatorsDM#minus_hours)\n    \t\n----\n\n[//]: # (keyword|operator_subtract_minutes)\n### `subtract_minutes`\nSame signification as [minus_minutes](OperatorsDM#minus_minutes)\n    \t\n----\n\n[//]: # (keyword|operator_subtract_months)\n### `subtract_months`\nSame signification as [minus_months](OperatorsDM#minus_months)\n    \t\n----\n\n[//]: # (keyword|operator_subtract_ms)\n### `subtract_ms`\nSame signification as [minus_ms](OperatorsDM#minus_ms)\n    \t\n----\n\n[//]: # (keyword|operator_subtract_seconds)\n### `subtract_seconds`\nSame signification as [-](OperatorsAC#-)\n    \t\n----\n\n[//]: # (keyword|operator_subtract_weeks)\n### `subtract_weeks`\nSame signification as [minus_weeks](OperatorsDM#minus_weeks)\n    \t\n----\n\n[//]: # (keyword|operator_subtract_years)\n### `subtract_years`\nSame signification as [minus_years](OperatorsDM#minus_years)\n    \t\n----\n\n[//]: # (keyword|operator_successors_of)\n### `successors_of`\n\n#### Possible use: \n  * `graph` **`successors_of`** `unknown` --->  `container`\n  *  **`successors_of`** (`graph` , `unknown`) --->  `container` \n\n#### Result: \nreturns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)\n\n#### Examples: \n```\ncontainer var1 <- graphEpidemio successors_of ({1,5}); \t// var1 equals [{12,45}]\ncontainer var2 <- graphEpidemio successors_of node({34,56}); \t// var2 equals []\n```\n      \n\n#### See also: \n[predecessors_of](OperatorsNZ#predecessors_of), [neighbors_of](OperatorsNZ#neighbors_of), \n    \t\n----\n\n[//]: # (keyword|operator_sum)\n### `sum`\n\n#### Possible use: \n  *  **`sum`** (`graph`) --->  `float`\n  *  **`sum`** (`container`) --->  `unknown` \n\n#### Result: \nthe sum of all the elements of the operand  \n\n#### Comment: \nthe behavior depends on the nature of the operand\n\n#### Special cases:     \n  * if it is a population or a list of other types: sum transforms all elements into float and sums them    \n  * if it is a map, sum returns the sum of the value of all elements    \n  * if it is a file, sum returns the sum of the content of the file (that is also a container)    \n  * if it is a graph, sum returns the total weight of the graph    \n  * if it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices)    \n  * if it is a matrix of other types: sum transforms all elements into float and sums them    \n  * if it is a list of colors: sum will sum them and return the blended resulting color    \n  * if it is a list of int or float: sum returns the sum of all the elements \n  \n```\nint var0 <- sum ([12,10,3]); \t// var0 equals 25\n\n``` \n\n    \n  * if it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element) \n  \n```\nunknown var1 <- sum([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); \t// var1 equals {20.0,17.0}\n\n``` \n\n    \n\n#### See also: \n[mul](OperatorsDM#mul), \n    \t\n----\n\n[//]: # (keyword|operator_sum_of)\n### `sum_of`\n\n#### Possible use: \n  * `container` **`sum_of`** `any expression` --->  `unknown`\n  *  **`sum_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe sum of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\nunknown var2 <- [1::2, 3::4, 5::6] sum_of (each + 3); \t// var2 equals 21\n\n``` \n\n\n\n#### Examples: \n```\nunknown var1 <- [1,2] sum_of (each * 100 ); \t// var1 equals 300\n```\n      \n\n#### See also: \n[min_of](OperatorsDM#min_of), [max_of](OperatorsDM#max_of), [product_of](OperatorsNZ#product_of), [mean_of](OperatorsDM#mean_of), \n    \t\n----\n\n[//]: # (keyword|operator_svg_file)\n### `svg_file`\n\n#### Possible use: \n  *  **`svg_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type svg. Allowed extensions are limited to svg\n    \t\n----\n\n[//]: # (keyword|operator_tan)\n### `tan`\n\n#### Possible use: \n  *  **`tan`** (`int`) --->  `float`\n  *  **`tan`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16    \n  * The tangent is only defined for any real number except 90 + k `*` 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).\n\n#### Examples: \n```\nfloat var0 <- tan (0); \t// var0 equals 0.0\nfloat var1 <- tan(90); \t// var1 equals 1.633123935319537E16\n```\n      \n\n#### See also: \n[cos](OperatorsAC#cos), [sin](OperatorsNZ#sin), \n    \t\n----\n\n[//]: # (keyword|operator_tan_rad)\n### `tan_rad`\n\n#### Possible use: \n  *  **`tan_rad`** (`float`) --->  `float` \n\n#### Result: \nReturns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.\n\n#### Special cases:     \n  * Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16    \n  * The tangent is only defined for any real number except 90 + k `*` 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).    \n\n#### See also: \n[cos](OperatorsAC#cos), [sin](OperatorsNZ#sin), \n    \t\n----\n\n[//]: # (keyword|operator_tanh)\n### `tanh`\n\n#### Possible use: \n  *  **`tanh`** (`float`) --->  `float`\n  *  **`tanh`** (`int`) --->  `float` \n\n#### Result: \nReturns the value (in the interval [-1,1]) of the hyperbolic tangent of the operand (which can be any real number, expressed in decimal degrees).\n\n#### Examples: \n```\nfloat var0 <- tanh(0); \t// var0 equals 0.0\nfloat var1 <- tanh(100); \t// var1 equals 1.0\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_target_of)\n### `target_of`\n\n#### Possible use: \n  * `graph` **`target_of`** `unknown` --->  `unknown`\n  *  **`target_of`** (`graph` , `unknown`) --->  `unknown` \n\n#### Result: \nreturns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.\n\n#### Special cases:     \n  * if the lef-hand operand (the graph) is nil, returns nil\n\n#### Examples: \n```\ngraph graphEpidemio <- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] );\nunknown var1 <- graphEpidemio source_of(edge(3)); \t// var1 equals node1\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nunknown var3 <- graphFromMap target_of(link({1,5}::{12,45})); \t// var3 equals {12,45}\n```\n      \n\n#### See also: \n[source_of](OperatorsNZ#source_of), \n    \t\n----\n\n[//]: # (keyword|operator_teapot)\n### `teapot`\n\n#### Possible use: \n  *  **`teapot`** (`float`) --->  `geometry` \n\n#### Result: \nA teapot geometry which radius is equal to the operand.  \n\n#### Comment: \nthe centre of the teapot is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns a point if the operand is lower or equal to 0.\n\n#### Examples: \n```\ngeometry var0 <- teapot(10); \t// var0 equals a geometry as a circle of radius 10 but displays a teapot.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), [triangle](OperatorsNZ#triangle), \n    \t\n----\n\n[//]: # (keyword|operator_text_file)\n### `text_file`\n\n#### Possible use: \n  *  **`text_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type text. Allowed extensions are limited to txt, data, text\n    \t\n----\n\n[//]: # (keyword|operator_threeds_file)\n### `threeds_file`\n\n#### Possible use: \n  *  **`threeds_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type threeds. Allowed extensions are limited to 3ds, max\n    \t\n----\n\n[//]: # (keyword|operator_to)\n### `to`\n\n#### Possible use: \n  * `date` **`to`** `date` --->  `msi.gama.util.IList<msi.gama.util.GamaDate>`\n  *  **`to`** (`date` , `date`) --->  `msi.gama.util.IList<msi.gama.util.GamaDate>` \n\n#### Result: \nbuilds an interval between two dates (the first inclusive and the second exclusive, which behaves like a read-only list of dates. The default step between two dates is the step of the model  \n\n#### Comment: \nThe default step can be overruled by using the every operator applied to this interval\n\n#### Examples: \n```\ndate('2000-01-01') to date('2010-01-01') // builds an interval between these two dates\n(date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval\n```\n      \n\n#### See also: \n[every](OperatorsDM#every), \n    \t\n----\n\n[//]: # (keyword|operator_to_GAMA_CRS)\n### `to_GAMA_CRS`\n\n#### Possible use: \n  *  **`to_GAMA_CRS`** (`geometry`) --->  `geometry`\n  * `geometry` **`to_GAMA_CRS`** `string` --->  `geometry`\n  *  **`to_GAMA_CRS`** (`geometry` , `string`) --->  `geometry`\n\n#### Special cases:     \n  * returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRS \n  \n```\ngeometry var0 <- to_GAMA_CRS({121,14}, \"EPSG:4326\"); \t// var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS\n\n``` \n\n    \n  * returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world's agent one \n  \n```\ngeometry var1 <- to_GAMA_CRS({121,14}); \t// var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_to_gaml)\n### `to_gaml`\n\n#### Possible use: \n  *  **`to_gaml`** (`unknown`) --->  `string` \n\n#### Result: \nreturns the literal description of an expression or description -- action, behavior, species, aspect, even model -- in gaml\n\n#### Examples: \n```\nstring var0 <- to_gaml(0); \t// var0 equals '0'\nstring var1 <- to_gaml(3.78); \t// var1 equals '3.78'\nstring var2 <- to_gaml(true); \t// var2 equals 'true'\nstring var3 <- to_gaml({23, 4.0}); \t// var3 equals '{23.0,4.0,0.0}'\nstring var4 <- to_gaml(5::34); \t// var4 equals '5::34'\nstring var5 <- to_gaml(rgb(255,0,125)); \t// var5 equals 'rgb (255, 0, 125,255)'\nstring var6 <- to_gaml('hello'); \t// var6 equals \"'hello'\"\nstring var7 <- to_gaml([1,5,9,3]); \t// var7 equals '[1,5,9,3]'\nstring var8 <- to_gaml(['a'::345, 'b'::13, 'c'::12]); \t// var8 equals \"(['a'::345,'b'::13,'c'::12] as map )\"\nstring var9 <- to_gaml([[3,5,7,9],[2,4,6,8]]); \t// var9 equals '[[3,5,7,9],[2,4,6,8]]'\nstring var10 <- to_gaml(a_graph); \t// var10 equals ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graph\nstring var11 <- to_gaml(node1); \t// var11 equals  1 as node\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_to_rectangles)\n### `to_rectangles`\n\n#### Possible use: \n  *  **`to_rectangles`** (`geometry`, `point`, `bool`) --->  `list<geometry>`\n  *  **`to_rectangles`** (`geometry`, `int`, `int`, `bool`) --->  `list<geometry>` \n\n#### Result: \nA list of rectangles of the size corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, dimension, overlaps), if overlaps = true, add the rectangles that overlap the border of the geometry\nA list of rectangles corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, nb_cols, nb_rows, overlaps) by a grid composed of the given number of columns and rows, if overlaps = true, add the rectangles that overlap the border of the geometry\n\n#### Examples: \n```\nlist<geometry> var0 <- to_rectangles(self, {10.0, 15.0}, true); \t// var0 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretization into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept\nlist<geometry> var1 <- to_rectangles(self, 5, 20, true); \t// var1 equals the list of rectangles corresponding to the discretization by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_to_squares)\n### `to_squares`\nSame signification as [split_geometry](OperatorsNZ#split_geometry)\n\n#### Possible use: \n  *  **`to_squares`** (`geometry`, `int`, `bool`) --->  `list<geometry>`\n  *  **`to_squares`** (`geometry`, `float`, `bool`) --->  `list<geometry>`\n  *  **`to_squares`** (`geometry`, `int`, `bool`, `float`) --->  `list<geometry>` \n\n#### Result: \nA list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps), if overlaps = true, add the squares that overlap the border of the geometry\nA list of squares of the size corresponding to the given size that result from the decomposition of the geometry into squares (geometry, size, overlaps), if overlaps = true, add the squares that overlap the border of the geometry\nA list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps, precision_coefficient), if overlaps = true, add the squares that overlap the border of the geometry, coefficient_precision should be close to 1.0\n\n#### Examples: \n```\nlist<geometry> var0 <- to_squares(self, 10, true); \t// var0 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept\nlist<geometry> var1 <- to_squares(self, 10.0, true); \t// var1 equals the list of squares of side size 10.0 corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept\nlist<geometry> var2 <- to_squares(self, 10, true, 0.99); \t// var2 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_to_triangles)\n### `to_triangles`\nSame signification as [triangulate](OperatorsNZ#triangulate)\n    \t\n----\n\n[//]: # (keyword|operator_tokenize)\n### `tokenize`\nSame signification as [split_with](OperatorsNZ#split_with)\n    \t\n----\n\n[//]: # (keyword|operator_topology)\n### `topology`\n\n#### Possible use: \n  *  **`topology`** (`unknown`) --->  `topology` \n\n#### Result: \ncasting of the operand to a topology.\n\n#### Special cases:     \n  * if the operand is a topology, returns the topology itself;    \n  * if the operand is a spatial graph, returns the graph topology associated;    \n  * if the operand is a population, returns the topology of the population;    \n  * if the operand is a shape or a geometry, returns the continuous topology bounded by the geometry;    \n  * if the operand is a matrix, returns the grid topology associated    \n  * if the operand is another kind of container, returns the multiple topology associated to the container    \n  * otherwise, casts the operand to a geometry and build a topology from it.\n\n#### Examples: \n```\ntopology var0 <- topology(0); \t// var0 equals nil\ntopology(a_graph)\t--: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046  7.867357373616512)) at location[53.556743711446195;34.57529210646354]\n```\n      \n\n#### See also: \n[geometry](OperatorsDM#geometry), \n    \t\n----\n\n[//]: # (keyword|operator_touches)\n### `touches`\n\n#### Possible use: \n  * `geometry` **`touches`** `geometry` --->  `bool`\n  *  **`touches`** (`geometry` , `geometry`) --->  `bool` \n\n#### Result: \nA boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).  \n\n#### Comment: \nreturns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.\n\n#### Special cases:     \n  * if one of the operand is null, returns false.\n\n#### Examples: \n```\nbool var0 <- polyline([{10,10},{20,20}]) touches {15,15}; \t// var0 equals false\nbool var1 <- polyline([{10,10},{20,20}]) touches {10,10}; \t// var1 equals true\nbool var2 <- {15,15} touches {15,15}; \t// var2 equals false\nbool var3 <- polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]); \t// var3 equals true\nbool var4 <- polyline([{10,10},{20,20}]) touches polyline([{5,5},{15,15}]); \t// var4 equals false\nbool var5 <- polyline([{10,10},{20,20}]) touches polyline([{15,15},{25,25}]); \t// var5 equals false\nbool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var6 equals false\nbool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var7 equals true\nbool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,10},{0,10},{0,0},{10,0}]); \t// var8 equals true\nbool var9 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {15,15}; \t// var9 equals false\nbool var10 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {10,15}; \t// var10 equals true\n```\n      \n\n#### See also: \n[disjoint_from](OperatorsDM#disjoint_from), [crosses](OperatorsAC#crosses), [overlaps](OperatorsNZ#overlaps), [partially_overlaps](OperatorsNZ#partially_overlaps), [intersects](OperatorsDM#intersects), \n    \t\n----\n\n[//]: # (keyword|operator_towards)\n### `towards`\n\n#### Possible use: \n  * `geometry` **`towards`** `geometry` --->  `int`\n  *  **`towards`** (`geometry` , `geometry`) --->  `int` \n\n#### Result: \nThe direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.\n\n#### Examples: \n```\nint var0 <- ag1 towards ag2; \t// var0 equals the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operator\n```\n      \n\n#### See also: \n[distance_between](OperatorsDM#distance_between), [distance_to](OperatorsDM#distance_to), [direction_between](OperatorsDM#direction_between), [path_between](OperatorsNZ#path_between), [path_to](OperatorsNZ#path_to), \n    \t\n----\n\n[//]: # (keyword|operator_trace)\n### `trace`\n\n#### Possible use: \n  *  **`trace`** (`matrix`) --->  `float` \n\n#### Result: \nThe trace of the given matrix (the sum of the elements on the main diagonal).\n\n#### Examples: \n```\nfloat var0 <- trace(matrix([[1,2],[3,4]])); \t// var0 equals 5\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_transformed_by)\n### `transformed_by`\n\n#### Possible use: \n  * `geometry` **`transformed_by`** `point` --->  `geometry`\n  *  **`transformed_by`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the application of a rotation and a scaling (right-operand : point {angle(degree), scale factor} of the left-hand operand (geometry, agent, point)\n\n#### Examples: \n```\ngeometry var0 <- self transformed_by {45, 0.5}; \t// var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.\n```\n      \n\n#### See also: \n[rotated_by](OperatorsNZ#rotated_by), [translated_by](OperatorsNZ#translated_by), \n    \t\n----\n\n[//]: # (keyword|operator_translated_by)\n### `translated_by`\n\n#### Possible use: \n  * `geometry` **`translated_by`** `point` --->  `geometry`\n  *  **`translated_by`** (`geometry` , `point`) --->  `geometry` \n\n#### Result: \nA geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)\n\n#### Examples: \n```\ngeometry var0 <- self translated_by {10,10,10}; \t// var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).\n```\n      \n\n#### See also: \n[rotated_by](OperatorsNZ#rotated_by), [transformed_by](OperatorsNZ#transformed_by), \n    \t\n----\n\n[//]: # (keyword|operator_translated_to)\n### `translated_to`\nSame signification as [at_location](OperatorsAC#at_location)\n    \t\n----\n\n[//]: # (keyword|operator_transpose)\n### `transpose`\n\n#### Possible use: \n  *  **`transpose`** (`matrix`) --->  `matrix` \n\n#### Result: \nThe transposition of the given matrix\n\n#### Examples: \n```\nmatrix var0 <- transpose(matrix([[5,-3],[6,-4]])); \t// var0 equals [[5,6],[-3,-4]]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_triangle)\n### `triangle`\n\n#### Possible use: \n  *  **`triangle`** (`float`) --->  `geometry` \n\n#### Result: \nA triangle geometry which side size is given by the operand.  \n\n#### Comment: \nthe center of the triangle is by default the location of the current agent in which has been called this operator.\n\n#### Special cases:     \n  * returns nil if the operand is nil.\n\n#### Examples: \n```\ngeometry var0 <- triangle(5); \t// var0 equals a geometry as a triangle with side_size = 5.\n```\n      \n\n#### See also: \n[around](OperatorsAC#around), [circle](OperatorsAC#circle), [cone](OperatorsAC#cone), [line](OperatorsDM#line), [link](OperatorsDM#link), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), [polygon](OperatorsNZ#polygon), [polyline](OperatorsNZ#polyline), [rectangle](OperatorsNZ#rectangle), [square](OperatorsNZ#square), \n    \t\n----\n\n[//]: # (keyword|operator_triangulate)\n### `triangulate`\n\n#### Possible use: \n  *  **`triangulate`** (`list<geometry>`) --->  `list<geometry>`\n  *  **`triangulate`** (`geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)\n\n#### Examples: \n```\nlist<geometry> var0 <- triangulate(self); \t// var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.\nlist<geometry> var1 <- triangulate(self); \t// var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_truncated_gauss)\n### `truncated_gauss`\n\n#### Possible use: \n  *  **`truncated_gauss`** (`container`) --->  `float`\n  *  **`truncated_gauss`** (`point`) --->  `float` \n\n#### Result: \nA random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.\n\n#### Special cases:     \n  * if the operand is a list, only the two first elements are taken into account as [mean, standardDeviation]    \n  * when truncated_gauss is called with a list of only one element mean, it will always return 0.0    \n  * when the operand is a point, it is read as {mean, standardDeviation}\n\n#### Examples: \n```\nfloat var0 <- truncated_gauss ([0.5, 0.0]); \t// var0 equals 0.5\nfloat var1 <- truncated_gauss ({0, 0.3}); \t// var1 equals a float between -0.3 and 0.3\n```\n      \n\n#### See also: \n[gauss](OperatorsDM#gauss), \n    \t\n----\n\n[//]: # (keyword|operator_undirected)\n### `undirected`\n\n#### Possible use: \n  *  **`undirected`** (`graph`) --->  `graph` \n\n#### Result: \nthe operand graph becomes an undirected graph.  \n\n#### Comment: \nthe operator alters the operand graph, it does not create a new one.    \n\n#### See also: \n[directed](OperatorsDM#directed), \n    \t\n----\n\n[//]: # (keyword|operator_union)\n### `union`\n\n#### Possible use: \n  *  **`union`** (`container<geometry>`) --->  `geometry`\n  * `container` **`union`** `container` --->  `container`\n  *  **`union`** (`container` , `container`) --->  `container` \n\n#### Result: \nreturns a new list containing all the elements of both containers without duplicated elements.\n\n#### Special cases:     \n  * if the left or right operand is nil, union throws an error    \n  * if the right-operand is a container of points, geometries or agents, returns the geometry resulting from the union all the geometries\n\n#### Examples: \n```\ncontainer var0 <- [1,2,3,4,5,6] union [2,4,9]; \t// var0 equals [1,2,3,4,5,6,9]\ncontainer var1 <- [1,2,3,4,5,6] union [0,8]; \t// var1 equals [1,2,3,4,5,6,0,8]\ncontainer var2 <- [1,3,2,4,5,6,8,5,6] union [0,8]; \t// var2 equals [1,3,2,4,5,6,8,0]\ngeometry var3 <- union([geom1, geom2, geom3]); \t// var3 equals a geometry corresponding to union between geom1, geom2 and geom3\n```\n      \n\n#### See also: \n[inter](OperatorsDM#inter), [+](OperatorsAC#+), \n    \t\n----\n\n[//]: # (keyword|operator_unknown)\n### `unknown`\n\n#### Possible use: \n  *  **`unknown`** (`any`) --->  `unknown` \n\n#### Result: \nCasts the operand into the type unknown\n    \t\n----\n\n[//]: # (keyword|operator_until)\n### `until`\n\n#### Possible use: \n  *  **`until`** (`date`) --->  `bool`\n  * `any expression` **`until`** `date` --->  `bool`\n  *  **`until`** (`any expression` , `date`) --->  `bool` \n\n#### Result: \nReturns true if the current_date of the model is before (or equel to) the date passed in argument. Synonym of 'current_date <= argument'\n\n#### Examples: \n```\nreflex when: until(starting_date) {} -: will be run only once at the beginning of the simulation\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_upper_case)\n### `upper_case`\n\n#### Possible use: \n  *  **`upper_case`** (`string`) --->  `string` \n\n#### Result: \nConverts all of the characters in the string operand to upper case\n\n#### Examples: \n```\nstring var0 <- upper_case(\"Abc\"); \t// var0 equals 'ABC'\n```\n      \n\n#### See also: \n[lower_case](OperatorsDM#lower_case), \n    \t\n----\n\n[//]: # (keyword|operator_use_cache)\n### `use_cache`\n\n#### Possible use: \n  * `graph` **`use_cache`** `bool` --->  `graph`\n  *  **`use_cache`** (`graph` , `bool`) --->  `graph` \n\n#### Result: \nif the second operand is true, the operand graph will store in a cache all the previously computed shortest path (the cache be cleared if the graph is modified).  \n\n#### Comment: \nthe operator alters the operand graph, it does not create a new one.    \n\n#### See also: \n[path_between](OperatorsNZ#path_between), \n    \t\n----\n\n[//]: # (keyword|operator_user_input)\n### `user_input`\n\n#### Possible use: \n  *  **`user_input`** (`any expression`) --->  `map<string,unknown>`\n  * `string` **`user_input`** `any expression` --->  `map<string,unknown>`\n  *  **`user_input`** (`string` , `any expression`) --->  `map<string,unknown>` \n\n#### Result: \nasks the user for some values (not defined as parameters). Takes a string (optional) and a map as arguments. The string is used to specify the message of the dialog box. The map is to specify the parameters you want the user to change before the simulation starts, with the name of the parameter in string key, and the default value as value.  \n\n#### Comment: \nThis operator takes a map [string::value] as argument, displays a dialog asking the user for these values, and returns the same map with the modified values (if any). The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section to force the user to input new values instead of relying on the initial values of parameters :\n\n#### Examples: \n```\nmap<string,unknown> values2 <- user_input(\"Enter numer of agents and locations\",[\"Number\" :: 100, \"Location\" :: {10, 10}]);\ncreate bug number: int(values2 at \"Number\") with: [location:: (point(values2 at \"Location\"))];\nmap<string,unknown> values <- user_input([\"Number\" :: 100, \"Location\" :: {10, 10}]);\ncreate bug number: int(values at \"Number\") with: [location:: (point(values at \"Location\"))];\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_using)\n### `using`\n\n#### Possible use: \n  * `any expression` **`using`** `topology` --->  `unknown`\n  *  **`using`** (`any expression` , `topology`) --->  `unknown` \n\n#### Result: \nAllows to specify in which topology a spatial computation should take place.\n\n#### Special cases:     \n  * has no effect if the topology passed as a parameter is nil\n\n#### Examples: \n```\nunknown var0 <- (agents closest_to self) using topology(world); \t// var0 equals the closest agent to self (the caller) in the continuous topology of the world\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_variance)\n### `variance`\n\n#### Possible use: \n  *  **`variance`** (`container`) --->  `float` \n\n#### Result: \nthe variance of the elements of the operand. See <A href=\"http://en.wikipedia.org/wiki/Variance\">Variance</A> for more details.  \n\n#### Comment: \nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\n\n#### Examples: \n```\nfloat var0 <- variance ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.671875\n```\n      \n\n#### See also: \n[mean](OperatorsDM#mean), [median](OperatorsDM#median), \n    \t\n----\n\n[//]: # (keyword|operator_variance_of)\n### `variance_of`\n\n#### Possible use: \n  * `container` **`variance_of`** `any expression` --->  `unknown`\n  *  **`variance_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \nthe variance of the right-hand expression evaluated on each of the elements of the left-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.    \n\n#### See also: \n[min_of](OperatorsDM#min_of), [max_of](OperatorsDM#max_of), [sum_of](OperatorsNZ#sum_of), [product_of](OperatorsNZ#product_of), \n    \t\n----\n\n[//]: # (keyword|operator_voronoi)\n### `voronoi`\n\n#### Possible use: \n  *  **`voronoi`** (`list<point>`) --->  `list<geometry>`\n  * `list<point>` **`voronoi`** `geometry` --->  `list<geometry>`\n  *  **`voronoi`** (`list<point>` , `geometry`) --->  `list<geometry>` \n\n#### Result: \nA list of geometries corresponding to the Voronoi diagram built from the list of points according to the given clip\nA list of geometries corresponding to the Voronoi diagram built from the list of points\n\n#### Examples: \n```\nlist<geometry> var0 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}], square(300)); \t// var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points with a square of 300m side size as clip.\nlist<geometry> var1 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]); \t// var1 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points.\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_weight_of)\n### `weight_of`\n\n#### Possible use: \n  * `graph` **`weight_of`** `unknown` --->  `float`\n  *  **`weight_of`** (`graph` , `unknown`) --->  `float` \n\n#### Result: \nreturns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.  \n\n#### Comment: \nIn a localized graph, an edge has a weight by default (the distance between both vertices).\n\n#### Special cases:     \n  * if the left-operand (the graph) is nil, returns nil    \n  * if the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight    \n  * if the right-hand operand is neither a node, nor an edge, returns 1.\n\n#### Examples: \n```\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);\nfloat var1 <- graphFromMap weight_of(link({1,5}::{12,45})); \t// var1 equals 1.0\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_weighted_means_DM)\n### `weighted_means_DM`\n\n#### Possible use: \n  * `list<list>` **`weighted_means_DM`** `list<map<string,object>>` --->  `int`\n  *  **`weighted_means_DM`** (`list<list>` , `list<map<string,object>>`) --->  `int` \n\n#### Result: \nThe index of the candidate that maximizes the weighted mean of its criterion values. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of map)\n\n#### Special cases:     \n  * returns -1 is the list of candidates is nil or empty\n\n#### Examples: \n```\nint var0 <- weighted_means_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0],[\"name\"::\"price\", \"weight\" :: 1.0]]); \t// var0 equals 1\n```\n      \n\n#### See also: \n[promethee_DM](OperatorsNZ#promethee_dm), [electre_DM](OperatorsDM#electre_dm), [evidence_theory_DM](OperatorsDM#evidence_theory_dm), \n    \t\n----\n\n[//]: # (keyword|operator_where)\n### `where`\n\n#### Possible use: \n  * `container` **`where`** `any expression` --->  `container`\n  *  **`where`** (`container` , `any expression`) --->  `container` \n\n#### Result: \na list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true.  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is a list nil, where returns a new empty list    \n  * if the left-operand is a map, the keyword each will contain each value \n  \n```\ncontainer var4 <- [1::2, 3::4, 5::6] where (each >= 4); \t// var4 equals [4, 6]\n\n``` \n\n\n\n#### Examples: \n```\ncontainer var0 <- [1,2,3,4,5,6,7,8] where (each > 3); \t// var0 equals [4, 5, 6, 7, 8] \ncontainer var2 <- g2 where (length(g2 out_edges_of each) = 0 ); \t// var2 equals [node9, node7, node10, node8, node11]\ncontainer var3 <- (list(node) where (round(node(each).location.x) > 32); \t// var3 equals [node2, node3]\n```\n      \n\n#### See also: \n[first_with](OperatorsDM#first_with), [last_with](OperatorsDM#last_with), [where](OperatorsNZ#where), \n    \t\n----\n\n[//]: # (keyword|operator_with_lifetime)\n### `with_lifetime`\n\n#### Possible use: \n  * `predicate` **`with_lifetime`** `int` --->  `predicate`\n  *  **`with_lifetime`** (`predicate` , `int`) --->  `predicate` \n\n#### Result: \nchange the parameters of the given predicate\n\n#### Examples: \n```\npredicate with_lifetime 10\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_with_max_of)\n### `with_max_of`\n\n#### Possible use: \n  * `container` **`with_max_of`** `any expression` --->  `unknown`\n  *  **`with_max_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \none of elements of the left-hand operand that maximizes the value of the right-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand\n\n#### Examples: \n```\nunknown var0 <- [1,2,3,4,5,6,7,8] with_max_of (each ); \t// var0 equals 8\nunknown var2 <- g2 with_max_of (length(g2 out_edges_of each)  ) ; \t// var2 equals node4\nunknown var3 <- (list(node) with_max_of (round(node(each).location.x)); \t// var3 equals node3\nunknown var4 <- [1::2, 3::4, 5::6] with_max_of (each); \t// var4 equals 6\n```\n      \n\n#### See also: \n[where](OperatorsNZ#where), [with_min_of](OperatorsNZ#with_min_of), \n    \t\n----\n\n[//]: # (keyword|operator_with_min_of)\n### `with_min_of`\n\n#### Possible use: \n  * `container` **`with_min_of`** `any expression` --->  `unknown`\n  *  **`with_min_of`** (`container` , `any expression`) --->  `unknown` \n\n#### Result: \none of elements of the left-hand operand that minimizes the value of the right-hand operand  \n\n#### Comment: \nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\n\n#### Special cases:     \n  * if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand\n\n#### Examples: \n```\nunknown var0 <- [1,2,3,4,5,6,7,8] with_min_of (each ); \t// var0 equals 1\nunknown var2 <- g2 with_min_of (length(g2 out_edges_of each)  ); \t// var2 equals node11\nunknown var3 <- (list(node) with_min_of (round(node(each).location.x)); \t// var3 equals node0\nunknown var4 <- [1::2, 3::4, 5::6] with_min_of (each); \t// var4 equals 2\n```\n      \n\n#### See also: \n[where](OperatorsNZ#where), [with_max_of](OperatorsNZ#with_max_of), \n    \t\n----\n\n[//]: # (keyword|operator_with_optimizer_type)\n### `with_optimizer_type`\n\n#### Possible use: \n  * `graph` **`with_optimizer_type`** `string` --->  `graph`\n  *  **`with_optimizer_type`** (`graph` , `string`) --->  `graph` \n\n#### Result: \nchanges the shortest path computation method of the given graph  \n\n#### Comment: \nthe right-hand operand can be \"Djikstra\", \"Bellmann\", \"Astar\" to use the associated algorithm. Note that these methods are dynamic: the path is computed when needed. In contrarily, if the operand is another string, a static method will be used, i.e. all the shortest are previously computed.\n\n#### Examples: \n```\ngraphEpidemio <- graphEpidemio with_optimizer_type \"static\";\n```\n      \n\n#### See also: \n[set_verbose](OperatorsNZ#set_verbose), \n    \t\n----\n\n[//]: # (keyword|operator_with_praiseworthiness)\n### `with_praiseworthiness`\n\n#### Possible use: \n  * `predicate` **`with_praiseworthiness`** `float` --->  `predicate`\n  *  **`with_praiseworthiness`** (`predicate` , `float`) --->  `predicate` \n\n#### Result: \nchange the praiseworthiness value of the given predicate\n\n#### Examples: \n```\npredicate set_truth false\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_with_precision)\n### `with_precision`\n\n#### Possible use: \n  * `float` **`with_precision`** `int` --->  `float`\n  *  **`with_precision`** (`float` , `int`) --->  `float`\n  * `point` **`with_precision`** `int` --->  `point`\n  *  **`with_precision`** (`point` , `int`) --->  `point` \n\n#### Result: \nRounds off the value of left-hand operand to the precision given by the value of right-hand operand\nRounds off the ordinates of the left-hand point to the precision given by the value of right-hand operand\n\n#### Examples: \n```\nfloat var0 <- 12345.78943 with_precision 2; \t// var0 equals 12345.79\nfloat var1 <- 123 with_precision 2; \t// var1 equals 123.00\npoint var2 <- {12345.78943, 12345.78943, 12345.78943} with_precision 2 ; \t// var2 equals {12345.79, 12345.79, 12345.79}\n```\n      \n\n#### See also: \n[round](OperatorsNZ#round), \n    \t\n----\n\n[//]: # (keyword|operator_with_priority)\n### `with_priority`\n\n#### Possible use: \n  * `predicate` **`with_priority`** `float` --->  `predicate`\n  *  **`with_priority`** (`predicate` , `float`) --->  `predicate` \n\n#### Result: \nchange the priority of the given predicate\n\n#### Examples: \n```\npredicate with_priority 2\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_with_values)\n### `with_values`\n\n#### Possible use: \n  * `predicate` **`with_values`** `map` --->  `predicate`\n  *  **`with_values`** (`predicate` , `map`) --->  `predicate` \n\n#### Result: \nchange the parameters of the given predicate\n\n#### Examples: \n```\npredicate with_values [\"time\"::10]\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_with_weights)\n### `with_weights`\n\n#### Possible use: \n  * `graph` **`with_weights`** `map` --->  `graph`\n  *  **`with_weights`** (`graph` , `map`) --->  `graph`\n  * `graph` **`with_weights`** `container` --->  `graph`\n  *  **`with_weights`** (`graph` , `container`) --->  `graph` \n\n#### Result: \nreturns the graph (left-hand operand) with weight given in the map (right-hand operand).  \n\n#### Comment: \nthis operand re-initializes the path finder\n\n#### Special cases:     \n  * if the right-hand operand is a list, affects the n elements of the list to the n first edges. Note that the ordering of edges may change overtime, which can create some problems...    \n  * if the left-hand operand is a map, the map should contains pairs such as: vertex/edge::double \n  \n```\ngraph_from_edges (list(ant) as_map each::one_of (list(ant))) with_weights (list(ant) as_map each::each.food)\n\n``` \n\n\n    \t\n----\n\n[//]: # (keyword|operator_without_holes)\n### `without_holes`\n\n#### Possible use: \n  *  **`without_holes`** (`geometry`) --->  `geometry` \n\n#### Result: \nA geometry corresponding to the operand geometry (geometry, agent, point) without its holes\n\n#### Examples: \n```\ngeometry var0 <- solid(self); \t// var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes.\n```\n  \n    \t\n----\n\n[//]: # (keyword|operator_writable)\n### `writable`\n\n#### Possible use: \n  * `file` **`writable`** `bool` --->  `file`\n  *  **`writable`** (`file` , `bool`) --->  `file` \n\n#### Result: \nMarks the file as read-only or not, depending on the second boolean argument, and returns the first argument  \n\n#### Comment: \nA file is created using its native flags. This operator can change them. Beware that this change is system-wide (and not only restrained to GAMA): changing a file to read-only mode (e.g. \"writable(f, false)\")\n\n#### Examples: \n```\nfile var0 <- shape_file(\"../images/point_eau.shp\") writable false; \t// var0 equals returns a file in read-only mode\n```\n      \n\n#### See also: \n[file](OperatorsDM#file), \n    \t\n----\n\n[//]: # (keyword|operator_xml_file)\n### `xml_file`\n\n#### Possible use: \n  *  **`xml_file`** (`string`) --->  `file` \n\n#### Result: \nConstructs a file of type xml. Allowed extensions are limited to xml\n    \t\n----\n\n[//]: # (keyword|operator_years_between)\n### `years_between`\n\n#### Possible use: \n  * `date` **`years_between`** `date` --->  `int`\n  *  **`years_between`** (`date` , `date`) --->  `int` \n\n#### Result: \nProvide the exact number of years between two dates. This number can be positive or negative (if the second operand is smaller than the first one)\n\n#### Examples: \n```\nyears_between(d1, d2) -: 10 \n```\n  ","url":"wiki/OperatorsNZ.md"},"Overview.md":{"title":" Introduction","content":"\n# Introduction\n\n| <a href='http://www.youtube.com/watch?feature=player_embedded&v=6m_-UY8UBuk' target='_blank'><img src='http://img.youtube.com/vi/6m_-UY8UBuk/0.jpg' width='425' height=344 /></a> | <a href='http://www.youtube.com/watch?feature=player_embedded&v=ycbeYxV2B7M' target='_blank'><img src='http://img.youtube.com/vi/ycbeYxV2B7M/0.jpg' width='425' height=344 /></a> |\n|---|---|\n\n\n**GAMA** is a simulation platform, which aims at providing field experts, modellers, and computer scientists with a complete modelling and simulation development environment for building spatially explicit multi-agent simulations. It has been first developed by the Vietnamese-French research team MSI (located at IFI, Hanoi, and part of the IRD/UPMC International Research Unit UMMISCO) from 2007 to 2010, and is now developed by a consortium of academic and industrial partners led by UMMISCO, among which the University of Rouen, France, the University of Toulouse 1, France, the University of Orsay, France, the University of Can Tho, Vietnam, the National University of Hanoi, EDF R&D, France, and CEA LISC, France.\n\nSome of the features of GAMA are illustrated in the videos above (more can be found [in our Youtube channel](http://www.youtube.com/channel/UCWJ1kWGDDI-9u2f2uD0gcaQ)).\n\nBeyond these features, GAMA also offers:\n\n* A complete modeling language, GAML, for modeling agents and environments\n* A large and extensible library of primitives (agent's movement, communication, mathematical functions, graphical features, ...)\n* A cross-platform reproducibility of experiments and simulations\n* A powerful declarative drawing and plotting subsystem\n* A flexible user interface based on the Eclipse platform\n* A complete set of batch tools, allowing for a systematic or \"intelligent\" exploration of models parameters spaces\n\n\n## Documentation\nThe documentation of GAMA is available online on the wiki of the project. It is organized around a few central activities ([installing GAMA](Installation), [writing models](WritingModels), [running experiments](LaunchingExperiments), [developing new extensions to the platform](DevelopingExtensions)) and provides complete references on both the [GAML language](GamlLanguage), the [platform](Platform) itself, and the scientific aspects of our work (with a complete [bibliography](References)). Several [tutorials](Tutorials) are also provided in the documentation in order to minimize the learning curve, allowing users to build, step by step, the models corresponding to these tutorials, which are of course shipped with the platform.\n\nThe documentation can be accessed from the side bar of this page. A good starting point for new users is [the installation page](Installation).\n\nA standalone version of the documentation, in PDF format, can be directly downloaded from [here](https://github.com/gama-platform/gama/wiki/Content/ressources/pdf/GAMA 1.6.1 Documentation.pdf)\n\n\n## Source Code\nGAMA can be [downloaded](Download) as a regular application or [built from source](https://github.com/gama-platform/gama), which is necessary if you want to contribute to the platform.\nThe source code is available from this GITHub repository:\n\n```\nhttps://github.com/gama-platform/gama\n```\n\nWhich you can also browse from the web [here](https://github.com/gama-platform/gama).\nIt is, in any case, recommended to follow the instructions on [this page](InstallingGitVersion) in order to build GAMA from source.\n\n\n\n\n## Copyright Information\nThis is a free software (distributed under the GNU GPL v3 license), so you can have access to the code, edit it and redistribute it under the same terms. Independently of the licensing issues, if you plan on reusing part of our code, we would be glad to know it !\n\n\n\n\n## Developers\nGAMA is being designed, developed and maintained by an active group of researchers coming from different institutions in France and Vietnam. Please find below a short introduction to each of them and a summary of their contributions to the platform:\n\n* **[Alexis Drogoul](https://www.researchgate.net/profile/Alexis_Drogoul)**, Senior Researcher at the [IRD](http://www.ird.fr), member of the [UMMISCO](http://www.ummisco.ird.fr) International Research Unit. Mostly working on agent-based modeling and simulation. Has contributed and still contributes to the original design of the platform, including the GAML language (from the meta-model to the editor) and simulation facilities like Java2D displays.\n* **[Patrick Taillandier](https://www.researchgate.net/profile/Patrick_Taillandier)**, Associate Professor at the [University of Rouen](http://www.univ-rouen.fr/), member of the [IDEES](http://www.umr-idees.fr/) CNRS Mixed Research Unit. Contributes since 2008 to the spatial and graph features (GIS integration, spatial operators) and to parameter space search algorithms. Currently working on new features related to graphical modeling and traffic simulation.\n* **[Benoit Gaudou](http://www.researchgate.net/profile/Benoit_Gaudou)**, Associate Professor at the [University Toulouse 1 Capitole](http://www.ut-capitole.fr/), member of the [IRIT](http://www.irit.fr/) CNRS Mixed Research Unit. Contributes since 2010 to documentation and unit test generation and coupling mathematical (ODE and PDE) and agent paradigms.\n* **[Arnaud Grignard](https://www.researchgate.net/profile/Arnaud_Grignard)**, software engineer and PhD fellow ([PDI-MSC](http://www.ummisco.ird.fr/pdi/)) at [UPMC](http://www.upmc.fr/). Contributes since 2011 to the development of new features related to visualization (3D Display), online analysis and interaction.\n* **[Huynh Quang Nghi](https://www.researchgate.net/profile/Huynh_Nghi)**, software engineering lecturer at [CTU](http://www.ctu.edu.vn) and PhD fellow ([PDI-MSC](http://www.ummisco.ird.fr/pdi/)) at [UPMC](http://www.upmc.fr/). Contributes since 2012 to the development of new features related to GAML parser, coupling formalisms in EBM-ABM and ABM-ABM.\n* **[Truong Minh Thai](https://www.researchgate.net/profile/Thai_Truong_Minh)**, software engineering lecturer at [CTU](http://www.ctu.edu.vn/) and PhD fellow (PRJ322-MOET) at [IRIT](http://www.irit.fr/)-[UT1](http://www.ut-capitole.fr/). Contributes since 2012 to the development of new features related to data management and analysis.\n* **[Nicolas Marilleau](http://www.ummisco.ird.fr/index.php?option=com_members&view=member&uid=62&Itemid=70)**, Researcher at the [IRD](http://www.ird.fr), member of the [UMMISCO](http://www.ummisco.ird.fr) International Research Unit and associate researcher at [DISC](http://disc.univ-fcomte.fr) team of [FEMTO-ST](http://www.femto-st.fr) institute. Contributes since 2010 to the development of headless mode and the high performance computing module.\n* **[Philippe Caillou](https://www.lri.fr/~caillou)**, Associate professor at the [University Paris Sud 11](http://www.u-psud.fr), member of the [LRI](http://www.lri.fr) and [INRIA](http://www.inria.fr) project-team [TAO](https://tao.lri.fr/tiki-index.php). Contributes since 2012 and actually working on charts, simulation analysis and BDI agents.\n* **[Vo Duc An](https://www.researchgate.net/profile/Duc-An_Vo)**, Post-doctoral Researcher, working on synthetic population generation in agent-based modelling, at the [UMMISCO](http://www.ummisco.ird.fr) International Research Unit of the [IRD](http://www.ird.fr). Has contributed to bringing the platform to the Eclipse RCP environment and to the development of several features (e.g., the FIPA-compliant agent communication capability, the multi-level architecture).\n* **[Truong Xuan Viet](https://www.researchgate.net/profile/Viet_Truong_Xuan)**, software engineering lecturer at [CTU](http://www.ctu.edu.vn) and PhD fellow ([PDI-MSC](http://www.ummisco.ird.fr/pdi/)) at [UPMC](http://www.upmc.fr/). Contributes since 2011 to the development of new features related to R caller, online GIS (OPENGIS: Web Map Service - WMS, Web Feature Services - WMS, Google map, etc).\n  * Samuel Thiriot\n\n\n\n\n## Citing GAMA\nIf you use GAMA in your research and want to cite it (in a paper, presentation, whatever), please use this reference:\n\n> A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems', Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.\n\nor you can choose to cite the website instead:\n\n> GAMA Platform website, http://gama-platform.org\n\nA complete list of references (papers and PhD theses on or using GAMA) is available on the [references](References) page.\n\n\n\n## Contact Us\nThe best way to get in touch with the developers of GAMA is to sign in for the [gama-platform@googlegroups.com mailing list](http://groups.google.com/group/gama-platform). If you wish to contribute to the platform, you might want, instead or in addition, to sign in for the [gama-dev@googlegroups.com mailing list](http://groups.google.com/group/gama-dev). On both lists, we generally answer quite quickly to requests.\n\nFinally, if you think you have found a bug in GAMA, or if you absolutely need a feature that does not exist yet, it is much more efficient and time-saving for everyone (including current and future users) to create a new issue report. Please refer to [these instructions](Troubleshooting#Submitting_an_Issue) to do so.","url":"wiki/Overview.md"},"PedagogicalMaterials.md":{"title":" Initiation to algorithms with Scratch","content":"# Initiation to algorithms with Scratch\nA set of exercices for your first step to algorithms using the graphical tool Scratch: [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/InitiationtoAlgorithmicswithScratch.pdf?attredirects=0&d=1).\n\n# Memo GAML\nA summary of the organization of a GAML model, its main parts and the main keywords, statements: [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/MementoAlgoGAML.pdf?attredirects=0&d=1).\n\n# Exercice (*): Firefly synchronization\nFrom UML diagram, implement a GAMA model.\n* **Keywords:** grid, displays, plot, synchronization.\n* **Subject:** [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Fireflies Exo.pdf?attredirects=0&amp;d=1), [Keynote](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Fireflies Exo.key?attredirects=0&amp;d=1), [PPTX](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Fireflies Exo.pptx?attredirects=0&d=1)\n* **UML diagrams:** [asta version](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/UML_Firefly_sync.asta?attredirects=0&d=1)\n* **A model:** [gaml file](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/luciole_on_grid.gaml?attredirects=0&d=1)\n\n# Exercice (*): Firefighter model\nImplement the model given in the model description file. The guide file helps you to separate the implementation of the structure of the model, its initialization, its dynamics and ways to visualize it.\n* **Keywords:** grid, inheritance, displays, plot, 3D.\n* **Model description**: [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Firefighter - Model description.pdf?attredirects=0&d=1)\n* **Guide:** [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Firefighter - Guide.pdf?attredirects=0&d=1), [Keynote](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Firefighter - Guide.key?attredirects=0&d=1), [PPTX](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Firefighter - Guide.pptx?attredirects=0&d=1)\n* **UML diagrams:** [asta version](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/UML_Pompiers_GAMA.asta?attredirects=0&d=1)\n* **A model:** [gaml file](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Firefighter.zip?attredirects=0&d=1)\n\n# Exercice (**): Wolves, Goats, Cabbages model\nImplement the model given in the model description file. The detailed subject divides the model in 3 steps and contains helps and advices to implement the model.\n* **Keywords:** grid, inheritance, displays, plot, prey-predator model.\n* **Model description**: [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Firefighter - Model description.pdf?attredirects=0&d=1)\n* **Detailed subject:** [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Coding Practice - subject with notes.pdf?attredirects=0&d=1), [Word](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Coding Practice - subject with notes.docx?attredirects=0&d=1)\n* **Guide:** [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Coding Practice.pptx.pdf?attredirects=0&d=1), [PPTX](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Coding Practice.pptx.pptx?attredirects=0&d=1)\n* **A model:** [gaml file](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Wolves-Goat-Cabbages.zip?attredirects=0&d=1)\n\n# Exercice (**): Schelling model\n* **Keywords:** grid, GIS data, displays, plot, Graphical modeling, Schelling model.\n* **Subject:** [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/MISS ABMS 2014 - Schelling.pdf?attredirects=0&d=1), [Keynote](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/MISS ABMS 2014 - Schelling.key?attredirects=0&d=1), [PPTX](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/MISS ABMS 2014 - Schelling.pptx?attredirects=0&d=1)\n* **A model:** [gaml file](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Schelling.zip?attredirects=0&d=1)\n\n# Exercice (**): Traffic model\n* **Keywords:** GIS data, graph, skills, moving skill, displays, plot, mobillity model.\n* **Subject:** [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/MISS ABMS 2014 - Traffic.pdf?attredirects=0&d=1), [Keynote](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/MISS ABMS 2014 - Traffic.key?attredirects=0&d=1), [PPTX](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/MISS ABMS 2014 - Traffic.pptx?attredirects=0&d=1)\n* **A model:** [gaml file](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/traffic.zip?attredirects=0&d=1)\n\n# Exercice (***): Shortest path on grid by distance diffusion\n* **Keywords:** grid, move, displays, diffusion model, algorithm.\n* **Subject:** [PDF](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Shortest Path on Grid by diffusion.pdf?attredirects=0&d=1), [Word](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Shortest Path on Grid by diffusion.docx?attredirects=0&d=1)\n* **A model:** [gaml file](https://sites.google.com/site/benoitgaudou/teaching/gama-exercices/Exo-ShortestPathDiffusion.zip?attredirects=0&d=1)","url":"wiki/PedagogicalMaterials.md"},"References.md":{"title":" References","content":"# References\n\n\n\nThis page contains a subset of the scientific papers that have been written either about GAMA or using the platform as an experimental/modeling support.\n\nIf you happen to publish a paper that uses or discusses GAMA, please let us know, so that we can include it in this list.\n\nAs stated in [the first page](Overview), if you need to cite GAMA in a paper, we kindly ask you to use this reference:\n  * [A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems', Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.](http://link.springer.com/chapter/10.1007/978-3-642-44927-7_9)\n\n\n\n\n## Papers about GAMA\n  * [Taillandier, Patrick, Arnaud Grignard, Benoit Gaudou, and Alexis Drogoul. \"Des données géographiques à la simulation à base d’agents: application de la plate-forme GAMA.\" Cybergeo: European Journal of Geography (2014).](http://spi.cybergeo.revues.org/26263)\n\n  * [A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems', Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.](http://link.springer.com/chapter/10.1007/978-3-642-44927-7_9)\n\n  * [Grignard, Arnaud, Alexis Drogoul, and Jean-Daniel Zucker. \"Online analysis and visualization of agent based models.\" Computational Science and Its Applications–ICCSA 2013. Springer Berlin Heidelberg, 2013. 662-672.](http://link.springer.com/chapter/10.1007/978-3-642-39637-3_52#page-1)\n\n  * [Taillandier, P., Drogoul, A., Vo, D.A. and Amouroux, E. (2012), GAMA: a simulation platform that integrates geographical information data, agent-based modeling and multi-scale control. In ‘The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, India, Volume 7057/2012, pp 242-258.](http://www.springerlink.com/content/j7135j8722742j82/)\n\n  * [Taillandier, P. & Drogoul, A. (2011), From Grid Environment to Geographic Vector Agents, Modeling with the GAMA simulation platform. In ‘25th Conference of the International Cartographic Association’, Paris, France.](http://icaci.org/files/documents/ICC_proceedings/ICC2011/Oral Presentations PDF/C4-Simulation, spatio-temporal modelling, visualisation/CO-288.pdf)\n\n  * Taillandier, P. ; Drogoul A. ; Vo D.A. & Amouroux, E. (2010), GAMA : bringing GIS and multi-level capabilities to multi-agent simulation, in ‘the 8th European Workshop on Multi-Agent Systems', Paris, France.\n\n  * Amouroux, E., Taillandier, P. &  Drogoul, A. (2010), Complex environment representation in epidemiology ABM: application on `H5N1` propagation. In ‘the 3rd International Conference on Theories and Applications of Computer Science’ (ICTACS'10).\n\n  * [Amouroux, E., Chu, T.Q., Boucher, A. and Drogoul, A. (2007), GAMA: an environment for implementing and running spatially explicit multi-agent simulations. In ‘Pacific Rim International Workshop on Multi-Agents', Bangkoku, Thailand, pp. 359--371.](http://www.springerlink.com/content/88006131542n1204/)\n\n\n\n\n## PhD theses\n  * **Truong Xuan Viet**, [\"Optimization by Simulation of an Environmental Surveillance Network: Application to the Fight against Rice Pests in the Mekong Delta (Vietnam)\"](https://drive.google.com/a/ctu.edu.vn/file/d/0B7ArAu2_CEjCaTVzZURNUGlfWmc/edit?usp=sharing), University of Paris 6 & Ho Chi Minh University of Technology, defended June 24th, 2014.\n\n  * **Nguyen Nhi Gia Vinh**, [\"Designing multi-scale models to support environmental decision: application to the control of Brown Plant Hopper invasions in the Mekong Delta (Vietnam)\"](https://drive.google.com/file/d/0BwzSY8KTNM0nLUVMVXR3WDVJSjQ/edit?usp=sharing), University of Paris 6, defended Oct. 31st, 2013.\n\n  * **Vo Duc An**, [\"An operational architecture to handle multiple levels of representation in agent-based models\"](https://dl.dropboxusercontent.com/u/70529600/manuscrit_VoDucAn.pdf), University of Paris 6, defended Nov. 30th 2012.\n\n  * **Amouroux Edouard**, [\"KIMONO: a descriptive agent-based modeling methodology for the exploration of complex systems: an application to epidemiology\"](http://tel.archives-ouvertes.fr/tel-00630779), University of Paris 6, defended Sept. 30th, 2011.\n\n  * **Chu Thanh Quang**, [\"Using agent-based models and machine learning to enhance spatial decision support systems: Application to resource allocation in situations of urban catastrophes\"](https://www.dropbox.com/s/i5ifnigqv7qltc9/CHU-Thanh-Quang_manuscrit.pdf), University of Paris 6, defended July 1st, 2011.\n\n  * **Nguyen Ngoc Doanh**, [\"Coupling Equation-Based and Individual-Based Models in the Study of Complex Systems: A Case Study in Theoretical Population Ecology\"](https://docs.google.com/file/d/0B5s1B4Qq19ycMDg4MTNhMmUtMDNlMC00NzQyLWFlZjEtMjZhOGY5YjRhNWU5/edit?hl=fr), University of Paris 6, defended Dec. 14th, 2010.\n\n\n\n\n## Research papers that use GAMA as modeling/simulation support\n\n**2016**\n\n* Bhamidipati, S., van der Lei, T., & Herder, P. (2016). A layered approach to model interconnected infrastructure and its significance for asset management. EJTIR, 16(1), 254-272.\n\n**2014**\n\n  * E. G. Macatulad , A. C. Blanco (2014) 3DGIS-BASED MULTI-AGENT GEOSIMULATION AND VISUALIZATION OF BUILDING EVACUATION USING GAMA PLATFORM. The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, Volume XL-2, 2014. ISPRS Technical Commission II Symposium, 6 – 8 October 2014, Toronto, Canada. Retrieved from http://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XL-2/87/2014/isprsarchives-XL-2-87-2014.pdf\n\n\n  * S. Bhamidipati (2014) A simulation framework for asset management in climate-change adaptation of transportation infrastructure. In: Proceedings of 42nd European Transport Conference. Frankfurt, Germany. Retrieved from http://abstracts.aetransport.org/paper/download/id/4317\n\n  * [Gaudou, B., Sibertin-Blanc, C., Thérond, O., Amblard, F., Auda, Y., Arcangeli, J.-P., Balestrat, M., Charron-Moirez, M.-H., Gondet, E., Hong, Y., Lardy, R., Louail, T., Mayor, E., Panzoli, D., Sauvage, S., Sanchez-Perez, J., Taillandier, P., Nguyen, V. B., Vavasseur, M., Mazzega, P. (2014). The MAELIA multi-agent platform for integrated assessment of low-water management issues. In: International Workshop on Multi-Agent-Based Simulation (MABS 2013), Saint-Paul, MN, USA, 06/05/2013-07/05/2013, Vol. 8235, Shah Jamal Alam, H. Van Dyke Parunak, (Eds.), Springer, Lecture Notes in Computer Science, p. 85-110.](http://simsoc.free.fr/ressources/articles/2013/MAELIAmabs13.pdf)\n\n  * [Gaudou, B., Lorini, E., Mayor, E. (2014.) Moral Guilt: An Agent-Based Model Analysis. In: Conference of the European Social Simulation Association (ESSA 2013), Warsaw, 16/09/2013-20/09/2013, Vol. 229, Springer, Advances in Intelligent Systems and Computing, p. 95-106.](http://www.irit.fr/EmoTES/Documents/Conference/Conf_ic_2013_Gaudou_et_al.pdf)\n\n**2013**\n  * [Drogoul, A., Gaudou, B., Grignard, A., Taillandier, P., & Vo, D. A. (2013). Practical Approach To Agent-Based Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, p. 277-300, Regional Social Sciences Summer University.](http://hal.archives-ouvertes.fr/docs/00/93/24/23/PDF/JTD2012_-_Atelier_-_EN.pdf)\n\n  * [Drogoul, A., Gaudou, B. (2013) Methods for Agent-Based Computer Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, 1.6, p. 130-154, Regional Social Sciences Summer University. ](http://www.tamdaoconf.com/tamdao/wp-content/plugins/download-monitor/download.php?id=185)\n\n  * [Truong, M.-T., Amblard, F., Gaudou, B., Sibertin-Blanc, C., Truong, V. X., Drogoul, A., Hyunh, X. H., Le, M. N. (2013). An implementation of framework of business intelligence for agent-based simulation. In: Symposium on Information and Communication Technology (SoICT 2013), Da Nang, Viet Nam, 05/12/2013-06/12/2013, Quyet Thang Huynh, Thanh Binh Nguyen, Van Tien Do, Marc Bui, Hong Son Ngo (Eds.), ACM, p. 35-44.](http://dl.acm.org/citation.cfm?id=2542069)\n\n  * [Le, V. M., Gaudou, B., Taillandier, P., Vo, D. A (2013). A New BDI Architecture To Formalize Cognitive Agent Behaviors Into Simulations. In: Advanced Methods and Technologies for Agent and Multi-Agent Systems (KES-AMSTA 2013), Hue, Vietnam, 27/05/2013-29/05/2013, Vol. 252, Dariusz Barbucha, Manh Thanh Le, Robert J. Howlett, C. Jain Lakhmi (Eds.), IOS Press, Frontiers in Artificial Intelligence and Applications, p. 395-403.](http://ebooks.iospress.nl/publication/32865)\n\n**2012**\n  * [Taillandier, P., Therond, O., Gaudou B. (2012), A new BDI agent architecture based on the belief theory. Application to the modelling of cropping plan decision-making. In 'International Environmental Modelling and Software Society', Germany, pp. 107-116.](http://www.iemss.org/sites/iemss2012//proceedings/H2_0404_Taillandier_et_al.pdf)\n\n  * Taillandier, P., Therond, O., Gaudou B. (2012), Une architecture d'agent BDI basée sur la théorie des fonctions de croyance: application à la simulation du comportement des agriculteurs. In 'Journées Francophones sur les Systèmes Multi-Agents', France, pp. 107-116.\n\n  * [NGUYEN, Quoc Tuan, Alain BOUJU, and Pascal ESTRAILLIER. \"Multi-agent architecture with space-time components for the simulation of urban transportation systems.\" (2012).](http://www.sciencedirect.com.accesdistant.upmc.fr/science/article/pii/S1877042812042188)\n\n  * [Cisse, A., Bah, A., Drogoul, A., Cisse, A.T., Ndione, J.A., Kebe, C.M.F. & Taillandier P. (2012), Un modèle à base d’agents sur la transmission et la diffusion de la fièvre de la Vallée du Rift à Barkédji (Ferlo, Sénégal), Studia Informatica Universalis 10 (1), pp. 77-97.](http://studia.complexica.net/Art/RI100104.pdf)\n\n  * [Taillandier, P., Amouroux, E., Vo, D.A. and Olteanu-Raimond A.M. (2012), Using Belief Theory to formalize the agent behavior: application to the simulation of avian flu propagation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 575-587.](http://www.springerlink.com/content/8qg53u75q46252l2/)\n\n  * [Le, V.M., Adam, C., Canal, R., Gaudou, B., Ho, T.V. and Taillandier, P. (2012), Simulation of the emotion dynamics in a group of agents in an evacuation situation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 604-619.](http://www.springerlink.com/content/c838365603qr7tx0/)\n\n  * [Nguyen Vu, Q. A., Canal, R., Gaudou, B., Hassas, S., Armetta, F. (2012), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system. In: Journal of Ambient Intelligence and Humanized Computing, Springer-Verlag, Vol. 3 N. 4, p. 251-263.](http://link.springer.com/article/10.1007%2Fs12652-012-0140-0)\n\n**2011**\n  * Taillandier, P. & Therond, O. (2011), Use of the Belief Theory to formalize Agent Decision Making Processes : Application to cropping Plan Decision Making. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 138-142.\n\n  * Taillandier, P. & Amblard, F. (2011), Cartography of Multi-Agent Model Parameter Space through a reactive Dicotomous Approach. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 38-42.\n\n  * [Taillandier, P. & Stinckwich, S. (2011), Using the PROMETHEE Multi-Criteria Decision Making Method to Define New Exploration Strategies for Rescue Robots’, IEEE International Symposium on Safety, Security, and Rescue Robotics, Kyoto, Japon, pp. 321 - 326.](http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6106747&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D6106747)\n\n**2010**\n  * [Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), A cluster-based approach for disturbed, spatialized, distributed information gathering systems,  in ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, pp. 588-603.](http://www.springerlink.com/content/u02nq35387418q11/)\n\n  * [Nguyen, N.D., Taillandier, P., Drogoul, A. and Augier, P. (2010), Inferring Equation-Based Models from Agent-Based Models: A Case Study in Competition Dynamics.In ‘The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, India, Volume 7057/2012, pp. 413-427.](http://www.springerlink.com/content/n23314gm326l4p27/)\n\n  * [Amouroux, E., Gaudou, B. Desvaux, S. and Drogoul, A. (2010), O.D.D.: a Promising but Incomplete Formalism For Individual-Based Model Specification. in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF'), pp. 1-4.](http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=5633421&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5633421)\n\n  * Nguyen, N.D., Phan, T.H.D., Nguyen, T.N.A., Drogoul, A. and Zucker, J-D. (2010), Disk Graph-Based Model for Competition Dynamic, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF').\n\n  * Nguyen, T.K., Marilleau, N., Ho T.V. and El Fallah Seghrouchni, A. (2010), A meta-model for specifying collaborative simulation, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF').\n\n  * [Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), `TrustSets` - Using trust to detect deceitful agents in a distributed information collecting system, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF'), the best student paper award.](http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5633080)\n\n  * [Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S., Armetta, F. and Stinckwich, S. (2010), Using trust and cluster organisation to improve robot swarm mapping, Paper to appear in ‘Workshop on Robots and Sensors integration in future rescue INformation system ’ (ROSIN 2010).](http://users.info.unicaen.fr/~serge/share/ROSIN10/rosin10_submission_8.pdf)\n\n**2009**\n  * [Taillandier, P. and Buard, E. (2009), Designing Agent Behaviour in Agent-Based Simulation through participatory method. In ‘The 12th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, Nagoya, Japan, pp. 571--578.](http://www.springerlink.com/content/hu37551467646471/)\n\n  * [Taillandier, P. and Chu, T.Q. (2009), Using Participatory Paradigm to Learn Human Behaviour. In ‘International Conference on Knowledge and Systems Engineering’, Ha noi, Viet Nam, pp. 55--60.](http://www.computer.org/portal/web/csdl/doi/10.1109/KSE.2009.33)\n\n  * [Gaudou, B., Ho, T.V. and Marilleau, N. (2009), Introduce collaboration in methodologies of modeling and simulation of Complex Systems. In ‘International Conference on Intelligent Networking and Collaborative Systems (INCOS '09)’. Barcelona, pp. 1--8.](http://portal2.acm.org/citation.cfm?id=1681504.1681534&coll=GUIDE&dl=GUIDE&CFID=://www.google.com.vn/search?hl=fr&CFTOKEN=www.google.com.vn/search?hl=fr)\n\n  * [Nguyen, T.K., Gaudou B., Ho T.V. and Marilleau N. (2009), Application of PAMS Collaboration Platform to Simulation-Based Researches in Soil Science: The Case of the MIcro-ORganism Project. In ‘IEEE International Conference on Computing and Telecommunication Technologies (IEEE-RIVF 09)’. Da Nang, Viet Nam, pp. 296--303.](http://ieeexplore.ieee.org/Xplore/login.jsp?url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel5%2F5174598%2F5174599%2F05174623.pdf%3Farnumber%3D5174623&authDecision=-203)\n\n  * [Nguyen, V.Q., Gaudou B., Canal R., Hassas S. and Armetta F. (2009), Stratégie de communication dans un système de collecte d’information à base d’agents perturbés. In ‘Journées Francophones sur les Systèmes Multi-Agents (JFSMA'09)’.](http://liesp.insa-lyon.fr/v2/?q=fr/node/100911)\n\n**2008**\n  * [Chu, T.Q., Boucher, A., Drogoul, A., Vo, D.A., Nguyen, H.P. and Zucker, J.D. (2008). Interactive Learning of Expert Criteria for Rescue Simulations. In ‘Pacific Rim International Workshop on Multi-Agents’, Ha Noi, Viet Nam, pp. 127--138.](http://www.springerlink.com/content/r83v0125vl0430l1/)\n\n  * [Amouroux, E., Desvaux, S. and Drogoul, A. (2008), Towards Virtual Epidemiology: An Agent-Based Approach to the Modeling of H5N1 Propagation and Persistence in North-Vietnam. In ‘Pacific Rim International Workshop on Multi-Agents’, Ha Noi, Viet Nam, pp. 26--33.](http://www.springerlink.com/content/v6471t1453k17244/)","url":"wiki/References.md"},"WritingModels.md":{"title":" Writing Models","content":"# Writing Models\n\n\n\nModels in GAMA play the same role as classes in Java or C++: they represent both the knowledge about a particular phenomenon a user wants to simulate and the way(s) to simulate it. A model is nothing more than a text file (or a collection of text files that refer to each other), which contains instructions in a [specific language](GamlLanguage) called GAML (for \"GAMA Modeling Language\").\nA model can then be theoretically edited using any text processor and later loaded into GAMA to [run experiments](RunningExperiments). However, because of the richness of the language, using a dedicated tool (with online help, live validation) is clearly the best way to write correct models.\n\nThe GUI version of GAMA offers such an _integrated model development environment_, which is composed of a set of coupled tools to support modelers in the [edition](EditingModels), [validation](ValidationOfModels), and [management](WorkspaceProjectsAndModels) of models. An optional [graphical modeling editor](G__GraphicalEditor) can also be installed on top of these tools to support higher-level modeling activities (similar to what a UML editor with Java bindings may provide to a Java development environment).\n\nThis chapter contains a description of these different tools and a comprehensive guide to the [GAML language](GamlLanguage), including a [complete reference](GamlReference) of all the built-in structures and facilities offered in its current version.\n\nPlease proceed to one of these sections :\n\n  * 1. [Editing Models](EditingModels)\n  * 2. [GAML Language](GamlLanguage)\n  * 3. [GAML Reference](GamlReference)\n  * 4. [Optimizing Models](OptimizingModels)","url":"wiki/WritingModels.md"},"G__BlankPage.md":{"title":"G__BlankPage","content":"\n","url":"wiki/G__BlankPage.md"},"Home.md":{"title":" Multiple application domains","content":"**The new website of GAMA is now available at this address : [gama-platform.org](http://gama-platform.org/)**\n\n<div style=\"text-align:center\"><img src =\"https://github.com/gama-platform/gama/wiki/resources/images/general/GamaPlatform.png\" width=\"800\"/></div>\n\nGAMA is a modeling and simulation development environment for building spatially explicit agent-based simulations. \n\n* [**Multiple application domains :**](#multiple-application-domains) Use GAMA for whatever application domain you want.\n* [**High-level and Intuitive Agent-based language :**](high-level-and-intuitive-agent-based-language) Write your models easily using GAML, a high-level and intuitive agent-based language.\n* [**GIS and Data-Driven models :**](#gis-and-data-driven-models) Instantiate agents from any dataset, including GIS data, and execute large-scale simulations (up to millions of agents).\n* [**Declarative user interface :**](#declarative-user-interface) Declare interfaces supporting deep inspections on agents, user-controlled action panels, multi-layer 2D/3D displays & agent aspects.\n\nIts latest version, **1.7**, can be freely [downloaded](Download) or [built from source](https://github.com/gama-platform/gama/), and comes pre-loaded with several models, [tutorials](Tutorials) and a complete [on-line documentation](Overview).\n\n## Multiple application domains\n\nGAMA has been developed with a very general approach, and can be used for many application domains. Some [additional plugins](TODO_URL) had been developed to fit with particular needs.\n\nExample of application domains where GAMA is mostly present :\n* Transport\n* Urban planning\n* Epidemiology\n* Environment\n\nSome [training sessions](TrainingSession) about topics such as \"urban management\", \"epidemiology\", \"risk management\" are also provided by the team.\nSince GAMA is an open-source software that continues to grow, if you have any particular needs of improvement, feel free to [share it to its active community](https://groups.google.com/forum/#!forum/gama-platform) !\n\n<div style=\"text-align:center\"><img src =\"https://github.com/gama-platform/gama/wiki/resources/images/general/multiple_application_domains.png\" width=\"800\"/></div>\n\n## High level and intuitive language\n\nThanks to its high-level and intuitive language, GAMA has been developed to be used by non-computer scientists. You can declare your species, giving them some special behaviors, create them in your world, and display them in [less than 10 minutes](TODO_URL).\n\nGAML is the language used in GAMA, coded in Java. It is an agent-based language, that provides you the possibility to build your model with [several paradigms of modeling](MultiParadigmModeling). Once your model is ready, some features allows you to [explore and calibrate it](ExploringModels), using the parameters you defined as input of your simulation.\n\nWe provides you a continual support through the [active mailing list](https://groups.google.com/forum/#!forum/gama-platform) where the team will answer your questions. Besides, you can learn GAML on your own, following the [step by step tutorial](LearnGAMLStepByStep), or [personal learning path](TODO_URL) in order reach the point you are interested in.\n\n<div style=\"text-align:center\"><img src =\"https://github.com/gama-platform/gama/wiki/resources/images/general/high_level_language.png\" width=\"800\"/></div>\n\n## GIS and Data-Driven models\n\nGAMA (GIS Agent-based Modeling Architecture) provides you, since its creation, the possibility to load easily GIS (Geographic Information System).\n\nYou can import a [large number of data types](DataTypes), such as text, files, CSV, shapefile, OSM ([open street map data](ManipulateOSMDatas)), grid, images, SVG, but also 3D files, such as 3DS or OBJ, with their texture.\n\nSome advanced features provides you the possibility to [connect GAMA to databases](UsingDatabase), and also to use powerful statistical tools such as [R](CallingR).\n\nGAMA has been used in [large-scale projects](Projects), using a great number of agents (up to millions of agents).\n\n<div style=\"text-align:center\"><img src =\"https://github.com/gama-platform/gama/wiki/resources/images/general/data_driven_models.png\" width=\"800\"/></div>\n\n## Declarative user interface\n\nGAMA provides you the possibility to have multiple displays for the same model. You can add as much visual representations as you want for the same model, in order to highlight a certain aspect of your simulation. Add easily new visual aspects to your agents.\n\nAdvanced [3D displays](Defining3DDisplays) are provided : you can control lights, cameras, and also adding textures to your 3D objects. In an other hand, dedicated statements allows you to define easily [charts](DefiningCharts), such as series, histogram, or pies.\n\nDuring the simulations, some advanced features are available to [inspect the population of your agents](InspectorsAndMonitors). To make your model more interactive, you can add easily some [user-controlled action panels, or mouse events](DefiningUserInteraction).\n\n<div style=\"text-align:center\"><img src =\"https://github.com/gama-platform/gama/wiki/resources/images/general/declarative_UI.png\" width=\"800\"/></div>\n\n______________________________________\n\n\nGAMA is developed by several teams under the umbrella of the IRD/UPMC international research unit [UMMISCO](http://www.ummisco.ird.fr/):\n\n* [MSI Research Team](http://www.ifi.auf.org/site/content/view/35/46/lang,french/), Vietnam National University, Hanoi, Vietnam (2007 - 2015)\n* [UMR 6228 IDEES](http://www.umr-idees.fr), CNRS/University of Rouen, France (2010 - 2015)\n* [UMR 5505 IRIT](http://www.irit.fr), CNRS/University of Toulouse 1, France (2010 - 2015)\n* [DREAM Research Team](http://www.cit.ctu.edu.vn), University of Can Tho, Vietnam (2011 - 2015)\n* [UMR 8623 LRI](http://www.lri.fr), CNRS/University Paris-Sud, France (2011 - 2015)\n\n---\n\n**Acknowledgement**:  \n\n![](https://www.yourkit.com/images/yklogo.png)  \n\n*YourKit supports open source projects with its full-featured Java Profiler.\nYourKit, LLC is the creator of <a href=\"https://www.yourkit.com/java/profiler/index.jsp\">YourKit Java Profiler</a>\nand <a href=\"https://www.yourkit.com/.net/profiler/index.jsp\">YourKit .NET Profiler</a>,\ninnovative and intelligent tools for profiling Java and .NET applications.*","url":"wiki/Home.md"}}